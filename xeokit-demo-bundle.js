var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb2, mod) => function __require() {
  return mod || (0, cb2[__getOwnPropNames(cb2)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name12 in all)
    __defProp(target, name12, { get: all[name12], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../node_modules/.pnpm/ste-core@3.0.11/node_modules/ste-core/dist/dispatching/DispatcherWrapper.js
var require_DispatcherWrapper = __commonJS({
  "../../node_modules/.pnpm/ste-core@3.0.11/node_modules/ste-core/dist/dispatching/DispatcherWrapper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DispatcherWrapper = void 0;
    var DispatcherWrapper = class {
      /**
       * Creates an instance of DispatcherWrapper.
       * @param {ISubscribable<TEventHandler>} dispatcher
       *
       * @memberOf DispatcherWrapper
       */
      constructor(dispatcher) {
        this._subscribe = (fn) => dispatcher.subscribe(fn);
        this._unsubscribe = (fn) => dispatcher.unsubscribe(fn);
        this._one = (fn) => dispatcher.one(fn);
        this._has = (fn) => dispatcher.has(fn);
        this._clear = () => dispatcher.clear();
        this._count = () => dispatcher.count;
        this._onSubscriptionChange = () => dispatcher.onSubscriptionChange;
      }
      /**
       * Triggered when subscriptions are changed (added or removed).
       *
       * @readonly
       * @type {ISubscribable<SubscriptionChangeEventHandler>}
       * @memberOf DispatcherWrapper
       */
      get onSubscriptionChange() {
        return this._onSubscriptionChange();
      }
      /**
       * Returns the number of subscriptions.
       *
       * @readonly
       * @type {number}
       * @memberOf DispatcherWrapper
       */
      get count() {
        return this._count();
      }
      /**
       * Subscribe to the event dispatcher.
       *
       * @param {TEventHandler} fn The event handler that is called when the event is dispatched.
       * @returns {() => void} A function that unsubscribes the event handler from the event.
       *
       * @memberOf DispatcherWrapper
       */
      subscribe(fn) {
        return this._subscribe(fn);
      }
      /**
       * Subscribe to the event dispatcher.
       *
       * @param {TEventHandler} fn The event handler that is called when the event is dispatched.
       * @returns {() => void} A function that unsubscribes the event handler from the event.
       *
       * @memberOf DispatcherWrapper
       */
      sub(fn) {
        return this.subscribe(fn);
      }
      /**
       * Unsubscribe from the event dispatcher.
       *
       * @param {TEventHandler} fn The event handler that is called when the event is dispatched.
       *
       * @memberOf DispatcherWrapper
       */
      unsubscribe(fn) {
        this._unsubscribe(fn);
      }
      /**
       * Unsubscribe from the event dispatcher.
       *
       * @param {TEventHandler} fn The event handler that is called when the event is dispatched.
       *
       * @memberOf DispatcherWrapper
       */
      unsub(fn) {
        this.unsubscribe(fn);
      }
      /**
       * Subscribe once to the event with the specified name.
       *
       * @returns {() => void} A function that unsubscribes the event handler from the event.
       *
       * @memberOf DispatcherWrapper
       */
      one(fn) {
        return this._one(fn);
      }
      /**
       * Checks it the event has a subscription for the specified handler.
       *
       * @param {TEventHandler} fn The event handler that is called when the event is dispatched.
       *
       * @memberOf DispatcherWrapper
       */
      has(fn) {
        return this._has(fn);
      }
      /**
       * Clears all the subscriptions.
       *
       * @memberOf DispatcherWrapper
       */
      clear() {
        this._clear();
      }
    };
    exports.DispatcherWrapper = DispatcherWrapper;
  }
});

// ../../node_modules/.pnpm/ste-core@3.0.11/node_modules/ste-core/dist/events/Subscription.js
var require_Subscription = __commonJS({
  "../../node_modules/.pnpm/ste-core@3.0.11/node_modules/ste-core/dist/events/Subscription.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Subscription = void 0;
    var Subscription = class {
      /**
       * Creates an instance of Subscription.
       *
       * @param {TEventHandler} handler The handler for the subscription.
       * @param {boolean} isOnce Indicates if the handler should only be executed once.
       */
      constructor(handler, isOnce) {
        this.handler = handler;
        this.isOnce = isOnce;
        this.isExecuted = false;
      }
      /**
       * Executes the handler.
       *
       * @param {boolean} executeAsync True if the even should be executed async.
       * @param {*} scope The scope the scope of the event.
       * @param {IArguments} args The arguments for the event.
       */
      execute(executeAsync, scope, args) {
        if (!this.isOnce || !this.isExecuted) {
          this.isExecuted = true;
          var fn = this.handler;
          if (executeAsync) {
            setTimeout(() => {
              fn.apply(scope, args);
            }, 1);
          } else {
            fn.apply(scope, args);
          }
        }
      }
    };
    exports.Subscription = Subscription;
  }
});

// ../../node_modules/.pnpm/ste-core@3.0.11/node_modules/ste-core/dist/management/EventManagement.js
var require_EventManagement = __commonJS({
  "../../node_modules/.pnpm/ste-core@3.0.11/node_modules/ste-core/dist/management/EventManagement.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EventManagement = void 0;
    var EventManagement = class {
      /**
       * Creates an instance of EventManagement.
       * @param {() => void} unsub An unsubscribe handler.
       *
       * @memberOf EventManagement
       */
      constructor(unsub) {
        this.unsub = unsub;
        this.propagationStopped = false;
      }
      /**
       * Stops the propagation of the event.
       * Cannot be used when async dispatch is done.
       *
       * @memberOf EventManagement
       */
      stopPropagation() {
        this.propagationStopped = true;
      }
    };
    exports.EventManagement = EventManagement;
  }
});

// ../../node_modules/.pnpm/ste-core@3.0.11/node_modules/ste-core/dist/dispatching/DispatcherBase.js
var require_DispatcherBase = __commonJS({
  "../../node_modules/.pnpm/ste-core@3.0.11/node_modules/ste-core/dist/dispatching/DispatcherBase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SubscriptionChangeEventDispatcher = exports.DispatcherBase = void 0;
    var DispatcherWrapper_1 = require_DispatcherWrapper();
    var Subscription_1 = require_Subscription();
    var EventManagement_1 = require_EventManagement();
    var DispatcherBase = class {
      constructor() {
        this._subscriptions = new Array();
      }
      /**
       * Returns the number of subscriptions.
       *
       * @readonly
       * @type {number}
       * @memberOf DispatcherBase
       */
      get count() {
        return this._subscriptions.length;
      }
      /**
       * Triggered when subscriptions are changed (added or removed).
       *
       * @readonly
       * @type {ISubscribable<SubscriptionChangeEventHandler>}
       * @memberOf DispatcherBase
       */
      get onSubscriptionChange() {
        if (this._onSubscriptionChange == null) {
          this._onSubscriptionChange = new SubscriptionChangeEventDispatcher();
        }
        return this._onSubscriptionChange.asEvent();
      }
      /**
       * Subscribe to the event dispatcher.
       *
       * @param {TEventHandler} fn The event handler that is called when the event is dispatched.
       * @returns A function that unsubscribes the event handler from the event.
       *
       * @memberOf DispatcherBase
       */
      subscribe(fn) {
        if (fn) {
          this._subscriptions.push(this.createSubscription(fn, false));
          this.triggerSubscriptionChange();
        }
        return () => {
          this.unsubscribe(fn);
        };
      }
      /**
       * Subscribe to the event dispatcher.
       *
       * @param {TEventHandler} fn The event handler that is called when the event is dispatched.
       * @returns A function that unsubscribes the event handler from the event.
       *
       * @memberOf DispatcherBase
       */
      sub(fn) {
        return this.subscribe(fn);
      }
      /**
       * Subscribe once to the event with the specified name.
       *
       * @param {TEventHandler} fn The event handler that is called when the event is dispatched.
       * @returns A function that unsubscribes the event handler from the event.
       *
       * @memberOf DispatcherBase
       */
      one(fn) {
        if (fn) {
          this._subscriptions.push(this.createSubscription(fn, true));
          this.triggerSubscriptionChange();
        }
        return () => {
          this.unsubscribe(fn);
        };
      }
      /**
       * Checks it the event has a subscription for the specified handler.
       *
       * @param {TEventHandler} fn The event handler.
       *
       * @memberOf DispatcherBase
       */
      has(fn) {
        if (!fn)
          return false;
        return this._subscriptions.some((sub) => sub.handler == fn);
      }
      /**
       * Unsubscribes the handler from the dispatcher.
       *
       * @param {TEventHandler} fn The event handler.
       *
       * @memberOf DispatcherBase
       */
      unsubscribe(fn) {
        if (!fn)
          return;
        let changes = false;
        for (let i = 0; i < this._subscriptions.length; i++) {
          if (this._subscriptions[i].handler == fn) {
            this._subscriptions.splice(i, 1);
            changes = true;
            break;
          }
        }
        if (changes) {
          this.triggerSubscriptionChange();
        }
      }
      /**
       * Unsubscribes the handler from the dispatcher.
       *
       * @param {TEventHandler} fn The event handler.
       *
       * @memberOf DispatcherBase
       */
      unsub(fn) {
        this.unsubscribe(fn);
      }
      /**
       * Generic dispatch will dispatch the handlers with the given arguments.
       *
       * @protected
       * @param {boolean} executeAsync `True` if the even should be executed async.
       * @param {*} scope The scope of the event. The scope becomes the `this` for handler.
       * @param {IArguments} args The arguments for the event.
       * @returns {(IPropagationStatus | null)} The propagation status, or if an `executeAsync` is used `null`.
       *
       * @memberOf DispatcherBase
       */
      _dispatch(executeAsync, scope, args) {
        for (let sub of [...this._subscriptions]) {
          let ev = new EventManagement_1.EventManagement(() => this.unsub(sub.handler));
          let nargs = Array.prototype.slice.call(args);
          nargs.push(ev);
          let s = sub;
          s.execute(executeAsync, scope, nargs);
          this.cleanup(sub);
          if (!executeAsync && ev.propagationStopped) {
            return { propagationStopped: true };
          }
        }
        if (executeAsync) {
          return null;
        }
        return { propagationStopped: false };
      }
      /**
       * Creates a subscription.
       *
       * @protected
       * @param {TEventHandler} handler The handler.
       * @param {boolean} isOnce True if the handler should run only one.
       * @returns {ISubscription<TEventHandler>} The subscription.
       *
       * @memberOf DispatcherBase
       */
      createSubscription(handler, isOnce) {
        return new Subscription_1.Subscription(handler, isOnce);
      }
      /**
       * Cleans up subs that ran and should run only once.
       *
       * @protected
       * @param {ISubscription<TEventHandler>} sub The subscription.
       *
       * @memberOf DispatcherBase
       */
      cleanup(sub) {
        let changes = false;
        if (sub.isOnce && sub.isExecuted) {
          let i = this._subscriptions.indexOf(sub);
          if (i > -1) {
            this._subscriptions.splice(i, 1);
            changes = true;
          }
        }
        if (changes) {
          this.triggerSubscriptionChange();
        }
      }
      /**
       * Creates an event from the dispatcher. Will return the dispatcher
       * in a wrapper. This will prevent exposure of any dispatcher methods.
       *
       * @returns {ISubscribable<TEventHandler>}
       *
       * @memberOf DispatcherBase
       */
      asEvent() {
        if (this._wrap == null) {
          this._wrap = new DispatcherWrapper_1.DispatcherWrapper(this);
        }
        return this._wrap;
      }
      /**
       * Clears the subscriptions.
       *
       * @memberOf DispatcherBase
       */
      clear() {
        if (this._subscriptions.length != 0) {
          this._subscriptions.splice(0, this._subscriptions.length);
          this.triggerSubscriptionChange();
        }
      }
      /**
       * Triggers the subscription change event.
       *
       * @private
       *
       * @memberOf DispatcherBase
       */
      triggerSubscriptionChange() {
        if (this._onSubscriptionChange != null) {
          this._onSubscriptionChange.dispatch(this.count);
        }
      }
    };
    exports.DispatcherBase = DispatcherBase;
    var SubscriptionChangeEventDispatcher = class extends DispatcherBase {
      /**
       * Dispatches the event.
       *
       * @param {number} count The currrent number of subscriptions.
       *
       * @memberOf SubscriptionChangeEventDispatcher
       */
      dispatch(count) {
        this._dispatch(false, this, arguments);
      }
    };
    exports.SubscriptionChangeEventDispatcher = SubscriptionChangeEventDispatcher;
  }
});

// ../../node_modules/.pnpm/ste-core@3.0.11/node_modules/ste-core/dist/dispatching/DispatchError.js
var require_DispatchError = __commonJS({
  "../../node_modules/.pnpm/ste-core@3.0.11/node_modules/ste-core/dist/dispatching/DispatchError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DispatchError = void 0;
    var DispatchError = class extends Error {
      /**
       * Creates an instance of DispatchError.
       * @param {string} message The message.
       *
       * @memberOf DispatchError
       */
      constructor(message) {
        super(message);
      }
    };
    exports.DispatchError = DispatchError;
  }
});

// ../../node_modules/.pnpm/ste-core@3.0.11/node_modules/ste-core/dist/dispatching/EventListBase.js
var require_EventListBase = __commonJS({
  "../../node_modules/.pnpm/ste-core@3.0.11/node_modules/ste-core/dist/dispatching/EventListBase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EventListBase = void 0;
    var EventListBase = class {
      constructor() {
        this._events = {};
      }
      /**
       * Gets the dispatcher associated with the name.
       *
       * @param {string} name The name of the event.
       * @returns {TEventDispatcher} The disptacher.
       *
       * @memberOf EventListBase
       */
      get(name12) {
        let event = this._events[name12];
        if (event) {
          return event;
        }
        event = this.createDispatcher();
        this._events[name12] = event;
        return event;
      }
      /**
       * Removes the dispatcher associated with the name.
       *
       * @param {string} name
       *
       * @memberOf EventListBase
       */
      remove(name12) {
        delete this._events[name12];
      }
    };
    exports.EventListBase = EventListBase;
  }
});

// ../../node_modules/.pnpm/ste-core@3.0.11/node_modules/ste-core/dist/handling/HandlingBase.js
var require_HandlingBase = __commonJS({
  "../../node_modules/.pnpm/ste-core@3.0.11/node_modules/ste-core/dist/handling/HandlingBase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HandlingBase = void 0;
    var HandlingBase = class {
      /**
       * Creates an instance of HandlingBase.
       * @param {TList} events The event list. Used for event management.
       *
       * @memberOf HandlingBase
       */
      constructor(events) {
        this.events = events;
      }
      /**
       * Subscribes once to the event with the specified name.
       * @param {string} name The name of the event.
       * @param {TEventHandler} fn The event handler.
       *
       * @memberOf HandlingBase
       */
      one(name12, fn) {
        this.events.get(name12).one(fn);
      }
      /**
       * Checks it the event has a subscription for the specified handler.
       * @param {string} name The name of the event.
       * @param {TEventHandler} fn The event handler.
       *
       * @memberOf HandlingBase
       */
      has(name12, fn) {
        return this.events.get(name12).has(fn);
      }
      /**
       * Subscribes to the event with the specified name.
       * @param {string} name The name of the event.
       * @param {TEventHandler} fn The event handler.
       *
       * @memberOf HandlingBase
       */
      subscribe(name12, fn) {
        this.events.get(name12).subscribe(fn);
      }
      /**
       * Subscribes to the event with the specified name.
       * @param {string} name The name of the event.
       * @param {TEventHandler} fn The event handler.
       *
       * @memberOf HandlingBase
       */
      sub(name12, fn) {
        this.subscribe(name12, fn);
      }
      /**
       * Unsubscribes from the event with the specified name.
       * @param {string} name The name of the event.
       * @param {TEventHandler} fn The event handler.
       *
       * @memberOf HandlingBase
       */
      unsubscribe(name12, fn) {
        this.events.get(name12).unsubscribe(fn);
      }
      /**
       * Unsubscribes from the event with the specified name.
       * @param {string} name The name of the event.
       * @param {TEventHandler} fn The event handler.
       *
       * @memberOf HandlingBase
       */
      unsub(name12, fn) {
        this.unsubscribe(name12, fn);
      }
    };
    exports.HandlingBase = HandlingBase;
  }
});

// ../../node_modules/.pnpm/ste-core@3.0.11/node_modules/ste-core/dist/events/PromiseSubscription.js
var require_PromiseSubscription = __commonJS({
  "../../node_modules/.pnpm/ste-core@3.0.11/node_modules/ste-core/dist/events/PromiseSubscription.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PromiseSubscription = void 0;
    var PromiseSubscription = class {
      /**
       * Creates an instance of PromiseSubscription.
       * @param {TEventHandler} handler The handler for the subscription.
       * @param {boolean} isOnce Indicates if the handler should only be executed once.
       *
       * @memberOf PromiseSubscription
       */
      constructor(handler, isOnce) {
        this.handler = handler;
        this.isOnce = isOnce;
        this.isExecuted = false;
      }
      /**
       * Executes the handler.
       *
       * @param {boolean} executeAsync True if the even should be executed async.
       * @param {*} scope The scope the scope of the event.
       * @param {IArguments} args The arguments for the event.
       *
       * @memberOf PromiseSubscription
       */
      async execute(executeAsync, scope, args) {
        if (!this.isOnce || !this.isExecuted) {
          this.isExecuted = true;
          var fn = this.handler;
          if (executeAsync) {
            setTimeout(() => {
              fn.apply(scope, args);
            }, 1);
            return;
          }
          let result = fn.apply(scope, args);
          await result;
        }
      }
    };
    exports.PromiseSubscription = PromiseSubscription;
  }
});

// ../../node_modules/.pnpm/ste-core@3.0.11/node_modules/ste-core/dist/dispatching/PromiseDispatcherBase.js
var require_PromiseDispatcherBase = __commonJS({
  "../../node_modules/.pnpm/ste-core@3.0.11/node_modules/ste-core/dist/dispatching/PromiseDispatcherBase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PromiseDispatcherBase = void 0;
    var PromiseSubscription_1 = require_PromiseSubscription();
    var EventManagement_1 = require_EventManagement();
    var DispatcherBase_1 = require_DispatcherBase();
    var DispatchError_1 = require_DispatchError();
    var PromiseDispatcherBase = class extends DispatcherBase_1.DispatcherBase {
      /**
       * The normal dispatch cannot be used in this class.
       *
       * @protected
       * @param {boolean} executeAsync `True` if the even should be executed async.
       * @param {*} scope The scope of the event. The scope becomes the `this` for handler.
       * @param {IArguments} args The arguments for the event.
       * @returns {(IPropagationStatus | null)} The propagation status, or if an `executeAsync` is used `null`.
       *
       * @memberOf DispatcherBase
       */
      _dispatch(executeAsync, scope, args) {
        throw new DispatchError_1.DispatchError("_dispatch not supported. Use _dispatchAsPromise.");
      }
      /**
       * Crates a new subscription.
       *
       * @protected
       * @param {TEventHandler} handler The handler.
       * @param {boolean} isOnce Indicates if the handler should only run once.
       * @returns {ISubscription<TEventHandler>} The subscription.
       *
       * @memberOf PromiseDispatcherBase
       */
      createSubscription(handler, isOnce) {
        return new PromiseSubscription_1.PromiseSubscription(handler, isOnce);
      }
      /**
       * Generic dispatch will dispatch the handlers with the given arguments.
       *
       * @protected
       * @param {boolean} executeAsync `True` if the even should be executed async.
       * @param {*} scope The scope of the event. The scope becomes the `this` for handler.
       * @param {IArguments} args The arguments for the event.
       * @returns {(IPropagationStatus | null)} The propagation status, or if an `executeAsync` is used `null`.
       *
       * @memberOf DispatcherBase
       */
      async _dispatchAsPromise(executeAsync, scope, args) {
        for (let sub of [...this._subscriptions]) {
          let ev = new EventManagement_1.EventManagement(() => this.unsub(sub.handler));
          let nargs = Array.prototype.slice.call(args);
          nargs.push(ev);
          let ps = sub;
          await ps.execute(executeAsync, scope, nargs);
          this.cleanup(sub);
          if (!executeAsync && ev.propagationStopped) {
            return { propagationStopped: true };
          }
        }
        if (executeAsync) {
          return null;
        }
        return { propagationStopped: false };
      }
    };
    exports.PromiseDispatcherBase = PromiseDispatcherBase;
  }
});

// ../../node_modules/.pnpm/ste-core@3.0.11/node_modules/ste-core/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/.pnpm/ste-core@3.0.11/node_modules/ste-core/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SubscriptionChangeEventDispatcher = exports.HandlingBase = exports.PromiseDispatcherBase = exports.PromiseSubscription = exports.DispatchError = exports.EventManagement = exports.EventListBase = exports.DispatcherWrapper = exports.DispatcherBase = exports.Subscription = void 0;
    var DispatcherBase_1 = require_DispatcherBase();
    Object.defineProperty(exports, "DispatcherBase", { enumerable: true, get: function() {
      return DispatcherBase_1.DispatcherBase;
    } });
    Object.defineProperty(exports, "SubscriptionChangeEventDispatcher", { enumerable: true, get: function() {
      return DispatcherBase_1.SubscriptionChangeEventDispatcher;
    } });
    var DispatchError_1 = require_DispatchError();
    Object.defineProperty(exports, "DispatchError", { enumerable: true, get: function() {
      return DispatchError_1.DispatchError;
    } });
    var DispatcherWrapper_1 = require_DispatcherWrapper();
    Object.defineProperty(exports, "DispatcherWrapper", { enumerable: true, get: function() {
      return DispatcherWrapper_1.DispatcherWrapper;
    } });
    var EventListBase_1 = require_EventListBase();
    Object.defineProperty(exports, "EventListBase", { enumerable: true, get: function() {
      return EventListBase_1.EventListBase;
    } });
    var EventManagement_1 = require_EventManagement();
    Object.defineProperty(exports, "EventManagement", { enumerable: true, get: function() {
      return EventManagement_1.EventManagement;
    } });
    var HandlingBase_1 = require_HandlingBase();
    Object.defineProperty(exports, "HandlingBase", { enumerable: true, get: function() {
      return HandlingBase_1.HandlingBase;
    } });
    var PromiseDispatcherBase_1 = require_PromiseDispatcherBase();
    Object.defineProperty(exports, "PromiseDispatcherBase", { enumerable: true, get: function() {
      return PromiseDispatcherBase_1.PromiseDispatcherBase;
    } });
    var PromiseSubscription_1 = require_PromiseSubscription();
    Object.defineProperty(exports, "PromiseSubscription", { enumerable: true, get: function() {
      return PromiseSubscription_1.PromiseSubscription;
    } });
    var Subscription_1 = require_Subscription();
    Object.defineProperty(exports, "Subscription", { enumerable: true, get: function() {
      return Subscription_1.Subscription;
    } });
  }
});

// ../../node_modules/.pnpm/ste-events@3.0.11/node_modules/ste-events/dist/EventDispatcher.js
var require_EventDispatcher = __commonJS({
  "../../node_modules/.pnpm/ste-events@3.0.11/node_modules/ste-events/dist/EventDispatcher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EventDispatcher = void 0;
    var ste_core_1 = require_dist();
    var EventDispatcher22 = class extends ste_core_1.DispatcherBase {
      /**
       * Creates an instance of EventDispatcher.
       *
       * @memberOf EventDispatcher
       */
      constructor() {
        super();
      }
      /**
       * Dispatches the event.
       *
       * @param {TSender} sender The sender.
       * @param {TArgs} args The arguments.
       * @returns {IPropagationStatus} The propagation status to interact with the event
       *
       * @memberOf EventDispatcher
       */
      dispatch(sender, args) {
        const result = this._dispatch(false, this, arguments);
        if (result == null) {
          throw new ste_core_1.DispatchError("Got `null` back from dispatch.");
        }
        return result;
      }
      /**
       * Dispatches the event in an async way. Does not support event interaction.
       *
       * @param {TSender} sender The sender.
       * @param {TArgs} args The arguments.
       *
       * @memberOf EventDispatcher
       */
      dispatchAsync(sender, args) {
        this._dispatch(true, this, arguments);
      }
      /**
       * Creates an event from the dispatcher. Will return the dispatcher
       * in a wrapper. This will prevent exposure of any dispatcher methods.
       *
       * @returns {IEvent<TSender, TArgs>} The event.
       *
       * @memberOf EventDispatcher
       */
      asEvent() {
        return super.asEvent();
      }
    };
    exports.EventDispatcher = EventDispatcher22;
  }
});

// ../../node_modules/.pnpm/ste-events@3.0.11/node_modules/ste-events/dist/EventList.js
var require_EventList = __commonJS({
  "../../node_modules/.pnpm/ste-events@3.0.11/node_modules/ste-events/dist/EventList.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EventList = void 0;
    var ste_core_1 = require_dist();
    var EventDispatcher_1 = require_EventDispatcher();
    var EventList = class extends ste_core_1.EventListBase {
      /**
       * Creates a new EventList instance.
       */
      constructor() {
        super();
      }
      /**
       * Creates a new dispatcher instance.
       */
      createDispatcher() {
        return new EventDispatcher_1.EventDispatcher();
      }
    };
    exports.EventList = EventList;
  }
});

// ../../node_modules/.pnpm/ste-events@3.0.11/node_modules/ste-events/dist/EventHandlingBase.js
var require_EventHandlingBase = __commonJS({
  "../../node_modules/.pnpm/ste-events@3.0.11/node_modules/ste-events/dist/EventHandlingBase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EventHandlingBase = void 0;
    var ste_core_1 = require_dist();
    var EventList_1 = require_EventList();
    var EventHandlingBase = class extends ste_core_1.HandlingBase {
      constructor() {
        super(new EventList_1.EventList());
      }
    };
    exports.EventHandlingBase = EventHandlingBase;
  }
});

// ../../node_modules/.pnpm/ste-events@3.0.11/node_modules/ste-events/dist/NonUniformEventList.js
var require_NonUniformEventList = __commonJS({
  "../../node_modules/.pnpm/ste-events@3.0.11/node_modules/ste-events/dist/NonUniformEventList.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NonUniformEventList = void 0;
    var EventDispatcher_1 = require_EventDispatcher();
    var NonUniformEventList = class {
      constructor() {
        this._events = {};
      }
      /**
       * Gets the dispatcher associated with the name.
       * @param name The name of the event.
       */
      get(name12) {
        if (this._events[name12]) {
          return this._events[name12];
        }
        const event = this.createDispatcher();
        this._events[name12] = event;
        return event;
      }
      /**
       * Removes the dispatcher associated with the name.
       * @param name The name of the event.
       */
      remove(name12) {
        delete this._events[name12];
      }
      /**
       * Creates a new dispatcher instance.
       */
      createDispatcher() {
        return new EventDispatcher_1.EventDispatcher();
      }
    };
    exports.NonUniformEventList = NonUniformEventList;
  }
});

// ../../node_modules/.pnpm/ste-events@3.0.11/node_modules/ste-events/dist/index.js
var require_dist2 = __commonJS({
  "../../node_modules/.pnpm/ste-events@3.0.11/node_modules/ste-events/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NonUniformEventList = exports.EventList = exports.EventHandlingBase = exports.EventDispatcher = void 0;
    var EventDispatcher_1 = require_EventDispatcher();
    Object.defineProperty(exports, "EventDispatcher", { enumerable: true, get: function() {
      return EventDispatcher_1.EventDispatcher;
    } });
    var EventHandlingBase_1 = require_EventHandlingBase();
    Object.defineProperty(exports, "EventHandlingBase", { enumerable: true, get: function() {
      return EventHandlingBase_1.EventHandlingBase;
    } });
    var EventList_1 = require_EventList();
    Object.defineProperty(exports, "EventList", { enumerable: true, get: function() {
      return EventList_1.EventList;
    } });
    var NonUniformEventList_1 = require_NonUniformEventList();
    Object.defineProperty(exports, "NonUniformEventList", { enumerable: true, get: function() {
      return NonUniformEventList_1.NonUniformEventList;
    } });
  }
});

// ../../node_modules/.pnpm/ste-simple-events@3.0.11/node_modules/ste-simple-events/dist/SimpleEventDispatcher.js
var require_SimpleEventDispatcher = __commonJS({
  "../../node_modules/.pnpm/ste-simple-events@3.0.11/node_modules/ste-simple-events/dist/SimpleEventDispatcher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SimpleEventDispatcher = void 0;
    var ste_core_1 = require_dist();
    var SimpleEventDispatcher = class extends ste_core_1.DispatcherBase {
      /**
       * Creates an instance of SimpleEventDispatcher.
       *
       * @memberOf SimpleEventDispatcher
       */
      constructor() {
        super();
      }
      /**
       * Dispatches the event.
       *
       * @param {TArgs} args The arguments object.
       * @returns {IPropagationStatus} The status of the event.
       *
       * @memberOf SimpleEventDispatcher
       */
      dispatch(args) {
        const result = this._dispatch(false, this, arguments);
        if (result == null) {
          throw new ste_core_1.DispatchError("Got `null` back from dispatch.");
        }
        return result;
      }
      /**
       * Dispatches the event without waiting for the result.
       *
       * @param {TArgs} args The arguments object.
       *
       * @memberOf SimpleEventDispatcher
       */
      dispatchAsync(args) {
        this._dispatch(true, this, arguments);
      }
      /**
       * Creates an event from the dispatcher. Will return the dispatcher
       * in a wrapper. This will prevent exposure of any dispatcher methods.
       *
       * @returns {ISimpleEvent<TArgs>} The event.
       *
       * @memberOf SimpleEventDispatcher
       */
      asEvent() {
        return super.asEvent();
      }
    };
    exports.SimpleEventDispatcher = SimpleEventDispatcher;
  }
});

// ../../node_modules/.pnpm/ste-simple-events@3.0.11/node_modules/ste-simple-events/dist/SimpleEventList.js
var require_SimpleEventList = __commonJS({
  "../../node_modules/.pnpm/ste-simple-events@3.0.11/node_modules/ste-simple-events/dist/SimpleEventList.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SimpleEventList = void 0;
    var ste_core_1 = require_dist();
    var SimpleEventDispatcher_1 = require_SimpleEventDispatcher();
    var SimpleEventList = class extends ste_core_1.EventListBase {
      /**
       * Creates a new SimpleEventList instance.
       */
      constructor() {
        super();
      }
      /**
       * Creates a new dispatcher instance.
       */
      createDispatcher() {
        return new SimpleEventDispatcher_1.SimpleEventDispatcher();
      }
    };
    exports.SimpleEventList = SimpleEventList;
  }
});

// ../../node_modules/.pnpm/ste-simple-events@3.0.11/node_modules/ste-simple-events/dist/SimpleEventHandlingBase.js
var require_SimpleEventHandlingBase = __commonJS({
  "../../node_modules/.pnpm/ste-simple-events@3.0.11/node_modules/ste-simple-events/dist/SimpleEventHandlingBase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SimpleEventHandlingBase = void 0;
    var ste_core_1 = require_dist();
    var SimpleEventList_1 = require_SimpleEventList();
    var SimpleEventHandlingBase = class extends ste_core_1.HandlingBase {
      constructor() {
        super(new SimpleEventList_1.SimpleEventList());
      }
    };
    exports.SimpleEventHandlingBase = SimpleEventHandlingBase;
  }
});

// ../../node_modules/.pnpm/ste-simple-events@3.0.11/node_modules/ste-simple-events/dist/NonUniformSimpleEventList.js
var require_NonUniformSimpleEventList = __commonJS({
  "../../node_modules/.pnpm/ste-simple-events@3.0.11/node_modules/ste-simple-events/dist/NonUniformSimpleEventList.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NonUniformSimpleEventList = void 0;
    var SimpleEventDispatcher_1 = require_SimpleEventDispatcher();
    var NonUniformSimpleEventList = class {
      constructor() {
        this._events = {};
      }
      /**
       * Gets the dispatcher associated with the name.
       * @param name The name of the event.
       */
      get(name12) {
        if (this._events[name12]) {
          return this._events[name12];
        }
        const event = this.createDispatcher();
        this._events[name12] = event;
        return event;
      }
      /**
       * Removes the dispatcher associated with the name.
       * @param name The name of the event.
       */
      remove(name12) {
        delete this._events[name12];
      }
      /**
       * Creates a new dispatcher instance.
       */
      createDispatcher() {
        return new SimpleEventDispatcher_1.SimpleEventDispatcher();
      }
    };
    exports.NonUniformSimpleEventList = NonUniformSimpleEventList;
  }
});

// ../../node_modules/.pnpm/ste-simple-events@3.0.11/node_modules/ste-simple-events/dist/index.js
var require_dist3 = __commonJS({
  "../../node_modules/.pnpm/ste-simple-events@3.0.11/node_modules/ste-simple-events/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NonUniformSimpleEventList = exports.SimpleEventList = exports.SimpleEventHandlingBase = exports.SimpleEventDispatcher = void 0;
    var SimpleEventDispatcher_1 = require_SimpleEventDispatcher();
    Object.defineProperty(exports, "SimpleEventDispatcher", { enumerable: true, get: function() {
      return SimpleEventDispatcher_1.SimpleEventDispatcher;
    } });
    var SimpleEventHandlingBase_1 = require_SimpleEventHandlingBase();
    Object.defineProperty(exports, "SimpleEventHandlingBase", { enumerable: true, get: function() {
      return SimpleEventHandlingBase_1.SimpleEventHandlingBase;
    } });
    var NonUniformSimpleEventList_1 = require_NonUniformSimpleEventList();
    Object.defineProperty(exports, "NonUniformSimpleEventList", { enumerable: true, get: function() {
      return NonUniformSimpleEventList_1.NonUniformSimpleEventList;
    } });
    var SimpleEventList_1 = require_SimpleEventList();
    Object.defineProperty(exports, "SimpleEventList", { enumerable: true, get: function() {
      return SimpleEventList_1.SimpleEventList;
    } });
  }
});

// ../../node_modules/.pnpm/ste-signals@3.0.11/node_modules/ste-signals/dist/SignalDispatcher.js
var require_SignalDispatcher = __commonJS({
  "../../node_modules/.pnpm/ste-signals@3.0.11/node_modules/ste-signals/dist/SignalDispatcher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SignalDispatcher = void 0;
    var ste_core_1 = require_dist();
    var SignalDispatcher = class extends ste_core_1.DispatcherBase {
      /**
       * Dispatches the signal.
       *
       * @returns {IPropagationStatus} The status of the signal.
       *
       * @memberOf SignalDispatcher
       */
      dispatch() {
        const result = this._dispatch(false, this, arguments);
        if (result == null) {
          throw new ste_core_1.DispatchError("Got `null` back from dispatch.");
        }
        return result;
      }
      /**
       * Dispatches the signal without waiting for the result.
       *
       * @memberOf SignalDispatcher
       */
      dispatchAsync() {
        this._dispatch(true, this, arguments);
      }
      /**
       * Creates an event from the dispatcher. Will return the dispatcher
       * in a wrapper. This will prevent exposure of any dispatcher methods.
       *
       * @returns {ISignal} The signal.
       *
       * @memberOf SignalDispatcher
       */
      asEvent() {
        return super.asEvent();
      }
    };
    exports.SignalDispatcher = SignalDispatcher;
  }
});

// ../../node_modules/.pnpm/ste-signals@3.0.11/node_modules/ste-signals/dist/SignalList.js
var require_SignalList = __commonJS({
  "../../node_modules/.pnpm/ste-signals@3.0.11/node_modules/ste-signals/dist/SignalList.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SignalList = void 0;
    var ste_core_1 = require_dist();
    var SignalDispatcher_1 = require_SignalDispatcher();
    var SignalList = class extends ste_core_1.EventListBase {
      /**
       * Creates an instance of SignalList.
       *
       * @memberOf SignalList
       */
      constructor() {
        super();
      }
      /**
       * Creates a new dispatcher instance.
       *
       * @protected
       * @returns {SignalDispatcher}
       *
       * @memberOf SignalList
       */
      createDispatcher() {
        return new SignalDispatcher_1.SignalDispatcher();
      }
    };
    exports.SignalList = SignalList;
  }
});

// ../../node_modules/.pnpm/ste-signals@3.0.11/node_modules/ste-signals/dist/SignalHandlingBase.js
var require_SignalHandlingBase = __commonJS({
  "../../node_modules/.pnpm/ste-signals@3.0.11/node_modules/ste-signals/dist/SignalHandlingBase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SignalHandlingBase = void 0;
    var ste_core_1 = require_dist();
    var SignalList_1 = require_SignalList();
    var SignalHandlingBase = class extends ste_core_1.HandlingBase {
      /**
       * Creates an instance of SignalHandlingBase.
       *
       * @memberOf SignalHandlingBase
       */
      constructor() {
        super(new SignalList_1.SignalList());
      }
    };
    exports.SignalHandlingBase = SignalHandlingBase;
  }
});

// ../../node_modules/.pnpm/ste-signals@3.0.11/node_modules/ste-signals/dist/index.js
var require_dist4 = __commonJS({
  "../../node_modules/.pnpm/ste-signals@3.0.11/node_modules/ste-signals/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SignalList = exports.SignalHandlingBase = exports.SignalDispatcher = void 0;
    var SignalDispatcher_1 = require_SignalDispatcher();
    Object.defineProperty(exports, "SignalDispatcher", { enumerable: true, get: function() {
      return SignalDispatcher_1.SignalDispatcher;
    } });
    var SignalHandlingBase_1 = require_SignalHandlingBase();
    Object.defineProperty(exports, "SignalHandlingBase", { enumerable: true, get: function() {
      return SignalHandlingBase_1.SignalHandlingBase;
    } });
    var SignalList_1 = require_SignalList();
    Object.defineProperty(exports, "SignalList", { enumerable: true, get: function() {
      return SignalList_1.SignalList;
    } });
  }
});

// ../../node_modules/.pnpm/ste-promise-events@3.0.11/node_modules/ste-promise-events/dist/PromiseEventDispatcher.js
var require_PromiseEventDispatcher = __commonJS({
  "../../node_modules/.pnpm/ste-promise-events@3.0.11/node_modules/ste-promise-events/dist/PromiseEventDispatcher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PromiseEventDispatcher = void 0;
    var ste_core_1 = require_dist();
    var PromiseEventDispatcher = class extends ste_core_1.PromiseDispatcherBase {
      /**
       * Creates a new EventDispatcher instance.
       */
      constructor() {
        super();
      }
      /**
       * Dispatches the event.
       *
       * @param {TSender} sender The sender object.
       * @param {TArgs} args The argument object.
       * @returns {Promise<IPropagationStatus>} The status.
       *
       * @memberOf PromiseEventDispatcher
       */
      async dispatch(sender, args) {
        const result = await this._dispatchAsPromise(false, this, arguments);
        if (result == null) {
          throw new ste_core_1.DispatchError("Got `null` back from dispatch.");
        }
        return result;
      }
      /**
       * Dispatches the event without waiting for the result.
       *
       * @param {TSender} sender The sender object.
       * @param {TArgs} args The argument object.
       *
       * @memberOf PromiseEventDispatcher
       */
      dispatchAsync(sender, args) {
        this._dispatchAsPromise(true, this, arguments);
      }
      /**
       * Creates an event from the dispatcher. Will return the dispatcher
       * in a wrapper. This will prevent exposure of any dispatcher methods.
       */
      asEvent() {
        return super.asEvent();
      }
    };
    exports.PromiseEventDispatcher = PromiseEventDispatcher;
  }
});

// ../../node_modules/.pnpm/ste-promise-events@3.0.11/node_modules/ste-promise-events/dist/PromiseEventList.js
var require_PromiseEventList = __commonJS({
  "../../node_modules/.pnpm/ste-promise-events@3.0.11/node_modules/ste-promise-events/dist/PromiseEventList.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PromiseEventList = void 0;
    var ste_core_1 = require_dist();
    var PromiseEventDispatcher_1 = require_PromiseEventDispatcher();
    var PromiseEventList = class extends ste_core_1.EventListBase {
      /**
       * Creates a new EventList instance.
       */
      constructor() {
        super();
      }
      /**
       * Creates a new dispatcher instance.
       */
      createDispatcher() {
        return new PromiseEventDispatcher_1.PromiseEventDispatcher();
      }
    };
    exports.PromiseEventList = PromiseEventList;
  }
});

// ../../node_modules/.pnpm/ste-promise-events@3.0.11/node_modules/ste-promise-events/dist/PromiseEventHandlingBase.js
var require_PromiseEventHandlingBase = __commonJS({
  "../../node_modules/.pnpm/ste-promise-events@3.0.11/node_modules/ste-promise-events/dist/PromiseEventHandlingBase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PromiseEventHandlingBase = void 0;
    var ste_core_1 = require_dist();
    var PromiseEventList_1 = require_PromiseEventList();
    var PromiseEventHandlingBase = class extends ste_core_1.HandlingBase {
      constructor() {
        super(new PromiseEventList_1.PromiseEventList());
      }
    };
    exports.PromiseEventHandlingBase = PromiseEventHandlingBase;
  }
});

// ../../node_modules/.pnpm/ste-promise-events@3.0.11/node_modules/ste-promise-events/dist/NonUniformPromiseEventList.js
var require_NonUniformPromiseEventList = __commonJS({
  "../../node_modules/.pnpm/ste-promise-events@3.0.11/node_modules/ste-promise-events/dist/NonUniformPromiseEventList.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NonUniformPromiseEventList = void 0;
    var PromiseEventDispatcher_1 = require_PromiseEventDispatcher();
    var NonUniformPromiseEventList = class {
      constructor() {
        this._events = {};
      }
      /**
       * Gets the dispatcher associated with the name.
       * @param name The name of the event.
       */
      get(name12) {
        if (this._events[name12]) {
          return this._events[name12];
        }
        const event = this.createDispatcher();
        this._events[name12] = event;
        return event;
      }
      /**
       * Removes the dispatcher associated with the name.
       * @param name The name of the event.
       */
      remove(name12) {
        delete this._events[name12];
      }
      /**
       * Creates a new dispatcher instance.
       */
      createDispatcher() {
        return new PromiseEventDispatcher_1.PromiseEventDispatcher();
      }
    };
    exports.NonUniformPromiseEventList = NonUniformPromiseEventList;
  }
});

// ../../node_modules/.pnpm/ste-promise-events@3.0.11/node_modules/ste-promise-events/dist/index.js
var require_dist5 = __commonJS({
  "../../node_modules/.pnpm/ste-promise-events@3.0.11/node_modules/ste-promise-events/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NonUniformPromiseEventList = exports.PromiseEventList = exports.PromiseEventHandlingBase = exports.PromiseEventDispatcher = void 0;
    var PromiseEventDispatcher_1 = require_PromiseEventDispatcher();
    Object.defineProperty(exports, "PromiseEventDispatcher", { enumerable: true, get: function() {
      return PromiseEventDispatcher_1.PromiseEventDispatcher;
    } });
    var PromiseEventHandlingBase_1 = require_PromiseEventHandlingBase();
    Object.defineProperty(exports, "PromiseEventHandlingBase", { enumerable: true, get: function() {
      return PromiseEventHandlingBase_1.PromiseEventHandlingBase;
    } });
    var PromiseEventList_1 = require_PromiseEventList();
    Object.defineProperty(exports, "PromiseEventList", { enumerable: true, get: function() {
      return PromiseEventList_1.PromiseEventList;
    } });
    var NonUniformPromiseEventList_1 = require_NonUniformPromiseEventList();
    Object.defineProperty(exports, "NonUniformPromiseEventList", { enumerable: true, get: function() {
      return NonUniformPromiseEventList_1.NonUniformPromiseEventList;
    } });
  }
});

// ../../node_modules/.pnpm/ste-promise-signals@3.0.11/node_modules/ste-promise-signals/dist/PromiseSignalDispatcher.js
var require_PromiseSignalDispatcher = __commonJS({
  "../../node_modules/.pnpm/ste-promise-signals@3.0.11/node_modules/ste-promise-signals/dist/PromiseSignalDispatcher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PromiseSignalDispatcher = void 0;
    var ste_core_1 = require_dist();
    var PromiseSignalDispatcher = class extends ste_core_1.PromiseDispatcherBase {
      /**
       * Creates a new SignalDispatcher instance.
       */
      constructor() {
        super();
      }
      /**
       * Dispatches the signal.
       *
       * @returns {IPropagationStatus} The status of the dispatch.
       *
       * @memberOf SignalDispatcher
       */
      async dispatch() {
        const result = await this._dispatchAsPromise(false, this, arguments);
        if (result == null) {
          throw new ste_core_1.DispatchError("Got `null` back from dispatch.");
        }
        return result;
      }
      /**
       * Dispatches the signal threaded.
       */
      dispatchAsync() {
        this._dispatchAsPromise(true, this, arguments);
      }
      /**
       * Creates an event from the dispatcher. Will return the dispatcher
       * in a wrapper. This will prevent exposure of any dispatcher methods.
       */
      asEvent() {
        return super.asEvent();
      }
    };
    exports.PromiseSignalDispatcher = PromiseSignalDispatcher;
  }
});

// ../../node_modules/.pnpm/ste-promise-signals@3.0.11/node_modules/ste-promise-signals/dist/PromiseSignalList.js
var require_PromiseSignalList = __commonJS({
  "../../node_modules/.pnpm/ste-promise-signals@3.0.11/node_modules/ste-promise-signals/dist/PromiseSignalList.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PromiseSignalList = void 0;
    var ste_core_1 = require_dist();
    var PromiseSignalDispatcher_1 = require_PromiseSignalDispatcher();
    var PromiseSignalList = class extends ste_core_1.EventListBase {
      /**
       * Creates a new SignalList instance.
       */
      constructor() {
        super();
      }
      /**
       * Creates a new dispatcher instance.
       */
      createDispatcher() {
        return new PromiseSignalDispatcher_1.PromiseSignalDispatcher();
      }
    };
    exports.PromiseSignalList = PromiseSignalList;
  }
});

// ../../node_modules/.pnpm/ste-promise-signals@3.0.11/node_modules/ste-promise-signals/dist/PromiseSignalHandlingBase.js
var require_PromiseSignalHandlingBase = __commonJS({
  "../../node_modules/.pnpm/ste-promise-signals@3.0.11/node_modules/ste-promise-signals/dist/PromiseSignalHandlingBase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PromiseSignalHandlingBase = void 0;
    var ste_core_1 = require_dist();
    var PromiseSignalList_1 = require_PromiseSignalList();
    var PromiseSignalHandlingBase = class extends ste_core_1.HandlingBase {
      constructor() {
        super(new PromiseSignalList_1.PromiseSignalList());
      }
    };
    exports.PromiseSignalHandlingBase = PromiseSignalHandlingBase;
  }
});

// ../../node_modules/.pnpm/ste-promise-signals@3.0.11/node_modules/ste-promise-signals/dist/index.js
var require_dist6 = __commonJS({
  "../../node_modules/.pnpm/ste-promise-signals@3.0.11/node_modules/ste-promise-signals/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PromiseSignalList = exports.PromiseSignalHandlingBase = exports.PromiseSignalDispatcher = void 0;
    var PromiseSignalDispatcher_1 = require_PromiseSignalDispatcher();
    Object.defineProperty(exports, "PromiseSignalDispatcher", { enumerable: true, get: function() {
      return PromiseSignalDispatcher_1.PromiseSignalDispatcher;
    } });
    var PromiseSignalHandlingBase_1 = require_PromiseSignalHandlingBase();
    Object.defineProperty(exports, "PromiseSignalHandlingBase", { enumerable: true, get: function() {
      return PromiseSignalHandlingBase_1.PromiseSignalHandlingBase;
    } });
    var PromiseSignalList_1 = require_PromiseSignalList();
    Object.defineProperty(exports, "PromiseSignalList", { enumerable: true, get: function() {
      return PromiseSignalList_1.PromiseSignalList;
    } });
  }
});

// ../../node_modules/.pnpm/ste-promise-simple-events@3.0.11/node_modules/ste-promise-simple-events/dist/PromiseSimpleEventDispatcher.js
var require_PromiseSimpleEventDispatcher = __commonJS({
  "../../node_modules/.pnpm/ste-promise-simple-events@3.0.11/node_modules/ste-promise-simple-events/dist/PromiseSimpleEventDispatcher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PromiseSimpleEventDispatcher = void 0;
    var ste_core_1 = require_dist();
    var PromiseSimpleEventDispatcher = class extends ste_core_1.PromiseDispatcherBase {
      /**
       * Creates a new SimpleEventDispatcher instance.
       */
      constructor() {
        super();
      }
      /**
       * Dispatches the event.
       * @param args The arguments object.
       * @returns {IPropagationStatus} The status of the dispatch.
       * @memberOf PromiseSimpleEventDispatcher
       */
      async dispatch(args) {
        const result = await this._dispatchAsPromise(false, this, arguments);
        if (result == null) {
          throw new ste_core_1.DispatchError("Got `null` back from dispatch.");
        }
        return result;
      }
      /**
       * Dispatches the event without waiting for it to complete.
       * @param args The argument object.
       * @memberOf PromiseSimpleEventDispatcher
       */
      dispatchAsync(args) {
        this._dispatchAsPromise(true, this, arguments);
      }
      /**
       * Creates an event from the dispatcher. Will return the dispatcher
       * in a wrapper. This will prevent exposure of any dispatcher methods.
       */
      asEvent() {
        return super.asEvent();
      }
    };
    exports.PromiseSimpleEventDispatcher = PromiseSimpleEventDispatcher;
  }
});

// ../../node_modules/.pnpm/ste-promise-simple-events@3.0.11/node_modules/ste-promise-simple-events/dist/NonUniformPromiseSimpleEventList.js
var require_NonUniformPromiseSimpleEventList = __commonJS({
  "../../node_modules/.pnpm/ste-promise-simple-events@3.0.11/node_modules/ste-promise-simple-events/dist/NonUniformPromiseSimpleEventList.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NonUniformPromiseSimpleEventList = void 0;
    var PromiseSimpleEventDispatcher_1 = require_PromiseSimpleEventDispatcher();
    var NonUniformPromiseSimpleEventList = class {
      constructor() {
        this._events = {};
      }
      /**
       * Gets the dispatcher associated with the name.
       * @param name The name of the event.
       */
      get(name12) {
        if (this._events[name12]) {
          return this._events[name12];
        }
        const event = this.createDispatcher();
        this._events[name12] = event;
        return event;
      }
      /**
       * Removes the dispatcher associated with the name.
       * @param name The name of the event.
       */
      remove(name12) {
        delete this._events[name12];
      }
      /**
       * Creates a new dispatcher instance.
       */
      createDispatcher() {
        return new PromiseSimpleEventDispatcher_1.PromiseSimpleEventDispatcher();
      }
    };
    exports.NonUniformPromiseSimpleEventList = NonUniformPromiseSimpleEventList;
  }
});

// ../../node_modules/.pnpm/ste-promise-simple-events@3.0.11/node_modules/ste-promise-simple-events/dist/PromiseSimpleEventList.js
var require_PromiseSimpleEventList = __commonJS({
  "../../node_modules/.pnpm/ste-promise-simple-events@3.0.11/node_modules/ste-promise-simple-events/dist/PromiseSimpleEventList.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PromiseSimpleEventList = void 0;
    var ste_core_1 = require_dist();
    var PromiseSimpleEventDispatcher_1 = require_PromiseSimpleEventDispatcher();
    var PromiseSimpleEventList = class extends ste_core_1.EventListBase {
      /**
       * Creates a new SimpleEventList instance.
       */
      constructor() {
        super();
      }
      /**
       * Creates a new dispatcher instance.
       */
      createDispatcher() {
        return new PromiseSimpleEventDispatcher_1.PromiseSimpleEventDispatcher();
      }
    };
    exports.PromiseSimpleEventList = PromiseSimpleEventList;
  }
});

// ../../node_modules/.pnpm/ste-promise-simple-events@3.0.11/node_modules/ste-promise-simple-events/dist/PromiseSimpleEventHandlingBase.js
var require_PromiseSimpleEventHandlingBase = __commonJS({
  "../../node_modules/.pnpm/ste-promise-simple-events@3.0.11/node_modules/ste-promise-simple-events/dist/PromiseSimpleEventHandlingBase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PromiseSimpleEventHandlingBase = void 0;
    var ste_core_1 = require_dist();
    var PromiseSimpleEventList_1 = require_PromiseSimpleEventList();
    var PromiseSimpleEventHandlingBase = class extends ste_core_1.HandlingBase {
      constructor() {
        super(new PromiseSimpleEventList_1.PromiseSimpleEventList());
      }
    };
    exports.PromiseSimpleEventHandlingBase = PromiseSimpleEventHandlingBase;
  }
});

// ../../node_modules/.pnpm/ste-promise-simple-events@3.0.11/node_modules/ste-promise-simple-events/dist/index.js
var require_dist7 = __commonJS({
  "../../node_modules/.pnpm/ste-promise-simple-events@3.0.11/node_modules/ste-promise-simple-events/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NonUniformPromiseSimpleEventList = exports.PromiseSimpleEventList = exports.PromiseSimpleEventHandlingBase = exports.PromiseSimpleEventDispatcher = void 0;
    var NonUniformPromiseSimpleEventList_1 = require_NonUniformPromiseSimpleEventList();
    Object.defineProperty(exports, "NonUniformPromiseSimpleEventList", { enumerable: true, get: function() {
      return NonUniformPromiseSimpleEventList_1.NonUniformPromiseSimpleEventList;
    } });
    var PromiseSimpleEventDispatcher_1 = require_PromiseSimpleEventDispatcher();
    Object.defineProperty(exports, "PromiseSimpleEventDispatcher", { enumerable: true, get: function() {
      return PromiseSimpleEventDispatcher_1.PromiseSimpleEventDispatcher;
    } });
    var PromiseSimpleEventHandlingBase_1 = require_PromiseSimpleEventHandlingBase();
    Object.defineProperty(exports, "PromiseSimpleEventHandlingBase", { enumerable: true, get: function() {
      return PromiseSimpleEventHandlingBase_1.PromiseSimpleEventHandlingBase;
    } });
    var PromiseSimpleEventList_1 = require_PromiseSimpleEventList();
    Object.defineProperty(exports, "PromiseSimpleEventList", { enumerable: true, get: function() {
      return PromiseSimpleEventList_1.PromiseSimpleEventList;
    } });
  }
});

// ../../node_modules/.pnpm/strongly-typed-events@3.0.7/node_modules/strongly-typed-events/dist/index.js
var require_dist8 = __commonJS({
  "../../node_modules/.pnpm/strongly-typed-events@3.0.7/node_modules/strongly-typed-events/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NonUniformPromiseSimpleEventList = exports.PromiseSimpleEventList = exports.PromiseSimpleEventHandlingBase = exports.PromiseSimpleEventDispatcher = exports.PromiseSignalList = exports.PromiseSignalHandlingBase = exports.PromiseSignalDispatcher = exports.NonUniformPromiseEventList = exports.PromiseEventList = exports.PromiseEventHandlingBase = exports.PromiseEventDispatcher = exports.SignalList = exports.SignalHandlingBase = exports.SignalDispatcher = exports.NonUniformSimpleEventList = exports.SimpleEventList = exports.SimpleEventHandlingBase = exports.SimpleEventDispatcher = exports.NonUniformEventList = exports.EventList = exports.EventHandlingBase = exports.EventDispatcher = exports.HandlingBase = exports.PromiseDispatcherBase = exports.PromiseSubscription = exports.DispatchError = exports.EventManagement = exports.EventListBase = exports.DispatcherWrapper = exports.DispatcherBase = exports.Subscription = void 0;
    var ste_core_1 = require_dist();
    Object.defineProperty(exports, "Subscription", { enumerable: true, get: function() {
      return ste_core_1.Subscription;
    } });
    Object.defineProperty(exports, "DispatcherBase", { enumerable: true, get: function() {
      return ste_core_1.DispatcherBase;
    } });
    Object.defineProperty(exports, "DispatcherWrapper", { enumerable: true, get: function() {
      return ste_core_1.DispatcherWrapper;
    } });
    Object.defineProperty(exports, "EventListBase", { enumerable: true, get: function() {
      return ste_core_1.EventListBase;
    } });
    Object.defineProperty(exports, "EventManagement", { enumerable: true, get: function() {
      return ste_core_1.EventManagement;
    } });
    Object.defineProperty(exports, "DispatchError", { enumerable: true, get: function() {
      return ste_core_1.DispatchError;
    } });
    Object.defineProperty(exports, "PromiseSubscription", { enumerable: true, get: function() {
      return ste_core_1.PromiseSubscription;
    } });
    Object.defineProperty(exports, "PromiseDispatcherBase", { enumerable: true, get: function() {
      return ste_core_1.PromiseDispatcherBase;
    } });
    Object.defineProperty(exports, "HandlingBase", { enumerable: true, get: function() {
      return ste_core_1.HandlingBase;
    } });
    var ste_events_1 = require_dist2();
    Object.defineProperty(exports, "EventDispatcher", { enumerable: true, get: function() {
      return ste_events_1.EventDispatcher;
    } });
    Object.defineProperty(exports, "EventHandlingBase", { enumerable: true, get: function() {
      return ste_events_1.EventHandlingBase;
    } });
    Object.defineProperty(exports, "EventList", { enumerable: true, get: function() {
      return ste_events_1.EventList;
    } });
    Object.defineProperty(exports, "NonUniformEventList", { enumerable: true, get: function() {
      return ste_events_1.NonUniformEventList;
    } });
    var ste_simple_events_1 = require_dist3();
    Object.defineProperty(exports, "SimpleEventDispatcher", { enumerable: true, get: function() {
      return ste_simple_events_1.SimpleEventDispatcher;
    } });
    Object.defineProperty(exports, "SimpleEventHandlingBase", { enumerable: true, get: function() {
      return ste_simple_events_1.SimpleEventHandlingBase;
    } });
    Object.defineProperty(exports, "SimpleEventList", { enumerable: true, get: function() {
      return ste_simple_events_1.SimpleEventList;
    } });
    Object.defineProperty(exports, "NonUniformSimpleEventList", { enumerable: true, get: function() {
      return ste_simple_events_1.NonUniformSimpleEventList;
    } });
    var ste_signals_1 = require_dist4();
    Object.defineProperty(exports, "SignalDispatcher", { enumerable: true, get: function() {
      return ste_signals_1.SignalDispatcher;
    } });
    Object.defineProperty(exports, "SignalHandlingBase", { enumerable: true, get: function() {
      return ste_signals_1.SignalHandlingBase;
    } });
    Object.defineProperty(exports, "SignalList", { enumerable: true, get: function() {
      return ste_signals_1.SignalList;
    } });
    var ste_promise_events_1 = require_dist5();
    Object.defineProperty(exports, "PromiseEventDispatcher", { enumerable: true, get: function() {
      return ste_promise_events_1.PromiseEventDispatcher;
    } });
    Object.defineProperty(exports, "PromiseEventHandlingBase", { enumerable: true, get: function() {
      return ste_promise_events_1.PromiseEventHandlingBase;
    } });
    Object.defineProperty(exports, "PromiseEventList", { enumerable: true, get: function() {
      return ste_promise_events_1.PromiseEventList;
    } });
    Object.defineProperty(exports, "NonUniformPromiseEventList", { enumerable: true, get: function() {
      return ste_promise_events_1.NonUniformPromiseEventList;
    } });
    var ste_promise_signals_1 = require_dist6();
    Object.defineProperty(exports, "PromiseSignalDispatcher", { enumerable: true, get: function() {
      return ste_promise_signals_1.PromiseSignalDispatcher;
    } });
    Object.defineProperty(exports, "PromiseSignalHandlingBase", { enumerable: true, get: function() {
      return ste_promise_signals_1.PromiseSignalHandlingBase;
    } });
    Object.defineProperty(exports, "PromiseSignalList", { enumerable: true, get: function() {
      return ste_promise_signals_1.PromiseSignalList;
    } });
    var ste_promise_simple_events_1 = require_dist7();
    Object.defineProperty(exports, "PromiseSimpleEventDispatcher", { enumerable: true, get: function() {
      return ste_promise_simple_events_1.PromiseSimpleEventDispatcher;
    } });
    Object.defineProperty(exports, "PromiseSimpleEventHandlingBase", { enumerable: true, get: function() {
      return ste_promise_simple_events_1.PromiseSimpleEventHandlingBase;
    } });
    Object.defineProperty(exports, "PromiseSimpleEventList", { enumerable: true, get: function() {
      return ste_promise_simple_events_1.PromiseSimpleEventList;
    } });
    Object.defineProperty(exports, "NonUniformPromiseSimpleEventList", { enumerable: true, get: function() {
      return ste_promise_simple_events_1.NonUniformPromiseSimpleEventList;
    } });
  }
});

// (disabled):path
var require_path = __commonJS({
  "(disabled):path"() {
  }
});

// (disabled):fs
var require_fs = __commonJS({
  "(disabled):fs"() {
  }
});

// ../sdk/src/core/index.ts
var core_exports = {};
__export(core_exports, {
  Component: () => Component,
  EventEmitter: () => EventEmitter,
  SDKError: () => SDKError
});

// ../sdk/src/core/EventEmitter.ts
var EventEmitter = class {
  #ievent;
  constructor(ievent) {
    this.#ievent = ievent;
  }
  /**
   * Returns the number of subscriptions.
   */
  get count() {
    return this.#ievent.count;
  }
  /**
   * Subscribe to the event.
   *
   * @param func The event handler that is called when the event is dispatched.
   * @returns Function that unsubscribes the event handler from the event.
   */
  subscribe(func) {
    return this.#ievent.asEvent().subscribe(func);
  }
  /**
   * @private
   * @param sender
   * @param args
   */
  dispatch(sender, args) {
    this.#ievent.dispatch(sender, args);
  }
  /**
   * Subscribe to the event.
   * @param func The event handler that is called when the event is dispatched.
   * @returns A function that unsubscribes the event handler from the event.
   */
  sub(func) {
    return this.#ievent.asEvent().sub(func);
  }
  /**
   * Unsubscribe from the event.
   * @param func The event handler that will be unsubsribed from the event.
   */
  unsubscribe(func) {
    this.#ievent.asEvent().unsubscribe(func);
  }
  /**
   * Unsubscribe from the event.
   * @param func The event handler that will be unsubsribed from the event.
   */
  unsub(func) {
    this.#ievent.asEvent().unsub(func);
  }
  /**
   * Subscribes to the event only once.
   * @param func The event handler that is called when the event is dispatched.
   * @returns A function that unsubscribes the event handler from the event.
   */
  one(func) {
    return this.#ievent.asEvent().one(func);
  }
  /**
   * Checks if the event has a subscription for the specified handler.
   * @param func The event handler.
   */
  has(func) {
    return this.#ievent.asEvent().has(func);
  }
  /**
   * Clears all the subscriptions.
   */
  clear() {
    this.#ievent.asEvent().clear();
  }
};

// ../sdk/src/core/Component.ts
var import_strongly_typed_events = __toESM(require_dist8());
var createUUID = (() => {
  const lut = [];
  for (let i = 0; i < 256; i++) {
    lut[i] = (i < 16 ? "0" : "") + i.toString(16);
  }
  return () => {
    const d0 = Math.random() * 4294967295 | 0;
    const d1 = Math.random() * 4294967295 | 0;
    const d2 = Math.random() * 4294967295 | 0;
    const d3 = Math.random() * 4294967295 | 0;
    return `${lut[d0 & 255] + lut[d0 >> 8 & 255] + lut[d0 >> 16 & 255] + lut[d0 >> 24 & 255]}-${lut[d1 & 255]}${lut[d1 >> 8 & 255]}-${lut[d1 >> 16 & 15 | 64]}${lut[d1 >> 24 & 255]}-${lut[d2 & 63 | 128]}${lut[d2 >> 8 & 255]}-${lut[d2 >> 16 & 255]}${lut[d2 >> 24 & 255]}${lut[d3 & 255]}${lut[d3 >> 8 & 255]}${lut[d3 >> 16 & 255]}${lut[d3 >> 24 & 255]}`;
  };
})();
var Component = class {
  /**
   * Unique ID of this Component.
   */
  id;
  /**
   * True once this Component has been destroyed.
   *
   * Don't use this Component if this is ````true````.
   */
  destroyed;
  dirty;
  #owner;
  #ownedComponents;
  /**
   * Emits an event when the {@link core!Component | Component} has been destroyed.
   *
   * @event
   */
  onDestroyed;
  /**
   * Creates a new component.
   */
  constructor(owner, cfg = {}) {
    this.#owner = owner;
    this.id = cfg.id || createUUID();
    this.destroyed = false;
    this.#ownedComponents = null;
    this.dirty = false;
    this.onDestroyed = new EventEmitter(new import_strongly_typed_events.EventDispatcher());
    if (owner) {
      owner.#own(this);
    }
  }
  /**
   * Logs a message for this component.
   *
   * The message will have this format: *````[LOG] [<component type> <component id>: <message>````*
   *
   * @param message - The message to log
   * @protected
   */
  log(message) {
    console.log(`[LOG] ${this.#prefixMessageWithID(message)}`);
  }
  /**
   * Logs a warning for this component to the JavaScript console.
   *
   * The console message will have this format: *````[WARN] [<component type> =<component id>: <message>````*
   *
   * @param message - The warning message to log
   * @protected
   */
  warn(message) {
    console.warn(`[WARN] ${this.#prefixMessageWithID(message)}`);
  }
  /**
       * Logs an error for this component to the JavaScript console.
       *
       * The console message will have this format: *````[ERROR] [<component type> =<component id>: <message>````*
  
       @param message The error message to log
       @protected
       */
  error(message) {
    console.error(`[ERROR] ${this.#prefixMessageWithID(message)}`);
  }
  /**
   * Flags this component as having a defered state updates it needs to perform.
   */
  setDirty() {
    this.dirty = true;
  }
  /**
   * Gives this component an opportunity to action any defered state updates.
   */
  cleanIfDirty() {
    if (this.dirty) {
      this.dirty = false;
      this.clean();
    }
  }
  /**
   * Forces this component to action any deferred state updates.
   */
  clean() {
  }
  /**
   * Destroys this component.
   *
   * Also destroys any components owned by this one.
   *
   * Sets {@link Component.destroyed} ````true````.
   *
   * Cancels any deferred state updates.
   */
  destroy() {
    if (this.destroyed) {
      return;
    }
    this.destroyed = true;
    if (this.#ownedComponents) {
      for (let id in this.#ownedComponents) {
        if (this.#ownedComponents.hasOwnProperty(id)) {
          const component = this.#ownedComponents[id];
          component.destroy();
          delete this.#ownedComponents[id];
        }
      }
    }
    this.#ownedComponents = null;
    this.dirty = false;
    this.onDestroyed.dispatch(this, null);
    this.onDestroyed.clear();
  }
  #prefixMessageWithID(message) {
    return ` [${this.constructor.name} "${this.id}"]: ${message}`;
  }
  #own(component) {
    if (!this.#ownedComponents) {
      this.#ownedComponents = {};
    }
    if (!this.#ownedComponents[component.id]) {
      this.#ownedComponents[component.id] = component;
    }
    component.onDestroyed.one(() => {
      delete this.#ownedComponents[component.id];
    });
  }
};

// ../sdk/src/core/SDKError.ts
var SDKError = class extends Error {
};

// ../sdk/src/constants/index.ts
var constants_exports = {};
__export(constants_exports, {
  AZERTYLayout: () => AZERTYLayout,
  AlphaFormat: () => AlphaFormat,
  ByteType: () => ByteType,
  CentimetersUnit: () => CentimetersUnit,
  ClampToEdgeWrapping: () => ClampToEdgeWrapping,
  CustomProjectionType: () => CustomProjectionType,
  DepthFormat: () => DepthFormat,
  DepthStencilFormat: () => DepthStencilFormat,
  DynamicDraw: () => DynamicDraw,
  FastRender: () => FastRender,
  FeetUnit: () => FeetUnit,
  FirstPersonNavigationMode: () => FirstPersonNavigationMode,
  FloatType: () => FloatType,
  FrustumProjectionType: () => FrustumProjectionType,
  GIFMediaType: () => GIFMediaType,
  HalfFloatType: () => HalfFloatType,
  InchesUnit: () => InchesUnit,
  IntType: () => IntType,
  JPEGMediaType: () => JPEGMediaType,
  LinearEncoding: () => LinearEncoding,
  LinearFilter: () => LinearFilter,
  LinearMipMapLinearFilter: () => LinearMipMapLinearFilter,
  LinearMipMapNearestFilter: () => LinearMipMapNearestFilter,
  LinearMipmapLinearFilter: () => LinearMipmapLinearFilter,
  LinearMipmapNearestFilter: () => LinearMipmapNearestFilter,
  LinesPrimitive: () => LinesPrimitive,
  LuminanceAlphaFormat: () => LuminanceAlphaFormat,
  LuminanceFormat: () => LuminanceFormat,
  MetersUnit: () => MetersUnit,
  MillimetersUnit: () => MillimetersUnit,
  MirroredRepeatWrapping: () => MirroredRepeatWrapping,
  NearestFilter: () => NearestFilter,
  NearestMipMapLinearFilter: () => NearestMipMapLinearFilter,
  NearestMipMapNearestFilter: () => NearestMipMapNearestFilter,
  NearestMipmapLinearFilter: () => NearestMipmapLinearFilter,
  NearestMipmapNearestFilter: () => NearestMipmapNearestFilter,
  OrbitNavigationMode: () => OrbitNavigationMode,
  OrthoProjectionType: () => OrthoProjectionType,
  PNGMediaType: () => PNGMediaType,
  PerspectiveProjectionType: () => PerspectiveProjectionType,
  PlanViewNavigationMode: () => PlanViewNavigationMode,
  PointsPrimitive: () => PointsPrimitive,
  QWERTYLayout: () => QWERTYLayout,
  QualityRender: () => QualityRender,
  RGBAFormat: () => RGBAFormat,
  RGBAIntegerFormat: () => RGBAIntegerFormat,
  RGBA_ASTC_10x10_Format: () => RGBA_ASTC_10x10_Format,
  RGBA_ASTC_10x5_Format: () => RGBA_ASTC_10x5_Format,
  RGBA_ASTC_10x6_Format: () => RGBA_ASTC_10x6_Format,
  RGBA_ASTC_10x8_Format: () => RGBA_ASTC_10x8_Format,
  RGBA_ASTC_12x10_Format: () => RGBA_ASTC_12x10_Format,
  RGBA_ASTC_12x12_Format: () => RGBA_ASTC_12x12_Format,
  RGBA_ASTC_4x4_Format: () => RGBA_ASTC_4x4_Format,
  RGBA_ASTC_5x4_Format: () => RGBA_ASTC_5x4_Format,
  RGBA_ASTC_5x5_Format: () => RGBA_ASTC_5x5_Format,
  RGBA_ASTC_6x5_Format: () => RGBA_ASTC_6x5_Format,
  RGBA_ASTC_6x6_Format: () => RGBA_ASTC_6x6_Format,
  RGBA_ASTC_8x5_Format: () => RGBA_ASTC_8x5_Format,
  RGBA_ASTC_8x6_Format: () => RGBA_ASTC_8x6_Format,
  RGBA_ASTC_8x8_Format: () => RGBA_ASTC_8x8_Format,
  RGBA_BPTC_Format: () => RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format: () => RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_2BPPV1_Format: () => RGBA_PVRTC_2BPPV1_Format,
  RGBA_PVRTC_4BPPV1_Format: () => RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT1_Format: () => RGBA_S3TC_DXT1_Format,
  RGBA_S3TC_DXT3_Format: () => RGBA_S3TC_DXT3_Format,
  RGBA_S3TC_DXT5_Format: () => RGBA_S3TC_DXT5_Format,
  RGBFormat: () => RGBFormat,
  RGB_ETC1_Format: () => RGB_ETC1_Format,
  RGB_ETC2_Format: () => RGB_ETC2_Format,
  RGB_PVRTC_2BPPV1_Format: () => RGB_PVRTC_2BPPV1_Format,
  RGB_PVRTC_4BPPV1_Format: () => RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format: () => RGB_S3TC_DXT1_Format,
  RGFormat: () => RGFormat,
  RGIntegerFormat: () => RGIntegerFormat,
  RedFormat: () => RedFormat,
  RedIntegerFormat: () => RedIntegerFormat,
  RepeatWrapping: () => RepeatWrapping,
  ShortType: () => ShortType,
  SolidPrimitive: () => SolidPrimitive,
  StaticDraw: () => StaticDraw,
  SurfacePrimitive: () => SurfacePrimitive,
  TrianglesPrimitive: () => TrianglesPrimitive,
  UnsignedByteType: () => UnsignedByteType,
  UnsignedInt248Type: () => UnsignedInt248Type,
  UnsignedIntType: () => UnsignedIntType,
  UnsignedShort4444Type: () => UnsignedShort4444Type,
  UnsignedShort5551Type: () => UnsignedShort5551Type,
  UnsignedShortType: () => UnsignedShortType,
  YardsUnit: () => YardsUnit,
  sRGBEncoding: () => sRGBEncoding
});
var RepeatWrapping = 1e3;
var ClampToEdgeWrapping = 1001;
var MirroredRepeatWrapping = 1002;
var NearestFilter = 1003;
var NearestMipMapNearestFilter = 1004;
var NearestMipmapNearestFilter = 1004;
var NearestMipmapLinearFilter = 1005;
var NearestMipMapLinearFilter = 1005;
var LinearFilter = 1006;
var LinearMipmapNearestFilter = 1007;
var LinearMipMapNearestFilter = 1007;
var LinearMipmapLinearFilter = 1008;
var LinearMipMapLinearFilter = 1008;
var UnsignedByteType = 1009;
var ByteType = 1010;
var ShortType = 1011;
var UnsignedShortType = 1012;
var IntType = 1013;
var UnsignedIntType = 1014;
var FloatType = 1015;
var HalfFloatType = 1016;
var UnsignedShort4444Type = 1017;
var UnsignedShort5551Type = 1018;
var UnsignedInt248Type = 1020;
var AlphaFormat = 1021;
var RGBFormat = 1022;
var RGBAFormat = 1023;
var LuminanceFormat = 1024;
var LuminanceAlphaFormat = 1025;
var DepthFormat = 1026;
var DepthStencilFormat = 1027;
var RedFormat = 1028;
var RedIntegerFormat = 1029;
var RGFormat = 1030;
var RGIntegerFormat = 1031;
var RGBAIntegerFormat = 1033;
var RGB_S3TC_DXT1_Format = 33776;
var RGBA_S3TC_DXT1_Format = 33777;
var RGBA_S3TC_DXT3_Format = 33778;
var RGBA_S3TC_DXT5_Format = 33779;
var RGB_PVRTC_4BPPV1_Format = 35840;
var RGB_PVRTC_2BPPV1_Format = 35841;
var RGBA_PVRTC_4BPPV1_Format = 35842;
var RGBA_PVRTC_2BPPV1_Format = 35843;
var RGB_ETC1_Format = 36196;
var RGB_ETC2_Format = 37492;
var RGBA_ETC2_EAC_Format = 37496;
var RGBA_ASTC_4x4_Format = 37808;
var RGBA_ASTC_5x4_Format = 37809;
var RGBA_ASTC_5x5_Format = 37810;
var RGBA_ASTC_6x5_Format = 37811;
var RGBA_ASTC_6x6_Format = 37812;
var RGBA_ASTC_8x5_Format = 37813;
var RGBA_ASTC_8x6_Format = 37814;
var RGBA_ASTC_8x8_Format = 37815;
var RGBA_ASTC_10x5_Format = 37816;
var RGBA_ASTC_10x6_Format = 37817;
var RGBA_ASTC_10x8_Format = 37818;
var RGBA_ASTC_10x10_Format = 37819;
var RGBA_ASTC_12x10_Format = 37820;
var RGBA_ASTC_12x12_Format = 37821;
var RGBA_BPTC_Format = 36492;
var LinearEncoding = 3e3;
var sRGBEncoding = 3001;
var GIFMediaType = 1e4;
var JPEGMediaType = 10001;
var PNGMediaType = 10002;
var PointsPrimitive = 2e4;
var LinesPrimitive = 20001;
var TrianglesPrimitive = 20002;
var SolidPrimitive = 20003;
var SurfacePrimitive = 20004;
var FastRender = 300001;
var QualityRender = 3e4;
var MetersUnit = 4e5;
var CentimetersUnit = 400001;
var MillimetersUnit = 400002;
var YardsUnit = 400003;
var FeetUnit = 400004;
var InchesUnit = 400005;
var PerspectiveProjectionType = 5e5;
var OrthoProjectionType = 500001;
var FrustumProjectionType = 500002;
var CustomProjectionType = 500003;
var OrbitNavigationMode = 600001;
var FirstPersonNavigationMode = 600002;
var PlanViewNavigationMode = 600003;
var StaticDraw = 7e5;
var DynamicDraw = 700001;
var QWERTYLayout = 800001;
var AZERTYLayout = 800002;

// ../sdk/src/math/index.ts
var math_exports = {};
__export(math_exports, {
  DEGTORAD: () => DEGTORAD,
  MAX_DOUBLE: () => MAX_DOUBLE,
  MAX_INT: () => MAX_INT,
  MIN_DOUBLE: () => MIN_DOUBLE,
  RADTODEG: () => RADTODEG,
  clamp: () => clamp,
  newFloatArray: () => newFloatArray,
  safeInv: () => safeInv
});
var MIN_DOUBLE = -Number.MAX_SAFE_INTEGER;
var MAX_DOUBLE = Number.MAX_SAFE_INTEGER;
var DEGTORAD = 0.0174532925;
var RADTODEG = 57.295779513;
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function newFloatArray(values) {
  return new Float64Array(values);
}
var MAX_INT = 1e7;
function safeInv(x) {
  const result = 1 / x;
  return isFinite(result) ? result : 1;
}

// ../sdk/src/matrix/index.ts
var matrix_exports = {};
__export(matrix_exports, {
  addVec3: () => addVec3,
  addVec3Scalar: () => addVec3Scalar,
  addVec4: () => addVec4,
  addVec4Scalar: () => addVec4Scalar,
  angleAxisToQuaternion: () => angleAxisToQuaternion,
  angleVec3: () => angleVec3,
  canvasPosToWorldRay: () => canvasPosToWorldRay,
  compareMat4: () => compareMat4,
  compareVec3: () => compareVec3,
  composeMat4: () => composeMat4,
  composeMat4Euler: () => composeMat4Euler,
  conjugateQuat: () => conjugateQuat,
  createMat3: () => createMat3,
  createMat4: () => createMat4,
  createVec2: () => createVec2,
  createVec3: () => createVec3,
  createVec4: () => createVec4,
  cross3Vec3: () => cross3Vec3,
  cross3Vec4: () => cross3Vec4,
  decomposeMat4: () => decomposeMat4,
  determinantMat4: () => determinantMat4,
  distVec2: () => distVec2,
  distVec3: () => distVec3,
  divScalarVec3: () => divScalarVec3,
  divScalarVec4: () => divScalarVec4,
  divVec3: () => divVec3,
  divVec3Scalar: () => divVec3Scalar,
  divVec4: () => divVec4,
  divVec4Scalar: () => divVec4Scalar,
  dotVec2: () => dotVec2,
  dotVec3: () => dotVec3,
  dotVec4: () => dotVec4,
  eulerToQuat: () => eulerToQuat,
  frustumMat4: () => frustumMat4,
  frustumMat4v: () => frustumMat4v,
  geometricMeanVec2: () => geometricMeanVec2,
  identityMat3: () => identityMat3,
  identityMat4: () => identityMat4,
  identityQuat: () => identityQuat,
  inverseMat4: () => inverseMat4,
  inverseQuat: () => inverseQuat,
  isIdentityMat4: () => isIdentityMat4,
  lenVec2: () => lenVec2,
  lenVec3: () => lenVec3,
  lenVec4: () => lenVec4,
  lerpMat4: () => lerpMat4,
  lerpVec3: () => lerpVec3,
  lookAtMat4v: () => lookAtMat4v,
  mat3ToMat4: () => mat3ToMat4,
  mat4ToEuler: () => mat4ToEuler,
  mat4ToQuat: () => mat4ToQuat,
  mulMat3: () => mulMat3,
  mulMat4: () => mulMat4,
  mulMat4v4: () => mulMat4v4,
  mulQuats: () => mulQuats,
  mulVec2Scalar: () => mulVec2Scalar,
  mulVec3Scalar: () => mulVec3Scalar,
  mulVec4: () => mulVec4,
  mulVec4Scalar: () => mulVec4Scalar,
  negateVec3: () => negateVec3,
  negateVec4: () => negateVec4,
  normalizeQuat: () => normalizeQuat,
  normalizeVec2: () => normalizeVec2,
  normalizeVec3: () => normalizeVec3,
  normalizeVec4: () => normalizeVec4,
  orthoMat4c: () => orthoMat4c,
  perspectiveMat4: () => perspectiveMat4,
  quatToAngleAxis: () => quatToAngleAxis,
  quatToEuler: () => quatToEuler,
  quatToMat4: () => quatToMat4,
  quatToRotationMat4: () => quatToRotationMat4,
  rayTriangleIntersect: () => rayTriangleIntersect,
  rcpVec3: () => rcpVec3,
  rotationMat4v: () => rotationMat4v,
  scaleMat4c: () => scaleMat4c,
  scaleMat4v: () => scaleMat4v,
  scalingMat3v: () => scalingMat3v,
  scalingMat4c: () => scalingMat4c,
  scalingMat4s: () => scalingMat4s,
  scalingMat4v: () => scalingMat4v,
  setMat4Translation: () => setMat4Translation,
  sqLenVec2: () => sqLenVec2,
  sqLenVec3: () => sqLenVec3,
  sqLenVec4: () => sqLenVec4,
  subScalarVec4: () => subScalarVec4,
  subVec2: () => subVec2,
  subVec3: () => subVec3,
  subVec4: () => subVec4,
  subVec4Scalar: () => subVec4Scalar,
  transformPoint3: () => transformPoint3,
  transformPoint4: () => transformPoint4,
  transformPoints3: () => transformPoints3,
  transformPositions3: () => transformPositions3,
  transformPositions4: () => transformPositions4,
  transformRay: () => transformRay,
  transformVec3: () => transformVec3,
  transformVec4: () => transformVec4,
  translateMat4c: () => translateMat4c,
  translateMat4v: () => translateMat4v,
  translationMat3v: () => translationMat3v,
  translationMat4c: () => translationMat4c,
  translationMat4s: () => translationMat4s,
  translationMat4v: () => translationMat4v,
  transposeMat4: () => transposeMat4,
  triangleNormal: () => triangleNormal,
  vec3ApplyQuat: () => vec3ApplyQuat,
  vec3FromMat4Scale: () => vec3FromMat4Scale,
  vec3PairToQuat: () => vec3PairToQuat,
  vecToArray: () => vecToArray
});
var tempVec4a = createVec4();
var tempVec3 = createVec3();
var tempVec3b = createVec3();
var tempVec3c = createVec3();
var tempVec3d = createVec3();
var tempVec3e = createVec3();
var tempVec4b = createVec4();
var tempMat4a = createMat4();
var tempMat4b = createMat4();
function dotVec3(u, v) {
  return u[0] * v[0] + u[1] * v[1] + u[2] * v[2];
}
function createVec2(values) {
  return new Float64Array(values || 2);
}
function createVec3(values) {
  return new Float64Array(values || 3);
}
function createVec4(values) {
  return new Float64Array(values || 4);
}
function negateVec3(v, dest) {
  if (!dest) {
    dest = v;
  }
  dest[0] = -v[0];
  dest[1] = -v[1];
  dest[2] = -v[2];
  return dest;
}
function negateVec4(v, dest) {
  if (!dest) {
    dest = v;
  }
  dest[0] = -v[0];
  dest[1] = -v[1];
  dest[2] = -v[2];
  dest[3] = -v[3];
  return dest;
}
function addVec4(u, v, dest) {
  if (!dest) {
    dest = u;
  }
  dest[0] = u[0] + v[0];
  dest[1] = u[1] + v[1];
  dest[2] = u[2] + v[2];
  dest[3] = u[3] + v[3];
  return dest;
}
function addVec4Scalar(v, s, dest) {
  if (!dest) {
    dest = v;
  }
  dest[0] = v[0] + s;
  dest[1] = v[1] + s;
  dest[2] = v[2] + s;
  dest[3] = v[3] + s;
  return dest;
}
function mulVec4Scalar(v, s, dest) {
  if (!dest) {
    dest = v;
  }
  dest[0] = v[0] * s;
  dest[1] = v[1] * s;
  dest[2] = v[2] * s;
  dest[3] = v[3] * s;
  return dest;
}
function mulVec3Scalar(v, s, dest) {
  if (!dest) {
    dest = v;
  }
  dest[0] = v[0] * s;
  dest[1] = v[1] * s;
  dest[2] = v[2] * s;
  return dest;
}
function mulVec2Scalar(v, s, dest) {
  if (!dest) {
    dest = v;
  }
  dest[0] = v[0] * s;
  dest[1] = v[1] * s;
  return dest;
}
function addVec3(u, v, dest) {
  if (!dest) {
    dest = u;
  }
  dest[0] = u[0] + v[0];
  dest[1] = u[1] + v[1];
  dest[2] = u[2] + v[2];
  return dest;
}
function addVec3Scalar(v, s, dest) {
  if (!dest) {
    dest = v;
  }
  dest[0] = v[0] + s;
  dest[1] = v[1] + s;
  dest[2] = v[2] + s;
  return dest;
}
function subVec4(u, v, dest) {
  if (!dest) {
    dest = u;
  }
  dest[0] = u[0] - v[0];
  dest[1] = u[1] - v[1];
  dest[2] = u[2] - v[2];
  dest[3] = u[3] - v[3];
  return dest;
}
function compareVec3(v1, v2) {
  return v1[0] === v2[0] && v1[1] === v2[1] && v1[2] === v2[2];
}
function subVec3(u, v, dest) {
  if (!dest) {
    dest = u;
  }
  dest[0] = u[0] - v[0];
  dest[1] = u[1] - v[1];
  dest[2] = u[2] - v[2];
  return dest;
}
function subVec2(u, v, dest) {
  if (!dest) {
    dest = u;
  }
  dest[0] = u[0] - v[0];
  dest[1] = u[1] - v[1];
  return dest;
}
function geometricMeanVec2(...vectors) {
  const geometricMean = new Float32Array(vectors[0]);
  for (let i = 1; i < vectors.length; i++) {
    geometricMean[0] += vectors[i][0];
    geometricMean[1] += vectors[i][1];
  }
  geometricMean[0] /= vectors.length;
  geometricMean[1] /= vectors.length;
  return geometricMean;
}
function subVec4Scalar(v, s, dest) {
  if (!dest) {
    dest = v;
  }
  dest[0] = v[0] - s;
  dest[1] = v[1] - s;
  dest[2] = v[2] - s;
  dest[3] = v[3] - s;
  return dest;
}
function subScalarVec4(v, s, dest) {
  if (!dest) {
    dest = v;
  }
  dest[0] = s - v[0];
  dest[1] = s - v[1];
  dest[2] = s - v[2];
  dest[3] = s - v[3];
  return dest;
}
function mulVec4(u, v, dest) {
  if (!dest) {
    dest = u;
  }
  dest[0] = u[0] * v[0];
  dest[1] = u[1] * v[1];
  dest[2] = u[2] * v[2];
  dest[3] = u[3] * v[3];
  return dest;
}
function divVec3(u, v, dest) {
  if (!dest) {
    dest = u;
  }
  dest[0] = u[0] / v[0];
  dest[1] = u[1] / v[1];
  dest[2] = u[2] / v[2];
  return dest;
}
function divVec4(u, v, dest) {
  if (!dest) {
    dest = u;
  }
  dest[0] = u[0] / v[0];
  dest[1] = u[1] / v[1];
  dest[2] = u[2] / v[2];
  dest[3] = u[3] / v[3];
  return dest;
}
function divScalarVec3(s, v, dest) {
  if (!dest) {
    dest = v;
  }
  dest[0] = s / v[0];
  dest[1] = s / v[1];
  dest[2] = s / v[2];
  return dest;
}
function divVec3Scalar(v, s, dest) {
  if (!dest) {
    dest = v;
  }
  dest[0] = v[0] / s;
  dest[1] = v[1] / s;
  dest[2] = v[2] / s;
  return dest;
}
function divVec4Scalar(v, s, dest) {
  if (!dest) {
    dest = v;
  }
  dest[0] = v[0] / s;
  dest[1] = v[1] / s;
  dest[2] = v[2] / s;
  dest[3] = v[3] / s;
  return dest;
}
function divScalarVec4(s, v, dest) {
  if (!dest) {
    dest = v;
  }
  dest[0] = s / v[0];
  dest[1] = s / v[1];
  dest[2] = s / v[2];
  dest[3] = s / v[3];
  return dest;
}
function dotVec4(u, v) {
  return u[0] * v[0] + u[1] * v[1] + u[2] * v[2] + u[3] * v[3];
}
function cross3Vec4(u, v) {
  const u0 = u[0];
  const u1 = u[1];
  const u2 = u[2];
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];
  return [
    u1 * v2 - u2 * v1,
    u2 * v0 - u0 * v2,
    u0 * v1 - u1 * v0,
    0
  ];
}
function cross3Vec3(u, v, dest) {
  if (!dest) {
    dest = u;
  }
  const x = u[0];
  const y = u[1];
  const z = u[2];
  const x2 = v[0];
  const y2 = v[1];
  const z2 = v[2];
  dest[0] = y * z2 - z * y2;
  dest[1] = z * x2 - x * z2;
  dest[2] = x * y2 - y * x2;
  return dest;
}
function sqLenVec4(v) {
  return dotVec4(v, v);
}
function lenVec4(v) {
  return Math.sqrt(sqLenVec4(v));
}
function dotVec2(u, v) {
  return u[0] * v[0] + u[1] * v[1];
}
function sqLenVec3(v) {
  return dotVec3(v, v);
}
function sqLenVec2(v) {
  return dotVec2(v, v);
}
function lenVec3(v) {
  return Math.sqrt(sqLenVec3(v));
}
var distVec3 = (() => {
  const vec = createVec3();
  return (v, w) => lenVec3(subVec3(v, w, vec));
})();
function lenVec2(v) {
  return Math.sqrt(sqLenVec2(v));
}
function lerpVec3(t, t1, t2, p1, p2, dest) {
  const result = dest || createVec3();
  const f = (t - t1) / (t2 - t1);
  result[0] = p1[0] + f * (p2[0] - p1[0]);
  result[1] = p1[1] + f * (p2[1] - p1[1]);
  result[2] = p1[2] + f * (p2[2] - p1[2]);
  return result;
}
var distVec2 = (() => {
  const vec = createVec2();
  return (v, w) => lenVec2(subVec2(v, w, vec));
})();
function rcpVec3(v, dest) {
  return divScalarVec3(1, v, dest);
}
function normalizeVec4(v, dest) {
  const f = 1 / lenVec4(v);
  return mulVec4Scalar(v, f, dest);
}
function normalizeVec3(v, dest) {
  const f = 1 / lenVec3(v);
  return mulVec3Scalar(v, f, dest);
}
function normalizeVec2(v, dest) {
  const f = 1 / lenVec2(v);
  return mulVec2Scalar(v, f, dest);
}
function angleVec3(v, w) {
  let theta = dotVec3(v, w) / Math.sqrt(sqLenVec3(v) * sqLenVec3(w));
  theta = theta < -1 ? -1 : theta > 1 ? 1 : theta;
  return Math.acos(theta);
}
var vec3FromMat4Scale = (() => {
  const tempVec36 = createVec3();
  return function(m, dest) {
    tempVec36[0] = m[0];
    tempVec36[1] = m[1];
    tempVec36[2] = m[2];
    dest[0] = lenVec3(tempVec36);
    tempVec36[0] = m[4];
    tempVec36[1] = m[5];
    tempVec36[2] = m[6];
    dest[1] = lenVec3(tempVec36);
    tempVec36[0] = m[8];
    tempVec36[1] = m[9];
    tempVec36[2] = m[10];
    dest[2] = lenVec3(tempVec36);
    return dest;
  };
})();
function vecToArray(v) {
  v = Array.prototype.slice.call(v);
  for (let i = 0, len = v.length; i < len; i++) {
    v[i] = trunc(v[i]);
  }
  return v;
}
function trunc(v) {
  return Math.round(v * 1e5) / 1e5;
}
function triangleNormal(a2, b4, c2, normal2 = createVec3()) {
  const p1x = b4[0] - a2[0];
  const p1y = b4[1] - a2[1];
  const p1z = b4[2] - a2[2];
  const p2x = c2[0] - a2[0];
  const p2y = c2[1] - a2[1];
  const p2z = c2[2] - a2[2];
  const p3x = p1y * p2z - p1z * p2y;
  const p3y = p1z * p2x - p1x * p2z;
  const p3z = p1x * p2y - p1y * p2x;
  const mag = Math.sqrt(p3x * p3x + p3y * p3y + p3z * p3z);
  if (mag === 0) {
    normal2[0] = 0;
    normal2[1] = 0;
    normal2[2] = 0;
  } else {
    normal2[0] = p3x / mag;
    normal2[1] = p3y / mag;
    normal2[2] = p3z / mag;
  }
  return normal2;
}
function createMat3(values) {
  return new newFloatArray(values || 9);
}
function mat3ToMat4(mat3, mat4) {
  if (!mat4) {
    mat4 = createMat4();
  }
  mat4[0] = mat3[0];
  mat4[1] = mat3[1];
  mat4[2] = mat3[2];
  mat4[3] = 0;
  mat4[4] = mat3[3];
  mat4[5] = mat3[4];
  mat4[6] = mat3[5];
  mat4[7] = 0;
  mat4[8] = mat3[6];
  mat4[9] = mat3[7];
  mat4[10] = mat3[8];
  mat4[11] = 0;
  mat4[12] = 0;
  mat4[13] = 0;
  mat4[14] = 0;
  mat4[15] = 1;
  return mat4;
}
function createMat4(values) {
  return new Float64Array(values || 16);
}
function compareMat4(m1, m2) {
  return m1[0] === m2[0] && m1[1] === m2[1] && m1[2] === m2[2] && m1[3] === m2[3] && m1[4] === m2[4] && m1[5] === m2[5] && m1[6] === m2[6] && m1[7] === m2[7] && m1[8] === m2[8] && m1[9] === m2[9] && m1[10] === m2[10] && m1[11] === m2[11] && m1[12] === m2[12] && m1[13] === m2[13] && m1[14] === m2[14] && m1[15] === m2[15];
}
function perspectiveMat4(fovyrad, aspectratio, znear, zfar, m) {
  const pmin = [];
  const pmax = [];
  pmin[2] = znear;
  pmax[2] = zfar;
  pmax[1] = pmin[2] * Math.tan(fovyrad / 2);
  pmin[1] = -pmax[1];
  pmax[0] = pmax[1] * aspectratio;
  pmin[0] = -pmax[0];
  return frustumMat4v(pmin, pmax, m);
}
function frustumMat4v(fmin, fmax, m) {
  if (!m) {
    m = createMat4();
  }
  const fmin4 = [fmin[0], fmin[1], fmin[2], 0];
  const fmax4 = [fmax[0], fmax[1], fmax[2], 0];
  addVec4(fmax4, fmin4, tempMat4a);
  subVec4(fmax4, fmin4, tempMat4b);
  const t = 2 * fmin4[2];
  const tempMat4b0 = tempMat4b[0];
  const tempMat4b1 = tempMat4b[1];
  const tempMat4b22 = tempMat4b[2];
  m[0] = t / tempMat4b0;
  m[1] = 0;
  m[2] = 0;
  m[3] = 0;
  m[4] = 0;
  m[5] = t / tempMat4b1;
  m[6] = 0;
  m[7] = 0;
  m[8] = tempMat4a[0] / tempMat4b0;
  m[9] = tempMat4a[1] / tempMat4b1;
  m[10] = -tempMat4a[2] / tempMat4b22;
  m[11] = -1;
  m[12] = 0;
  m[13] = 0;
  m[14] = -t * fmax4[2] / tempMat4b22;
  m[15] = 0;
  return m;
}
function orthoMat4c(left, right, bottom, top, near, far, dest) {
  if (!dest) {
    dest = createMat4();
  }
  const rl = right - left;
  const tb = top - bottom;
  const fn = far - near;
  dest[0] = 2 / rl;
  dest[1] = 0;
  dest[2] = 0;
  dest[3] = 0;
  dest[4] = 0;
  dest[5] = 2 / tb;
  dest[6] = 0;
  dest[7] = 0;
  dest[8] = 0;
  dest[9] = 0;
  dest[10] = -2 / fn;
  dest[11] = 0;
  dest[12] = -(left + right) / rl;
  dest[13] = -(top + bottom) / tb;
  dest[14] = -(far + near) / fn;
  dest[15] = 1;
  return dest;
}
function frustumMat4(left, right, bottom, top, near, far, dest) {
  if (!dest) {
    dest = createMat4();
  }
  const rl = right - left;
  const tb = top - bottom;
  const fn = far - near;
  dest[0] = near * 2 / rl;
  dest[1] = 0;
  dest[2] = 0;
  dest[3] = 0;
  dest[4] = 0;
  dest[5] = near * 2 / tb;
  dest[6] = 0;
  dest[7] = 0;
  dest[8] = (right + left) / rl;
  dest[9] = (top + bottom) / tb;
  dest[10] = -(far + near) / fn;
  dest[11] = -1;
  dest[12] = 0;
  dest[13] = 0;
  dest[14] = -(far * near * 2) / fn;
  dest[15] = 0;
  return dest;
}
function identityMat4(dest) {
  if (!dest) {
    dest = createMat4();
  }
  dest[0] = 1;
  dest[1] = 0;
  dest[2] = 0;
  dest[3] = 0;
  dest[4] = 0;
  dest[5] = 1;
  dest[6] = 0;
  dest[7] = 0;
  dest[8] = 0;
  dest[9] = 0;
  dest[10] = 1;
  dest[11] = 0;
  dest[12] = 0;
  dest[13] = 0;
  dest[14] = 0;
  dest[15] = 1;
  return dest;
}
function identityMat3(dest) {
  if (!dest) {
    dest = createMat4();
  }
  dest[0] = 1;
  dest[1] = 0;
  dest[2] = 0;
  dest[3] = 0;
  dest[4] = 1;
  dest[5] = 0;
  dest[6] = 0;
  dest[7] = 0;
  dest[8] = 1;
  return dest;
}
function isIdentityMat4(m) {
  if (m[0] !== 1 || m[1] !== 0 || m[2] !== 0 || m[3] !== 0 || m[4] !== 0 || m[5] !== 1 || m[6] !== 0 || m[7] !== 0 || m[8] !== 0 || m[9] !== 0 || m[10] !== 1 || m[11] !== 0 || m[12] !== 0 || m[13] !== 0 || m[14] !== 0 || m[15] !== 1) {
    return false;
  }
  return true;
}
function rotationMat4v(anglerad, axis, m) {
  if (!m) {
    m = createMat4();
  }
  const ax = normalizeVec4([axis[0], axis[1], axis[2], 0], []);
  const s = Math.sin(anglerad);
  const c2 = Math.cos(anglerad);
  const q = 1 - c2;
  const x = ax[0];
  const y = ax[1];
  const z = ax[2];
  const xy = x * y;
  const yz = y * z;
  const zx = z * x;
  const xs = x * s;
  const ys = y * s;
  const zs = z * s;
  m[0] = q * x * x + c2;
  m[1] = q * xy + zs;
  m[2] = q * zx - ys;
  m[3] = 0;
  m[4] = q * xy - zs;
  m[5] = q * y * y + c2;
  m[6] = q * yz + xs;
  m[7] = 0;
  m[8] = q * zx + ys;
  m[9] = q * yz - xs;
  m[10] = q * z * z + c2;
  m[11] = 0;
  m[12] = 0;
  m[13] = 0;
  m[14] = 0;
  m[15] = 1;
  return m;
}
function lookAtMat4v(pos, target, up, dest) {
  if (!dest) {
    dest = createMat4();
  }
  const [posx, posy, posz] = pos;
  const [upx, upy, upz] = up;
  const [targetx, targety, targetz] = target;
  if (posx === targetx && posy === targety && posz === targetz) {
    return identityMat4();
  }
  let z0 = posx - targetx;
  let z1 = posy - targety;
  let z2 = posz - targetz;
  let len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  let x0 = upy * z2 - upz * z1;
  let x1 = upz * z0 - upx * z2;
  let x2 = upx * z1 - upy * z0;
  len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
  if (len) {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  } else {
    x0 = x1 = x2 = 0;
  }
  let y0 = z1 * x2 - z2 * x1;
  let y1 = z2 * x0 - z0 * x2;
  let y2 = z0 * x1 - z1 * x0;
  len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
  if (len) {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  } else {
    y0 = y1 = y2 = 0;
  }
  dest[0] = x0;
  dest[1] = y0;
  dest[2] = z0;
  dest[3] = 0;
  dest[4] = x1;
  dest[5] = y1;
  dest[6] = z1;
  dest[7] = 0;
  dest[8] = x2;
  dest[9] = y2;
  dest[10] = z2;
  dest[11] = 0;
  dest[12] = -(x0 * posx + x1 * posy + x2 * posz);
  dest[13] = -(y0 * posx + y1 * posy + y2 * posz);
  dest[14] = -(z0 * posx + z1 * posy + z2 * posz);
  dest[15] = 1;
  return dest;
}
function inverseMat4(mat, dest) {
  if (!dest) {
    dest = mat;
  }
  const [
    a00,
    a01,
    a02,
    a03,
    a10,
    a11,
    a12,
    a13,
    a20,
    a21,
    a22,
    a23,
    a30,
    a31,
    a32,
    a33
  ] = mat;
  const b00 = a00 * a11 - a01 * a10;
  const b01 = a00 * a12 - a02 * a10;
  const b02 = a00 * a13 - a03 * a10;
  const b03 = a01 * a12 - a02 * a11;
  const b04 = a01 * a13 - a03 * a11;
  const b05 = a02 * a13 - a03 * a12;
  const b06 = a20 * a31 - a21 * a30;
  const b07 = a20 * a32 - a22 * a30;
  const b08 = a20 * a33 - a23 * a30;
  const b09 = a21 * a32 - a22 * a31;
  const b10 = a21 * a33 - a23 * a31;
  const b11 = a22 * a33 - a23 * a32;
  const invDet = 1 / (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06);
  dest[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
  dest[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
  dest[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
  dest[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
  dest[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
  dest[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
  dest[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
  dest[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
  dest[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
  dest[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
  dest[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
  dest[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
  dest[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
  dest[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
  dest[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
  dest[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;
  return dest;
}
function transposeMat4(mat, dest) {
  const [
    m00,
    m01,
    m02,
    m03,
    m10,
    m11,
    m12,
    m13,
    m20,
    m21,
    m22,
    m23,
    m30,
    m31,
    m32,
    m33
  ] = mat;
  if (!dest || mat === dest) {
    mat[1] = m10;
    mat[2] = m20;
    mat[3] = m30;
    mat[4] = m01;
    mat[6] = m21;
    mat[7] = m31;
    mat[8] = m02;
    mat[9] = m12;
    mat[11] = m32;
    mat[12] = m03;
    mat[13] = m13;
    mat[14] = m23;
    return mat;
  }
  dest[0] = m00;
  dest[1] = m10;
  dest[2] = m20;
  dest[3] = m30;
  dest[4] = m01;
  dest[5] = m11;
  dest[6] = m21;
  dest[7] = m31;
  dest[8] = m02;
  dest[9] = m12;
  dest[10] = m22;
  dest[11] = m32;
  dest[12] = m03;
  dest[13] = m13;
  dest[14] = m23;
  dest[15] = m33;
  return dest;
}
function mulMat4v4(m, v, dest) {
  dest = dest || m;
  const [v0, v1, v2, v3] = v;
  dest[0] = m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12] * v3;
  dest[1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13] * v3;
  dest[2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14] * v3;
  dest[3] = m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15] * v3;
  return dest;
}
function mulMat4(a2, b4, dest) {
  dest = dest || a2;
  const [a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, a30, a31, a32, a33] = a2;
  const [b00, b01, b02, b03, b10, b11, b12, b13, b20, b21, b22, b23, b30, b31, b32, b33] = b4;
  dest[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
  dest[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
  dest[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
  dest[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;
  dest[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
  dest[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
  dest[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
  dest[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;
  dest[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
  dest[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
  dest[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
  dest[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;
  dest[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
  dest[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
  dest[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
  dest[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;
  return dest;
}
function mulMat3(a2, b4, dest = newFloatArray(9)) {
  const [a11, a12, a13, a21, a22, a23, a31, a32, a33] = a2;
  const [b11, b12, b13, b21, b22, b23, b31, b32, b33] = b4;
  dest[0] = a11 * b11 + a12 * b21 + a13 * b31;
  dest[3] = a11 * b12 + a12 * b22 + a13 * b32;
  dest[6] = a11 * b13 + a12 * b23 + a13 * b33;
  dest[1] = a21 * b11 + a22 * b21 + a23 * b31;
  dest[4] = a21 * b12 + a22 * b22 + a23 * b32;
  dest[7] = a21 * b13 + a22 * b23 + a23 * b33;
  dest[2] = a31 * b11 + a32 * b21 + a33 * b31;
  dest[5] = a31 * b12 + a32 * b22 + a33 * b32;
  dest[8] = a31 * b13 + a32 * b23 + a33 * b33;
  return dest;
}
function transformPoint3(m, p, dest) {
  dest = dest || p;
  const [x, y, z] = p;
  dest[0] = m[0] * x + m[4] * y + m[8] * z + m[12];
  dest[1] = m[1] * x + m[5] * y + m[9] * z + m[13];
  dest[2] = m[2] * x + m[6] * y + m[10] * z + m[14];
  return dest;
}
function transformPoint4(m, v, dest) {
  const [v0, v1, v2, v3] = v;
  dest[0] = m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12] * v3;
  dest[1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13] * v3;
  dest[2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14] * v3;
  dest[3] = m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15] * v3;
  return dest;
}
function transformPoints3(m, points, result = []) {
  const len = points.length;
  const [m0, m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, m11, m12, m13, m14, m15] = m;
  for (let i = 0; i < len; ++i) {
    const [p0, p1, p2] = points[i];
    const r = result[i] || (result[i] = [0, 0, 0]);
    r[0] = m0 * p0 + m4 * p1 + m8 * p2 + m12;
    r[1] = m1 * p0 + m5 * p1 + m9 * p2 + m13;
    r[2] = m2 * p0 + m6 * p1 + m10 * p2 + m14;
    r[3] = m3 * p0 + m7 * p1 + m11 * p2 + m15;
  }
  result.length = len;
  return result;
}
function transformPositions3(m, p, p2 = p) {
  const len = p.length;
  const [m0, m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, m11, m12, m13, m14, m15] = m;
  for (let i = 0; i < len; i += 3) {
    const x = p[i];
    const y = p[i + 1];
    const z = p[i + 2];
    p2[i] = m0 * x + m4 * y + m8 * z + m12;
    p2[i + 1] = m1 * x + m5 * y + m9 * z + m13;
    p2[i + 2] = m2 * x + m6 * y + m10 * z + m14;
    p2[i + 3] = m3 * x + m7 * y + m11 * z + m15;
  }
  return p2;
}
function transformPositions4(m, p, p2 = p) {
  const len = p.length;
  const m0 = m[0], m1 = m[1], m2 = m[2], m3 = m[3];
  const m4 = m[4], m5 = m[5], m6 = m[6], m7 = m[7];
  const m8 = m[8], m9 = m[9], m10 = m[10], m11 = m[11];
  const m12 = m[12], m13 = m[13], m14 = m[14], m15 = m[15];
  for (let i = 0; i < len; i += 4) {
    const x = p[i], y = p[i + 1], z = p[i + 2];
    p2[i] = m0 * x + m4 * y + m8 * z + m12;
    p2[i + 1] = m1 * x + m5 * y + m9 * z + m13;
    p2[i + 2] = m2 * x + m6 * y + m10 * z + m14;
    p2[i + 3] = m3 * x + m7 * y + m11 * z + m15;
  }
  return p2;
}
function transformVec3(m, v, dest = createVec3()) {
  const v0 = v[0], v1 = v[1], v2 = v[2];
  dest[0] = m[0] * v0 + m[4] * v1 + m[8] * v2;
  dest[1] = m[1] * v0 + m[5] * v1 + m[9] * v2;
  dest[2] = m[2] * v0 + m[6] * v1 + m[10] * v2;
  return dest;
}
function transformVec4(m, v, dest = createVec4()) {
  const v0 = v[0], v1 = v[1], v2 = v[2], v3 = v[3];
  dest[0] = m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12] * v3;
  dest[1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13] * v3;
  dest[2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14] * v3;
  dest[3] = m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15] * v3;
  return dest;
}
function scaleMat4v(xyz, m = identityMat4()) {
  const [x, y, z] = xyz;
  m[0] *= x;
  m[4] *= y;
  m[8] *= z;
  m[1] *= x;
  m[5] *= y;
  m[9] *= z;
  m[2] *= x;
  m[6] *= y;
  m[10] *= z;
  m[3] *= x;
  m[7] *= y;
  m[11] *= z;
  return m;
}
function scalingMat4v(v, m = identityMat4()) {
  m[0] = v[0];
  m[5] = v[1];
  m[10] = v[2];
  return m;
}
function scalingMat3v(v, m = identityMat3()) {
  m[0] = v[0];
  m[4] = v[1];
  return m;
}
var scalingMat4c = (() => {
  const xyz = newFloatArray(3);
  return (x, y, z, dest) => {
    xyz[0] = x;
    xyz[1] = y;
    xyz[2] = z;
    return scalingMat4v(xyz, dest);
  };
})();
function scaleMat4c(x, y, z, m) {
  m[0] *= x;
  m[4] *= y;
  m[8] *= z;
  m[1] *= x;
  m[5] *= y;
  m[9] *= z;
  m[2] *= x;
  m[6] *= y;
  m[10] *= z;
  m[3] *= x;
  m[7] *= y;
  m[11] *= z;
  return m;
}
function scalingMat4s(s) {
  return scalingMat4c(s, s, s);
}
function composeMat4(position, quaternion, scale3, mat = createMat4()) {
  quatToRotationMat4(quaternion, mat);
  scaleMat4v(scale3, mat);
  translateMat4v(position, mat);
  return mat;
}
function composeMat4Euler(position, rotation, scale3, mat = createMat4()) {
  quatToRotationMat4(eulerToQuat(rotation, "XYZ", identityQuat()), mat);
  scaleMat4v(scale3, mat);
  translateMat4v(position, mat);
  return mat;
}
var decomposeMat4 = (() => {
  const vec = createVec3();
  const matrix = createMat4();
  return function decompose(mat, position, quaternion, scale3) {
    vec[0] = mat[0];
    vec[1] = mat[1];
    vec[2] = mat[2];
    let sx = lenVec3(vec);
    vec[0] = mat[4];
    vec[1] = mat[5];
    vec[2] = mat[6];
    const sy = lenVec3(vec);
    vec[8] = mat[8];
    vec[9] = mat[9];
    vec[10] = mat[10];
    const sz = lenVec3(vec);
    const det = determinantMat4(mat);
    if (det < 0) {
      sx = -sx;
    }
    position[0] = mat[12];
    position[1] = mat[13];
    position[2] = mat[14];
    matrix.set(mat);
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    matrix[0] *= invSX;
    matrix[1] *= invSX;
    matrix[2] *= invSX;
    matrix[4] *= invSY;
    matrix[5] *= invSY;
    matrix[6] *= invSY;
    matrix[8] *= invSZ;
    matrix[9] *= invSZ;
    matrix[10] *= invSZ;
    mat4ToQuat(matrix, quaternion);
    scale3[0] = sx;
    scale3[1] = sy;
    scale3[2] = sz;
  };
})();
function translateMat4v(xyz, m = identityMat4()) {
  return translateMat4c(xyz[0], xyz[1], xyz[2], m);
}
function translateMat4c(x, y, z, m = identityMat4()) {
  const m3 = m[3];
  m[0] += m3 * x;
  m[1] += m3 * y;
  m[2] += m3 * z;
  const m7 = m[7];
  m[4] += m7 * x;
  m[5] += m7 * y;
  m[6] += m7 * z;
  const m11 = m[11];
  m[8] += m11 * x;
  m[9] += m11 * y;
  m[10] += m11 * z;
  const m15 = m[15];
  m[12] += m15 * x;
  m[13] += m15 * y;
  m[14] += m15 * z;
  return m;
}
function setMat4Translation(m, translation, dest) {
  dest[0] = m[0];
  dest[1] = m[1];
  dest[2] = m[2];
  dest[3] = m[3];
  dest[4] = m[4];
  dest[5] = m[5];
  dest[6] = m[6];
  dest[7] = m[7];
  dest[8] = m[8];
  dest[9] = m[9];
  dest[10] = m[10];
  dest[11] = m[11];
  dest[12] = translation[0];
  dest[13] = translation[1];
  dest[14] = translation[2];
  dest[15] = m[15];
  return dest;
}
function translationMat4v(v, dest) {
  const m = dest || identityMat4();
  m[12] = v[0];
  m[13] = v[1];
  m[14] = v[2];
  return m;
}
function translationMat3v(v, dest) {
  const m = dest || identityMat3();
  m[6] = v[0];
  m[7] = v[1];
  return m;
}
var translationMat4c = (() => {
  const xyz = newFloatArray(3);
  return (x, y, z, dest) => {
    xyz[0] = x;
    xyz[1] = y;
    xyz[2] = z;
    return translationMat4v(xyz, dest);
  };
})();
function translationMat4s(s, dest) {
  return translationMat4c(s, s, s, dest);
}
function determinantMat4(mat) {
  const [a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, a30, a31, a32, a33] = mat;
  return a30 * a21 * a12 * a03 - a20 * a31 * a12 * a03 - a30 * a11 * a22 * a03 + a10 * a31 * a22 * a03 + a20 * a11 * a32 * a03 - a10 * a21 * a32 * a03 - a30 * a21 * a02 * a13 + a20 * a31 * a02 * a13 + a30 * a01 * a22 * a13 - a00 * a31 * a22 * a13 - a20 * a01 * a32 * a13 + a00 * a21 * a32 * a13 + a30 * a11 * a02 * a23 - a10 * a31 * a02 * a23 - a30 * a01 * a12 * a23 + a00 * a31 * a12 * a23 + a10 * a01 * a32 * a23 - a00 * a11 * a32 * a23 - a20 * a11 * a02 * a33 + a10 * a21 * a02 * a33 + a20 * a01 * a12 * a33 - a00 * a21 * a12 * a33 - a10 * a01 * a22 * a33 + a00 * a11 * a22 * a33;
}
function mat4ToEuler(mat, order, dest = createVec3()) {
  const [m11, m12, m13, m21, m22, m23, m31, m32, m33] = mat;
  if (order === "XYZ") {
    dest[1] = Math.asin(clamp(m13, -1, 1));
    if (Math.abs(m13) < 0.99999) {
      dest[0] = Math.atan2(-m23, m33);
      dest[2] = Math.atan2(-m12, m11);
    } else {
      dest[0] = Math.atan2(m32, m22);
      dest[2] = 0;
    }
  } else if (order === "YXZ") {
    dest[0] = Math.asin(-clamp(m23, -1, 1));
    if (Math.abs(m23) < 0.99999) {
      dest[1] = Math.atan2(m13, m33);
      dest[2] = Math.atan2(m21, m22);
    } else {
      dest[1] = Math.atan2(-m31, m11);
      dest[2] = 0;
    }
  } else if (order === "ZXY") {
    dest[0] = Math.asin(clamp(m32, -1, 1));
    if (Math.abs(m32) < 0.99999) {
      dest[1] = Math.atan2(-m31, m33);
      dest[2] = Math.atan2(-m12, m22);
    } else {
      dest[1] = 0;
      dest[2] = Math.atan2(m21, m11);
    }
  } else if (order === "ZYX") {
    dest[1] = Math.asin(-clamp(m31, -1, 1));
    if (Math.abs(m31) < 0.99999) {
      dest[0] = Math.atan2(m32, m33);
      dest[2] = Math.atan2(m21, m11);
    } else {
      dest[0] = 0;
      dest[2] = Math.atan2(-m12, m22);
    }
  } else if (order === "YZX") {
    dest[2] = Math.asin(clamp(m21, -1, 1));
    if (Math.abs(m21) < 0.99999) {
      dest[0] = Math.atan2(-m23, m22);
      dest[1] = Math.atan2(-m31, m11);
    } else {
      dest[0] = 0;
      dest[1] = Math.atan2(m13, m33);
    }
  } else if (order === "XZY") {
    dest[2] = Math.asin(-clamp(m12, -1, 1));
    if (Math.abs(m12) < 0.99999) {
      dest[0] = Math.atan2(m32, m22);
      dest[1] = Math.atan2(m13, m11);
    } else {
      dest[0] = Math.atan2(-m23, m33);
      dest[1] = 0;
    }
  }
  return dest;
}
function lerpMat4(t, t1, t2, m1, m2, dest) {
  const result = dest || createMat4();
  const f = (t - t1) / (t2 - t1);
  result[0] = m1[0] + f * (m2[0] - m1[0]);
  result[1] = m1[1] + f * (m2[1] - m1[1]);
  result[2] = m1[2] + f * (m2[2] - m1[2]);
  result[3] = m1[3] + f * (m2[3] - m1[3]);
  result[4] = m1[4] + f * (m2[4] - m1[4]);
  result[5] = m1[5] + f * (m2[5] - m1[5]);
  result[6] = m1[6] + f * (m2[6] - m1[6]);
  result[7] = m1[7] + f * (m2[7] - m1[7]);
  result[8] = m1[8] + f * (m2[8] - m1[8]);
  result[9] = m1[9] + f * (m2[9] - m1[9]);
  result[10] = m1[10] + f * (m2[10] - m1[10]);
  result[11] = m1[11] + f * (m2[11] - m1[11]);
  result[12] = m1[12] + f * (m2[12] - m1[12]);
  result[13] = m1[13] + f * (m2[13] - m1[13]);
  result[14] = m1[14] + f * (m2[14] - m1[14]);
  result[15] = m1[15] + f * (m2[15] - m1[15]);
  return result;
}
function identityQuat(dest = createVec4()) {
  dest[0] = 0;
  dest[1] = 0;
  dest[2] = 0;
  dest[3] = 1;
  return dest;
}
function eulerToQuat(euler, order, dest = createVec4()) {
  const a2 = euler[0] * DEGTORAD / 2;
  const b4 = euler[1] * DEGTORAD / 2;
  const c2 = euler[2] * DEGTORAD / 2;
  const c1 = Math.cos(a2);
  const c22 = Math.cos(b4);
  const c3 = Math.cos(c2);
  const s1 = Math.sin(a2);
  const s2 = Math.sin(b4);
  const s3 = Math.sin(c2);
  switch (order) {
    case "XYZ":
      dest[0] = s1 * c22 * c3 + c1 * s2 * s3;
      dest[1] = c1 * s2 * c3 - s1 * c22 * s3;
      dest[2] = c1 * c22 * s3 + s1 * s2 * c3;
      dest[3] = c1 * c22 * c3 - s1 * s2 * s3;
      break;
    case "YXZ":
      dest[0] = s1 * c22 * c3 + c1 * s2 * s3;
      dest[1] = c1 * s2 * c3 - s1 * c22 * s3;
      dest[2] = c1 * c22 * s3 - s1 * s2 * c3;
      dest[3] = c1 * c22 * c3 + s1 * s2 * s3;
      break;
    case "ZXY":
      dest[0] = s1 * c22 * c3 - c1 * s2 * s3;
      dest[1] = c1 * s2 * c3 + s1 * c22 * s3;
      dest[2] = c1 * c22 * s3 + s1 * s2 * c3;
      dest[3] = c1 * c22 * c3 - s1 * s2 * s3;
      break;
    case "ZYX":
      dest[0] = s1 * c22 * c3 - c1 * s2 * s3;
      dest[1] = c1 * s2 * c3 + s1 * c22 * s3;
      dest[2] = c1 * c22 * s3 - s1 * s2 * c3;
      dest[3] = c1 * c22 * c3 + s1 * s2 * s3;
      break;
    case "YZX":
      dest[0] = s1 * c22 * c3 + c1 * s2 * s3;
      dest[1] = c1 * s2 * c3 + s1 * c22 * s3;
      dest[2] = c1 * c22 * s3 - s1 * s2 * c3;
      dest[3] = c1 * c22 * c3 - s1 * s2 * s3;
      break;
    case "XZY":
      dest[0] = s1 * c22 * c3 - c1 * s2 * s3;
      dest[1] = c1 * s2 * c3 - s1 * c22 * s3;
      dest[2] = c1 * c22 * s3 + s1 * s2 * c3;
      dest[3] = c1 * c22 * c3 + s1 * s2 * s3;
      break;
    default:
      throw new Error(`Unsupported Euler angle order: ${order}`);
  }
  return dest;
}
function mat4ToQuat(m, dest = createVec4()) {
  const m11 = m[0], m12 = m[4], m13 = m[8];
  const m21 = m[1], m22 = m[5], m23 = m[9];
  const m31 = m[2], m32 = m[6], m33 = m[10];
  const trace = m11 + m22 + m33;
  let s;
  if (trace > 0) {
    s = 0.5 / Math.sqrt(trace + 1);
    dest[3] = 0.25 / s;
    dest[0] = (m32 - m23) * s;
    dest[1] = (m13 - m31) * s;
    dest[2] = (m21 - m12) * s;
  } else {
    if (m11 > m22 && m11 > m33) {
      s = 2 * Math.sqrt(1 + m11 - m22 - m33);
      dest[3] = (m32 - m23) / s;
      dest[0] = 0.25 * s;
      dest[1] = (m12 + m21) / s;
      dest[2] = (m13 + m31) / s;
    } else if (m22 > m33) {
      s = 2 * Math.sqrt(1 + m22 - m11 - m33);
      dest[3] = (m13 - m31) / s;
      dest[0] = (m12 + m21) / s;
      dest[1] = 0.25 * s;
      dest[2] = (m23 + m32) / s;
    } else {
      s = 2 * Math.sqrt(1 + m33 - m11 - m22);
      dest[3] = (m21 - m12) / s;
      dest[0] = (m13 + m31) / s;
      dest[1] = (m23 + m32) / s;
      dest[2] = 0.25 * s;
    }
  }
  return dest;
}
function vec3PairToQuat(u, v, dest = createVec4()) {
  const norm_u_norm_v = Math.sqrt(dotVec3(u, u) * dotVec3(v, v));
  let real_part = norm_u_norm_v + dotVec3(u, v);
  if (real_part < 1e-8 * norm_u_norm_v) {
    real_part = 0;
    if (Math.abs(u[0]) > Math.abs(u[2])) {
      dest[0] = -u[1];
      dest[1] = u[0];
      dest[2] = 0;
    } else {
      dest[0] = 0;
      dest[1] = -u[2];
      dest[2] = u[1];
    }
  } else {
    cross3Vec3(u, v, dest);
  }
  dest[3] = real_part;
  return normalizeQuat(dest);
}
function angleAxisToQuaternion(angleAxis, dest = createVec4()) {
  const halfAngle = angleAxis[3] / 2;
  const fsin = Math.sin(halfAngle);
  dest[0] = fsin * angleAxis[0];
  dest[1] = fsin * angleAxis[1];
  dest[2] = fsin * angleAxis[2];
  dest[3] = Math.cos(halfAngle);
  return dest;
}
function quatToEuler(q, order, dest = createVec3()) {
  quatToRotationMat4(q, tempMat4a);
  mat4ToEuler(tempMat4a, order, dest);
  return dest;
}
function mulQuats(p, q, dest = createVec4()) {
  const p0 = p[0], p1 = p[1], p2 = p[2], p3 = p[3];
  const q0 = q[0], q1 = q[1], q2 = q[2], q3 = q[3];
  dest[0] = p3 * q0 + p0 * q3 + p1 * q2 - p2 * q1;
  dest[1] = p3 * q1 + p1 * q3 + p2 * q0 - p0 * q2;
  dest[2] = p3 * q2 + p2 * q3 + p0 * q1 - p1 * q0;
  dest[3] = p3 * q3 - p0 * q0 - p1 * q1 - p2 * q2;
  return dest;
}
function vec3ApplyQuat(q, vec, dest = createVec3()) {
  const x = vec[0], y = vec[1], z = vec[2];
  const qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  const ix = qw * x + qy * z - qz * y;
  const iy = qw * y + qz * x - qx * z;
  const iz = qw * z + qx * y - qy * x;
  const iw = -qx * x - qy * y - qz * z;
  dest[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  dest[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  dest[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  return dest;
}
function quatToMat4(q, dest = identityMat4()) {
  const q0 = q[0], q1 = q[1], q2 = q[2], q3 = q[3];
  const tx = 2 * q0, ty = 2 * q1, tz = 2 * q2;
  const twx = tx * q3, twy = ty * q3, twz = tz * q3;
  const txx = tx * q0, txy = ty * q0, txz = tz * q0;
  const tyy = ty * q1, tyz = tz * q1, tzz = tz * q2;
  dest[0] = 1 - (tyy + tzz);
  dest[1] = txy + twz;
  dest[2] = txz - twy;
  dest[4] = txy - twz;
  dest[5] = 1 - (txx + tzz);
  dest[6] = tyz + twx;
  dest[8] = txz + twy;
  dest[9] = tyz - twx;
  dest[10] = 1 - (txx + tyy);
  return dest;
}
function quatToRotationMat4(q, m) {
  const x = q[0];
  const y = q[1];
  const z = q[2];
  const w = q[3];
  const x2 = x + x;
  const y2 = y + y;
  const z2 = z + z;
  const xx = x * x2;
  const xy = x * y2;
  const xz = x * z2;
  const yy = y * y2;
  const yz = y * z2;
  const zz = z * z2;
  const wx = w * x2;
  const wy = w * y2;
  const wz = w * z2;
  m[0] = 1 - (yy + zz);
  m[4] = xy - wz;
  m[8] = xz + wy;
  m[1] = xy + wz;
  m[5] = 1 - (xx + zz);
  m[9] = yz - wx;
  m[2] = xz - wy;
  m[6] = yz + wx;
  m[10] = 1 - (xx + yy);
  m[3] = 0;
  m[7] = 0;
  m[11] = 0;
  m[12] = 0;
  m[13] = 0;
  m[14] = 0;
  m[15] = 1;
  return m;
}
function normalizeQuat(q, dest = q) {
  const len = lenVec4([q[0], q[1], q[2], q[3]]);
  dest[0] = q[0] / len;
  dest[1] = q[1] / len;
  dest[2] = q[2] / len;
  dest[3] = q[3] / len;
  return dest;
}
function conjugateQuat(q, dest = q) {
  dest[0] = -q[0];
  dest[1] = -q[1];
  dest[2] = -q[2];
  dest[3] = q[3];
  return dest;
}
function inverseQuat(q, dest) {
  return normalizeQuat(conjugateQuat(q, dest));
}
function quatToAngleAxis(q, angleAxis = createVec4()) {
  q = normalizeQuat(q, tempVec4a);
  const q3 = q[3];
  const angle2 = 2 * Math.acos(q3);
  const s = Math.sqrt(1 - q3 * q3);
  if (s < 1e-3) {
    angleAxis[0] = q[0];
    angleAxis[1] = q[1];
    angleAxis[2] = q[2];
  } else {
    angleAxis[0] = q[0] / s;
    angleAxis[1] = q[1] / s;
    angleAxis[2] = q[2] / s;
  }
  angleAxis[3] = angle2;
  return angleAxis;
}
function rayTriangleIntersect(origin, dir, a2, b4, c2, isect) {
  isect = isect || createVec3();
  const EPSILON3 = 1e-6;
  const edge1 = subVec3(b4, a2, tempVec3);
  const edge2 = subVec3(c2, a2, tempVec3b);
  const pvec = cross3Vec3(dir, edge2, tempVec3c);
  const det = dotVec3(edge1, pvec);
  if (det < EPSILON3)
    return null;
  const tvec = subVec3(origin, a2, tempVec3d);
  const u = dotVec3(tvec, pvec);
  if (u < 0 || u > det)
    return null;
  const qvec = cross3Vec3(tvec, edge1, tempVec3e);
  const v = dotVec3(dir, qvec);
  if (v < 0 || u + v > det)
    return null;
  const t = dotVec3(edge2, qvec) / det;
  isect[0] = origin[0] + t * dir[0];
  isect[1] = origin[1] + t * dir[1];
  isect[2] = origin[2] + t * dir[2];
  return isect;
}
function transformRay(matrix, rayOrigin, rayDir, rayOriginDest, rayDirDest) {
  tempVec4a[0] = rayOrigin[0];
  tempVec4a[1] = rayOrigin[1];
  tempVec4a[2] = rayOrigin[2];
  tempVec4a[3] = 1;
  transformVec4(matrix, tempVec4a, tempVec4b);
  rayOriginDest[0] = tempVec4b[0];
  rayOriginDest[1] = tempVec4b[1];
  rayOriginDest[2] = tempVec4b[2];
  tempVec4a[0] = rayDir[0];
  tempVec4a[1] = rayDir[1];
  tempVec4a[2] = rayDir[2];
  transformVec3(matrix, tempVec4a, tempVec4b);
  normalizeVec3(tempVec4b);
  rayDirDest[0] = tempVec4b[0];
  rayDirDest[1] = tempVec4b[1];
  rayDirDest[2] = tempVec4b[2];
}
var canvasPosToWorldRay = (() => {
  const pvMatInv = new Float64Array(16);
  const vec4Near = new Float64Array(4);
  const vec4Far = new Float64Array(4);
  const clipToWorld = (clipX, clipY, clipZ, isOrtho, outVec4) => {
    outVec4[0] = clipX;
    outVec4[1] = clipY;
    outVec4[2] = clipZ;
    outVec4[3] = 1;
    transformVec4(pvMatInv, outVec4, outVec4);
    if (!isOrtho) {
      mulVec4Scalar(outVec4, 1 / outVec4[3]);
    }
  };
  return (canvas2, viewMatrix, projMatrix, projection, canvasPos2, worldRayOrigin, worldRayDir) => {
    const isOrtho = projection === "ortho";
    mulMat4(projMatrix, viewMatrix, pvMatInv);
    inverseMat4(pvMatInv, pvMatInv);
    const clipX = 2 * canvasPos2[0] / canvas2.width - 1;
    const clipY = 1 - 2 * canvasPos2[1] / canvas2.height;
    clipToWorld(clipX, clipY, -1, isOrtho, vec4Near);
    clipToWorld(clipX, clipY, 1, isOrtho, vec4Far);
    worldRayOrigin[0] = vec4Near[0];
    worldRayOrigin[1] = vec4Near[1];
    worldRayOrigin[2] = vec4Near[2];
    subVec3(vec4Far, vec4Near, worldRayDir);
    normalizeVec3(worldRayDir);
  };
})();

// ../sdk/src/utils/index.ts
var utils_exports = {};
__export(utils_exports, {
  Cache: () => Cache,
  DefaultLoadingManager: () => DefaultLoadingManager,
  FileLoader: () => FileLoader,
  Loader: () => Loader,
  LoadingManager: () => LoadingManager,
  Map: () => Map2,
  Queue: () => Queue,
  WorkerPool: () => WorkerPool,
  apply: () => apply,
  apply2: () => apply2,
  applyIf: () => applyIf,
  b64: () => b64,
  clone: () => clone,
  compressGuid: () => compressGuid,
  concat: () => concat,
  copy: () => copy,
  createUUID: () => createUUID2,
  findNodeOfType: () => findNodeOfType,
  httpRequest: () => httpRequest,
  inQuotes: () => inQuotes,
  isArray: () => isArray,
  isEmptyObject: () => isEmptyObject,
  isFunction: () => isFunction,
  isID: () => isID,
  isJSONObject: () => isJSONObject,
  isNumeric: () => isNumeric,
  isObject: () => isObject,
  isString: () => isString,
  loadArraybuffer: () => loadArraybuffer,
  loadJSON: () => loadJSON,
  saveArrayBuffer: () => saveArrayBuffer,
  saveJSON: () => saveJSON,
  timeout: () => timeout
});

// ../sdk/src/utils/Map.ts
var Map2 = class {
  items;
  #lastUniqueId;
  constructor(items, baseId) {
    this.items = items || [];
    this.#lastUniqueId = (baseId || 0) + 1;
  }
  /**
   * Usage:
   *
   * id = myMap.addItem("foo") // ID internally generated
   * id = myMap.addItem("foo", "bar") // ID is "foo"
   */
  addItem() {
    let item;
    if (arguments.length === 2) {
      const id = arguments[0];
      item = arguments[1];
      if (this.items[id]) {
        throw "ID clash: '" + id + "'";
      }
      this.items[id] = item;
      return id;
    } else {
      item = arguments[0] || {};
      while (true) {
        const findId = this.#lastUniqueId++;
        if (!this.items[findId]) {
          this.items[findId] = item;
          return findId;
        }
      }
    }
  }
  removeItem(id) {
    const item = this.items[id];
    delete this.items[id];
    return item;
  }
};

// ../sdk/src/utils/Queue.ts
var Queue = class {
  _head;
  _headLength;
  _tail;
  _index;
  _length;
  constructor() {
    this._head = [];
    this._headLength = 0;
    this._tail = [];
    this._index = 0;
    this._length = 0;
  }
  get length() {
    return this._length;
  }
  shift() {
    if (this._index >= this._headLength) {
      const t = this._head;
      t.length = 0;
      this._head = this._tail;
      this._tail = t;
      this._index = 0;
      this._headLength = this._head.length;
      if (!this._headLength) {
        return;
      }
    }
    const value = this._head[this._index];
    if (this._index < 0) {
      delete this._head[this._index++];
    } else {
      this._head[this._index++] = void 0;
    }
    this._length--;
    return value;
  }
  push(item) {
    this._length++;
    this._tail.push(item);
    return this;
  }
  unshift(item) {
    this._head[--this._index] = item;
    this._length++;
    return this;
  }
  clear() {
    this._head = [];
    this._headLength = 0;
    this._tail = [];
    this._index = 0;
    this._length = 0;
  }
};

// ../sdk/src/utils/LoadingManager.ts
var LoadingManager = class {
  isLoading;
  itemsLoaded;
  itemsTotal;
  urlModifier;
  handlers;
  onStart;
  onLoad;
  onProgress;
  onError;
  constructor(onLoad, onProgress, onError) {
    this.isLoading = false;
    this.itemsLoaded = 0;
    this.itemsTotal = 0;
    this.urlModifier = void 0;
    this.handlers = [];
    this.onStart = void 0;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
  }
  itemStart(url) {
    this.itemsTotal++;
    if (!this.isLoading) {
      if (this.onStart !== void 0) {
        this.onStart(url, this.itemsLoaded, this.itemsTotal);
      }
    }
    this.isLoading = true;
  }
  itemEnd(url) {
    this.itemsLoaded++;
    if (this.onProgress !== void 0) {
      this.onProgress(url, this.itemsLoaded, this.itemsTotal);
    }
    if (this.itemsLoaded === this.itemsTotal) {
      this.isLoading = false;
      if (this.onLoad !== void 0) {
        this.onLoad();
      }
    }
  }
  itemError(url) {
    if (this.onError !== void 0) {
      this.onError(url);
    }
  }
  resolveURL(url) {
    if (this.urlModifier) {
      return this.urlModifier(url);
    }
    return url;
  }
  setURLModifier(transform) {
    this.urlModifier = transform;
    return this;
  }
  addHandler(regex, loader) {
    this.handlers.push(regex, loader);
    return this;
  }
  removeHandler(regex) {
    const index = this.handlers.indexOf(regex);
    if (index !== -1) {
      this.handlers.splice(index, 2);
    }
    return this;
  }
  getHandler(file) {
    for (let i = 0, l = this.handlers.length; i < l; i += 2) {
      const regex = this.handlers[i];
      const loader = this.handlers[i + 1];
      if (regex.global)
        regex.lastIndex = 0;
      if (regex.test(file)) {
        return loader;
      }
    }
    return null;
  }
};
var DefaultLoadingManager = new LoadingManager();

// ../sdk/src/utils/Loader.ts
var Loader = class {
  manager;
  crossOrigin;
  withCredentials;
  path;
  resourcePath;
  requestHeader;
  constructor(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
    this.crossOrigin = "anonymous";
    this.withCredentials = false;
    this.path = "";
    this.resourcePath = "";
    this.requestHeader = {};
  }
  load(url, onLoad, onProgress, onError) {
  }
  loadAsync(url, onProgress) {
    const scope = this;
    return new Promise(function(resolve2, reject) {
      scope.load(url, resolve2, onProgress, reject);
    });
  }
  parse() {
  }
  setCrossOrigin(crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  }
  setWithCredentials(value) {
    this.withCredentials = value;
    return this;
  }
  setPath(path) {
    this.path = path;
    return this;
  }
  setResourcePath(resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  }
  setRequestHeader(requestHeader) {
    this.requestHeader = requestHeader;
    return this;
  }
};

// ../sdk/src/utils/WorkerPool.ts
var WorkerPool = class {
  pool;
  // The maximum number of workers in the pool.
  queue;
  // The task queue, holds tasks when no idle workers are available.
  workers;
  // The list of workers currently in the pool.
  workersResolve;
  // The list of resolve functions, one for each worker.
  workerStatus;
  // A bitmask representing the status of each worker (idle or busy).
  workerCreator;
  // A function to create new workers.
  /**
   * Constructs the WorkerPool instance with a given pool size.
   * @param pool The number of workers in the pool (default is 4).
   */
  constructor(pool = 4) {
    this.pool = pool;
    this.queue = [];
    this.workers = [];
    this.workersResolve = [];
    this.workerStatus = 0;
  }
  /**
   * Initializes a worker by creating it and adding an event listener for messages.
   * @param workerId The ID of the worker to initialize.
   */
  _initWorker(workerId) {
    if (!this.workers[workerId]) {
      const worker = this.workerCreator();
      worker.addEventListener("message", this._onMessage.bind(this, workerId));
      this.workers[workerId] = worker;
    }
  }
  /**
   * Finds and returns an idle worker by checking the worker status.
   * @returns The index of an idle worker, or -1 if no idle workers are available.
   */
  _getIdleWorker() {
    for (let i = 0; i < this.pool; i++)
      if (!(this.workerStatus & 1 << i))
        return i;
    return -1;
  }
  /**
   * Handles messages received from workers.
   * @param workerId The ID of the worker sending the message.
   * @param msg The message received from the worker.
   */
  _onMessage(workerId, msg) {
    const resolve2 = this.workersResolve[workerId];
    resolve2 && resolve2(msg);
    if (this.queue.length) {
      const { resolve: resolve3, msg: msg2, transfer } = this.queue.shift();
      this.workersResolve[workerId] = resolve3;
      this.workers[workerId].postMessage(msg2, transfer);
    } else {
      this.workerStatus ^= 1 << workerId;
    }
  }
  /**
   * Sets the worker creator function, which is used to create new workers.
   * @param workerCreator The function that creates a new worker.
   */
  setWorkerCreator(workerCreator) {
    this.workerCreator = workerCreator;
  }
  /**
   * Sets the limit for the number of workers in the pool.
   * @param pool The new pool size.
   */
  setWorkerLimit(pool) {
    this.pool = pool;
  }
  /**
   * Posts a message to an available worker. If no worker is available, the task is queued.
   * @param msg The message to send to the worker.
   * @param transfer Any transferable objects to send with the message.
   * @returns A promise that resolves when the worker finishes processing the message.
   */
  postMessage(msg, transfer) {
    return new Promise((resolve2) => {
      const workerId = this._getIdleWorker();
      if (workerId !== -1) {
        this._initWorker(workerId);
        this.workerStatus |= 1 << workerId;
        this.workersResolve[workerId] = resolve2;
        this.workers[workerId].postMessage(msg, transfer);
      } else {
        this.queue.push({ resolve: resolve2, msg, transfer });
      }
    });
  }
  /**
   * Terminates all workers, clears the resolve functions, and resets the pool status.
   * This will effectively destroy the WorkerPool and free up any resources used.
   */
  destroy() {
    this.workers.forEach((worker) => worker.terminate());
    this.workersResolve.length = 0;
    this.workers.length = 0;
    this.queue.length = 0;
    this.workerStatus = 0;
  }
};

// ../sdk/src/utils/Cache.ts
var files = {};
var enabled = false;
var Cache = {
  enabled: false,
  files: {},
  add: function(key, file) {
    if (!enabled) {
      return;
    }
    files[key] = file;
  },
  get: function(key) {
    if (!enabled) {
      return;
    }
    return files[key];
  },
  remove: function(key) {
    delete files[key];
  },
  clear: function() {
    this.files = {};
  }
};

// ../sdk/src/utils/FileLoader.ts
var loading = {};
var FileLoader = class extends Loader {
  mimeType;
  responseType;
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (url === void 0) {
      url = "";
    }
    if (this.path !== void 0) {
      url = this.path + url;
    }
    url = this.manager.resolveURL(url);
    const cached = Cache.get(url);
    if (cached !== void 0) {
      this.manager.itemStart(url);
      setTimeout(() => {
        if (onLoad) {
          onLoad(cached);
        }
        this.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    if (loading[url] !== void 0) {
      loading[url].push({ onLoad, onProgress, onError });
      return;
    }
    loading[url] = [];
    loading[url].push({ onLoad, onProgress, onError });
    const req = new Request(url, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
    });
    const mimeType = this.mimeType;
    const responseType = this.responseType;
    fetch(req).then((response) => {
      if (response.status === 200 || response.status === 0) {
        if (response.status === 0) {
          console.warn("FileLoader: HTTP Status 0 received.");
        }
        if (typeof ReadableStream === "undefined" || response.body.getReader === void 0) {
          return response;
        }
        const callbacks = loading[url];
        const reader = response.body.getReader();
        const contentLength = response.headers.get("Content-Length");
        const total = contentLength ? parseInt(contentLength) : 0;
        const lengthComputable = total !== 0;
        let loaded = 0;
        const stream = new ReadableStream({
          start(controller) {
            readData();
            function readData() {
              reader.read().then(({ done, value }) => {
                if (done) {
                  controller.close();
                } else {
                  loaded += value.byteLength;
                  const event = new ProgressEvent("progress", { lengthComputable, loaded, total });
                  for (let i = 0, il = callbacks.length; i < il; i++) {
                    const callback = callbacks[i];
                    if (callback.onProgress) {
                      callback.onProgress(event);
                    }
                  }
                  controller.enqueue(value);
                  readData();
                }
              });
            }
          }
        });
        return new Response(stream);
      } else {
        throw new Error(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`);
      }
    }).then((response) => {
      switch (responseType) {
        case "arraybuffer":
          return response.arrayBuffer();
        case "blob":
          return response.blob();
        case "document":
          return response.text().then((text) => {
            const parser = new DOMParser();
            return parser.parseFromString(text, mimeType);
          });
        case "json":
          return response.json();
        default:
          if (mimeType === void 0) {
            return response.text();
          } else {
            const re = /charset="?([^;"\s]*)"?/i;
            const exec = re.exec(mimeType);
            const label = exec && exec[1] ? exec[1].toLowerCase() : void 0;
            const decoder = new TextDecoder(label);
            return response.arrayBuffer().then((ab2) => decoder.decode(ab2));
          }
      }
    }).then((data) => {
      Cache.add(url, data);
      const callbacks = loading[url];
      delete loading[url];
      for (let i = 0, il = callbacks.length; i < il; i++) {
        const callback = callbacks[i];
        if (callback.onLoad) {
          callback.onLoad(data);
        }
      }
    }).catch((err2) => {
      const callbacks = loading[url];
      if (callbacks === void 0) {
        this.manager.itemError(url);
        throw err2;
      }
      delete loading[url];
      for (let i = 0, il = callbacks.length; i < il; i++) {
        const callback = callbacks[i];
        if (callback.onError) {
          callback.onError(err2);
        }
      }
      this.manager.itemError(url);
    }).finally(() => {
      this.manager.itemEnd(url);
    });
    this.manager.itemStart(url);
  }
  setResponseType(value) {
    this.responseType = value;
    return this;
  }
  setMimeType(value) {
    this.mimeType = value;
    return this;
  }
};

// ../sdk/src/utils/index.ts
function isJSONObject(arg) {
  return typeof arg === "object" && arg !== null && !Array.isArray(arg);
}
function clone(ob) {
  return JSON.parse(JSON.stringify(ob));
}
var guidChars = [["0", 10], ["A", 26], ["a", 26], ["_", 1], ["$", 1]].map(function(a2) {
  const li = [];
  const st = a2[0].charCodeAt(0);
  const en = st + a2[1];
  for (let i = st; i < en; ++i) {
    li.push(i);
  }
  return String.fromCharCode.apply(null, li);
}).join("");
function b64(v, len) {
  const r = !len || len === 4 ? [0, 6, 12, 18] : [0, 6];
  return r.map(
    function(i) {
      return guidChars.substr(parseInt(String(v / (1 << i))) % 64, 1);
    }
  ).reverse().join("");
}
function compressGuid(g) {
  const bs = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30].map(function(i) {
    return parseInt(g.substr(i, 2), 16);
  });
  return b64(bs[0], 2) + [1, 4, 7, 10, 13].map(function(i) {
    return b64((bs[i] << 16) + (bs[i + 1] << 8) + bs[i + 2], 4);
  }).join("");
}
function findNodeOfType(m, t) {
  const li = [];
  const _ = function(n) {
    if (n.type === t)
      li.push(n);
    (n.children || []).forEach(function(c2) {
      _(c2);
    });
  };
  _(m);
  return li;
}
function timeout(dt) {
  return new Promise(function(resolve2, reject) {
    setTimeout(resolve2, dt);
  });
}
function httpRequest(args) {
  return new Promise(function(resolve2, reject) {
    const xhr = new XMLHttpRequest();
    xhr.open(args.method || "GET", args.url, true);
    xhr.onload = function(e) {
      console.log(args.url, xhr.readyState, xhr.status);
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          resolve2(xhr.responseXML);
        } else {
          reject(xhr.statusText);
        }
      }
    };
    xhr.send(null);
  });
}
function loadJSON(url, ok, err2) {
  const defaultCallback = (_value) => void 0;
  ok = ok || defaultCallback;
  err2 = err2 || defaultCallback;
  const request = new XMLHttpRequest();
  request.overrideMimeType("application/json");
  request.open("GET", url, true);
  request.addEventListener("load", function(event) {
    const response = event.target.response;
    if (this.status === 200) {
      let json;
      try {
        json = JSON.parse(response);
      } catch (e) {
        err2(`utils.loadJSON(): Failed to parse JSON response - ${e}`);
      }
      ok(json);
    } else if (this.status === 0) {
      console.warn("loadFile: HTTP Status 0 received.");
      try {
        ok(JSON.parse(response));
      } catch (e) {
        err2(`utils.loadJSON(): Failed to parse JSON response - ${e}`);
      }
    } else {
      err2(event);
    }
  }, false);
  request.addEventListener("error", function(event) {
    err2(event);
  }, false);
  request.send(null);
}
function loadArraybuffer(url, ok, err2) {
  const defaultCallback = (_value) => void 0;
  ok = ok || defaultCallback;
  err2 = err2 || defaultCallback;
  const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
  const dataUriRegexResult = url.match(dataUriRegex);
  if (dataUriRegexResult) {
    const isBase64 = !!dataUriRegexResult[2];
    let data = dataUriRegexResult[3];
    data = window.decodeURIComponent(data);
    if (isBase64) {
      data = window.atob(data);
    }
    try {
      const buffer = new ArrayBuffer(data.length);
      const view = new Uint8Array(buffer);
      for (let i = 0; i < data.length; i++) {
        view[i] = data.charCodeAt(i);
      }
      window.setTimeout(function() {
        ok(buffer);
      }, 0);
    } catch (error) {
      window.setTimeout(function() {
        err2(error);
      }, 0);
    }
  } else {
    const request = new XMLHttpRequest();
    request.open("GET", url, true);
    request.responseType = "arraybuffer";
    request.onreadystatechange = function() {
      if (request.readyState === 4) {
        if (request.status === 200) {
          ok(request.response);
        } else {
          err2("loadArrayBuffer error : " + request.response);
        }
      }
    };
    request.send(null);
  }
}
function saveArrayBuffer(arrayBuffer, filename2) {
  const blob = new Blob([arrayBuffer], { type: "application/octet-stream" });
  const link = document.createElement("a");
  link.download = filename2;
  link.href = window.URL.createObjectURL(blob);
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}
function saveJSON(data, filename2) {
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
  const link = document.createElement("a");
  link.download = filename2;
  link.href = window.URL.createObjectURL(blob);
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}
function isArray(value) {
  return value && !value.propertyIsEnumerable("length") && typeof value === "object" && typeof value.length === "number";
}
function isString(value) {
  return typeof value === "string" || value instanceof String;
}
function isNumeric(value) {
  return !isNaN(parseFloat(value)) && isFinite(value);
}
function isID(value) {
  return isString(value) || isNumeric(value);
}
function isFunction(value) {
  return typeof value === "function";
}
function isObject(value) {
  const objectConstructor = {}.constructor;
  return !!value && value.constructor === objectConstructor;
}
function copy(o) {
  return apply(o, {});
}
function apply(o, o2) {
  for (const name12 in o) {
    if (o.hasOwnProperty(name12)) {
      o2[name12] = o[name12];
    }
  }
  return o2;
}
function apply2(o, o2) {
  for (const name12 in o) {
    if (o.hasOwnProperty(name12)) {
      if (o[name12] !== void 0 && o[name12] !== null) {
        o2[name12] = o[name12];
      }
    }
  }
  return o2;
}
function applyIf(o, o2) {
  for (const name12 in o) {
    if (o.hasOwnProperty(name12)) {
      if (o2[name12] === void 0 || o2[name12] === null) {
        o2[name12] = o[name12];
      }
    }
  }
  return o2;
}
function isEmptyObject(obj) {
  for (const name12 in obj) {
    if (obj.hasOwnProperty(name12)) {
      return false;
    }
  }
  return true;
}
function inQuotes(id) {
  return isNumeric(id) ? `${id}` : `'${id}'`;
}
function concat(a2, b4) {
  const c2 = new a2.constructor(a2.length + b4.length);
  c2.set(a2);
  c2.set(b4, a2.length);
  return c2;
}
var createUUID2 = (() => {
  const lut = [];
  for (let i = 0; i < 256; i++) {
    lut[i] = (i < 16 ? "0" : "") + i.toString(16);
  }
  return () => {
    const d0 = Math.random() * 4294967295 | 0;
    const d1 = Math.random() * 4294967295 | 0;
    const d2 = Math.random() * 4294967295 | 0;
    const d3 = Math.random() * 4294967295 | 0;
    return `${lut[d0 & 255] + lut[d0 >> 8 & 255] + lut[d0 >> 16 & 255] + lut[d0 >> 24 & 255]}-${lut[d1 & 255]}${lut[d1 >> 8 & 255]}-${lut[d1 >> 16 & 15 | 64]}${lut[d1 >> 24 & 255]}-${lut[d2 & 63 | 128]}${lut[d2 >> 8 & 255]}-${lut[d2 >> 16 & 255]}${lut[d2 >> 24 & 255]}${lut[d3 & 255]}${lut[d3 >> 8 & 255]}${lut[d3 >> 16 & 255]}${lut[d3 >> 24 & 255]}`;
  };
})();

// ../sdk/src/rtc/index.ts
var rtc_exports = {};
__export(rtc_exports, {
  RTC_CELL_SIZE: () => RTC_CELL_SIZE,
  createRTCModelMat: () => createRTCModelMat,
  createRTCViewMat: () => createRTCViewMat,
  getPlaneRTCPos: () => getPlaneRTCPos,
  rtcToWorldPos: () => rtcToWorldPos,
  worldToRTCCenter: () => worldToRTCCenter,
  worldToRTCPos: () => worldToRTCPos,
  worldToRTCPositions: () => worldToRTCPositions
});

// ../sdk/src/boundaries/index.ts
var boundaries_exports = {};
__export(boundaries_exports, {
  AABB3ToOBB3: () => AABB3ToOBB3,
  Frustum3: () => Frustum3,
  FrustumPlane3: () => FrustumPlane3,
  INSIDE: () => INSIDE,
  INTERSECT: () => INTERSECT,
  OBB3ToAABB3: () => OBB3ToAABB3,
  OUTSIDE: () => OUTSIDE,
  collapseAABB3: () => collapseAABB3,
  containsAABB2: () => containsAABB2,
  containsAABB2Point2: () => containsAABB2Point2,
  containsAABB3: () => containsAABB3,
  containsAABB3Point3: () => containsAABB3Point3,
  createAABB2: () => createAABB2,
  createAABB3: () => createAABB3,
  createAABB3Int16: () => createAABB3Int16,
  createOBB2: () => createOBB2,
  createOBB3: () => createOBB3,
  createSphere3: () => createSphere3,
  expandAABB2: () => expandAABB2,
  expandAABB2Point2: () => expandAABB2Point2,
  expandAABB3: () => expandAABB3,
  expandAABB3Point3: () => expandAABB3Point3,
  expandAABB3Points3: () => expandAABB3Points3,
  getAABB3Area: () => getAABB3Area,
  getAABB3Center: () => getAABB3Center,
  getAABB3Diag: () => getAABB3Diag,
  getAABB3DiagPoint: () => getAABB3DiagPoint,
  getPositions3Center: () => getPositions3Center,
  intersectAABB3Lines3: () => intersectAABB3Lines3,
  intersectAABB3Positions3: () => intersectAABB3Positions3,
  intersectAABB3Triangles3: () => intersectAABB3Triangles3,
  intersectAABB3s: () => intersectAABB3s,
  intersectFrustum3AABB3: () => intersectFrustum3AABB3,
  intersectFrustum3Lines3: () => intersectFrustum3Lines3,
  intersectFrustum3Point3: () => intersectFrustum3Point3,
  intersectFrustum3Positions3: () => intersectFrustum3Positions3,
  intersectFrustum3Triangle3: () => intersectFrustum3Triangle3,
  intersectFrustum3Triangles3: () => intersectFrustum3Triangles3,
  points3ToAABB3: () => points3ToAABB3,
  positions3ToAABB3: () => positions3ToAABB3,
  setFrustum3: () => setFrustum3,
  transformOBB3: () => transformOBB3
});

// ../sdk/src/compression/index.ts
var compression_exports = {};
__export(compression_exports, {
  compressNormals: () => compressNormals,
  compressPoint3WithAABB3: () => compressPoint3WithAABB3,
  compressPositions3: () => compressPositions3,
  compressRGBColors: () => compressRGBColors,
  compressUVs: () => compressUVs,
  createPositions3DecompressMat4: () => createPositions3DecompressMat4,
  decompressAABB3WithAABB3: () => decompressAABB3WithAABB3,
  decompressAABB3WithMat4: () => decompressAABB3WithMat4,
  decompressNormal: () => decompressNormal,
  decompressNormals: () => decompressNormals,
  decompressPoint3WithAABB3: () => decompressPoint3WithAABB3,
  decompressPoint3WithMat4: () => decompressPoint3WithMat4,
  decompressPositions3WithAABB3: () => decompressPositions3WithAABB3,
  decompressPositions3WithMat4: () => decompressPositions3WithMat4,
  decompressUV: () => decompressUV,
  decompressUVs: () => decompressUVs,
  getPositions3MinMax: () => getPositions3MinMax,
  getUVBounds: () => getUVBounds,
  octEncodeNormal: () => octEncodeNormal,
  octEncodeVec3: () => octEncodeVec3,
  quantizePositions3: () => quantizePositions3,
  quantizePositions3AndCreateMat4: () => quantizePositions3AndCreateMat4,
  transformAndOctEncodeNormals: () => transformAndOctEncodeNormals
});
var translate = createMat4();
var scale = createMat4();
function getPositions3MinMax(array, min = new Float64Array(3), max = new Float64Array(3)) {
  for (let i = 0; i < 3; i++) {
    min[i] = Number.MAX_VALUE;
    max[i] = -Number.MAX_VALUE;
  }
  for (let i = 0; i < array.length; i += 3) {
    for (let j = 0; j < 3; j++) {
      min[j] = Math.min(min[j], array[i + j]);
      max[j] = Math.max(max[j], array[i + j]);
    }
  }
  return {
    min,
    max
  };
}
function createPositions3DecompressMat4(aabb, positionsDecompressMatrix = createMat4()) {
  const [xmin, ymin, zmin, xmax, ymax, zmax] = aabb;
  const xwid = xmax - xmin;
  const ywid = ymax - ymin;
  const zwid = zmax - zmin;
  const maxInt = 65535;
  identityMat4(translate);
  translationMat4v(aabb, translate);
  identityMat4(scale);
  scalingMat4v([xwid / maxInt, ywid / maxInt, zwid / maxInt], scale);
  mulMat4(translate, scale, positionsDecompressMatrix);
  return positionsDecompressMatrix;
}
function compressPositions3(array, min, max) {
  const quantized = new Uint16Array(array.length);
  const multiplier = new Float32Array([
    max[0] !== min[0] ? 65535 / (max[0] - min[0]) : 0,
    max[1] !== min[1] ? 65535 / (max[1] - min[1]) : 0,
    max[2] !== min[2] ? 65535 / (max[2] - min[2]) : 0
  ]);
  for (let i = 0; i < array.length; i += 3) {
    quantized[i + 0] = Math.floor((array[i + 0] - min[0]) * multiplier[0]);
    quantized[i + 1] = Math.floor((array[i + 1] - min[1]) * multiplier[1]);
    quantized[i + 2] = Math.floor((array[i + 2] - min[2]) * multiplier[2]);
  }
  const translate3 = createMat4();
  translationMat4v(min, translate3);
  const scale3 = createMat4();
  scalingMat4v([
    (max[0] - min[0]) / 65535,
    (max[1] - min[1]) / 65535,
    (max[2] - min[2]) / 65535
  ], scale3);
  const decompressMatrix = mulMat4(translate3, scale3, identityMat4());
  return {
    quantized,
    decompressMatrix
  };
}
function compressPoint3WithAABB3(p, aabb, dest = p) {
  const multiplier = new Float32Array([
    aabb[3] !== aabb[0] ? 65535 / (aabb[3] - aabb[0]) : 0,
    aabb[4] !== aabb[1] ? 65535 / (aabb[4] - aabb[1]) : 0,
    aabb[5] !== aabb[2] ? 65535 / (aabb[5] - aabb[2]) : 0
  ]);
  dest[0] = Math.max(0, Math.min(65535, Math.floor((p[0] - aabb[0]) * multiplier[0])));
  dest[1] = Math.max(0, Math.min(65535, Math.floor((p[1] - aabb[1]) * multiplier[1])));
  dest[2] = Math.max(0, Math.min(65535, Math.floor((p[2] - aabb[2]) * multiplier[2])));
  return dest;
}
function decompressPoint3WithMat4(position, decompressMatrix, dest = position) {
  dest[0] = position[0] * decompressMatrix[0] + decompressMatrix[12];
  dest[1] = position[1] * decompressMatrix[5] + decompressMatrix[13];
  dest[2] = position[2] * decompressMatrix[10] + decompressMatrix[14];
  return dest;
}
function decompressPoint3WithAABB3(position, aabb, dest = position) {
  const xScale = (aabb[3] - aabb[0]) / 65535;
  const xOffset = aabb[0];
  const yScale = (aabb[4] - aabb[1]) / 65535;
  const yOffset = aabb[1];
  const zScale = (aabb[5] - aabb[2]) / 65535;
  const zOffset = aabb[2];
  dest[0] = position[0] * xScale + xOffset;
  dest[1] = position[1] * yScale + yOffset;
  dest[2] = position[2] * zScale + zOffset;
  return dest;
}
function decompressAABB3WithMat4(aabb, decompressMatrix, dest = aabb) {
  dest[0] = aabb[0] * decompressMatrix[0] + decompressMatrix[12];
  dest[1] = aabb[1] * decompressMatrix[5] + decompressMatrix[13];
  dest[2] = aabb[2] * decompressMatrix[10] + decompressMatrix[14];
  dest[3] = aabb[3] * decompressMatrix[0] + decompressMatrix[12];
  dest[4] = aabb[4] * decompressMatrix[5] + decompressMatrix[13];
  dest[5] = aabb[5] * decompressMatrix[10] + decompressMatrix[14];
  return dest;
}
function decompressAABB3WithAABB3(aabb, aabb2, dest = aabb) {
  const xScale = (aabb2[3] - aabb2[0]) / 65535;
  const xOffset = aabb2[0];
  const yScale = (aabb2[4] - aabb2[1]) / 65535;
  const yOffset = aabb2[1];
  const zScale = (aabb2[5] - aabb2[2]) / 65535;
  const zOffset = aabb2[2];
  dest[0] = aabb[0] * xScale + xOffset;
  dest[1] = aabb[1] * yScale + yOffset;
  dest[2] = aabb[2] * zScale + zOffset;
  dest[3] = aabb[3] * xScale + xOffset;
  dest[4] = aabb[4] * yScale + yOffset;
  dest[5] = aabb[5] * zScale + zOffset;
  return dest;
}
function decompressPositions3WithMat4(positions, decompressMatrix, dest = new Float32Array(positions.length)) {
  const m = decompressMatrix;
  for (let i = 0, len = positions.length; i < len; i += 3) {
    dest[i] = positions[i] * m[0] + m[12];
    dest[i + 1] = positions[i + 1] * m[5] + m[13];
    dest[i + 2] = positions[i + 2] * m[10] + m[14];
  }
  return dest;
}
function decompressPositions3WithAABB3(positions, aabb, dest = new Float32Array(positions.length)) {
  const xScale = (aabb[3] - aabb[0]) / 65535;
  const xOffset = aabb[0];
  const yScale = (aabb[4] - aabb[1]) / 65535;
  const yOffset = aabb[1];
  const zScale = (aabb[5] - aabb[2]) / 65535;
  const zOffset = aabb[2];
  for (let i = 0; i < positions.length; i += 3) {
    dest[i] = positions[i] * xScale + xOffset;
    dest[i + 1] = positions[i + 1] * yScale + yOffset;
    dest[i + 2] = positions[i + 2] * zScale + zOffset;
  }
  return dest;
}
function getUVBounds(array) {
  const min = new Float32Array(2).fill(Number.MAX_VALUE);
  const max = new Float32Array(2).fill(-Number.MAX_VALUE);
  for (let i = 0; i < array.length; i += 2) {
    min[0] = Math.min(min[0], array[i]);
    min[1] = Math.min(min[1], array[i + 1]);
    max[0] = Math.max(max[0], array[i]);
    max[1] = Math.max(max[1], array[i + 1]);
  }
  return { min, max };
}
function compressUVs(array, min, max) {
  const quantized = new Uint16Array(array.length);
  const multipliers = new Float32Array([
    65535 / (max[0] - min[0]),
    65535 / (max[1] - min[1])
  ]);
  for (let i = 0; i < array.length; i += 2) {
    quantized[i] = Math.floor((array[i] - min[0]) * multipliers[0]);
    quantized[i + 1] = Math.floor((array[i + 1] - min[1]) * multipliers[1]);
  }
  identityMat3(translate);
  translationMat3v(min, translate);
  identityMat3(scale);
  scalingMat3v([
    (max[0] - min[0]) / 65535,
    (max[1] - min[1]) / 65535
  ], scale);
  const decompressMatrix = mulMat3(translate, scale, identityMat3());
  return {
    quantized,
    decompressMatrix
  };
}
function compressNormals(array) {
  const encoded = new Int8Array(array.length);
  let oct, dec, best, currentCos, bestCos;
  for (let i = 0; i < array.length; i += 3) {
    best = oct = octEncodeNormalFromArray(array, i, "floor", "floor");
    dec = octDecodeVec2(oct);
    bestCos = currentCos = dot(array, i, dec);
    const strategies = [
      ["ceil", "floor"],
      ["floor", "ceil"],
      ["ceil", "ceil"]
    ];
    strategies.forEach(([xFunc, yFunc]) => {
      oct = octEncodeNormalFromArray(array, i, xFunc, yFunc);
      dec = octDecodeVec2(oct);
      currentCos = dot(array, i, dec);
      if (currentCos > bestCos) {
        best = oct;
        bestCos = currentCos;
      }
    });
    encoded[i] = best[0];
    encoded[i + 1] = best[1];
  }
  return encoded;
}
function octEncodeNormalFromArray(array, i, xfunc, yfunc) {
  let x = array[i] / (Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]));
  let y = array[i + 1] / (Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]));
  if (array[i + 2] < 0) {
    let tempx = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);
    let tempy = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);
    x = tempx;
    y = tempy;
  }
  return new Int8Array([Math[xfunc](x * 127.5 + (x < 0 ? -1 : 0)), Math[yfunc](y * 127.5 + (y < 0 ? -1 : 0))]);
}
function dot(array, i, createVec32) {
  return array[i] * createVec32[0] + array[i + 1] * createVec32[1] + array[i + 2] * createVec32[2];
}
function decompressUV(uv, decompressMatrix, dest = new Float32Array(2)) {
  if (uv.length < 2 || decompressMatrix.length < 8) {
    throw new Error("Invalid input arrays: UV must have at least 2 elements, and decompressMatrix must have at least 8 elements.");
  }
  const u = uv[0];
  const v = uv[1];
  dest[0] = u * decompressMatrix[0] + decompressMatrix[6];
  dest[1] = v * decompressMatrix[4] + decompressMatrix[7];
  return dest;
}
function decompressUVs(uvs, decompressMatrix, dest = new Float32Array(uvs.length)) {
  if (uvs.length % 2 !== 0 || decompressMatrix.length < 8) {
    throw new Error("Invalid input: UVs must be a multiple of 2, and decompressMatrix must have at least 8 elements.");
  }
  for (let i = 0, len = uvs.length; i < len; i += 2) {
    dest[i] = uvs[i] * decompressMatrix[0] + decompressMatrix[6];
    dest[i + 1] = uvs[i + 1] * decompressMatrix[4] + decompressMatrix[7];
  }
  return dest;
}
function decompressNormal(oct, result) {
  if (oct.length < 2 || result.length < 3) {
    throw new Error("Invalid input: oct must have at least 2 elements, and result must have at least 3 elements.");
  }
  let x = (2 * oct[0] + 1) / 255;
  let y = (2 * oct[1] + 1) / 255;
  let z = 1 - Math.abs(x) - Math.abs(y);
  if (z < 0) {
    const tempx = (1 - Math.abs(y)) * Math.sign(x);
    const tempy = (1 - Math.abs(x)) * Math.sign(y);
    x = tempx;
    y = tempy;
  }
  const length = Math.sqrt(x * x + y * y + z * z);
  result[0] = x / length;
  result[1] = y / length;
  result[2] = z / length;
  return result;
}
function decompressNormals(octs, result) {
  if (octs.length % 2 !== 0) {
    throw new Error("Invalid input: octs must contain an even number of elements.");
  }
  if (result.length < octs.length / 2 * 3) {
    throw new Error("Invalid output array: result must be large enough to store all decompressed normals.");
  }
  for (let i = 0, j = 0, len = octs.length; i < len; i += 2, j += 3) {
    let x = (2 * octs[i] + 1) / 255;
    let y = (2 * octs[i + 1] + 1) / 255;
    let z = 1 - Math.abs(x) - Math.abs(y);
    if (z < 0) {
      const tempx = (1 - Math.abs(y)) * Math.sign(x);
      const tempy = (1 - Math.abs(x)) * Math.sign(y);
      x = tempx;
      y = tempy;
    }
    const length = Math.sqrt(x * x + y * y + z * z);
    result[j] = x / length;
    result[j + 1] = y / length;
    result[j + 2] = z / length;
  }
  return result;
}
function octDecodeVec2(oct, result = createVec3()) {
  let x = oct[0];
  let y = oct[1];
  x = (2 * x + 1) / 255;
  y = (2 * y + 1) / 255;
  let z = 1 - Math.abs(x) - Math.abs(y);
  if (z < 0) {
    x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);
    y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);
  }
  const length = Math.sqrt(x * x + y * y + z * z);
  result[0] = x / length;
  result[1] = y / length;
  result[2] = z / length;
  return result;
}
function quantizePositions3AndCreateMat4(positions, aabb, positionsDecompressMatrix) {
  const lenPositions = positions.length;
  const positionsCompressed = new Uint16Array(lenPositions);
  const [xmin, ymin, zmin, xmax, ymax, zmax] = aabb;
  const xwid = xmax - xmin;
  const ywid = ymax - ymin;
  const zwid = zmax - zmin;
  const maxInt = 65525;
  const xMultiplier = maxInt / xwid;
  const yMultiplier = maxInt / ywid;
  const zMultiplier = maxInt / zwid;
  const verify = (num) => Math.max(0, num);
  for (let i = 0; i < lenPositions; i += 3) {
    positionsCompressed[i] = Math.floor(verify(positions[i] - xmin) * xMultiplier);
    positionsCompressed[i + 1] = Math.floor(verify(positions[i + 1] - ymin) * yMultiplier);
    positionsCompressed[i + 2] = Math.floor(verify(positions[i + 2] - zmin) * zMultiplier);
  }
  const translate3 = new Float32Array(16);
  identityMat4(translate3);
  translationMat4v(aabb, translate3);
  const scale3 = new Float32Array(16);
  identityMat4(scale3);
  scalingMat4v([xwid / maxInt, ywid / maxInt, zwid / maxInt], scale3);
  mulMat4(translate3, scale3, positionsDecompressMatrix);
  return positionsCompressed;
}
function quantizePositions3(positions, aabb) {
  const lenPositions = positions.length;
  const positionsCompressed = new Uint16Array(lenPositions);
  const [xmin, ymin, zmin, xmax, ymax, zmax] = aabb;
  const xwid = xmax - xmin;
  const ywid = ymax - ymin;
  const zwid = zmax - zmin;
  const maxInt = 65525;
  const xMultiplier = maxInt / xwid;
  const yMultiplier = maxInt / ywid;
  const zMultiplier = maxInt / zwid;
  const verify = (num) => Math.max(0, num);
  for (let i = 0; i < lenPositions; i += 3) {
    positionsCompressed[i] = Math.floor(verify(positions[i] - xmin) * xMultiplier);
    positionsCompressed[i + 1] = Math.floor(verify(positions[i + 1] - ymin) * yMultiplier);
    positionsCompressed[i + 2] = Math.floor(verify(positions[i + 2] - zmin) * zMultiplier);
  }
  return positionsCompressed;
}
function transformAndOctEncodeNormals(worldNormalMatrix, normals, lenNormals, compressedNormals, lenCompressedNormals) {
  const dot3 = (p, createVec32) => {
    return p[0] * createVec32[0] + p[1] * createVec32[1] + p[2] * createVec32[2];
  };
  let localNormal = new Float32Array(3);
  let worldNormal = new Float32Array(3);
  let best, currentCos, bestCos, dec;
  for (let i = 0; i < lenNormals; i += 3) {
    localNormal[0] = normals[i];
    localNormal[1] = normals[i + 1];
    localNormal[2] = normals[i + 2];
    transformVec3(worldNormalMatrix, localNormal, worldNormal);
    normalizeVec3(worldNormal, worldNormal);
    bestCos = -Infinity;
    for (const xfunc of ["floor", "ceil"]) {
      for (const yfunc of ["floor", "ceil"]) {
        const oct = octEncodeVec3(worldNormal, xfunc, yfunc);
        dec = octDecodeVec2(oct);
        currentCos = dot3(worldNormal, dec);
        if (currentCos > bestCos) {
          best = oct;
          bestCos = currentCos;
        }
      }
    }
    compressedNormals[lenCompressedNormals + i] = best[0];
    compressedNormals[lenCompressedNormals + i + 1] = best[1];
    compressedNormals[lenCompressedNormals + i + 2] = 0;
  }
  lenCompressedNormals += lenNormals;
  return lenCompressedNormals;
}
function octEncodeVec3(p, xfunc, yfunc) {
  if (typeof Math[xfunc] !== "function" || typeof Math[yfunc] !== "function") {
    throw new Error(`Invalid math function names: ${xfunc} or ${yfunc} are not valid functions.`);
  }
  const total = Math.abs(p[0]) + Math.abs(p[1]) + Math.abs(p[2]);
  let x = p[0] / total;
  let y = p[1] / total;
  if (p[2] < 0) {
    x = (1 - Math.abs(y)) * Math.sign(x);
    y = (1 - Math.abs(x)) * Math.sign(y);
  }
  const encodedX = Math[xfunc](x * 127.5 + (x < 0 ? -1 : 0));
  const encodedY = Math[yfunc](y * 127.5 + (y < 0 ? -1 : 0));
  return new Int8Array([encodedX, encodedY]);
}
function octEncodeNormal(array, i, xfunc, yfunc) {
  if (typeof Math[xfunc] !== "function" || typeof Math[yfunc] !== "function") {
    throw new Error(`Invalid math function names: ${xfunc} or ${yfunc} are not valid functions.`);
  }
  const total = Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]);
  let x = array[i] / total;
  let y = array[i + 1] / total;
  if (array[i + 2] < 0) {
    const tempx = (1 - Math.abs(y)) * Math.sign(x);
    const tempy = (1 - Math.abs(x)) * Math.sign(y);
    x = tempx;
    y = tempy;
  }
  const encodedX = Math[xfunc](x * 127.5 + (x < 0 ? -1 : 0));
  const encodedY = Math[yfunc](y * 127.5 + (y < 0 ? -1 : 0));
  return new Int8Array([encodedX, encodedY]);
}
function compressRGBColors(colors) {
  const len = colors.length;
  const compressed = new Uint16Array(len);
  for (let i = 0; i < len; i++) {
    if (colors[i] < 0 || colors[i] > 1) {
      throw new Error(`Color value at index ${i} (${colors[i]}) is out of range [0, 1].`);
    }
    compressed[i] = Math.round(colors[i] * 255);
  }
  return compressed;
}

// ../sdk/src/boundaries/index.ts
var tempVec3a = createVec3();
var tempVec3b2 = createVec3();
var tempVec3c2 = createVec3();
var tempMat4a2 = createMat4();
function createAABB3(values) {
  return new Float64Array(values || 6);
}
function createAABB3Int16(values) {
  return new Int16Array(values || 6);
}
function createAABB2(values) {
  return newFloatArray(values || 4);
}
function createOBB3(values) {
  return newFloatArray(values || 32);
}
function createOBB2(values) {
  return newFloatArray(values || 16);
}
function createSphere3(x, y, z, r) {
  return newFloatArray([x, y, z, r]);
}
function transformOBB3(m, p, p2 = p) {
  for (let i = 0; i < p.length; i += 4) {
    const x = p[i], y = p[i + 1], z = p[i + 2];
    p2[i] = m[0] * x + m[4] * y + m[8] * z + m[12];
    p2[i + 1] = m[1] * x + m[5] * y + m[9] * z + m[13];
    p2[i + 2] = m[2] * x + m[6] * y + m[10] * z + m[14];
    p2[i + 3] = m[3] * x + m[7] * y + m[11] * z + m[15];
  }
  return p2;
}
function containsAABB2(aabb1, aabb2) {
  return aabb1[0] <= aabb2[0] && aabb2[3] <= aabb1[3] && aabb1[1] <= aabb2[1] && aabb2[2] <= aabb1[2];
}
function containsAABB3(aabb1, aabb2) {
  return aabb1[0] <= aabb2[0] && aabb2[3] <= aabb1[3] && aabb1[1] <= aabb2[1] && aabb2[4] <= aabb1[4] && aabb1[2] <= aabb2[2] && aabb2[5] <= aabb1[5];
}
function getAABB3Diag(aabb) {
  return Math.abs(lenVec3(subVec3([aabb[3], aabb[4], aabb[5]], [aabb[0], aabb[1], aabb[2]], tempVec3a)));
}
function getAABB3Center(aabb, dest = createVec3()) {
  dest[0] = (aabb[0] + aabb[3]) / 2;
  dest[1] = (aabb[1] + aabb[4]) / 2;
  dest[2] = (aabb[2] + aabb[5]) / 2;
  return dest;
}
var getAABB3DiagPoint = (aabb, p) => {
  const min = tempVec3a;
  const max = tempVec3b2;
  min[0] = aabb[0];
  min[1] = aabb[1];
  min[2] = aabb[2];
  max[0] = aabb[3];
  max[1] = aabb[4];
  max[2] = aabb[5];
  const diagVec = subVec3(max, min, tempVec3c2);
  const xneg = p[0] - aabb[0];
  const xpos = aabb[3] - p[0];
  const yneg = p[1] - aabb[1];
  const ypos = aabb[4] - p[1];
  const zneg = p[2] - aabb[2];
  const zpos = aabb[5] - p[2];
  diagVec[0] += xneg > xpos ? xneg : xpos;
  diagVec[1] += yneg > ypos ? yneg : ypos;
  diagVec[2] += zneg > zpos ? zneg : zpos;
  return Math.abs(lenVec3(diagVec));
};
function getAABB3Area(aabb) {
  const width = aabb[3] - aabb[0];
  const height = aabb[4] - aabb[1];
  const depth = aabb[5] - aabb[2];
  return width * height * depth;
}
function collapseAABB3(aabb = createAABB3()) {
  aabb.set([MAX_DOUBLE, MAX_DOUBLE, MAX_DOUBLE, MIN_DOUBLE, MIN_DOUBLE, MIN_DOUBLE]);
  return aabb;
}
function AABB3ToOBB3(aabb = createAABB3(), obb = createOBB3()) {
  const [minX, minY, minZ, maxX, maxY, maxZ] = aabb;
  const corners = [
    [minX, minY, minZ],
    [maxX, minY, minZ],
    [maxX, maxY, minZ],
    [minX, maxY, minZ],
    [minX, minY, maxZ],
    [maxX, minY, maxZ],
    [maxX, maxY, maxZ],
    [minX, maxY, maxZ]
  ];
  for (let i = 0; i < 8; i++) {
    obb[i * 4] = corners[i][0];
    obb[i * 4 + 1] = corners[i][1];
    obb[i * 4 + 2] = corners[i][2];
    obb[i * 4 + 3] = 1;
  }
  return obb;
}
function expandAABB3(aabb1, aabb2) {
  for (let i = 0; i < 3; i++) {
    aabb1[i] = Math.min(aabb1[i], aabb2[i]);
    aabb1[i + 3] = Math.max(aabb1[i + 3], aabb2[i + 3]);
  }
  return aabb1;
}
function expandAABB2(aabb1, aabb2) {
  for (let i = 0; i < 2; i++) {
    aabb1[i] = Math.min(aabb1[i], aabb2[i]);
    aabb1[i + 3] = Math.max(aabb1[i + 3], aabb2[i + 3]);
  }
  return aabb1;
}
function expandAABB3Point3(aabb, p) {
  for (let i = 0; i < 3; i++) {
    aabb[i] = Math.min(aabb[i], p[i]);
    aabb[i + 3] = Math.max(aabb[i + 3], p[i]);
  }
  return aabb;
}
function expandAABB2Point2(aabb, p) {
  for (let i = 0; i < 2; i++) {
    aabb[i] = Math.min(aabb[i], p[i]);
    aabb[i + 3] = Math.max(aabb[i + 3], p[i]);
  }
  return aabb;
}
function expandAABB3Points3(aabb, positions) {
  for (let i = 0; i < positions.length; i += 3) {
    for (let j = 0; j < 3; j++) {
      aabb[j] = Math.min(aabb[j], positions[i + j]);
      aabb[j + 3] = Math.max(aabb[j + 3], positions[i + j]);
    }
  }
  return aabb;
}
var positions3ToAABB3 = (() => {
  const p = newFloatArray(3);
  return (positions, aabb = createAABB3(), positionsDecompressMatrix) => {
    let xmin = MAX_DOUBLE, ymin = MAX_DOUBLE, zmin = MAX_DOUBLE;
    let xmax = MIN_DOUBLE, ymax = MIN_DOUBLE, zmax = MIN_DOUBLE;
    for (let i = 0, len = positions.length; i < len; i += 3) {
      let x = positions[i], y = positions[i + 1], z = positions[i + 2];
      if (positionsDecompressMatrix) {
        p[0] = x;
        p[1] = y;
        p[2] = z;
        decompressPoint3WithMat4(p, positionsDecompressMatrix, p);
        x = p[0];
        y = p[1];
        z = p[2];
      }
      xmin = Math.min(xmin, x);
      ymin = Math.min(ymin, y);
      zmin = Math.min(zmin, z);
      xmax = Math.max(xmax, x);
      ymax = Math.max(ymax, y);
      zmax = Math.max(zmax, z);
    }
    aabb[0] = xmin;
    aabb[1] = ymin;
    aabb[2] = zmin;
    aabb[3] = xmax;
    aabb[4] = ymax;
    aabb[5] = zmax;
    return aabb;
  };
})();
function OBB3ToAABB3(obb, aabb = createAABB3()) {
  let xmin = MAX_DOUBLE, ymin = MAX_DOUBLE, zmin = MAX_DOUBLE;
  let xmax = MIN_DOUBLE, ymax = MIN_DOUBLE, zmax = MIN_DOUBLE;
  for (let i = 0, len = obb.length; i < len; i += 4) {
    const x = obb[i], y = obb[i + 1], z = obb[i + 2];
    xmin = Math.min(xmin, x);
    ymin = Math.min(ymin, y);
    zmin = Math.min(zmin, z);
    xmax = Math.max(xmax, x);
    ymax = Math.max(ymax, y);
    zmax = Math.max(zmax, z);
  }
  aabb[0] = xmin;
  aabb[1] = ymin;
  aabb[2] = zmin;
  aabb[3] = xmax;
  aabb[4] = ymax;
  aabb[5] = zmax;
  return aabb;
}
function points3ToAABB3(points, aabb = createAABB3()) {
  let xmin = MAX_DOUBLE, ymin = MAX_DOUBLE, zmin = MAX_DOUBLE;
  let xmax = MIN_DOUBLE, ymax = MIN_DOUBLE, zmax = MIN_DOUBLE;
  for (const [x, y, z] of points) {
    xmin = Math.min(xmin, x);
    ymin = Math.min(ymin, y);
    zmin = Math.min(zmin, z);
    xmax = Math.max(xmax, x);
    ymax = Math.max(ymax, y);
    zmax = Math.max(zmax, z);
  }
  aabb[0] = xmin;
  aabb[1] = ymin;
  aabb[2] = zmin;
  aabb[3] = xmax;
  aabb[4] = ymax;
  aabb[5] = zmax;
  return aabb;
}
function getPositions3Center(positions, center2 = createVec3()) {
  let xSum = 0, ySum = 0, zSum = 0;
  const numPoints = positions.length / 3;
  for (let i = 0; i < positions.length; i += 3) {
    xSum += positions[i];
    ySum += positions[i + 1];
    zSum += positions[i + 2];
  }
  center2[0] = xSum / numPoints;
  center2[1] = ySum / numPoints;
  center2[2] = zSum / numPoints;
  return center2;
}
var FrustumPlane3 = class {
  /**
   * A vertex used to test intersections with this plane.
   */
  testVertex;
  /**
   * The distance of the plane from the origin along its normal.
   */
  offset;
  /**
   * The normal vector of the plane.
   */
  normal;
  /**
   * Creates a new frustum plane.
   */
  constructor() {
    this.normal = createVec3();
    this.offset = 0;
    this.testVertex = createVec3();
  }
  /**
   * Sets the position and direction of the frustum plane.
   *
   * @param nx - X component of the normal vector.
   * @param ny - Y component of the normal vector.
   * @param nz - Z component of the normal vector.
   * @param offset - Distance of the plane from the origin.
   */
  set(nx, ny, nz, offset) {
    const s = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);
    this.normal[0] = nx * s;
    this.normal[1] = ny * s;
    this.normal[2] = nz * s;
    this.offset = offset * s;
    this.testVertex[0] = this.normal[0] >= 0 ? 1 : 0;
    this.testVertex[1] = this.normal[1] >= 0 ? 1 : 0;
    this.testVertex[2] = this.normal[2] >= 0 ? 1 : 0;
  }
};
var INSIDE = 1;
var INTERSECT = 2;
var OUTSIDE = 3;
var Frustum3 = class {
  /**
   * The six planes that define the frustum boundary.
   */
  planes;
  /**
   * Creates a new 3D frustum.
   */
  constructor() {
    this.planes = [
      new FrustumPlane3(),
      new FrustumPlane3(),
      new FrustumPlane3(),
      new FrustumPlane3(),
      new FrustumPlane3(),
      new FrustumPlane3()
    ];
  }
};
function setFrustum3(viewMat, projMat, frustum) {
  const m = mulMat4(projMat, viewMat, tempMat4a2);
  const m0 = m[0], m1 = m[1], m2 = m[2], m3 = m[3];
  const m4 = m[4], m5 = m[5], m6 = m[6], m7 = m[7];
  const m8 = m[8], m9 = m[9], m10 = m[10], m11 = m[11];
  const m12 = m[12], m13 = m[13], m14 = m[14], m15 = m[15];
  frustum = frustum || new Frustum3();
  frustum.planes[0].set(m3 - m0, m7 - m4, m11 - m8, m15 - m12);
  frustum.planes[1].set(m3 + m0, m7 + m4, m11 + m8, m15 + m12);
  frustum.planes[2].set(m3 - m1, m7 - m5, m11 - m9, m15 - m13);
  frustum.planes[3].set(m3 + m1, m7 + m5, m11 + m9, m15 + m13);
  frustum.planes[4].set(m3 - m2, m7 - m6, m11 - m10, m15 - m14);
  frustum.planes[5].set(m3 + m2, m7 + m6, m11 + m10, m15 + m14);
  return frustum;
}
function intersectFrustum3AABB3(frustum, aabb) {
  let ret = INSIDE;
  const min = tempVec3a;
  const max = tempVec3b2;
  min[0] = aabb[0];
  min[1] = aabb[1];
  min[2] = aabb[2];
  max[0] = aabb[3];
  max[1] = aabb[4];
  max[2] = aabb[5];
  const bminmax = [min, max];
  for (let i = 0; i < 6; ++i) {
    const plane = frustum.planes[i];
    if (plane.normal[0] * bminmax[plane.testVertex[0]][0] + plane.normal[1] * bminmax[plane.testVertex[1]][1] + plane.normal[2] * bminmax[plane.testVertex[2]][2] + plane.offset < 0) {
      return OUTSIDE;
    }
    if (plane.normal[0] * bminmax[1 - plane.testVertex[0]][0] + plane.normal[1] * bminmax[1 - plane.testVertex[1]][1] + plane.normal[2] * bminmax[1 - plane.testVertex[2]][2] + plane.offset < 0) {
      ret = INTERSECT;
    }
  }
  return ret;
}
function intersectAABB3s(aabb1, aabb2) {
  return INTERSECT;
}
function intersectFrustum3Triangles3(frustum, positions, indices) {
  return true;
}
function intersectFrustum3Triangle3(frustum, a2, b4, c2) {
  return true;
}
function intersectFrustum3Lines3(frustum, positions, indices) {
  return true;
}
function intersectFrustum3Positions3(frustum, positions) {
  return true;
}
function intersectFrustum3Point3(frustum, position) {
  return true;
}
function intersectAABB3Triangles3(aabb, positions, indices) {
  return false;
}
function intersectAABB3Lines3(aabb, positions, indices) {
  return false;
}
function intersectAABB3Positions3(aabb, positions) {
  return false;
}
function containsAABB3Point3(aabb, p) {
  return aabb[0] <= p[0] && p[0] <= aabb[3] && aabb[1] <= p[1] && p[1] <= aabb[4] && aabb[2] <= p[2] && p[2] <= aabb[5];
}
function containsAABB2Point2(aabb, p) {
  return aabb[0] <= p[0] && p[0] <= aabb[3] && aabb[1] <= p[1] && p[1] <= aabb[4];
}

// ../sdk/src/rtc/index.ts
var tempVec3a2 = createVec3();
var tempMat = new Float32Array(16);
var rtcCenterWorld = new Float64Array(4);
var rtcCenterView = new Float64Array(4);
var RTC_CELL_SIZE = 200;
function createRTCViewMat(viewMat, rtcCenter2, rtcViewMat = tempMat) {
  rtcCenterWorld[0] = rtcCenter2[0];
  rtcCenterWorld[1] = rtcCenter2[1];
  rtcCenterWorld[2] = rtcCenter2[2];
  rtcCenterWorld[3] = 1;
  transformVec4(viewMat, rtcCenterWorld, rtcCenterView);
  setMat4Translation(viewMat, rtcCenterView, rtcViewMat);
  return rtcViewMat;
}
var createRTCModelMat = (() => {
  const zeroVec4 = createVec4([0, 0, 0, 1]);
  const tempVec4a8 = createVec4();
  return (matrix, rtcCenter2) => {
    const tempVec4 = transformVec4(matrix, zeroVec4, tempVec4a8);
    rtcCenter2[0] = Math.round(tempVec4[0] / RTC_CELL_SIZE) * RTC_CELL_SIZE;
    rtcCenter2[1] = Math.round(tempVec4[1] / RTC_CELL_SIZE) * RTC_CELL_SIZE;
    rtcCenter2[2] = Math.round(tempVec4[2] / RTC_CELL_SIZE) * RTC_CELL_SIZE;
    const rtcModelMatrix = matrix.slice();
    translateMat4v(mulVec3Scalar(rtcCenter2, -1, tempVec3a2), rtcModelMatrix);
    return rtcModelMatrix;
  };
})();
function worldToRTCPos(worldPos, rtcCenter2, rtcPos) {
  const xHigh = Float32Array.from([worldPos[0]])[0];
  const xLow = worldPos[0] - xHigh;
  const yHigh = Float32Array.from([worldPos[1]])[0];
  const yLow = worldPos[1] - yHigh;
  const zHigh = Float32Array.from([worldPos[2]])[0];
  const zLow = worldPos[2] - zHigh;
  rtcCenter2[0] = xHigh;
  rtcCenter2[1] = yHigh;
  rtcCenter2[2] = zHigh;
  rtcPos[0] = xLow;
  rtcPos[1] = yLow;
  rtcPos[2] = zLow;
}
function worldToRTCCenter(worldCenter, rtcCenter2, cellSize = RTC_CELL_SIZE) {
  rtcCenter2[0] = Math.round(worldCenter[0] / cellSize) * cellSize;
  rtcCenter2[1] = Math.round(worldCenter[1] / cellSize) * cellSize;
  rtcCenter2[2] = Math.round(worldCenter[2] / cellSize) * cellSize;
  return rtcCenter2;
}
function worldToRTCPositions(worldPositions, rtcPositions, rtcCenter2, cellSize = RTC_CELL_SIZE) {
  const center2 = getPositions3Center(worldPositions, tempVec3a2);
  const rtcCenterX = Math.round(center2[0] / cellSize) * cellSize;
  const rtcCenterY = Math.round(center2[1] / cellSize) * cellSize;
  const rtcCenterZ = Math.round(center2[2] / cellSize) * cellSize;
  for (let i = 0, len = worldPositions.length; i < len; i += 3) {
    rtcPositions[i + 0] = worldPositions[i + 0] - rtcCenterX;
    rtcPositions[i + 1] = worldPositions[i + 1] - rtcCenterY;
    rtcPositions[i + 2] = worldPositions[i + 2] - rtcCenterZ;
  }
  rtcCenter2[0] = rtcCenterX;
  rtcCenter2[1] = rtcCenterY;
  rtcCenter2[2] = rtcCenterZ;
  return rtcCenter2[0] !== 0 || rtcCenter2[1] !== 0 || rtcCenter2[2] !== 0;
}
function rtcToWorldPos(rtcCenter2, rtcPos, worldPos) {
  worldPos[0] = rtcCenter2[0] + rtcPos[0];
  worldPos[1] = rtcCenter2[1] + rtcPos[1];
  worldPos[2] = rtcCenter2[2] + rtcPos[2];
  return worldPos;
}
function getPlaneRTCPos(dist, dir, rtcCenter2, rtcPlanePos) {
  const rtcCenterToPlaneDist = dotVec3(dir, rtcCenter2) + dist;
  const dirNormalized = normalizeVec3(dir, tempVec3a2);
  mulVec3Scalar(dirNormalized, -rtcCenterToPlaneDist, rtcPlanePos);
  return rtcPlanePos;
}

// ../sdk/src/curves/index.ts
var curves_exports = {};
__export(curves_exports, {
  b2: () => b2,
  b2p0: () => b2p0,
  b2p1: () => b2p1,
  b2p2: () => b2p2,
  b3: () => b3,
  b3p0: () => b3p0,
  b3p1: () => b3p1,
  b3p2: () => b3p2,
  b3p3: () => b3p3,
  catmullRomInterpolate: () => catmullRomInterpolate,
  tangentQuadraticBezier: () => tangentQuadraticBezier,
  tangentQuadraticBezier3: () => tangentQuadraticBezier3,
  tangentSpline: () => tangentSpline
});
function tangentQuadraticBezier(t, p0, p1, p2) {
  return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
}
function tangentQuadraticBezier3(t, p0, p1, p2, p3) {
  return -3 * p0 * (1 - t) ** 2 + 3 * p1 * (1 - t) ** 2 - 6 * t * p1 * (1 - t) + 6 * t * p2 * (1 - t) - 3 * t ** 2 * p2 + 3 * t ** 2 * p3;
}
function tangentSpline(t) {
  const h00 = 6 * t ** 2 - 6 * t;
  const h10 = 3 * t ** 2 - 4 * t + 1;
  const h01 = -6 * t ** 2 + 6 * t;
  const h11 = 3 * t ** 2 - 2 * t;
  return h00 + h10 + h01 + h11;
}
function catmullRomInterpolate(p0, p1, p2, p3, t) {
  const v0 = (p2 - p0) * 0.5;
  const v1 = (p3 - p1) * 0.5;
  const t2 = t ** 2;
  const t3 = t * t2;
  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
}
function b2p0(t, p) {
  const k = 1 - t;
  return k * k * p;
}
function b2p1(t, p) {
  return 2 * (1 - t) * t * p;
}
function b2p2(t, p) {
  return t * t * p;
}
function b2(t, p0, p1, p2) {
  return b2p0(t, p0) + b2p1(t, p1) + b2p2(t, p2);
}
function b3p0(t, p) {
  const k = 1 - t;
  return k * k * k * p;
}
function b3p1(t, p) {
  const k = 1 - t;
  return 3 * k * k * t * p;
}
function b3p2(t, p) {
  const k = 1 - t;
  return 3 * k * t * t * p;
}
function b3p3(t, p) {
  return t * t * t * p;
}
function b3(t, p0, p1, p2, p3) {
  return b3p0(t, p0) + b3p1(t, p1) + b3p2(t, p2) + b3p3(t, p3);
}

// ../sdk/src/procgen/index.ts
var procgen_exports = {};
__export(procgen_exports, {
  buildBoxGeometry: () => buildBoxGeometry,
  buildBoxLinesGeometry: () => buildBoxLinesGeometry,
  buildCylinderGeometry: () => buildCylinderGeometry,
  buildGridGeometry: () => buildGridGeometry,
  buildPlaneGeometry: () => buildPlaneGeometry,
  buildSphereGeometry: () => buildSphereGeometry,
  buildTorusGeometry: () => buildTorusGeometry,
  buildVectorTextGeometry: () => buildVectorTextGeometry
});

// ../sdk/src/procgen/buildBoxGeometry.ts
function buildBoxGeometry(cfg = {
  center: [0, 0, 0],
  xSize: 1,
  ySize: 1,
  zSize: 1
}) {
  let xSize = cfg.xSize || 1;
  if (xSize < 0) {
    return new SDKError("Negative xSize not allowed");
  }
  let ySize = cfg.ySize || 1;
  if (ySize < 0) {
    return new SDKError("Negative ySize not allowed");
  }
  let zSize = cfg.zSize || 1;
  if (zSize < 0) {
    return new SDKError("Negative zSize not allowed");
  }
  const center2 = cfg.center;
  const centerX = center2 ? center2[0] : 0;
  const centerY = center2 ? center2[1] : 0;
  const centerZ = center2 ? center2[2] : 0;
  const xmin = -xSize + centerX;
  const ymin = -ySize + centerY;
  const zmin = -zSize + centerZ;
  const xmax = xSize + centerX;
  const ymax = ySize + centerY;
  const zmax = zSize + centerZ;
  return apply(cfg, {
    primitive: TrianglesPrimitive,
    // The vertices - eight for our cube, each
    // one spanning three array elements for X, Y, and Z
    positions: [
      // v0-v1-v2-v3 front
      xmax,
      ymax,
      zmax,
      xmin,
      ymax,
      zmax,
      xmin,
      ymin,
      zmax,
      xmax,
      ymin,
      zmax,
      // v0-v3-v4-v1 right
      xmax,
      ymax,
      zmax,
      xmax,
      ymin,
      zmax,
      xmax,
      ymin,
      zmin,
      xmax,
      ymax,
      zmin,
      // v0-v1-v6-v1 top
      xmax,
      ymax,
      zmax,
      xmax,
      ymax,
      zmin,
      xmin,
      ymax,
      zmin,
      xmin,
      ymax,
      zmax,
      // v1-v6-v7-v2 left
      xmin,
      ymax,
      zmax,
      xmin,
      ymax,
      zmin,
      xmin,
      ymin,
      zmin,
      xmin,
      ymin,
      zmax,
      // v7-v4-v3-v2 bottom
      xmin,
      ymin,
      zmin,
      xmax,
      ymin,
      zmin,
      xmax,
      ymin,
      zmax,
      xmin,
      ymin,
      zmax,
      // v4-v7-v6-v1 back
      xmax,
      ymin,
      zmin,
      xmin,
      ymin,
      zmin,
      xmin,
      ymax,
      zmin,
      xmax,
      ymax,
      zmin
    ],
    // UV coordinates for each vertex
    uv: [
      // v0-v1-v2-v3 front
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      // v0-v3-v4-v1 right
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      0,
      // v0-v1-v6-v1 top
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      // v1-v6-v7-v2 left
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      // v7-v4-v3-v2 bottom
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      // v4-v7-v6-v1 back
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      0
    ],
    // Indices that organize vertices into geometric primitives (triangles)
    // The triangles are specified in counter-clockwise winding order
    indices: [
      0,
      1,
      2,
      0,
      2,
      3,
      // front
      4,
      5,
      6,
      4,
      6,
      7,
      // right
      8,
      9,
      10,
      8,
      10,
      11,
      // top
      12,
      13,
      14,
      12,
      14,
      15,
      // left
      16,
      17,
      18,
      16,
      18,
      19,
      // bottom
      20,
      21,
      22,
      20,
      22,
      23
      // back
    ]
  });
}

// ../sdk/src/procgen/buildGridGeometry.ts
function buildGridGeometry(cfg = {
  size: 1,
  divisions: 1
}) {
  let size = cfg.size || 1;
  if (size < 0) {
    console.error("negative size not allowed - will invert");
    size *= -1;
  }
  let divisions = cfg.divisions || 1;
  if (divisions < 0) {
    console.error("negative divisions not allowed - will invert");
    divisions *= -1;
  }
  if (divisions < 1) {
    divisions = 1;
  }
  size = size || 10;
  divisions = divisions || 10;
  const step = size / divisions;
  const halfSize = size / 2;
  const positions = [];
  const indices = [];
  let l = 0;
  for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
    positions.push(-halfSize);
    positions.push(0);
    positions.push(k);
    positions.push(halfSize);
    positions.push(0);
    positions.push(k);
    positions.push(k);
    positions.push(0);
    positions.push(-halfSize);
    positions.push(k);
    positions.push(0);
    positions.push(halfSize);
    indices.push(l++);
    indices.push(l++);
    indices.push(l++);
    indices.push(l++);
  }
  return apply(cfg, {
    primitive: "lines",
    positions,
    indices
  });
}

// ../sdk/src/procgen/buildBoxLinesGeometry.ts
function buildBoxLinesGeometry(cfg = {
  center: [0, 0, 0],
  xSize: 1,
  ySize: 1,
  zSize: 1
}) {
  let xSize = cfg.xSize || 1;
  if (xSize < 0) {
    console.error("negative xSize not allowed - will invert");
    xSize *= -1;
  }
  let ySize = cfg.ySize || 1;
  if (ySize < 0) {
    console.error("negative ySize not allowed - will invert");
    ySize *= -1;
  }
  let zSize = cfg.zSize || 1;
  if (zSize < 0) {
    console.error("negative zSize not allowed - will invert");
    zSize *= -1;
  }
  const center2 = cfg.center;
  const centerX = center2 ? center2[0] : 0;
  const centerY = center2 ? center2[1] : 0;
  const centerZ = center2 ? center2[2] : 0;
  const xmin = -xSize + centerX;
  const ymin = -ySize + centerY;
  const zmin = -zSize + centerZ;
  const xmax = xSize + centerX;
  const ymax = ySize + centerY;
  const zmax = zSize + centerZ;
  return apply(cfg, {
    primitive: LinesPrimitive,
    // The positions represent the vertices of the box.
    // These are the 8 corner points of the box in 3D space.
    positions: [
      xmin,
      ymin,
      zmin,
      xmin,
      ymin,
      zmax,
      xmin,
      ymax,
      zmin,
      xmin,
      ymax,
      zmax,
      xmax,
      ymin,
      zmin,
      xmax,
      ymin,
      zmax,
      xmax,
      ymax,
      zmin,
      xmax,
      ymax,
      zmax
    ],
    // Indices define the lines that connect the vertices to form the wireframe.
    indices: [
      0,
      1,
      // line from v0 to v1
      1,
      3,
      // line from v1 to v3
      3,
      2,
      // line from v3 to v2
      2,
      0,
      // line from v2 to v0
      4,
      5,
      // line from v4 to v5
      5,
      7,
      // line from v5 to v7
      7,
      6,
      // line from v7 to v6
      6,
      4,
      // line from v6 to v4
      0,
      4,
      // line from v0 to v4
      1,
      5,
      // line from v1 to v5
      2,
      6,
      // line from v2 to v6
      3,
      7
      // line from v3 to v7
    ]
  });
}

// ../sdk/src/procgen/buildCylinderGeometry.ts
function buildCylinderGeometry(cfg = {
  radiusTop: 1,
  radiusBottom: 1,
  height: 1,
  radialSegments: 60,
  heightSegments: 1,
  openEnded: false,
  center: [0, 0, 0]
}) {
  let radiusTop = cfg.radiusTop || 1;
  if (radiusTop < 0) {
    console.error("negative radiusTop not allowed - will invert");
    radiusTop *= -1;
  }
  let radiusBottom = cfg.radiusBottom || 1;
  if (radiusBottom < 0) {
    console.error("negative radiusBottom not allowed - will invert");
    radiusBottom *= -1;
  }
  let height = cfg.height || 1;
  if (height < 0) {
    console.error("negative height not allowed - will invert");
    height *= -1;
  }
  let radialSegments = cfg.radialSegments || 32;
  if (radialSegments < 0) {
    console.error("negative radialSegments not allowed - will invert");
    radialSegments *= -1;
  }
  if (radialSegments < 3) {
    radialSegments = 3;
  }
  let heightSegments = cfg.heightSegments || 1;
  if (heightSegments < 0) {
    console.error("negative heightSegments not allowed - will invert");
    heightSegments *= -1;
  }
  if (heightSegments < 1) {
    heightSegments = 1;
  }
  const openEnded = cfg.openEnded;
  let center2 = cfg.center;
  const centerX = center2 ? center2[0] : 0;
  const centerY = center2 ? center2[1] : 0;
  const centerZ = center2 ? center2[2] : 0;
  const heightHalf = height / 2;
  const heightLength = height / heightSegments;
  const radialAngle = 2 * Math.PI / radialSegments;
  const radialLength = 1 / radialSegments;
  const radiusChange = (radiusTop - radiusBottom) / heightSegments;
  const positions = [];
  const normals = [];
  const uvs = [];
  const indices = [];
  let h;
  let i;
  let x;
  let z;
  let currentRadius;
  let currentHeight;
  let first;
  let second;
  let startIndex;
  let tu;
  let tv;
  const normalY = (90 - Math.atan(height / (radiusBottom - radiusTop)) * 180 / Math.PI) / 90;
  for (h = 0; h <= heightSegments; h++) {
    currentRadius = radiusTop - h * radiusChange;
    currentHeight = heightHalf - h * heightLength;
    for (i = 0; i <= radialSegments; i++) {
      x = Math.sin(i * radialAngle);
      z = Math.cos(i * radialAngle);
      normals.push(currentRadius * x);
      normals.push(normalY);
      normals.push(currentRadius * z);
      uvs.push(i * radialLength);
      uvs.push(h * 1 / heightSegments);
      positions.push(currentRadius * x + centerX);
      positions.push(currentHeight + centerY);
      positions.push(currentRadius * z + centerZ);
    }
  }
  for (h = 0; h < heightSegments; h++) {
    for (i = 0; i <= radialSegments; i++) {
      first = h * (radialSegments + 1) + i;
      second = first + radialSegments;
      indices.push(first);
      indices.push(second);
      indices.push(second + 1);
      indices.push(first);
      indices.push(second + 1);
      indices.push(first + 1);
    }
  }
  if (!openEnded && radiusTop > 0) {
    startIndex = positions.length / 3;
    normals.push(0);
    normals.push(1);
    normals.push(0);
    uvs.push(0.5);
    uvs.push(0.5);
    positions.push(0 + centerX);
    positions.push(heightHalf + centerY);
    positions.push(0 + centerZ);
    for (i = 0; i <= radialSegments; i++) {
      x = Math.sin(i * radialAngle);
      z = Math.cos(i * radialAngle);
      tu = 0.5 * Math.sin(i * radialAngle) + 0.5;
      tv = 0.5 * Math.cos(i * radialAngle) + 0.5;
      normals.push(radiusTop * x);
      normals.push(1);
      normals.push(radiusTop * z);
      uvs.push(tu);
      uvs.push(tv);
      positions.push(radiusTop * x + centerX);
      positions.push(heightHalf + centerY);
      positions.push(radiusTop * z + centerZ);
    }
    for (i = 0; i < radialSegments; i++) {
      first = startIndex + 1 + i;
      indices.push(first);
      indices.push(first + 1);
      indices.push(startIndex);
    }
  }
  if (!openEnded && radiusBottom > 0) {
    startIndex = positions.length / 3;
    normals.push(0);
    normals.push(-1);
    normals.push(0);
    uvs.push(0.5);
    uvs.push(0.5);
    positions.push(0 + centerX);
    positions.push(0 - heightHalf + centerY);
    positions.push(0 + centerZ);
    for (i = 0; i <= radialSegments; i++) {
      x = Math.sin(i * radialAngle);
      z = Math.cos(i * radialAngle);
      tu = 0.5 * Math.sin(i * radialAngle) + 0.5;
      tv = 0.5 * Math.cos(i * radialAngle) + 0.5;
      normals.push(radiusBottom * x);
      normals.push(-1);
      normals.push(radiusBottom * z);
      uvs.push(tu);
      uvs.push(tv);
      positions.push(radiusBottom * x + centerX);
      positions.push(0 - heightHalf + centerY);
      positions.push(radiusBottom * z + centerZ);
    }
    for (i = 0; i < radialSegments; i++) {
      first = startIndex + 1 + i;
      indices.push(startIndex);
      indices.push(first + 1);
      indices.push(first);
    }
  }
  return apply(cfg, {
    primitive: TrianglesPrimitive,
    positions,
    normals,
    uv: uvs,
    indices
  });
}

// ../sdk/src/procgen/buildSphereGeometry.ts
function buildSphereGeometry(cfg = {
  heightSegments: 18,
  widthSegments: 18,
  radius: 1,
  center: [0, 0, 0]
}) {
  const centerX = cfg.center ? cfg.center[0] : 0;
  const centerY = cfg.center ? cfg.center[1] : 0;
  const centerZ = cfg.center ? cfg.center[2] : 0;
  let radius = cfg.radius || 1;
  if (radius < 0) {
    console.error("negative radius not allowed - will invert");
    radius *= -1;
  }
  let heightSegments = cfg.heightSegments || 18;
  if (heightSegments < 0) {
    console.error("negative heightSegments not allowed - will invert");
    heightSegments *= -1;
  }
  heightSegments = Math.floor(heightSegments);
  if (heightSegments < 18) {
    heightSegments = 18;
  }
  let widthSegments = cfg.widthSegments || 18;
  if (widthSegments < 0) {
    console.error("negative widthSegments not allowed - will invert");
    widthSegments *= -1;
  }
  widthSegments = Math.floor(widthSegments);
  if (widthSegments < 18) {
    widthSegments = 18;
  }
  const positions = [];
  const normals = [];
  const uvs = [];
  const indices = [];
  let i;
  let j;
  let theta;
  let sinTheta;
  let cosTheta;
  let phi;
  let sinPhi;
  let cosPhi;
  let x;
  let y;
  let z;
  let u;
  let v;
  let first;
  let second;
  for (i = 0; i <= heightSegments; i++) {
    theta = i * Math.PI / heightSegments;
    sinTheta = Math.sin(theta);
    cosTheta = Math.cos(theta);
    for (j = 0; j <= widthSegments; j++) {
      phi = j * 2 * Math.PI / widthSegments;
      sinPhi = Math.sin(phi);
      cosPhi = Math.cos(phi);
      x = cosPhi * sinTheta;
      y = cosTheta;
      z = sinPhi * sinTheta;
      u = 1 - j / widthSegments;
      v = i / heightSegments;
      normals.push(x);
      normals.push(y);
      normals.push(z);
      uvs.push(u);
      uvs.push(v);
      positions.push(centerX + radius * x);
      positions.push(centerY + radius * y);
      positions.push(centerZ + radius * z);
    }
  }
  for (i = 0; i < heightSegments; i++) {
    for (j = 0; j < widthSegments; j++) {
      first = i * (widthSegments + 1) + j;
      second = first + widthSegments + 1;
      indices.push(first + 1);
      indices.push(second + 1);
      indices.push(second);
      indices.push(first + 1);
      indices.push(second);
      indices.push(first);
    }
  }
  return apply(cfg, {
    primitive: TrianglesPrimitive,
    // The geometry is created as triangles
    positions,
    normals,
    uv: uvs,
    indices
  });
}

// ../sdk/src/procgen/buildTorusGeometry.ts
function buildTorusGeometry(cfg = {
  radius: 0,
  tube: 0,
  radialSegments: 0,
  tubeSegments: 0,
  arc: 0,
  center: [0, 0, 0]
}) {
  let radius = cfg.radius || 1;
  if (radius < 0) {
    console.error("negative radius not allowed - will invert");
    radius *= -1;
  }
  radius *= 0.5;
  let tube = cfg.tube || 0.3;
  if (tube < 0) {
    console.error("negative tube not allowed - will invert");
    tube *= -1;
  }
  let radialSegments = cfg.radialSegments || 32;
  if (radialSegments < 0) {
    console.error("negative radialSegments not allowed - will invert");
    radialSegments *= -1;
  }
  if (radialSegments < 4) {
    radialSegments = 4;
  }
  let tubeSegments = cfg.tubeSegments || 24;
  if (tubeSegments < 0) {
    console.error("negative tubeSegments not allowed - will invert");
    tubeSegments *= -1;
  }
  if (tubeSegments < 4) {
    tubeSegments = 4;
  }
  let arc = cfg.arc || Math.PI * 2;
  if (arc < 0) {
    console.warn("negative arc not allowed - will invert");
    arc *= -1;
  }
  if (arc > 360) {
    arc = 360;
  }
  const center2 = cfg.center;
  let centerX = center2 ? center2[0] : 0;
  let centerY = center2 ? center2[1] : 0;
  const centerZ = center2 ? center2[2] : 0;
  const positions = [];
  const normals = [];
  const uvs = [];
  const indices = [];
  let u;
  let v;
  let x;
  let y;
  let z;
  let vec;
  let i;
  let j;
  for (j = 0; j <= tubeSegments; j++) {
    for (i = 0; i <= radialSegments; i++) {
      u = i / radialSegments * arc;
      v = 0.785398 + j / tubeSegments * Math.PI * 2;
      centerX = radius * Math.cos(u);
      centerY = radius * Math.sin(u);
      x = (radius + tube * Math.cos(v)) * Math.cos(u);
      y = (radius + tube * Math.cos(v)) * Math.sin(u);
      z = tube * Math.sin(v);
      positions.push(x + centerX);
      positions.push(y + centerY);
      positions.push(z + centerZ);
      uvs.push(1 - i / radialSegments);
      uvs.push(j / tubeSegments);
      vec = normalizeVec3(subVec3([x, y, z], [centerX, centerY, centerZ], []), []);
      normals.push(vec[0]);
      normals.push(vec[1]);
      normals.push(vec[2]);
    }
  }
  let a2;
  let b4;
  let c2;
  let d;
  for (j = 1; j <= tubeSegments; j++) {
    for (i = 1; i <= radialSegments; i++) {
      a2 = (radialSegments + 1) * j + i - 1;
      b4 = (radialSegments + 1) * (j - 1) + i - 1;
      c2 = (radialSegments + 1) * (j - 1) + i;
      d = (radialSegments + 1) * j + i;
      indices.push(a2);
      indices.push(b4);
      indices.push(c2);
      indices.push(c2);
      indices.push(d);
      indices.push(a2);
    }
  }
  return apply(cfg, {
    primitive: TrianglesPrimitive,
    // The geometry is constructed as triangles
    positions,
    normals,
    uv: uvs,
    indices
  });
}

// ../sdk/src/procgen/buildVectorTextGeometry.ts
var letters = {
  // @ts-ignore
  " ": { width: 16, points: [] },
  "!": {
    width: 10,
    points: [
      [5, 21],
      [5, 7],
      [-1, -1],
      [5, 2],
      [4, 1],
      [5, 0],
      [6, 1],
      [5, 2]
    ]
  },
  '"': {
    width: 16,
    points: [
      [4, 21],
      [4, 14],
      [-1, -1],
      [12, 21],
      [12, 14]
    ]
  },
  "#": {
    width: 21,
    points: [
      [11, 25],
      [4, -7],
      [-1, -1],
      [17, 25],
      [10, -7],
      [-1, -1],
      [4, 12],
      [18, 12],
      [-1, -1],
      [3, 6],
      [17, 6]
    ]
  },
  "$": {
    width: 20,
    points: [
      [8, 25],
      [8, -4],
      [-1, -1],
      [12, 25],
      [12, -4],
      [-1, -1],
      [17, 18],
      [15, 20],
      [12, 21],
      [8, 21],
      [5, 20],
      [3, 18],
      [3, 16],
      [4, 14],
      [5, 13],
      [7, 12],
      [13, 10],
      [15, 9],
      [16, 8],
      [17, 6],
      [17, 3],
      [15, 1],
      [12, 0],
      [8, 0],
      [5, 1],
      [3, 3]
    ]
  },
  "%": {
    width: 24,
    points: [
      [21, 21],
      [3, 0],
      [-1, -1],
      [8, 21],
      [10, 19],
      [10, 17],
      [9, 15],
      [7, 14],
      [5, 14],
      [3, 16],
      [3, 18],
      [4, 20],
      [6, 21],
      [8, 21],
      [10, 20],
      [13, 19],
      [16, 19],
      [19, 20],
      [21, 21],
      [-1, -1],
      [17, 7],
      [15, 6],
      [14, 4],
      [14, 2],
      [16, 0],
      [18, 0],
      [20, 1],
      [21, 3],
      [21, 5],
      [19, 7],
      [17, 7]
    ]
  },
  "&": {
    width: 26,
    points: [
      [23, 12],
      [23, 13],
      [22, 14],
      [21, 14],
      [20, 13],
      [19, 11],
      [17, 6],
      [15, 3],
      [13, 1],
      [11, 0],
      [7, 0],
      [5, 1],
      [4, 2],
      [3, 4],
      [3, 6],
      [4, 8],
      [5, 9],
      [12, 13],
      [13, 14],
      [14, 16],
      [14, 18],
      [13, 20],
      [11, 21],
      [9, 20],
      [8, 18],
      [8, 16],
      [9, 13],
      [11, 10],
      [16, 3],
      [18, 1],
      [20, 0],
      [22, 0],
      [23, 1],
      [23, 2]
    ]
  },
  "'": {
    width: 10,
    points: [
      [5, 19],
      [4, 20],
      [5, 21],
      [6, 20],
      [6, 18],
      [5, 16],
      [4, 15]
    ]
  },
  "(": {
    width: 14,
    points: [
      [11, 25],
      [9, 23],
      [7, 20],
      [5, 16],
      [4, 11],
      [4, 7],
      [5, 2],
      [7, -2],
      [9, -5],
      [11, -7]
    ]
  },
  ")": {
    width: 14,
    points: [
      [3, 25],
      [5, 23],
      [7, 20],
      [9, 16],
      [10, 11],
      [10, 7],
      [9, 2],
      [7, -2],
      [5, -5],
      [3, -7]
    ]
  },
  "*": {
    width: 16,
    points: [
      [8, 21],
      [8, 9],
      [-1, -1],
      [3, 18],
      [13, 12],
      [-1, -1],
      [13, 18],
      [3, 12]
    ]
  },
  "+": {
    width: 26,
    points: [
      [13, 18],
      [13, 0],
      [-1, -1],
      [4, 9],
      [22, 9]
    ]
  },
  ",": {
    width: 10,
    points: [
      [6, 1],
      [5, 0],
      [4, 1],
      [5, 2],
      [6, 1],
      [6, -1],
      [5, -3],
      [4, -4]
    ]
  },
  "-": {
    width: 26,
    points: [
      [4, 9],
      [22, 9]
    ]
  },
  ".": {
    width: 10,
    points: [
      [5, 2],
      [4, 1],
      [5, 0],
      [6, 1],
      [5, 2]
    ]
  },
  "/": {
    width: 22,
    points: [
      [20, 25],
      [2, -7]
    ]
  },
  "0": {
    width: 20,
    points: [
      [9, 21],
      [6, 20],
      [4, 17],
      [3, 12],
      [3, 9],
      [4, 4],
      [6, 1],
      [9, 0],
      [11, 0],
      [14, 1],
      [16, 4],
      [17, 9],
      [17, 12],
      [16, 17],
      [14, 20],
      [11, 21],
      [9, 21]
    ]
  },
  "1": {
    width: 20,
    points: [
      [6, 17],
      [8, 18],
      [11, 21],
      [11, 0]
    ]
  },
  "2": {
    width: 20,
    points: [
      [4, 16],
      [4, 17],
      [5, 19],
      [6, 20],
      [8, 21],
      [12, 21],
      [14, 20],
      [15, 19],
      [16, 17],
      [16, 15],
      [15, 13],
      [13, 10],
      [3, 0],
      [17, 0]
    ]
  },
  "3": {
    width: 20,
    points: [
      [5, 21],
      [16, 21],
      [10, 13],
      [13, 13],
      [15, 12],
      [16, 11],
      [17, 8],
      [17, 6],
      [16, 3],
      [14, 1],
      [11, 0],
      [8, 0],
      [5, 1],
      [4, 2],
      [3, 4]
    ]
  },
  "4": {
    width: 20,
    points: [
      [13, 21],
      [3, 7],
      [18, 7],
      [-1, -1],
      [13, 21],
      [13, 0]
    ]
  },
  "5": {
    width: 20,
    points: [
      [15, 21],
      [5, 21],
      [4, 12],
      [5, 13],
      [8, 14],
      [11, 14],
      [14, 13],
      [16, 11],
      [17, 8],
      [17, 6],
      [16, 3],
      [14, 1],
      [11, 0],
      [8, 0],
      [5, 1],
      [4, 2],
      [3, 4]
    ]
  },
  "6": {
    width: 20,
    points: [
      [16, 18],
      [15, 20],
      [12, 21],
      [10, 21],
      [7, 20],
      [5, 17],
      [4, 12],
      [4, 7],
      [5, 3],
      [7, 1],
      [10, 0],
      [11, 0],
      [14, 1],
      [16, 3],
      [17, 6],
      [17, 7],
      [16, 10],
      [14, 12],
      [11, 13],
      [10, 13],
      [7, 12],
      [5, 10],
      [4, 7]
    ]
  },
  "7": {
    width: 20,
    points: [
      [17, 21],
      [7, 0],
      [-1, -1],
      [3, 21],
      [17, 21]
    ]
  },
  "8": {
    width: 20,
    points: [
      [8, 21],
      [5, 20],
      [4, 18],
      [4, 16],
      [5, 14],
      [7, 13],
      [11, 12],
      [14, 11],
      [16, 9],
      [17, 7],
      [17, 4],
      [16, 2],
      [15, 1],
      [12, 0],
      [8, 0],
      [5, 1],
      [4, 2],
      [3, 4],
      [3, 7],
      [4, 9],
      [6, 11],
      [9, 12],
      [13, 13],
      [15, 14],
      [16, 16],
      [16, 18],
      [15, 20],
      [12, 21],
      [8, 21]
    ]
  },
  "9": {
    width: 20,
    points: [
      [16, 14],
      [15, 11],
      [13, 9],
      [10, 8],
      [9, 8],
      [6, 9],
      [4, 11],
      [3, 14],
      [3, 15],
      [4, 18],
      [6, 20],
      [9, 21],
      [10, 21],
      [13, 20],
      [15, 18],
      [16, 14],
      [16, 9],
      [15, 4],
      [13, 1],
      [10, 0],
      [8, 0],
      [5, 1],
      [4, 3]
    ]
  },
  ":": {
    width: 10,
    points: [
      [5, 14],
      [4, 13],
      [5, 12],
      [6, 13],
      [5, 14],
      [-1, -1],
      [5, 2],
      [4, 1],
      [5, 0],
      [6, 1],
      [5, 2]
    ]
  },
  ";": {
    width: 10,
    points: [
      [5, 14],
      [4, 13],
      [5, 12],
      [6, 13],
      [5, 14],
      [-1, -1],
      [6, 1],
      [5, 0],
      [4, 1],
      [5, 2],
      [6, 1],
      [6, -1],
      [5, -3],
      [4, -4]
    ]
  },
  "<": {
    width: 24,
    points: [
      [20, 18],
      [4, 9],
      [20, 0]
    ]
  },
  "=": {
    width: 26,
    points: [
      [4, 12],
      [22, 12],
      [-1, -1],
      [4, 6],
      [22, 6]
    ]
  },
  ">": {
    width: 24,
    points: [
      [4, 18],
      [20, 9],
      [4, 0]
    ]
  },
  "?": {
    width: 18,
    points: [
      [3, 16],
      [3, 17],
      [4, 19],
      [5, 20],
      [7, 21],
      [11, 21],
      [13, 20],
      [14, 19],
      [15, 17],
      [15, 15],
      [14, 13],
      [13, 12],
      [9, 10],
      [9, 7],
      [-1, -1],
      [9, 2],
      [8, 1],
      [9, 0],
      [10, 1],
      [9, 2]
    ]
  },
  "@": {
    width: 27,
    points: [
      [18, 13],
      [17, 15],
      [15, 16],
      [12, 16],
      [10, 15],
      [9, 14],
      [8, 11],
      [8, 8],
      [9, 6],
      [11, 5],
      [14, 5],
      [16, 6],
      [17, 8],
      [-1, -1],
      [12, 16],
      [10, 14],
      [9, 11],
      [9, 8],
      [10, 6],
      [11, 5],
      [-1, -1],
      [18, 16],
      [17, 8],
      [17, 6],
      [19, 5],
      [21, 5],
      [23, 7],
      [24, 10],
      [24, 12],
      [23, 15],
      [22, 17],
      [20, 19],
      [18, 20],
      [15, 21],
      [12, 21],
      [9, 20],
      [7, 19],
      [5, 17],
      [4, 15],
      [3, 12],
      [3, 9],
      [4, 6],
      [5, 4],
      [7, 2],
      [9, 1],
      [12, 0],
      [15, 0],
      [18, 1],
      [20, 2],
      [21, 3],
      [-1, -1],
      [19, 16],
      [18, 8],
      [18, 6],
      [19, 5]
    ]
  },
  "A": {
    width: 18,
    points: [
      [9, 21],
      [1, 0],
      [-1, -1],
      [9, 21],
      [17, 0],
      [-1, -1],
      [4, 7],
      [14, 7]
    ]
  },
  "B": {
    width: 21,
    points: [
      [4, 21],
      [4, 0],
      [-1, -1],
      [4, 21],
      [13, 21],
      [16, 20],
      [17, 19],
      [18, 17],
      [18, 15],
      [17, 13],
      [16, 12],
      [13, 11],
      [-1, -1],
      [4, 11],
      [13, 11],
      [16, 10],
      [17, 9],
      [18, 7],
      [18, 4],
      [17, 2],
      [16, 1],
      [13, 0],
      [4, 0]
    ]
  },
  "C": {
    width: 21,
    points: [
      [18, 16],
      [17, 18],
      [15, 20],
      [13, 21],
      [9, 21],
      [7, 20],
      [5, 18],
      [4, 16],
      [3, 13],
      [3, 8],
      [4, 5],
      [5, 3],
      [7, 1],
      [9, 0],
      [13, 0],
      [15, 1],
      [17, 3],
      [18, 5]
    ]
  },
  "D": {
    width: 21,
    points: [
      [4, 21],
      [4, 0],
      [-1, -1],
      [4, 21],
      [11, 21],
      [14, 20],
      [16, 18],
      [17, 16],
      [18, 13],
      [18, 8],
      [17, 5],
      [16, 3],
      [14, 1],
      [11, 0],
      [4, 0]
    ]
  },
  "E": {
    width: 19,
    points: [
      [4, 21],
      [4, 0],
      [-1, -1],
      [4, 21],
      [17, 21],
      [-1, -1],
      [4, 11],
      [12, 11],
      [-1, -1],
      [4, 0],
      [17, 0]
    ]
  },
  "F": {
    width: 18,
    points: [
      [4, 21],
      [4, 0],
      [-1, -1],
      [4, 21],
      [17, 21],
      [-1, -1],
      [4, 11],
      [12, 11]
    ]
  },
  "G": {
    width: 21,
    points: [
      [18, 16],
      [17, 18],
      [15, 20],
      [13, 21],
      [9, 21],
      [7, 20],
      [5, 18],
      [4, 16],
      [3, 13],
      [3, 8],
      [4, 5],
      [5, 3],
      [7, 1],
      [9, 0],
      [13, 0],
      [15, 1],
      [17, 3],
      [18, 5],
      [18, 8],
      [-1, -1],
      [13, 8],
      [18, 8]
    ]
  },
  "H": {
    width: 22,
    points: [
      [4, 21],
      [4, 0],
      [-1, -1],
      [18, 21],
      [18, 0],
      [-1, -1],
      [4, 11],
      [18, 11]
    ]
  },
  "I": {
    width: 8,
    points: [
      [4, 21],
      [4, 0]
    ]
  },
  "J": {
    width: 16,
    points: [
      [12, 21],
      [12, 5],
      [11, 2],
      [10, 1],
      [8, 0],
      [6, 0],
      [4, 1],
      [3, 2],
      [2, 5],
      [2, 7]
    ]
  },
  "K": {
    width: 21,
    points: [
      [4, 21],
      [4, 0],
      [-1, -1],
      [18, 21],
      [4, 7],
      [-1, -1],
      [9, 12],
      [18, 0]
    ]
  },
  "L": {
    width: 17,
    points: [
      [4, 21],
      [4, 0],
      [-1, -1],
      [4, 0],
      [16, 0]
    ]
  },
  "M": {
    width: 24,
    points: [
      [4, 21],
      [4, 0],
      [-1, -1],
      [4, 21],
      [12, 0],
      [-1, -1],
      [20, 21],
      [12, 0],
      [-1, -1],
      [20, 21],
      [20, 0]
    ]
  },
  "N": {
    width: 22,
    points: [
      [4, 21],
      [4, 0],
      [-1, -1],
      [4, 21],
      [18, 0],
      [-1, -1],
      [18, 21],
      [18, 0]
    ]
  },
  "O": {
    width: 22,
    points: [
      [9, 21],
      [7, 20],
      [5, 18],
      [4, 16],
      [3, 13],
      [3, 8],
      [4, 5],
      [5, 3],
      [7, 1],
      [9, 0],
      [13, 0],
      [15, 1],
      [17, 3],
      [18, 5],
      [19, 8],
      [19, 13],
      [18, 16],
      [17, 18],
      [15, 20],
      [13, 21],
      [9, 21]
    ]
  },
  "P": {
    width: 21,
    points: [
      [4, 21],
      [4, 0],
      [-1, -1],
      [4, 21],
      [13, 21],
      [16, 20],
      [17, 19],
      [18, 17],
      [18, 14],
      [17, 12],
      [16, 11],
      [13, 10],
      [4, 10]
    ]
  },
  "Q": {
    width: 22,
    points: [
      [9, 21],
      [7, 20],
      [5, 18],
      [4, 16],
      [3, 13],
      [3, 8],
      [4, 5],
      [5, 3],
      [7, 1],
      [9, 0],
      [13, 0],
      [15, 1],
      [17, 3],
      [18, 5],
      [19, 8],
      [19, 13],
      [18, 16],
      [17, 18],
      [15, 20],
      [13, 21],
      [9, 21],
      [-1, -1],
      [12, 4],
      [18, -2]
    ]
  },
  "R": {
    width: 21,
    points: [
      [4, 21],
      [4, 0],
      [-1, -1],
      [4, 21],
      [13, 21],
      [16, 20],
      [17, 19],
      [18, 17],
      [18, 15],
      [17, 13],
      [16, 12],
      [13, 11],
      [4, 11],
      [-1, -1],
      [11, 11],
      [18, 0]
    ]
  },
  "S": {
    width: 20,
    points: [
      [17, 18],
      [15, 20],
      [12, 21],
      [8, 21],
      [5, 20],
      [3, 18],
      [3, 16],
      [4, 14],
      [5, 13],
      [7, 12],
      [13, 10],
      [15, 9],
      [16, 8],
      [17, 6],
      [17, 3],
      [15, 1],
      [12, 0],
      [8, 0],
      [5, 1],
      [3, 3]
    ]
  },
  "T": {
    width: 16,
    points: [
      [8, 21],
      [8, 0],
      [-1, -1],
      [1, 21],
      [15, 21]
    ]
  },
  "U": {
    width: 22,
    points: [
      [4, 21],
      [4, 6],
      [5, 3],
      [7, 1],
      [10, 0],
      [12, 0],
      [15, 1],
      [17, 3],
      [18, 6],
      [18, 21]
    ]
  },
  "V": {
    width: 18,
    points: [
      [1, 21],
      [9, 0],
      [-1, -1],
      [17, 21],
      [9, 0]
    ]
  },
  "W": {
    width: 24,
    points: [
      [2, 21],
      [7, 0],
      [-1, -1],
      [12, 21],
      [7, 0],
      [-1, -1],
      [12, 21],
      [17, 0],
      [-1, -1],
      [22, 21],
      [17, 0]
    ]
  },
  "X": {
    width: 20,
    points: [
      [3, 21],
      [17, 0],
      [-1, -1],
      [17, 21],
      [3, 0]
    ]
  },
  "Y": {
    width: 18,
    points: [
      [1, 21],
      [9, 11],
      [9, 0],
      [-1, -1],
      [17, 21],
      [9, 11]
    ]
  },
  "Z": {
    width: 20,
    points: [
      [17, 21],
      [3, 0],
      [-1, -1],
      [3, 21],
      [17, 21],
      [-1, -1],
      [3, 0],
      [17, 0]
    ]
  },
  "[": {
    width: 14,
    points: [
      [4, 25],
      [4, -7],
      [-1, -1],
      [5, 25],
      [5, -7],
      [-1, -1],
      [4, 25],
      [11, 25],
      [-1, -1],
      [4, -7],
      [11, -7]
    ]
  },
  "\\": {
    width: 14,
    points: [
      [0, 21],
      [14, -3]
    ]
  },
  "]": {
    width: 14,
    points: [
      [9, 25],
      [9, -7],
      [-1, -1],
      [10, 25],
      [10, -7],
      [-1, -1],
      [3, 25],
      [10, 25],
      [-1, -1],
      [3, -7],
      [10, -7]
    ]
  },
  "^": {
    width: 16,
    points: [
      [6, 15],
      [8, 18],
      [10, 15],
      [-1, -1],
      [3, 12],
      [8, 17],
      [13, 12],
      [-1, -1],
      [8, 17],
      [8, 0]
    ]
  },
  "_": {
    width: 16,
    points: [
      [0, -2],
      [16, -2]
    ]
  },
  "`": {
    width: 10,
    points: [
      [6, 21],
      [5, 20],
      [4, 18],
      [4, 16],
      [5, 15],
      [6, 16],
      [5, 17]
    ]
  },
  "a": {
    width: 19,
    points: [
      [15, 14],
      [15, 0],
      [-1, -1],
      [15, 11],
      [13, 13],
      [11, 14],
      [8, 14],
      [6, 13],
      [4, 11],
      [3, 8],
      [3, 6],
      [4, 3],
      [6, 1],
      [8, 0],
      [11, 0],
      [13, 1],
      [15, 3]
    ]
  },
  "b": {
    width: 19,
    points: [
      [4, 21],
      [4, 0],
      [-1, -1],
      [4, 11],
      [6, 13],
      [8, 14],
      [11, 14],
      [13, 13],
      [15, 11],
      [16, 8],
      [16, 6],
      [15, 3],
      [13, 1],
      [11, 0],
      [8, 0],
      [6, 1],
      [4, 3]
    ]
  },
  "c": {
    width: 18,
    points: [
      [15, 11],
      [13, 13],
      [11, 14],
      [8, 14],
      [6, 13],
      [4, 11],
      [3, 8],
      [3, 6],
      [4, 3],
      [6, 1],
      [8, 0],
      [11, 0],
      [13, 1],
      [15, 3]
    ]
  },
  "d": {
    width: 19,
    points: [
      [15, 21],
      [15, 0],
      [-1, -1],
      [15, 11],
      [13, 13],
      [11, 14],
      [8, 14],
      [6, 13],
      [4, 11],
      [3, 8],
      [3, 6],
      [4, 3],
      [6, 1],
      [8, 0],
      [11, 0],
      [13, 1],
      [15, 3]
    ]
  },
  "e": {
    width: 18,
    points: [
      [3, 8],
      [15, 8],
      [15, 10],
      [14, 12],
      [13, 13],
      [11, 14],
      [8, 14],
      [6, 13],
      [4, 11],
      [3, 8],
      [3, 6],
      [4, 3],
      [6, 1],
      [8, 0],
      [11, 0],
      [13, 1],
      [15, 3]
    ]
  },
  "f": {
    width: 12,
    points: [
      [10, 21],
      [8, 21],
      [6, 20],
      [5, 17],
      [5, 0],
      [-1, -1],
      [2, 14],
      [9, 14]
    ]
  },
  "g": {
    width: 19,
    points: [
      [15, 14],
      [15, -2],
      [14, -5],
      [13, -6],
      [11, -7],
      [8, -7],
      [6, -6],
      [-1, -1],
      [15, 11],
      [13, 13],
      [11, 14],
      [8, 14],
      [6, 13],
      [4, 11],
      [3, 8],
      [3, 6],
      [4, 3],
      [6, 1],
      [8, 0],
      [11, 0],
      [13, 1],
      [15, 3]
    ]
  },
  "h": {
    width: 19,
    points: [
      [4, 21],
      [4, 0],
      [-1, -1],
      [4, 10],
      [7, 13],
      [9, 14],
      [12, 14],
      [14, 13],
      [15, 10],
      [15, 0]
    ]
  },
  "i": {
    width: 8,
    points: [
      [3, 21],
      [4, 20],
      [5, 21],
      [4, 22],
      [3, 21],
      [-1, -1],
      [4, 14],
      [4, 0]
    ]
  },
  "j": {
    width: 10,
    points: [
      [5, 21],
      [6, 20],
      [7, 21],
      [6, 22],
      [5, 21],
      [-1, -1],
      [6, 14],
      [6, -3],
      [5, -6],
      [3, -7],
      [1, -7]
    ]
  },
  "k": {
    width: 17,
    points: [
      [4, 21],
      [4, 0],
      [-1, -1],
      [14, 14],
      [4, 4],
      [-1, -1],
      [8, 8],
      [15, 0]
    ]
  },
  "l": {
    width: 8,
    points: [
      [4, 21],
      [4, 0]
    ]
  },
  "m": {
    width: 30,
    points: [
      [4, 14],
      [4, 0],
      [-1, -1],
      [4, 10],
      [7, 13],
      [9, 14],
      [12, 14],
      [14, 13],
      [15, 10],
      [15, 0],
      [-1, -1],
      [15, 10],
      [18, 13],
      [20, 14],
      [23, 14],
      [25, 13],
      [26, 10],
      [26, 0]
    ]
  },
  "n": {
    width: 19,
    points: [
      [4, 14],
      [4, 0],
      [-1, -1],
      [4, 10],
      [7, 13],
      [9, 14],
      [12, 14],
      [14, 13],
      [15, 10],
      [15, 0]
    ]
  },
  "o": {
    width: 19,
    points: [
      [8, 14],
      [6, 13],
      [4, 11],
      [3, 8],
      [3, 6],
      [4, 3],
      [6, 1],
      [8, 0],
      [11, 0],
      [13, 1],
      [15, 3],
      [16, 6],
      [16, 8],
      [15, 11],
      [13, 13],
      [11, 14],
      [8, 14]
    ]
  },
  "p": {
    width: 19,
    points: [
      [4, 14],
      [4, -7],
      [-1, -1],
      [4, 11],
      [6, 13],
      [8, 14],
      [11, 14],
      [13, 13],
      [15, 11],
      [16, 8],
      [16, 6],
      [15, 3],
      [13, 1],
      [11, 0],
      [8, 0],
      [6, 1],
      [4, 3]
    ]
  },
  "q": {
    width: 19,
    points: [
      [15, 14],
      [15, -7],
      [-1, -1],
      [15, 11],
      [13, 13],
      [11, 14],
      [8, 14],
      [6, 13],
      [4, 11],
      [3, 8],
      [3, 6],
      [4, 3],
      [6, 1],
      [8, 0],
      [11, 0],
      [13, 1],
      [15, 3]
    ]
  },
  "r": {
    width: 13,
    points: [
      [4, 14],
      [4, 0],
      [-1, -1],
      [4, 8],
      [5, 11],
      [7, 13],
      [9, 14],
      [12, 14]
    ]
  },
  "s": {
    width: 17,
    points: [
      [14, 11],
      [13, 13],
      [10, 14],
      [7, 14],
      [4, 13],
      [3, 11],
      [4, 9],
      [6, 8],
      [11, 7],
      [13, 6],
      [14, 4],
      [14, 3],
      [13, 1],
      [10, 0],
      [7, 0],
      [4, 1],
      [3, 3]
    ]
  },
  "t": {
    width: 12,
    points: [
      [5, 21],
      [5, 4],
      [6, 1],
      [8, 0],
      [10, 0],
      [-1, -1],
      [2, 14],
      [9, 14]
    ]
  },
  "u": {
    width: 19,
    points: [
      [4, 14],
      [4, 4],
      [5, 1],
      [7, 0],
      [10, 0],
      [12, 1],
      [15, 4],
      [-1, -1],
      [15, 14],
      [15, 0]
    ]
  },
  "v": {
    width: 16,
    points: [
      [2, 14],
      [8, 0],
      [-1, -1],
      [14, 14],
      [8, 0]
    ]
  },
  "w": {
    width: 22,
    points: [
      [3, 14],
      [7, 0],
      [-1, -1],
      [11, 14],
      [7, 0],
      [-1, -1],
      [11, 14],
      [15, 0],
      [-1, -1],
      [19, 14],
      [15, 0]
    ]
  },
  "x": {
    width: 17,
    points: [
      [3, 14],
      [14, 0],
      [-1, -1],
      [14, 14],
      [3, 0]
    ]
  },
  "y": {
    width: 16,
    points: [
      [2, 14],
      [8, 0],
      [-1, -1],
      [14, 14],
      [8, 0],
      [6, -4],
      [4, -6],
      [2, -7],
      [1, -7]
    ]
  },
  "z": {
    width: 17,
    points: [
      [14, 14],
      [3, 0],
      [-1, -1],
      [3, 14],
      [14, 14],
      [-1, -1],
      [3, 0],
      [14, 0]
    ]
  },
  "{": {
    width: 14,
    points: [
      [9, 25],
      [7, 24],
      [6, 23],
      [5, 21],
      [5, 19],
      [6, 17],
      [7, 16],
      [8, 14],
      [8, 12],
      [6, 10],
      [-1, -1],
      [7, 24],
      [6, 22],
      [6, 20],
      [7, 18],
      [8, 17],
      [9, 15],
      [9, 13],
      [8, 11],
      [4, 9],
      [8, 7],
      [9, 5],
      [9, 3],
      [8, 1],
      [7, 0],
      [6, -2],
      [6, -4],
      [7, -6],
      [-1, -1],
      [6, 8],
      [8, 6],
      [8, 4],
      [7, 2],
      [6, 1],
      [5, -1],
      [5, -3],
      [6, -5],
      [7, -6],
      [9, -7]
    ]
  },
  "|": {
    width: 8,
    points: [
      [4, 25],
      [4, -7]
    ]
  },
  "}": {
    width: 14,
    points: [
      [5, 25],
      [7, 24],
      [8, 23],
      [9, 21],
      [9, 19],
      [8, 17],
      [7, 16],
      [6, 14],
      [6, 12],
      [8, 10],
      [-1, -1],
      [7, 24],
      [8, 22],
      [8, 20],
      [7, 18],
      [6, 17],
      [5, 15],
      [5, 13],
      [6, 11],
      [10, 9],
      [6, 7],
      [5, 5],
      [5, 3],
      [6, 1],
      [7, 0],
      [8, -2],
      [8, -4],
      [7, -6],
      [-1, -1],
      [8, 8],
      [6, 6],
      [6, 4],
      [7, 2],
      [8, 1],
      [9, -1],
      [9, -3],
      [8, -5],
      [7, -6],
      [5, -7]
    ]
  },
  "~": {
    width: 24,
    points: [
      [3, 6],
      [3, 8],
      [4, 11],
      [6, 12],
      [8, 12],
      [10, 11],
      [14, 8],
      [16, 7],
      [18, 7],
      [20, 8],
      [21, 10],
      [-1, -1],
      [3, 8],
      [4, 10],
      [6, 11],
      [8, 11],
      [10, 10],
      [14, 7],
      [16, 6],
      [18, 6],
      [20, 7],
      [21, 10],
      [21, 12]
    ]
  }
};
function buildVectorTextGeometry(cfg = {
  origin: [0, 0, 0],
  size: 1,
  text: ""
}) {
  const origin = cfg.origin || [0, 0, 0];
  const xOrigin = origin[0];
  const yOrigin = origin[1];
  const zOrigin = origin[2];
  const size = cfg.size || 1;
  const positions = [];
  const indices = [];
  let text = cfg.text;
  if (isNumeric(text)) {
    text = "" + text;
  }
  const lines = (text || "").split("\n");
  let countVerts = 0;
  let y = 0;
  let x;
  let str;
  let len;
  let c2;
  const mag = 1 / 25;
  let penUp;
  let p1;
  let p2;
  let needLine;
  let pointsLen;
  let a2;
  for (let iLine = 0; iLine < lines.length; iLine++) {
    x = 0;
    str = lines[iLine];
    len = str.length;
    for (let i = 0; i < len; i++) {
      c2 = letters[str.charAt(i)];
      if (c2 === "\n") {
        continue;
      }
      if (!c2) {
        continue;
      }
      penUp = 1;
      p1 = -1;
      p2 = -1;
      needLine = false;
      pointsLen = c2.points.length;
      for (let j = 0; j < pointsLen; j++) {
        a2 = c2.points[j];
        if (a2[0] === -1 && a2[1] === -1) {
          penUp = 1;
          needLine = false;
          continue;
        }
        positions.push(x + a2[0] * size * mag + xOrigin);
        positions.push(y + a2[1] * size * mag + yOrigin);
        positions.push(0 + zOrigin);
        if (p1 === -1) {
          p1 = countVerts;
        } else if (p2 === -1) {
          p2 = countVerts;
        } else {
          p1 = p2;
          p2 = countVerts;
        }
        countVerts++;
        if (penUp) {
          penUp = false;
        } else {
          indices.push(p1);
          indices.push(p2);
        }
        needLine = true;
      }
      x += c2.width * mag * size;
    }
    y -= 35 * mag * size;
  }
  return apply(cfg, {
    primitive: LinesPrimitive,
    // The geometry is constructed as wireframe lines
    positions,
    indices
  });
}

// ../sdk/src/procgen/buildPlaneGeometry.ts
function buildPlaneGeometry(cfg = {
  xSize: 0,
  zSize: 0,
  xSegments: 1,
  zSegments: 1,
  center: [0, 0, 0]
}) {
  let xSize = cfg.xSize || 1;
  if (xSize < 0) {
    console.error("negative xSize not allowed - will invert");
    xSize *= -1;
  }
  let zSize = cfg.zSize || 1;
  if (zSize < 0) {
    console.error("negative zSize not allowed - will invert");
    zSize *= -1;
  }
  let xSegments = cfg.xSegments || 1;
  if (xSegments < 0) {
    console.error("negative xSegments not allowed - will invert");
    xSegments *= -1;
  }
  if (xSegments < 1) {
    xSegments = 1;
  }
  let zSegments = cfg.zSegments || 1;
  if (zSegments < 0) {
    console.error("negative zSegments not allowed - will invert");
    zSegments *= -1;
  }
  if (zSegments < 1) {
    zSegments = 1;
  }
  const center2 = cfg.center;
  const centerX = center2 ? center2[0] : 0;
  const centerY = center2 ? center2[1] : 0;
  const centerZ = center2 ? center2[2] : 0;
  const halfWidth = xSize / 2;
  const halfHeight = zSize / 2;
  const planeX = Math.floor(xSegments) || 1;
  const planeZ = Math.floor(zSegments) || 1;
  const planeX1 = planeX + 1;
  const planeZ1 = planeZ + 1;
  const segmentWidth = xSize / planeX;
  const segmentHeight = zSize / planeZ;
  const positions = new Float32Array(planeX1 * planeZ1 * 3);
  const normals = new Float32Array(planeX1 * planeZ1 * 3);
  const uvs = new Float32Array(planeX1 * planeZ1 * 2);
  let offset = 0;
  let offset2 = 0;
  let iz;
  let ix;
  let x;
  let a2;
  let b4;
  let c2;
  let d;
  for (iz = 0; iz < planeZ1; iz++) {
    const z = iz * segmentHeight - halfHeight;
    for (ix = 0; ix < planeX1; ix++) {
      x = ix * segmentWidth - halfWidth;
      positions[offset] = x + centerX;
      positions[offset + 1] = centerY;
      positions[offset + 2] = -z + centerZ;
      normals[offset + 2] = -1;
      uvs[offset2] = ix / planeX;
      uvs[offset2 + 1] = (planeZ - iz) / planeZ;
      offset += 3;
      offset2 += 2;
    }
  }
  offset = 0;
  const indices = new (positions.length / 3 > 65535 ? Uint32Array : Uint16Array)(planeX * planeZ * 6);
  for (iz = 0; iz < planeZ; iz++) {
    for (ix = 0; ix < planeX; ix++) {
      a2 = ix + planeX1 * iz;
      b4 = ix + planeX1 * (iz + 1);
      c2 = ix + 1 + planeX1 * (iz + 1);
      d = ix + 1 + planeX1 * iz;
      indices[offset] = d;
      indices[offset + 1] = b4;
      indices[offset + 2] = a2;
      indices[offset + 3] = d;
      indices[offset + 4] = c2;
      indices[offset + 5] = b4;
      offset += 6;
    }
  }
  return apply(cfg, {
    positions,
    normals,
    uv: uvs,
    indices
  });
}

// ../sdk/src/locale/index.ts
var locale_exports = {};
__export(locale_exports, {
  LocaleService: () => LocaleService
});

// ../sdk/src/locale/LocaleService.ts
var import_strongly_typed_events2 = __toESM(require_dist8());
var LocaleService = class {
  /**
   * Emits an event each time the locale translations have updated.
   *
   * @event
   */
  onUpdated;
  #messages;
  #locales;
  #locale = "en";
  /**
   * Constructs a LocaleService.
   *
   * @param cfg LocaleService configuration
   * @param cfg.messages Set of locale translations
   * @param cfg.locale Initial locale
   */
  constructor(cfg = {
    messages: {},
    locale: ""
  }) {
    this.onUpdated = new EventEmitter(new import_strongly_typed_events2.EventDispatcher());
    this.messages = cfg.messages;
    this.locale = cfg.locale;
  }
  /**
   * Replaces the current set of locale translations.
   *
   * * Fires an "updated" event when done.
   * * Automatically refreshes any plugins that depend on the translations.
   * * Does not change the current locale.
   *
   * ## Usage
   *
   * ````javascript
   * viewer.localeService.setMessages({
   *     messages: {
   *         "en": { // English
   *             "NavCube": {
   *                 "front": "Front",
   *                 "back": "Back",
   *                 "top": "Top",
   *                 "bottom": "Bottom",
   *                 "left": "Left",
   *                 "right": "Right"
   *             }
   *         },
   *         "mi": { // Mori
   *             "NavCube": {
   *                 "front": "Mua",
   *                 "back": "Tuar",
   *                 "top": "Runga",
   *                 "bottom": "Raro",
   *                 "left": "Mau",
   *                 "right": "Tika"
   *             }
   *         }
   *    }
   * });
   * ````
   *
   * @param messages The new translations.
   */
  set messages(messages2) {
    this.#messages = messages2 || {};
    this.#locales = Object.keys(this.#messages);
    this.onUpdated.dispatch(this, this.#locale);
  }
  /**
   * Gets the list of available locales.
   *
   * These are derived from the currently configured set of translations.
   *
   * @returns The list of available locales.
   */
  get locales() {
    return this.#locales;
  }
  /**
   * Gets the current locale.
   *
   * @returns {String} The current locale.
   */
  get locale() {
    return this.#locale;
  }
  /**
   * Sets the current locale.
   *
   * * Fires an "updated" event when done.
   * * The given locale does not need to be in the list of available locales returned by {@link LocaleService.locales}, since
   * this method assumes that you may want to load the locales at a later point.
   * * Automatically refreshes any plugins that depend on the translations.
   * * We can then get translations for the locale, if translations have been loaded for it, via {@link LocaleService.translate} and {@link LocaleService.translatePlurals}.
   *
   * @param locale The new current locale.
   */
  set locale(locale) {
    locale = locale || "de";
    if (this.#locale === locale) {
      return;
    }
    this.#locale = locale;
    this.onUpdated.dispatch(this, this.#locale);
  }
  /**
   * Loads a new set of locale translations, adding them to the existing translations.
   *
   * * Fires an "updated" event when done.
   * * Automatically refreshes any plugins that depend on the translations.
   * * Does not change the current locale.
   *
   * ## Usage
   *
   * ````javascript
   * viewer.localeService.loadMessages({
   *     "jp": { // Japanese
   *         "NavCube": {
   *             "front": "",
   *             "back": "",
   *             "top": "",
   *             "bottom": "",
   *             "left": "",
   *             "right": ""
   *         }
   *     }
   * });
   * ````
   *
   * @param messages The new translations.
   */
  loadMessages(messages2 = {}) {
    for (let locale in messages2) {
      this.#messages[locale] = messages2[locale];
    }
    this.messages = this.#messages;
  }
  /**
   * Clears all locale translations.
   *
   * * Fires an "updated" event when done.
   * * Does not change the current locale.
   * * Automatically refreshes any plugins that depend on the translations, which will cause those
   * plugins to fall back on their internal hard-coded text values, since this method removes all
   * our translations.
   */
  clearMessages() {
    this.messages = {};
  }
  /**
   * Translates the given string according to the current locale.
   *
   * Returns null if no translation can be found.
   *
   * @param msg String to translate.
   * @param args Extra parameters.
   * @returns  Translated string if found, else null.
   */
  translate(msg, args) {
    const localeMessages = this.#messages[this.#locale];
    if (!localeMessages) {
      return null;
    }
    const localeMessage = resolvePath(msg, localeMessages);
    if (localeMessage) {
      if (args) {
        return vsprintf(localeMessage, args);
      }
      return localeMessage;
    }
    return null;
  }
  /**
   * Translates the given phrase according to the current locale.
   *
   * Returns null if no translation can be found.
   *
   * @param msg Phrase to translate.
   * @param count The plural number.
   * @param [args] Extra parameters.
   * @returns String|null Translated string if found, else null.
   */
  translatePlurals(msg, count, args) {
    const localeMessages = this.#messages[this.#locale];
    if (!localeMessages) {
      return null;
    }
    let localeMessage = resolvePath(msg, localeMessages);
    count = parseInt("" + count, 10);
    if (count === 0) {
      localeMessage = localeMessage.zero;
    } else {
      localeMessage = count > 1 ? localeMessage.other : localeMessage.one;
    }
    if (!localeMessage) {
      return null;
    }
    localeMessage = vsprintf(localeMessage, [count]);
    if (args) {
      localeMessage = vsprintf(localeMessage, args);
    }
    return localeMessage;
  }
};
function resolvePath(key, json) {
  if (json[key]) {
    return json[key];
  }
  const parts = key.split(".");
  let obj = json;
  for (let i = 0, len = parts.length; obj && i < len; i++) {
    const part = parts[i];
    obj = obj[part];
  }
  return obj;
}
function vsprintf(msg, args = []) {
  return msg.replace(/\{\{|\}\}|\{(\d+)\}/g, function(m, n) {
    if (m === "{{") {
      return "{";
    }
    if (m === "}}") {
      return "}";
    }
    return args[n];
  });
}

// ../sdk/src/data/index.ts
var data_exports = {};
__export(data_exports, {
  Data: () => Data,
  DataModel: () => DataModel,
  DataModelParamsExporter: () => DataModelParamsExporter,
  DataModelParamsLoader: () => DataModelParamsLoader,
  DataObject: () => DataObject,
  Property: () => Property,
  PropertySet: () => PropertySet,
  Relationship: () => Relationship,
  searchObjects: () => searchObjects
});

// ../sdk/src/data/Property.ts
var Property = class {
  /**
   * The {@link PropertySet | PropertySet} to which this Property belongs.
   */
  propertySet;
  /**
   * The name of this property.
   */
  name;
  /**
   * The value of this property.
   */
  value;
  /**
   * The type of this property (e.g., string, number, etc.).
   */
  type;
  /**
   * The type of this property's value (e.g., string, integer, etc.).
   */
  valueType;
  /**
   * An informative description to explain the purpose or details of the property.
   */
  description;
  /**
   * @private
   * @ignore
   */
  constructor(propertySet, propertyCfg) {
    this.propertySet = propertySet;
    this.name = propertyCfg.name;
    this.type = propertyCfg.type;
    this.value = propertyCfg.value;
    this.valueType = propertyCfg.valueType;
    this.description = propertyCfg.description;
  }
};

// ../sdk/src/data/PropertySet.ts
var PropertySet = class {
  /**
   * The {@link DataModel | DataModels} that this PropertySet belongs to.
   */
  models;
  /**
   * The unique identifier for this PropertySet.
   *
   * PropertySet instances are registered by this ID in {@link Data.propertySets | Data.propertySets}
   * and {@link DataModel.propertySets | DataModel.propertySets}.
   */
  id;
  /**
   * The ID of the corresponding object in the originating system, if applicable.
   */
  originalSystemId;
  /**
   * The human-readable name of this PropertySet.
   */
  name;
  /**
   * The type of this PropertySet.
   */
  type;
  /**
   * The collection of {@link Property | Properties} within this PropertySet.
   */
  properties;
  /**
   * Constructs a new PropertySet.
   *
   * @param dataModel - The DataModel to which this PropertySet belongs.
   * @param propertySetCfg - Configuration parameters to initialize the PropertySet.
   */
  constructor(dataModel, propertySetCfg) {
    this.models = [dataModel];
    this.id = propertySetCfg.id;
    this.name = propertySetCfg.name;
    this.type = propertySetCfg.type;
    this.properties = [];
    if (propertySetCfg.properties) {
      for (let i = 0, len = propertySetCfg.properties.length; i < len; i++) {
        const property = new Property(this, propertySetCfg.properties[i]);
        this.properties.push(property);
      }
    }
  }
};

// ../sdk/src/data/DataObject.ts
var DataObject = class {
  /**
   * The {@link Data | Data} instance that contains this DataObject.
   */
  data;
  /**
   * The {@link DataModel | DataModels} that share this DataObject.
   */
  models;
  /**
   * A globally unique identifier for this DataObject.
   *
   * This ID is used to store the DataObject in {@link Data.objects | Data.objects},
   * {@link Data.rootObjects | Data.rootObjects}, {@link Data.objectsByType | Data.objectsByType},
   * and {@link DataModel.rootObjects | DataModel.rootObjects}.
   */
  id;
  /**
   * The ID of this DataObject in the originating system, if available.
   *
   * Defaults to the value of {@link DataObject.id | DataObject.id} if not provided.
   */
  originalSystemId;
  /**
   * A human-readable name for this DataObject.
   */
  name;
  /**
   * A human-readable description of this DataObject.
   */
  description;
  /**
   * The type of this DataObject.
   */
  type;
  /**
   * A list of {@link PropertySet | PropertySets} referenced by this DataObject.
   */
  propertySets;
  /**
   * A map of {@link Relationship | Relationships} in which this DataObject is the {@link Relationship.relatingObject | relatingObject}.
   *
   * Relationships are categorized by {@link Relationship.type | Relationship.type} and further indexed by
   * {@link Relationship.relatingObject | relatingObject}.
   */
  relating;
  /**
   * A map of {@link Relationship | Relationships} in which this DataObject is the {@link Relationship.relatedObject | relatedObject}.
   *
   * Relationships are categorized by {@link Relationship.type | Relationship.type} and further indexed by
   * {@link Relationship.relatedObject | relatedObject}.
   */
  related;
  /**
   * @private
   */
  constructor(data, model, id, originalSystemId, name12, description, type, propertySets) {
    this.data = data;
    this.models = [model];
    this.id = id;
    this.originalSystemId = originalSystemId;
    this.name = name12;
    this.description = description;
    this.type = type;
    this.propertySets = propertySets || [];
    this.related = {};
    this.relating = {};
  }
};

// ../sdk/src/data/Relationship.ts
var Relationship = class {
  /**
   * The type of this Relationship.
   *
   * This value uniquely identifies the relationship type within your DataModel.
   */
  type;
  /**
   * The {@link DataObject | DataObject} that is the source of this Relationship.
   *
   * This Relationship will be stored in the {@link DataObject.related | DataObject.related} attribute
   * of the relating DataObject.
   */
  relatingObject;
  /**
   * The {@link DataObject | DataObject} that is the target of this Relationship.
   *
   * This Relationship will be stored in the {@link DataObject.relating | DataObject.relating} attribute
   * of the related DataObject.
   */
  relatedObject;
  /**
   * Constructs a new Relationship between two {@link DataObject | DataObjects}.
   *
   * @private
   * @param type - The type of relationship.
   * @param relatingObject - The source DataObject in the relationship.
   * @param relatedObject - The target DataObject in the relationship.
   */
  constructor(type, relatingObject, relatedObject) {
    this.type = type;
    this.relatingObject = relatingObject;
    this.relatedObject = relatedObject;
  }
};

// ../sdk/src/data/DataModel.ts
var import_strongly_typed_events3 = __toESM(require_dist8());
var DataModel = class extends Component {
  /**
   * The Data that contains this DataModel.
   */
  data;
  /**
   * The model name, if available.
   */
  name;
  /**
   * The project ID, if available.
   */
  projectId;
  /**
   * The revision ID, if available.
   */
  revisionId;
  /**
   * The model author, if available.
   */
  author;
  /**
   * The date the model was created, if available.
   */
  createdAt;
  /**
   * The application that created the model, if available.
   */
  creatingApplication;
  /**
   * The model schema version, if available.
   */
  schema;
  /**
   * The{@link PropertySet | PropertySets} in this DataModel, mapped to{@link PropertySet.id | PropertySet.id}.
   *
   * PropertySets have globally-unique IDs and will also be stored in {@link Data.propertySets | Data.propertySets}.
   */
  propertySets;
  /**
   * The {@link DataObject | DataObjects} in this DataModel, mapped to {@link DataObject.id | DataObject.id}.
   *
   * DataObjects have globally-unique IDs and will also be stored in {@link Data.objects | Data.objects}.
   */
  objects;
  /**
   * The root {@link DataObject | DataObjects} in this DataModel, mapped
   * to {@link DataObject.id | DataObject.id}.
   *
   * * This is the set of DataObjects in this DataModel that are not the *related* participant in
   * any {@link Relationship | Relationships}, where they have no incoming Relationships and
   * their {@link DataObject.relating} property is empty.
   */
  rootObjects;
  /**
   * The {@link DataObject | DataObjects} in this DataModel, mapped to {@link DataObject.type | DataObject.type},
   * sub-mapped to {@link DataObject.id | DataObject.id}.
   */
  objectsByType;
  /**
   * The {@link Relationship | Relationships} in this DataModel.
   *
   * * The Relationships can be between DataObjects in different DataModels, but always within the same Data.
   */
  relationships;
  /**
   * The count of each type of {@link DataObject | DataObject} in this DataModel, mapped to {@link DataObject.type | DataObject.type}.
   */
  typeCounts;
  /**
   * Emits an event when the {@link DataModel | DataModel} has been built.
   *
   * * The DataModel is built using {@link DataModel.build | DataModel.build}.
   * * {@link DataModel.built | DataModel.built} indicates if the DataModel is currently built.
   * * Don't create anything more in this DataModel once it's built.
   *
   * @event
   */
  onBuilt;
  /**
   * Indicates if this DataModel has been built.
   *
   * * Set true by {@link DataModel.build | DataModel.build}.
   * * Subscribe to updates using {@link DataModel.onBuilt | DataModel.onBuilt} and {@link Data.onModelCreated | Data.onModelCreated}.
   */
  built;
  #destroyed;
  /**
   * @private
   */
  constructor(data, id, dataModelParams, options) {
    super(data);
    this.onBuilt = new EventEmitter(new import_strongly_typed_events3.EventDispatcher());
    this.data = data;
    this.id = id;
    this.projectId = dataModelParams.projectId || "";
    this.revisionId = dataModelParams.revisionId || "";
    this.author = dataModelParams.author || "";
    this.createdAt = dataModelParams.createdAt || "";
    this.creatingApplication = dataModelParams.creatingApplication || "";
    this.schema = dataModelParams.schema || "";
    this.propertySets = {};
    this.objects = {};
    this.objectsByType = {};
    this.relationships = [];
    this.typeCounts = {};
    this.rootObjects = {};
    this.built = false;
    this.#destroyed = false;
    this.fromParams(dataModelParams);
  }
  /**
   * Creates a new {@link PropertySet | PropertySet} and registers it within the DataModel and Data.
   *
   * - The new PropertySet is stored in {@link DataModel.propertySets | DataModel.propertySets} and
   *   {@link Data.propertySets | Data.propertySets}.
   * - PropertySet IDs are globally unique. If a PropertySet with the given ID already exists in the same Data,
   *   it will be reused and shared across DataModels instead of creating a duplicate.
   * - A PropertySet ID **must be unique within a single DataModel** but can be shared between multiple DataModels.
   *
   * ### Usage Example
   *
   * ```javascript
   * const propertySet = dataModel.createPropertySet({
   *     id: "myPropertySet",
   *     name: "My properties",
   *     properties: [
   *         {
   *             name: "Weight",
   *             value: 5,
   *             type: "",
   *             valueType: "",
   *             description: "Weight of a thing"
   *         },
   *         {
   *             name: "Height",
   *             value: 12,
   *             type: "",
   *             valueType: "",
   *             description: "Height of a thing"
   *         }
   *     ]
   * });
   *
   * if (propertySet instanceof SDKError) {
   *     console.error(propertySet.message);
   * } else {
   *     // PropertySet successfully created
   * }
   * ```
   *
   * See {@link data | @xeokit/sdk/data} for more details.
   *
   * @param propertySetCfg - Configuration parameters for the new PropertySet.
   * @returns {@link PropertySet} on success.
   * @returns {@link core!SDKError | SDKError} if:
   * - The DataModel has already been built.
   * - The DataModel has been destroyed.
   * - A PropertySet with the same ID already exists within this DataModel.
   */
  createPropertySet(propertySetCfg) {
    if (this.destroyed) {
      return new SDKError("Failed to create PropertySet - DataModel already destroyed");
    }
    if (this.built) {
      return new SDKError("DataModel already built");
    }
    if (this.propertySets[propertySetCfg.id]) {
      return new SDKError("Failed to create PropertySet - PropertySet with same ID already created in this DataModel. It's OK to have duplicates shared between DataModels, but they must be unique within each DataModel.");
    }
    let propertySet = this.data.propertySets[propertySetCfg.id];
    if (propertySet) {
      this.propertySets[propertySetCfg.id] = propertySet;
      propertySet.models.push(this);
      return propertySet;
    }
    propertySet = new PropertySet(this, propertySetCfg);
    this.propertySets[propertySetCfg.id] = propertySet;
    this.data.propertySets[propertySetCfg.id] = propertySet;
    return propertySet;
  }
  /**
   * Creates a new {@link DataObject | DataObject} and registers it within the DataModel and Data.
   *
   * - The new DataObject is stored in {@link DataModel.objects | DataModel.objects} and
   *   {@link Data.objects | Data.objects}.
   * - Triggers an event via {@link Data.onObjectCreated | Data.onObjectCreated}.
   * - DataObject IDs are **globally unique**. If a DataObject with the given ID already exists in the same Data,
   *   it will be reused and shared across DataModels rather than creating a duplicate.
   * - This behavior enables xeokit to support [*federated data models*](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#federated-models).
   *
   * ### Usage Example
   *
   * ```javascript
   * const myDataObject = dataModel.createObject({
   *     id: "myDataObject",
   *     type: BasicEntity, // @xeokit/basictypes!basicTypes
   *     name: "My Object",
   *     propertySetIds: ["myPropertySet"]
   * });
   *
   * const myDataObject2 = dataModel.createObject({
   *     id: "myDataObject2",
   *     name: "My Other Object",
   *     type: BasicEntity,
   *     propertySetIds: ["myPropertySet"]
   * });
   *
   * if (myDataObject instanceof SDKError) {
   *     console.error(myDataObject.message);
   * } else if (myDataObject2 instanceof SDKError) {
   *     console.error(myDataObject2.message);
   * } else {
   *     // Success
   *     const gotMyDataObject = dataModel.objects["myDataObject"];
   *     const gotMyDataObjectAgain = data.objects["myDataObject"];
   * }
   * ```
   *
   * See {@link data | @xeokit/sdk/data} for more details.
   *
   * @param dataObjectParams - Configuration parameters for the new DataObject.
   * @returns {@link DataObject} on success.
   * @returns {@link core!SDKError | SDKError} if:
   * - The DataModel has already been built.
   * - The DataModel has been destroyed.
   * - A DataObject with the same ID already exists within this DataModel.
   * - A specified PropertySet could not be found.
   */
  createObject(dataObjectParams) {
    if (this.destroyed) {
      return new SDKError("Failed to create DataObject - DataModel already destroyed");
    }
    if (this.built) {
      return new SDKError("Failed to create DataObject - DataModel already built");
    }
    const id = dataObjectParams.id;
    if (this.objects[id]) {
      return new SDKError("Failed to create DataObject - DataObject with same ID already created in this DataModel. It's OK to have duplicates shared between DataModels, but they must be unique within each DataModel.");
    }
    const type = dataObjectParams.type;
    let dataObject = this.data.objects[id];
    if (!dataObject) {
      const propertySets = [];
      if (dataObjectParams.propertySetIds) {
        for (let i = 0, len = dataObjectParams.propertySetIds.length; i < len; i++) {
          const propertySetId = dataObjectParams.propertySetIds[i];
          const propertySet = this.propertySets[propertySetId];
          if (!propertySet) {
            return new SDKError(`Failed to create DataObject - PropertySet not found: "${propertySetId}"`);
          } else {
            propertySets.push(propertySet);
          }
        }
      }
      dataObject = new DataObject(this.data, this, id, dataObjectParams.originalSystemId, dataObjectParams.name, dataObjectParams.description, dataObjectParams.type, propertySets);
      this.objects[id] = dataObject;
      this.data.objects[id] = dataObject;
      if (!this.data.objectsByType[type]) {
        this.data.objectsByType[type] = {};
      }
      this.data.objectsByType[type][id] = dataObject;
      this.data.typeCounts[type] = this.data.typeCounts[type] === void 0 ? 1 : this.data.typeCounts[type] + 1;
      dataObject.models.push(this);
      this.data.onObjectCreated.dispatch(this.data, dataObject);
    } else {
      this.objects[id] = dataObject;
      this.data.objects[id] = dataObject;
      if (!this.objectsByType[type]) {
        this.objectsByType[type] = {};
      }
      this.objectsByType[type][id] = dataObject;
      this.typeCounts[type] = this.typeCounts[type] === void 0 ? 1 : this.typeCounts[type] + 1;
      dataObject.models.push(this);
    }
    return dataObject;
  }
  /**
   * Creates a new {@link Relationship | Relationship} between two existing {@link DataObject | DataObjects}.
   *
   * - A Relationship consists of a *relating* DataObject and a *related* DataObject.
   * - The *relating* and *related* DataObjects can belong to different DataModels, provided both DataModels exist
   *   within the same {@link Data}. This enables xeokit to support [*federated models*](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#federated-models).
   * - The created Relationship is stored in:
   *   - {@link DataModel.relationships | DataModel.relationships},
   *   - {@link DataObject.related | DataObject.related} on the *relating* DataObject, and
   *   - {@link DataObject.relating | DataObject.relating} on the *related* DataObject.
   *
   * ### Usage Example
   *
   * ```javascript
   * const myRelationship = dataModel.createRelationship({
   *     type: BasicAggregation,  // @xeokit/basictypes!basicTypes
   *     relatingObjectId: "myDataObject",
   *     relatedObjectId: "myDataObject2"
   * });
   *
   * if (myRelationship instanceof SDKError) {
   *     console.error(myRelationship.message);
   * } else {
   *     // Success
   *     const myDataObject = dataModel.objects["myDataObject"];
   *     const myDataObject2 = dataModel.objects["myDataObject2"];
   *
   *     const gotMyRelationship = myDataObject.related[BasicAggregation][0];
   *     const gotMyRelationshipAgain = myDataObject2.relating[BasicAggregation][0];
   * }
   * ```
   *
   * See {@link data | @xeokit/sdk/data} for more details.
   *
   * @param relationshipParams - Configuration parameters for the new Relationship.
   * @returns {@link Relationship} on success.
   * @returns {@link core!SDKError | SDKError} if:
   * - The DataModel has already been built or destroyed.
   * - The *relating* DataObject does not exist in the {@link Data} containing this DataModel.
   * - The *related* DataObject does not exist in the {@link Data} containing this DataModel.
   */
  createRelationship(relationshipParams) {
    if (this.destroyed) {
      return new SDKError("Failed to create Relationship - DataModel already destroyed");
    }
    if (this.built) {
      return new SDKError("Failed to create Relationship - DataModel already built");
    }
    const relatingObject = this.data.objects[relationshipParams.relatingObjectId];
    if (!relatingObject) {
      return new SDKError(`Failed to create Relationship - relating DataObject not found: ${relationshipParams.relatingObjectId}`);
    }
    const relatedObject = this.data.objects[relationshipParams.relatedObjectId];
    if (!relatedObject) {
      return new SDKError(`Failed to create Relationship - related DataObject not found: ${relationshipParams.relatedObjectId}`);
    }
    const relation = new Relationship(relationshipParams.type, relatingObject, relatedObject);
    if (!relatedObject.relating[relationshipParams.type]) {
      relatedObject.relating[relationshipParams.type] = [];
    }
    relatedObject.relating[relationshipParams.type].push(relation);
    if (!relatingObject.related[relationshipParams.type]) {
      relatingObject.related[relationshipParams.type] = [];
    }
    relatingObject.related[relationshipParams.type].push(relation);
    this.relationships.push(relation);
    return relation;
  }
  /**
   * Finalizes this DataModel, making it ready for use.
   *
   * - Triggers the following events to notify subscribers:
   *   - {@link DataModel.onBuilt | DataModel.onBuilt}
   *   - {@link Data.onModelCreated | Data.onModelCreated}
   * - Sets {@link DataModel.built | DataModel.built} to `true`.
   * - Can only be called once per DataModel.
   * - Once built, no additional components can be created within this DataModel.
   *
   * ### Usage Example
   *
   * ```javascript
   * dataModel.onBuilt.subscribe(() => {
   *     // The DataModel is built and ready for use
   * });
   *
   * data.onModelCreated.subscribe((dataModel) => {
   *     // Another way to listen for DataModel readiness
   * });
   *
   * const result = dataModel.build();
   *
   * if (result instanceof SDKError) {
   *     console.error(result.message);
   * } else {
   *     // Success
   * }
   * ```
   *
   * See {@link data | @xeokit/sdk/data} for more details.
   *
   * @throws {@link core!SDKError | SDKError} if:
   * - The DataModel has already been built.
   * - The DataModel has been destroyed.
   */
  build() {
    return new Promise((resolve2) => {
      if (this.destroyed) {
        throw new SDKError("Failed to build DataModel - DataModel already destroyed");
      }
      if (this.built) {
        throw new SDKError("Failed to build DataModel - DataModel already built");
      }
      this.built = true;
      this.onBuilt.dispatch(this, null);
      resolve2(this);
    });
  }
  /**
   * Adds components from the specified `DataModelParams` to the data model.
   *
   * For detailed usage, refer to {@link data | @xeokit/sdk/data}.
   *
   * @param dataModelParams - The parameters to configure and populate the data model.
   *
   * @returns `void`
   * * If the operation is successful.
   *
   * @returns {@link core!SDKError | SDKError}
   * * If the data model has already been built.
   * * If the data model has already been destroyed.
   * * If a duplicate `PropertySet` was already created for the data model.
   * * If a duplicate `DataObject` already exists in the data model.
   * * If the necessary `DataObjects` were not found for a relationship.
   */
  fromParams(dataModelParams) {
    if (this.destroyed) {
      return new SDKError("Failed to add components to DataModel - DataModel already destroyed");
    }
    if (this.built) {
      throw new SDKError("Failed to add components to DataModel - DataModel already built");
    }
    if (dataModelParams.propertySets) {
      for (let i = 0, len = dataModelParams.propertySets.length; i < len; i++) {
        this.createPropertySet(dataModelParams.propertySets[i]);
      }
    }
    if (dataModelParams.objects) {
      for (let i = 0, len = dataModelParams.objects.length; i < len; i++) {
        this.createObject(dataModelParams.objects[i]);
      }
    }
    if (dataModelParams.relationships) {
      for (let i = 0, len = dataModelParams.relationships.length; i < len; i++) {
        this.createRelationship(dataModelParams.relationships[i]);
      }
    }
  }
  /**
   * Gets this DataModel as a DataModelParams.
   */
  toParams() {
    if (this.destroyed) {
      return new SDKError("DataModel already destroyed");
    }
    const dataModelParams = {
      id: this.id,
      propertySets: [],
      objects: [],
      relationships: []
    };
    for (let id in this.propertySets) {
      const propertySet = this.propertySets[id];
      const propertySetParams = {
        id,
        name: propertySet.name,
        properties: [],
        type: propertySet.type,
        originalSystemId: propertySet.originalSystemId
      };
      for (let i = 0, len = propertySet.properties.length; i < len; i++) {
        const property = propertySet.properties[i];
        const propertyParams = {
          name: property.name,
          value: property.value,
          type: property.type,
          valueType: property.valueType,
          description: property.description
        };
        propertySetParams.properties.push(propertyParams);
      }
      dataModelParams.propertySets?.push(propertySetParams);
    }
    for (let id in this.objects) {
      const dataObject = this.objects[id];
      const dataObjectParams = {
        id,
        originalSystemId: dataObject.originalSystemId,
        type: dataObject.type,
        name: dataObject.name,
        propertySetIds: []
      };
      if (dataObject.description !== void 0) {
        dataObjectParams.description = dataObject.description;
      }
      if (dataObject.propertySets) {
        for (let i = 0, len = dataObject.propertySets.length; i < len; i++) {
          const propertySet = dataObject.propertySets[i];
          dataObjectParams.propertySetIds?.push(propertySet.id);
        }
      }
      dataModelParams.objects?.push(dataObjectParams);
    }
    for (let i = 0, len = this.relationships.length; i < len; i++) {
      const relationship = this.relationships[i];
      const relationParams = {
        type: relationship.type,
        relatingObjectId: relationship.relatingObject.id,
        relatedObjectId: relationship.relatedObject.id
      };
      dataModelParams.relationships?.push(relationParams);
    }
    return dataModelParams;
  }
  /**
   * Destroys this DataModel.
   *
   * This method performs the following actions:
   * * Fires an event via {@link DataModel.onDestroyed | DataModel.onDestroyed} and
   * {@link Data.onModelDestroyed | Data.onModelDestroyed}.
   * * Can only be called once on a DataModel.
   * * After destruction, no more components can be created in the DataModel.
   * * It is safe to call this method even if the DataModel has not yet been built.
   *
   * For detailed usage, refer to {@link data | @xeokit/sdk/data}.
   *
   * @returns `void`
   * * If the operation is successful.
   *
   * @returns {@link core!SDKError | SDKError}
   * * If the DataModel has already been destroyed.
   */
  destroy() {
    if (this.destroyed) {
      return new SDKError("Failed to destroy DataModel - DataModel already destroyed");
    }
    for (let id in this.objects) {
      const dataObject = this.objects[id];
      if (dataObject.models.length > 1) {
        this.#removeObjectFromModels(dataObject);
      } else {
        delete this.data.objects[id];
        const type = dataObject.type;
        if (--this.data.typeCounts[type] === 0) {
          delete this.data.typeCounts[type];
          delete this.data.objectsByType[type];
          this.data.onObjectDestroyed.dispatch(this.data, dataObject);
          for (let type2 in dataObject.relating) {
            const relations = dataObject.relating[type2];
            for (let i = 0, len = relations.length; i < len; i++) {
              const relation = relations[i];
              const related = relation.relatedObject;
              const list = related.relating[type2];
              for (let j = 0, k = 0, lenj = list.length; j < lenj; j++) {
                if (list[k].relatingObject === dataObject) {
                  list[j] = list[j];
                }
              }
            }
          }
        }
      }
    }
    this.#destroyed = true;
    this.onBuilt.clear();
    super.destroy();
  }
  // #removePropertySetFromModels(dataObject: DataObject) {
  //     for (let i = 0, len = dataObject.models.length; i < len; i++) {
  //         if (dataObject.models[i] === this) {
  //             dataObject.models = dataObject.models.splice(i, 1);
  //             break;
  //         }
  //     }
  // }
  #removeObjectFromModels(dataObject) {
    for (let i = 0, len = dataObject.models.length; i < len; i++) {
      if (dataObject.models[i] === this) {
        dataObject.models = dataObject.models.splice(i, 1);
        break;
      }
    }
  }
};

// ../sdk/src/data/Data.ts
var import_strongly_typed_events4 = __toESM(require_dist8());
var Data = class extends Component {
  /**
   * The {@link DataModel | DataModels} belonging to this Data, each keyed to
   * its {@link DataModel.id | DataModel.id}.
   */
  models;
  /**
   * The{@link PropertySet | PropertySets} belonging to this Data, mapped to{@link PropertySet.id | PropertySet.id}.
   */
  propertySets;
  /**
   * The {@link DataObject | DataObjects} in this Data, mapped to {@link DataObject.id | DataObject.id}.
   */
  objects;
  /**
   * The root {@link DataObject | DataObjects} belonging to this Data, each keyed to its {@link DataObject.id | DataObject.id}.
   *
   * * This is the set of DataObjects in the DataModels within this Data that are not the *related* participant in
   * any {@link Relationship | Relationships}, where they have no incoming Relationships and
   * their {@link DataObject.relating} property is empty.
   */
  rootObjects;
  /**
   * The {@link DataObject | DataObjects} belonging to this Data, each map keyed to {@link DataObject.type | DataObject.type},
   * containing {@link DataObject | DataObjects} keyed to {@link DataObject.id | DataObject.id}.
   */
  objectsByType;
  /**
   * Tracks number of {@link DataObject | DataObjects} of each type in this Data.
   */
  typeCounts;
  /**
   * Emits an event each time a {@link DataModel | DataModel} has been created in this Data.
   *
   * @event
   */
  onModelCreated;
  /**
   * Emits an event each time a {@link DataModel | DataModel} has been destroyed within this Data.
   *
   * @event
   */
  onModelDestroyed;
  /**
   * Emits an event each time a {@link DataObject | DataObject} is created within this Data.
   *
   * @event
   */
  onObjectCreated;
  /**
   * Emits an event each time a {@link DataObject | DataObject} is destroyed within this Data.
   *
   * @event
   */
  onObjectDestroyed;
  /**
   * Creates a new Data.
   *
   * See {@link data | @xeokit/sdk/data}   for usage.
   */
  constructor() {
    super(null, {});
    this.models = {};
    this.propertySets = {};
    this.objects = {};
    this.rootObjects = {};
    this.objectsByType = {};
    this.typeCounts = {};
    this.onModelCreated = new EventEmitter(new import_strongly_typed_events4.EventDispatcher());
    this.onModelDestroyed = new EventEmitter(new import_strongly_typed_events4.EventDispatcher());
    this.onObjectCreated = new EventEmitter(new import_strongly_typed_events4.EventDispatcher());
    this.onObjectDestroyed = new EventEmitter(new import_strongly_typed_events4.EventDispatcher());
  }
  /**
   * Creates a new {@link DataModel | DataModel} in this Data.
   *
   * Remember to call {@link DataModel.build | DataModel.build} when you've finished building or loading the DataModel. That will
   * fire events via {@link Data.onModelCreated | Data.onModelCreated} and {@link DataModel.onBuilt | DataModel.onBuilt}, to
   * indicate to any subscribers that the DataModel is built and ready for use.
   *
   * Note that while we're building/loading the DataModel, each call that we make to {@link DataModel.createObject | DataModel.createObject}
   * will create a new {@link DataObject | DataObject}
   * in {@link Data.objects | Data.objects} and {@link DataModel.objects | DataModel.objects}, and will also fire an event
   * via {@link Data.onObjectCreated | Data.onObjectCreated}. However,
   * only when we've received the {@link Data.onModelCreated | Data.onModelCreated} and {@link DataModel.onBuilt | DataModel.onBuilt}
   * events can we actually consider the DataModel to be fully constructed.
   *
   * See {@link data | @xeokit/sdk/data}   for more details on usage.
   *
   * @param  dataModelParams Creation parameters for the new {@link DataModel | DataModel}.
   * @param [options] Options for creating the {@link DataModel | DataModel}.
   * @param [options.includeTypes] When provided, only create {@link DataObject | DataObjects} with types in this list.
   * @param  [options.excludeRelating] When provided, never create {@link DataObject | DataObjects} with types in this list.
   * @returns {@link DataModel | DataModel}
   * * On success.
   * @returns *{@link core!SDKError | SDKError}*
   * * This Data has already been destroyed.
   * * A DataModel with the given ID already exists in this Data.
   */
  createModel(dataModelParams, options) {
    if (this.destroyed) {
      return new SDKError("Data already destroyed");
    }
    let id = dataModelParams.id;
    if (this.models[id]) {
      return new SDKError(`DataModel already created in this Data: ${id}`);
    }
    const dataModel = new DataModel(this, id, dataModelParams, options);
    this.models[dataModel.id] = dataModel;
    dataModel.onDestroyed.one(() => {
      delete this.models[dataModel.id];
      this.onModelDestroyed.dispatch(this, dataModel);
    });
    dataModel.onBuilt.one(() => {
      this.onModelCreated.dispatch(this, dataModel);
    });
    return dataModel;
  }
  /**
   * Gets the {@link DataObject.id}s of the {@link DataObject | DataObjects} that have the given {@link DataObject.type}.
   *
   * See {@link data | @xeokit/sdk/data} for usage.
   *
   * @param type The type.
   * @returns {string[]}
   * * Array of {@link DataObject.id}s on success.
   * @returns *{@link core!SDKError | SDKError}*
   * * This Data has already been destroyed.
   */
  getObjectIdsByType(type) {
    if (this.destroyed) {
      return new SDKError("Data already destroyed");
    }
    const objects = this.objectsByType[type];
    return objects ? Object.keys(objects) : [];
  }
  /**
   * Destroys all contained {@link DataModel | DataModels}.
   *
   * Fires {@link Data.onModelDestroyed | Data.onModelDestroyed} and {@link DataModel.onDestroyed | DataModel.onDestroyed}
   * for each existing DataModel in this Data.
   *
   * See {@link data | @xeokit/sdk/data}   for usage.
   *
   * @returns *void*
   * * On success.
   * @returns *{@link core!SDKError | SDKError}*
   * * This Data has already been destroyed.
   */
  clear() {
    if (this.destroyed) {
      return new SDKError("Data already destroyed");
    }
    for (let id in this.models) {
      this.models[id].destroy();
    }
  }
  /**
   * Destroys this Data and all contained {@link DataModel | DataModels}.
   *
   * * Fires {@link Data.onModelDestroyed | Data.onModelDestroyed} and {@link DataModel.onDestroyed | DataModel.onDestroyed}
   * for each existing DataModels in this Data.
   * * Unsubscribes all subscribers to {@link Data.onModelCreated | Data.onModelCreated}, {@link Data.onModelDestroyed | Data.onModelDestroyed}, {@link DataModel.onDestroyed | DataModel.onDestroyed}
   *
   * See {@link data | @xeokit/sdk/data}   for usage.
   *
   * @returns *void*
   * * On success.
   * @returns *{@link core!SDKError | SDKError}*
   * * This Data has already been destroyed.
   */
  destroy() {
    if (this.destroyed) {
      return new SDKError("Data already destroyed");
    }
    this.clear();
    this.onModelCreated.clear();
    this.onModelDestroyed.clear();
    super.destroy();
  }
};

// ../sdk/src/data/searchObjects.ts
function searchObjects(data, searchParams) {
  if (data.destroyed) {
    return new SDKError("Data already destroyed");
  }
  const includeObjects = searchParams.includeObjects && searchParams.includeObjects.length > 0 ? arrayToMap(searchParams.includeObjects) : null;
  const excludeObjects = searchParams.excludeObjects && searchParams.excludeObjects.length > 0 ? arrayToMap(searchParams.excludeObjects) : null;
  const includeRelating = searchParams.includeRelating && searchParams.includeRelating.length > 0 ? arrayToMap(searchParams.includeRelating) : null;
  const excludeRelating = searchParams.excludeRelating && searchParams.excludeRelating.length > 0 ? arrayToMap(searchParams.excludeRelating) : null;
  function visit(dataObject, depth2) {
    if (!dataObject) {
      return;
    }
    let includeObject = true;
    if (excludeObjects && excludeObjects[dataObject.type]) {
      includeObject = false;
    } else {
      if (includeObjects && !includeObjects[dataObject.type]) {
        includeObject = false;
      }
    }
    if (depth2 === 0 && searchParams.includeStart === false) {
      includeObject = false;
    }
    if (includeObject) {
      if (searchParams.resultObjectIds) {
        searchParams.resultObjectIds.push(dataObject.id);
      } else if (searchParams.resultObjects) {
        searchParams.resultObjects.push(dataObject);
      } else if (searchParams.resultCallback) {
        if (searchParams.resultCallback(dataObject)) {
          return;
        }
      }
    }
    const related = dataObject.related;
    for (let type in related) {
      const relations = related[type];
      if (relations) {
        for (let i = 0, len = relations.length; i < len; i++) {
          let includeRelation = true;
          if (excludeRelating && excludeRelating[dataObject.type]) {
            includeRelation = false;
          } else {
            if (includeRelating && !includeRelating[dataObject.type]) {
              includeRelation = false;
            }
          }
          if (includeRelation) {
            visit(relations[i].relatedObject, depth2 + 1);
          }
        }
      }
    }
  }
  const depth = 0;
  if (searchParams.startObjectId) {
    const startObject = data.objects[searchParams.startObjectId];
    if (!startObject) {
      return new SDKError(`Failed to search DataObjects - starting DataObject not found in Data: "${searchParams.startObjectId}"`);
    }
    visit(startObject, depth);
  } else if (searchParams.startObject) {
    if (searchParams.startObject.data != data) {
      return new SDKError(`Failed to search DataObjects - starting DataObject not in same Data: "${searchParams.startObjectId}"`);
    }
    visit(searchParams.startObject, depth + 1);
  } else {
    for (let id in data.rootObjects) {
      visit(data.rootObjects[id], depth + 1);
    }
  }
}
function arrayToMap(array) {
  const map = {};
  for (let i = 0, len = array.length; i < len; i++) {
    map[array[i]] = true;
  }
  return map;
}

// ../sdk/src/data/versions/1_0/parse.ts
function parse(params2, options) {
  return new Promise(function(resolve2, reject) {
    if (params2.dataModel && params2.fileData) {
      params2.dataModel.fromParams(params2.fileData);
    }
    return resolve2();
  });
}

// ../sdk/src/io/index.ts
var io_exports = {};
__export(io_exports, {
  ModelExporter: () => ModelExporter,
  ModelLoader: () => ModelLoader
});

// ../sdk/src/scene/SceneModel.ts
var import_strongly_typed_events5 = __toESM(require_dist8());

// ../sdk/src/scene/SceneGeometry.ts
var SceneGeometry = class {
  /**
   * ID for the geometry.
   */
  id;
  /**
   * Primitive type.
   *
   * Possible values are {@link constants!SolidPrimitive}, {@link constants!SurfacePrimitive},
   * {@link constants!LinesPrimitive}, {@link constants!PointsPrimitive}
   * and {@link constants!TrianglesPrimitive}.
   */
  primitive;
  /**
   * Axis-aligned, non-quantized 3D boundary of the geometry's vertex positions.
   */
  aabb;
  /**
   * 4x4 matrix to de-quantize the geometry's UV coordinates, when UVs are provided.
   */
  uvsDecompressMatrix;
  /**
   * 3D vertex positions, quantized as 16-bit integers.
   *
   * Internally, the Viewer dequantizes these using {@link SceneGeometry.aabb | SceneGeometry.aabb}, which provides their unquantized 3D boundary.
   *
   * Vertex positions are required for all primitive types.
   */
  positionsCompressed;
  /**
   * UV coordinates, quantized as 16-bit integers.
   *
   * Internally, the Viewer de-quantizes these with {@link SceneGeometry.uvsDecompressMatrix | SceneGeometry.uvsDecompressMatrix}.
   */
  uvsCompressed;
  /**
   * Vertex RGB colors, quantized as 8-bit integers.
   */
  colorsCompressed;
  /**
   * primitive indices.
   *
   * This is either an array of 8-bit, 16-bit or 32-bit values.
   */
  indices;
  /**
   * Edge indices.
   *
   * This is either an array of 8-bit, 16-bit or 32-bit values.
   */
  edgeIndices;
  /**
   * Interface through which this SceneGeometry can load any user-updated geometry arrays into the renderers.
   *
   * @internal
   */
  rendererGeometry;
  /**
   * TODO
   */
  origin;
  /**
   * The count of {@link SceneMesh | SceneMeshes} that reference this SceneGeometry.
   */
  numMeshes;
  constructor(params2) {
    this.id = params2.id;
    this.primitive = params2.primitive;
    this.positionsCompressed = params2.positionsCompressed;
    this.uvsCompressed = params2.uvsCompressed;
    this.colorsCompressed = params2.colorsCompressed;
    this.indices = params2.indices;
    this.edgeIndices = params2.edgeIndices;
    this.origin = params2.origin;
    this.aabb = params2.aabb ? params2.aabb.slice() : createAABB3();
    this.numMeshes = 0;
  }
  /**
   * Gets this SceneGeometry as SceneGeometryCompressedParams.
   */
  toParams() {
    const params2 = {
      id: this.id,
      primitive: this.primitive,
      aabb: Array.from(this.aabb),
      positionsCompressed: Array.from(this.positionsCompressed)
    };
    if (this.positionsCompressed) {
      params2.positionsCompressed = Array.from(this.positionsCompressed);
    }
    if (this.uvsCompressed) {
      params2.uvsCompressed = Array.from(this.uvsCompressed);
    }
    if (this.colorsCompressed) {
      params2.colorsCompressed = Array.from(this.colorsCompressed);
    }
    if (this.indices) {
      params2.indices = Array.from(this.indices);
    }
    if (this.edgeIndices) {
      params2.edgeIndices = Array.from(this.edgeIndices);
    }
    return params2;
  }
};

// ../sdk/src/scene/SceneObject.ts
var SceneObject = class {
  /**
   * Unique ID of this SceneObject.
   *
   * SceneObjects are stored by ID in {@link Scene.objects | Scene.objects}
   * and {@link SceneModel.objects | SceneModel.objects}.
   */
  id;
  /**
   * ID of this SceneObject within the originating system.
   */
  originalSystemId;
  /**
   * Optional layer ID for this SceneObject.
   *
   * When the {@link Scene} is attached to a {@link view!Viewer | View}, this will identify an optional {@link view!ViewLayer | ViewLayer}
   * to assign the object to. ViewLayers allow users to group and segregate object based on their roles or aspects in a scene,
   * simplifying interaction and focusing operations on specific object groups.
   */
  layerId;
  /**
   * The {@link SceneModel | SceneModel} that contains this SceneObject.
   */
  model;
  /**
   * The {@link SceneMesh | Meshes} belonging to this SceneObject.
   */
  meshes;
  /**
   *  Internal interface through which a {@link viewer!ViewObject | ViewObject} can load property updates
   *  into a {@link viewer!Renderer | Renderer} for this SceneObject.
   *
   *  This is defined when the owner {@link SceneModel | SceneModel} has been added to a {@link viewer!Viewer | Viewer}.
   *
   * @internal
   */
  rendererObject;
  #aabb;
  #aabbDirty;
  /**
   * @private
   */
  constructor(cfg) {
    this.id = cfg.id;
    this.originalSystemId = cfg.originallSystemId || this.id;
    this.layerId = cfg.layerId;
    this.meshes = cfg.meshes;
    this.#aabb = null;
    this.#aabbDirty = true;
    this.rendererObject = null;
  }
  /**
   * @private
   */
  setAABBDirty() {
    this.#aabbDirty = true;
  }
  /**
   * Gets the axis-aligned 3D World-space boundary of this SceneObject.
   */
  get aabb() {
    if (this.meshes.length === 1) {
      return this.meshes[0].aabb;
    }
    if (this.#aabbDirty) {
      if (!this.#aabb) {
        this.#aabb = collapseAABB3();
      } else {
        collapseAABB3(this.#aabb);
      }
      for (let i = 0, len = this.meshes.length; i < len; i++) {
        expandAABB3(this.#aabb, this.meshes[i].aabb);
      }
      this.#aabbDirty = false;
    }
    return this.#aabb;
  }
  /**
   * Gets this SceneObject as SceneObjectParams.
   */
  toParams() {
    const sceneObjectParams = {
      id: this.id,
      meshIds: []
    };
    if (this.layerId != void 0) {
      sceneObjectParams.layerId = this.layerId;
    }
    if (this.meshes != void 0) {
      for (let i = 0, len = this.meshes.length; i < len; i++) {
        sceneObjectParams.meshIds.push(this.meshes[i].id);
      }
    }
    return sceneObjectParams;
  }
};

// ../sdk/src/scene/SceneTextureSet.ts
var SceneTextureSet = class {
  /**
   * The ID of this SceneTextureSet.
   */
  id;
  /**
   * The color {@link SceneTexture} in this set.
   */
  colorTexture;
  /**
   * The metallic-roughness {@link SceneTexture} in this set.
   */
  metallicRoughnessTexture;
  /**
   * The occlusion {@link SceneTexture} in this set.
   */
  occlusionTexture;
  /**
   * The emissive {@link SceneTexture} in this set.
   */
  emissiveTexture;
  /**
   *  Internal interface through which a SceneTextureSet can load property updates into a renderers.
   *
   *  This is defined while the owner {@link SceneModel | SceneModel} has been added to a {@link viewer!Viewer | Viewer}.
   *
   * @internal
   */
  rendererTextureSet;
  /**
   * @private
   */
  constructor(textureSetParams, textures) {
    this.id = textureSetParams.id;
    this.colorTexture = textures.colorTexture;
    this.metallicRoughnessTexture = textures.metallicRoughnessTexture;
    this.occlusionTexture = textures.occlusionTexture;
    this.emissiveTexture = textures.emissiveTexture;
    this.rendererTextureSet = null;
  }
};

// ../sdk/src/scene/SceneTexture.ts
var SceneTexture = class {
  /**
   *  Internal interface through which this {@link SceneTexture} can load property updates into a renderers.
   *
   *  This is defined when the owner {@link SceneModel | SceneModel} has been added to a {@link viewer!Viewer | Viewer}.
   *
   * @internal
   */
  rendererTexture;
  /**
   * ID for the texture.
   */
  id;
  /**
   * Path to an image file.
   */
  src;
  /**
   * Image file data.
   */
  imageData;
  /**
   * Transcoded texture data.
   */
  buffers;
  /**
   * HTMLImage containing the texture image.
   */
  image;
  /**
   * Pixel height of the texture.
   */
  height;
  /**
   * Pixel width of the texture.
   */
  width;
  /**
   * True if the texture is compressed.
   */
  compressed;
  /**
   * Media type of this SceneTexture.
   *
   * Supported values are {@link constants!GIFMediaType}, {@link constants!PNGMediaType} and {@link constants!JPEGMediaType}.
   *
   * Ignored for compressed textures.
   */
  mediaType;
  /**
   * How the texture is sampled when a texel covers more than one pixel.
   *
   * Supported values are {@link constants!LinearFilter} and {@link constants!NearestFilter}.
   */
  magFilter;
  /**
   * How the texture is sampled when a texel covers less than one pixel. Supported values
   * are {@link constants!LinearMipmapLinearFilter}, {@link constants!LinearMipMapNearestFilter},
   * {@link constants!NearestMipMapNearestFilter}, {@link constants!NearestMipMapLinearFilter}
   * and {@link constants!LinearMipMapLinearFilter}.
   *
   * Ignored for compressed textures.
   */
  minFilter;
  /**
   * S wrapping mode.
   *
   * Supported values are {@link constants!ClampToEdgeWrapping}, {@link constants!MirroredRepeatWrapping} and {@link constants!RepeatWrapping}.
   *
   * Ignored for compressed textures.
   */
  wrapS;
  /**
   * T wrapping mode.
   *
   * Supported values are {@link constants!ClampToEdgeWrapping}, {@link constants!MirroredRepeatWrapping} and {@link constants!RepeatWrapping}.
   *
   * Ignored for compressed textures.
   */
  wrapT;
  /**
   * R wrapping mode.
   *
   * Supported values are {@link constants!ClampToEdgeWrapping}, {@link constants!MirroredRepeatWrapping} and {@link constants!RepeatWrapping}.
   *
   * Ignored for compressed textures.
   */
  wrapR;
  /**
   * Flips this SceneTexture's source data along its vertical axis when ````true````.
   */
  flipY;
  /**
   * SceneTexture encoding format.
   *
   * Supported values are {@link constants!LinearEncoding} and {@link constants!sRGBEncoding}.
   */
  encoding;
  /**
   * RGBA color to preload the texture with.
   */
  preloadColor;
  /**
   * @private
   */
  channel;
  /**
   * @private
   */
  constructor(params2) {
    this.id = params2.id;
    this.imageData = params2.imageData;
    this.src = params2.src;
    this.mediaType = params2.mediaType;
    this.minFilter = params2.minFilter || LinearMipMapNearestFilter;
    this.magFilter = params2.magFilter || LinearMipMapNearestFilter;
    this.wrapS = params2.wrapS || RepeatWrapping;
    this.wrapT = params2.wrapT || RepeatWrapping;
    this.wrapR = params2.wrapR || RepeatWrapping;
    this.encoding = params2.encoding || LinearEncoding;
    this.preloadColor = createVec4(params2.preloadColor || [1, 1, 1, 1]);
    this.channel = 0;
    this.rendererTexture = null;
  }
};

// ../sdk/src/scene/SceneMesh.ts
var tempVec4a2 = createVec4();
var tempVec4b2 = createVec4();
function getPositionsWorldAABB3(positions, aabb, matrix, worldAABB = createAABB3()) {
  collapseAABB3(worldAABB);
  const xScale = (aabb[3] - aabb[0]) / 65535;
  const xOffset = aabb[0];
  const yScale = (aabb[4] - aabb[1]) / 65535;
  const yOffset = aabb[1];
  const zScale = (aabb[5] - aabb[2]) / 65535;
  const zOffset = aabb[2];
  for (let i = 0, len = positions.length; i < len; i += 3) {
    tempVec4a2[0] = positions[i + 0] * xScale + xOffset;
    tempVec4a2[1] = positions[i + 1] * yScale + yOffset;
    tempVec4a2[2] = positions[i + 2] * zScale + zOffset;
    tempVec4a2[3] = 1;
    transformPoint4(matrix, tempVec4a2, tempVec4b2);
    expandAABB3Point3(worldAABB, tempVec4b2);
  }
  return worldAABB;
}
var SceneMesh = class {
  /**
   * Unique ID of this SceneMesh.
   *
   * SceneMesh is stored by this ID in {@link SceneModel.meshes}.
   */
  id;
  /**
   * {@link SceneTile} this SceneMesh belongs to.
   */
  tile;
  /**
   * {@link SceneGeometry} used by this SceneMesh.
   */
  geometry;
  /**
   * {@link SceneTextureSet} used by this SceneMesh.
   */
  textureSet;
  /**
   *  Internal interface through which a {@link SceneMesh} can load property updates into a renderers.
   *
   *  This is defined when the owner {@link SceneModel | SceneModel} has been added to
   *  a {@link viewer!Viewer | Viewer}.
   *
   * @internal
   */
  rendererMesh;
  /**
   * The {@link SceneObject} that uses this SceneMesh.
   */
  object;
  /**
   * TODO
   */
  streamLayerIndex;
  #color;
  #matrix;
  #rtcMatrix;
  #opacity;
  origin;
  #aabbDirty;
  #aabb;
  /**
   * @private
   */
  constructor(meshParams) {
    this.id = meshParams.id;
    this.#matrix = meshParams.matrix ? createMat4(meshParams.matrix) : identityMat4();
    this.#rtcMatrix = meshParams.rtcMatrix ? createMat4(meshParams.rtcMatrix) : this.#matrix.slice();
    this.#aabb = createAABB3();
    this.#aabbDirty = true;
    this.geometry = meshParams.geometry;
    this.textureSet = meshParams.textureSet;
    this.rendererMesh = null;
    this.color = meshParams.color || new Float32Array([1, 1, 1]);
    this.opacity = meshParams.opacity !== void 0 && meshParams.opacity !== null ? meshParams.opacity : 1;
    this.tile = meshParams.tile;
    this.streamLayerIndex = meshParams.streamLayerIndex !== void 0 ? meshParams.streamLayerIndex : 0;
  }
  /**
   * Gets the RGB color for this SceneMesh.
   *
   * Each element of the color is in range ````[0..1]````.
   */
  get color() {
    return this.#color;
  }
  /**
   * Sets the RGB color for this SceneMesh.
   *
   * Each element of the color is in range ````[0..1]````.
   */
  set color(value) {
    let color2 = this.#color;
    if (!color2) {
      color2 = this.#color = new Float32Array(4);
      color2[3] = 1;
    }
    if (value) {
      color2[0] = value[0];
      color2[1] = value[1];
      color2[2] = value[2];
    } else {
      color2[0] = 1;
      color2[1] = 1;
      color2[2] = 1;
    }
    if (this.rendererMesh) {
      this.rendererMesh.setColor(this.#color);
    }
  }
  /**
   * Gets this SceneMesh's local modeling transform matrix.
   *
   * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
   *
   * @type {FloatArrayParam}
   */
  get matrix() {
    return this.#matrix;
  }
  /**
   * Gets this SceneMesh's RTC modeling transform matrix.
   *
   * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
   *
   * @internal
   * @type {FloatArrayParam}
   */
  get rtcMatrix() {
    return this.#rtcMatrix;
  }
  /**
   * Updates this SceneMesh's local modeling transform matrix.
   *
   * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
   *
   * @type {FloatArrayParam}
   */
  set matrix(matrix) {
    if (matrix) {
      this.#matrix.set(matrix);
    } else {
      identityMat4(this.#matrix);
    }
    if (this.rendererMesh) {
      this.rendererMesh.setMatrix(this.#matrix);
    }
    this.#aabbDirty = true;
    if (this.object) {
      this.object.setAABBDirty();
    }
  }
  /**
   * Gets the opacity factor for this SceneMesh.
   *
   * This is a factor in range ````[0..1]````.
   */
  get opacity() {
    return this.#opacity;
  }
  /**
   * Sets the opacity factor for this SceneMesh.
   *
   * This is a factor in range ````[0..1]````.
   */
  set opacity(opacity) {
    opacity = opacity !== void 0 && opacity !== null ? opacity : 1;
    if (this.#opacity === opacity) {
      return;
    }
    this.#opacity = opacity;
    if (this.rendererMesh) {
    }
  }
  /**
   * Gets the World-space AABB of this SceneMesh.
   */
  get aabb() {
    if (!this.#aabbDirty) {
      return this.#aabb;
    }
    getPositionsWorldAABB3(this.geometry.positionsCompressed, this.geometry.aabb, this.#matrix, this.#aabb);
    this.#aabbDirty = false;
    return this.#aabb;
  }
  /**
   * Gets this SceneMesh as SceneMeshParams.
   */
  toParams() {
    const meshParams = {
      streamLayerIndex: this.streamLayerIndex || 0,
      id: this.id,
      geometryId: this.geometry.id,
      color: Array.from(this.#color),
      opacity: this.#opacity
    };
    if (!isIdentityMat4(this.#matrix)) {
      meshParams.matrix = Array.from(this.#matrix);
    }
    if (this.textureSet !== void 0) {
      meshParams.textureSetId = this.textureSet.id;
    }
    return meshParams;
  }
};

// ../sdk/src/scene/buildEdgeIndices.ts
var uniquePositions = [];
var indicesLookup = [];
var indicesReverseLookup = [];
var weldedIndices = [];
var faces = [];
var numFaces = 0;
var compa = new Uint16Array(3);
var compb = new Uint16Array(3);
var compc = new Uint16Array(3);
var a = createVec3();
var b = createVec3();
var c = createVec3();
var cb = createVec3();
var ab = createVec3();
var cross = createVec3();
var normal = createVec3();
function weldVertices(positions, indices) {
  const positionsMap = {};
  let vx;
  let vy;
  let vz;
  let key;
  const precisionPoints = 4;
  const precision = Math.pow(10, precisionPoints);
  let i;
  let len;
  let lenUniquePositions = 0;
  for (i = 0, len = positions.length; i < len; i += 3) {
    vx = positions[i];
    vy = positions[i + 1];
    vz = positions[i + 2];
    key = Math.round(vx * precision) + "_" + Math.round(vy * precision) + "_" + Math.round(vz * precision);
    if (positionsMap[key] === void 0) {
      positionsMap[key] = lenUniquePositions / 3;
      uniquePositions[lenUniquePositions++] = vx;
      uniquePositions[lenUniquePositions++] = vy;
      uniquePositions[lenUniquePositions++] = vz;
    }
    indicesLookup[i / 3] = positionsMap[key];
  }
  for (i = 0, len = indices.length; i < len; i++) {
    weldedIndices[i] = indicesLookup[indices[i]];
    indicesReverseLookup[weldedIndices[i]] = indices[i];
  }
}
function buildFaces(numIndices, aabb) {
  numFaces = 0;
  for (let i = 0, len = numIndices; i < len; i += 3) {
    const ia = weldedIndices[i] * 3;
    const ib = weldedIndices[i + 1] * 3;
    const ic = weldedIndices[i + 2] * 3;
    if (aabb) {
      compa[0] = uniquePositions[ia];
      compa[1] = uniquePositions[ia + 1];
      compa[2] = uniquePositions[ia + 2];
      compb[0] = uniquePositions[ib];
      compb[1] = uniquePositions[ib + 1];
      compb[2] = uniquePositions[ib + 2];
      compc[0] = uniquePositions[ic];
      compc[1] = uniquePositions[ic + 1];
      compc[2] = uniquePositions[ic + 2];
      decompressPoint3WithAABB3(compa, aabb, a);
      decompressPoint3WithAABB3(compb, aabb, b);
      decompressPoint3WithAABB3(compc, aabb, c);
    } else {
      a[0] = uniquePositions[ia];
      a[1] = uniquePositions[ia + 1];
      a[2] = uniquePositions[ia + 2];
      b[0] = uniquePositions[ib];
      b[1] = uniquePositions[ib + 1];
      b[2] = uniquePositions[ib + 2];
      c[0] = uniquePositions[ic];
      c[1] = uniquePositions[ic + 1];
      c[2] = uniquePositions[ic + 2];
    }
    subVec3(c, b, cb);
    subVec3(a, b, ab);
    cross3Vec3(cb, ab, cross);
    normalizeVec3(cross, normal);
    const face = faces[numFaces] || (faces[numFaces] = { normal: createVec3() });
    face.normal[0] = normal[0];
    face.normal[1] = normal[1];
    face.normal[2] = normal[2];
    numFaces++;
  }
}
function buildEdgeIndices(positions, indices, aabb, edgeThreshold) {
  weldVertices(positions, indices);
  buildFaces(indices.length, aabb);
  const edgeIndices = [];
  const thresholdDot = Math.cos(DEGTORAD * edgeThreshold);
  const edges = {};
  let edge1;
  let edge2;
  let index1;
  let index2;
  let key;
  let largeIndex = false;
  let edge;
  let normal1;
  let normal2;
  let dot3;
  let ia;
  let ib;
  for (let i = 0, len = indices.length; i < len; i += 3) {
    const faceIndex = i / 3;
    for (let j = 0; j < 3; j++) {
      edge1 = weldedIndices[i + j];
      edge2 = weldedIndices[i + (j + 1) % 3];
      index1 = Math.min(edge1, edge2);
      index2 = Math.max(edge1, edge2);
      key = index1 + "," + index2;
      if (edges[key] === void 0) {
        edges[key] = {
          index1,
          index2,
          face1: faceIndex,
          face2: void 0
        };
      } else {
        edges[key].face2 = faceIndex;
      }
    }
  }
  for (key in edges) {
    edge = edges[key];
    if (edge.face2 !== void 0) {
      normal1 = faces[edge.face1].normal;
      normal2 = faces[edge.face2].normal;
      dot3 = dotVec3(normal1, normal2);
      if (dot3 > thresholdDot) {
        continue;
      }
    }
    ia = indicesReverseLookup[edge.index1];
    ib = indicesReverseLookup[edge.index2];
    if (!largeIndex && ia > 65535 || ib > 65535) {
      largeIndex = true;
    }
    edgeIndices.push(ia);
    edgeIndices.push(ib);
  }
  return largeIndex ? new Uint32Array(edgeIndices) : new Uint16Array(edgeIndices);
}

// ../sdk/src/scene/compressGeometryParams.ts
var rtcCenter = createVec3();
function compressGeometryParams(geometryParams) {
  const rtcNeeded = false;
  const aabb = collapseAABB3();
  expandAABB3Points3(aabb, geometryParams.positions);
  const positionsCompressed = quantizePositions3(geometryParams.positions, aabb);
  if (geometryParams.primitive === PointsPrimitive) {
    return {
      id: geometryParams.id,
      primitive: PointsPrimitive,
      aabb,
      uvsDecompressMatrix: void 0,
      positionsCompressed,
      colorsCompressed: geometryParams.colorsCompressed ? geometryParams.colorsCompressed : geometryParams.colors ? compressRGBColors(geometryParams.colors) : null,
      origin: rtcNeeded ? rtcCenter : null
    };
  }
  if (geometryParams.primitive === LinesPrimitive) {
    return {
      id: geometryParams.id,
      primitive: LinesPrimitive,
      aabb,
      positionsCompressed,
      indices: geometryParams.indices,
      origin: rtcNeeded ? rtcCenter : null
    };
  } else {
    const edgeIndices = (geometryParams.primitive === SolidPrimitive || geometryParams.primitive === SurfacePrimitive || geometryParams.primitive === TrianglesPrimitive) && geometryParams.indices ? buildEdgeIndices(positionsCompressed, geometryParams.indices, aabb, 10) : null;
    return {
      // Assume that closed triangle mesh is decomposed into open surfaces
      id: geometryParams.id,
      primitive: geometryParams.primitive,
      aabb,
      positionsCompressed,
      indices: geometryParams.indices,
      edgeIndices,
      origin: rtcNeeded ? rtcCenter : null
    };
  }
}

// ../sdk/src/scene/SceneModel.ts
var COLOR_TEXTURE = 0;
var METALLIC_ROUGHNESS_TEXTURE = 1;
var NORMALS_TEXTURE = 2;
var EMISSIVE_TEXTURE = 3;
var OCCLUSION_TEXTURE = 4;
var TEXTURE_ENCODING_OPTIONS = {};
TEXTURE_ENCODING_OPTIONS[COLOR_TEXTURE] = {
  useSRGB: true,
  qualityLevel: 50,
  encodeUASTC: true,
  mipmaps: true
};
TEXTURE_ENCODING_OPTIONS[EMISSIVE_TEXTURE] = {
  useSRGB: true,
  encodeUASTC: true,
  qualityLevel: 10,
  mipmaps: false
};
TEXTURE_ENCODING_OPTIONS[METALLIC_ROUGHNESS_TEXTURE] = {
  useSRGB: false,
  encodeUASTC: true,
  qualityLevel: 50,
  mipmaps: true
  // Needed for GGX roughness shading
};
TEXTURE_ENCODING_OPTIONS[NORMALS_TEXTURE] = {
  useSRGB: false,
  encodeUASTC: true,
  qualityLevel: 10,
  mipmaps: false
};
TEXTURE_ENCODING_OPTIONS[OCCLUSION_TEXTURE] = {
  useSRGB: false,
  encodeUASTC: true,
  qualityLevel: 10,
  mipmaps: false
};
var SceneModel = class extends Component {
  /**
   * Indicates what renderer resources will need to be allocated in a {@link viewer!Viewer | Viewer's}
   * {@link viewer!Renderer | Renderer} to support progressive loading for the {@link SceneModel | SceneModel}.
   *
   * See {@link scene | @xeokit/sdk/scene}   for usage.
   */
  streamParams;
  /**
   * The {@link Scene | Scene} that contains this SceneModel.
   */
  scene;
  /**
   * If we want to view this SceneModel with a {@link viewer!Viewer | Viewer}, an
   * optional ID of a {@link viewer!ViewLayer | ViewLayer} to view it in.
   */
  layerId;
  /**
   * Indicates if this SceneModel has already been built.
   *
   * * Set ````true```` by {@link SceneModel.build | SceneModel.build}.
   * * Subscribe to updates using {@link SceneModel.onBuilt | SceneModel.onBuilt}
   * and {@link Scene.onModelCreated | Scene.onModelCreated}.
   * * Don't create anything more in this SceneModel once it's built.
   */
  built;
  /**
   * The edge threshold for automatic [edge primitive generation](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#geometry-edge-generation).
   */
  edgeThreshold;
  /**
   * {@link SceneGeometry | Geometries} within this SceneModel, each mapped to {@link SceneGeometry.id | SceneGeometry.id}.
   *
   * * Created by {@link SceneModel.createGeometry | SceneModel.createGeometry}.
   */
  geometries;
  /**
   * {@link SceneTexture | Textures} within this SceneModel, each mapped to {@link SceneTexture.id | SceneTexture.id}.
   *
   * * Created by {@link SceneModel.createTexture | SceneModel.createTexture}.
   * * Compressed asynchronously in {@link SceneModel.build | SceneModel.build}.
   */
  textures;
  /**
   * {@link SceneTextureSet | TextureSets} within this SceneModel, each mapped to {@link SceneTextureSet.id | SceneTextureSet.id}.
   *
   * * Created by {@link SceneModel.createTextureSet | SceneModel.createTextureSet}.
   */
  textureSets;
  /**
   * The {@link SceneTile | Tiles} used by this SceneModel, each mapped to {@link SceneTile.id | SceneTile.id}.
   */
  tiles;
  /**
   * The {@link SceneTile | Tiles} used by this SceneModel.
   */
  tilesList;
  /**
   * {@link SceneMesh | SceneMeshes} within this SceneModel, each mapped to {@link SceneMesh.id | SceneMesh.id}.
   *
   * * Created by {@link SceneModel.createMesh | SceneModel.createMesh}.
   */
  meshes;
  /**
   * {@link SceneObject | SceneObjects} within this SceneModel, each mapped to {@link SceneObject.id | SceneObject.id}.
   *
   * * Created by {@link SceneModel.createObject | SceneModel.createObject}.
   */
  objects;
  /**
   * List of {@link SceneObject | SceneObjects} within this SceneModel.
   *
   * * Created by {@link SceneModel.createObject | SceneModel.createObject}.
   */
  objectsList;
  /**
   * Emits an event when this {@link SceneModel | SceneModel} has been built.
   *
   * * Triggered by {@link SceneModel.build | SceneModel.build}.
   *
   * @event onBuilt
   */
  onBuilt;
  /**
   *  Internal interface through which a SceneModel can load updated content into a renderers.
   *
   * @internal
   */
  rendererModel;
  /**
   * Statistics on this SceneModel.
   */
  stats;
  /**
   * Whether this SceneModel retains {@link SceneObject | SceneObjects}, {@link SceneMesh | SceneMeshes},
   * {@link SceneGeometry | SceneGeometries} etc after we call {@link SceneModel.build | SceneModel.build}.
   *
   * Default value is `true`.
   */
  retained;
  #texturesList;
  #numObjects;
  #meshUsedByObject;
  #aabb;
  #aabbDirty;
  /**
   * @private
   */
  constructor(scene, sceneModelParams) {
    super(scene, {
      id: sceneModelParams.id
    });
    this.scene = scene;
    this.tiles = {};
    this.tilesList = [];
    this.onBuilt = new EventEmitter(new import_strongly_typed_events5.EventDispatcher());
    this.onDestroyed = new EventEmitter(new import_strongly_typed_events5.EventDispatcher());
    this.#numObjects = 0;
    this.#meshUsedByObject = {};
    this.#aabb = createAABB3();
    this.#aabbDirty = true;
    this.streamParams = sceneModelParams.streamParams;
    this.globalizedIds = !!sceneModelParams.globalizedIds;
    this.id = sceneModelParams.id || "default";
    this.layerId = sceneModelParams.layerId;
    this.edgeThreshold = 10;
    this.geometries = {};
    this.textures = {};
    this.#texturesList = [];
    this.textureSets = {};
    this.meshes = {};
    this.objects = {};
    this.objectsList = [];
    this.built = false;
    this.rendererModel = null;
    this.stats = {
      numGeometries: 0,
      numLines: 0,
      numMeshes: 0,
      numObjects: 0,
      numPoints: 0,
      numTextureSets: 0,
      numTextures: 0,
      numTriangles: 0,
      numVertices: 0,
      textureBytes: 0
    };
    this.fromParams(sceneModelParams);
    this.retained = sceneModelParams.retained !== false;
  }
  /**
   * Creates a new {@link SceneTexture} within this SceneModel.
   *
   * * Stores the new {@link SceneTexture} in {@link SceneModel.textures | SceneModel.textures}.
   * * Textures are compressed asynchronously by {@link SceneModel.build | SceneModel.build}.
   *
   * ### Usage
   *
   * ````javascript
   * const texture = sceneModel.createTexture({
   *      id: "myColorTexture",
   *      src: // Path to JPEG, PNG, KTX2,
   *      image: // HTMLImageElement,
   *      buffers: // ArrayBuffer[] containing KTX2 MIP levels
   *      preloadColor: [1,0,0,1],
   *      flipY: false,
   *      encoding: LinearEncoding, // @xeokit/constants
   *      magFilter: LinearFilter,
   *      minFilter: LinearFilter,
   *      wrapR: ClampToEdgeWrapping,
   *      wrapS: ClampToEdgeWrapping,
   *      wrapT: ClampToEdgeWrapping,
   * });
   *
   * const textureAgain = sceneModel.textures["myColorTexture"];
   * ````
   *
   * See {@link scene | @xeokit/sdk/scene} for more usage info.
   *
   * @param textureParams - SceneTexture creation parameters.
   * @returns *{@link SceneTexture}*
   * * On success.
   * @returns *{@link core!SDKError | SDKError}*
   * * If SceneModel has already been built or destroyed.
   * * Invalid SceneTextureParams were given.
   * * SceneTexture with given ID already exists in this Scene.
   */
  createTexture(textureParams) {
    if (this.destroyed) {
      return new SDKError("Failed to create SceneTexture in SceneModel - SceneModel already destroyed");
    }
    if (this.built) {
      return new SDKError("Failed to create SceneTexture in SceneModel - SceneModel already built");
    }
    if (!textureParams.imageData && !textureParams.src && !textureParams.buffers) {
      return new SDKError("Failed to create SceneTexture in SceneModel - Parameter expected: textureParams.imageData, textureParams.src or textureParams.buffers");
    }
    if (this.textures[textureParams.id]) {
      return new SDKError(`Failed to create Texture in SceneModel - Texture already exists with this ID: ${textureParams.id}`);
    }
    if (textureParams.src) {
      const fileExt = textureParams.src.split(".").pop();
    }
    if (textureParams.imageData) {
      this.stats.textureBytes += textureParams.imageData.width * textureParams.imageData.height * 4;
    }
    const texture = new SceneTexture(textureParams);
    this.textures[textureParams.id] = texture;
    this.#texturesList.push(texture);
    this.stats.numTextures++;
    return texture;
  }
  /**
   * Creates a new {@link SceneTextureSet} within this SceneModel.
   *
   * * Stores the new {@link SceneTextureSet} in {@link SceneModel.textureSets | SceneModel.textureSets}.
   *
   * ### Usage
   *
   * ````javascript
   * const textureSet = sceneModel.createTextureSet({
   *      id: "myTextureSet",
   *      colorTextureId: "myColorTexture"
   * });
   *
   * const textureSetAgain = sceneModel.textureSets["myTextureSet"];
   * ````
   *
   * See {@link scene | @xeokit/sdk/scene}   for more usage info.
   *
   * @param textureSetParams SceneTextureSet creation parameters.
   *
   * @returns *{@link SceneTextureSet}*
   * * On success.
   * @returns *{@link core!SDKError | SDKError}*
   * * If SceneModel has already been built or destroyed.
   * * Invalid SceneTextureSetParams were given.
   * * SceneTextureSet with given ID already exists in this SceneModel.
   * * One or more of the given Textures could not be found in this SceneModel.
   */
  createTextureSet(textureSetParams) {
    if (this.destroyed) {
      return new SDKError("Failed to create SceneTextureSet in SceneModel - SceneModel already destroyed");
    }
    if (this.built) {
      return new SDKError("Failed to create SceneTextureSet in SceneModel - SceneModel already built");
    }
    if (this.textureSets[textureSetParams.id]) {
      return new SDKError(`Failed to create TextureSet in SceneModel - TextureSet already exists with this ID: ${textureSetParams.id}`);
    }
    let colorTexture;
    if (textureSetParams.colorTextureId !== void 0 && textureSetParams.colorTextureId !== null) {
      colorTexture = this.textures[textureSetParams.colorTextureId];
      if (!colorTexture) {
        return new SDKError(`Failed to create TextureSet in SceneModel - Texture not found: ${textureSetParams.colorTextureId} - ensure that you create it first with createTexture()`);
      }
      colorTexture.channel = COLOR_TEXTURE;
    }
    let metallicRoughnessTexture;
    if (textureSetParams.metallicRoughnessTextureId !== void 0 && textureSetParams.metallicRoughnessTextureId !== null) {
      metallicRoughnessTexture = this.textures[textureSetParams.metallicRoughnessTextureId];
      if (!metallicRoughnessTexture) {
        return new SDKError(`Failed to create TextureSet in SceneModel - Texture not found: ${textureSetParams.metallicRoughnessTextureId} - ensure that you create it first with createTexture()`);
      }
      metallicRoughnessTexture.channel = METALLIC_ROUGHNESS_TEXTURE;
    }
    let normalsTexture;
    if (textureSetParams.normalsTextureId !== void 0 && textureSetParams.normalsTextureId !== null) {
      normalsTexture = this.textures[textureSetParams.normalsTextureId];
      if (!normalsTexture) {
        return new SDKError(`Failed to create TextureSet in SceneModel - Texture not found: ${textureSetParams.normalsTextureId} - ensure that you create it first with createTexture()`);
      }
      normalsTexture.channel = NORMALS_TEXTURE;
    }
    let emissiveTexture;
    if (textureSetParams.emissiveTextureId !== void 0 && textureSetParams.emissiveTextureId !== null) {
      emissiveTexture = this.textures[textureSetParams.emissiveTextureId];
      if (!emissiveTexture) {
        return new SDKError(`Failed to create TextureSet in SceneModel - Texture not found: ${textureSetParams.emissiveTextureId} - ensure that you create it first with createTexture()`);
      }
      emissiveTexture.channel = EMISSIVE_TEXTURE;
    }
    let occlusionTexture;
    if (textureSetParams.occlusionTextureId !== void 0 && textureSetParams.occlusionTextureId !== null) {
      occlusionTexture = this.textures[textureSetParams.occlusionTextureId];
      if (!occlusionTexture) {
        return new SDKError(`Failed to create TextureSet in SceneModel - Texture not found: ${textureSetParams.occlusionTextureId} - ensure that you create it first with createTexture()`);
      }
      occlusionTexture.channel = OCCLUSION_TEXTURE;
    }
    const textureSet = new SceneTextureSet(textureSetParams, {
      emissiveTexture,
      occlusionTexture,
      metallicRoughnessTexture,
      colorTexture
    });
    this.textureSets[textureSetParams.id] = textureSet;
    this.stats.numTextureSets++;
    return textureSet;
  }
  /**
   * Creates a new {@link SceneGeometry} within this SceneModel, from non-compressed geometry parameters.
   *
   * * Stores the new {@link SceneGeometry} in {@link SceneModel.geometries | SceneModel.geometries}.
   *
   * ### Usage
   *
   * ````javascript
   * const boxGeometry = sceneModel.createGeometry({
   *      id: "boxGeometry",
   *      primitive: TrianglesPrimitive, // @xeokit/constants
   *      positions: [
   *          1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, // v0-v1-v2-v3 front
   *          1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, // v0-v3-v4-v1 right
   *          1, 1, 1, 1, 1, -1, -1, 1, -1, -1, 1, 1, // v0-v1-v6-v1 top
   *          -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, // v1-v6-v7-v2 left
   *          -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1,// v7-v4-v3-v2 bottom
   *          1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1 // v4-v7-v6-v1 back
   *      ],
   *      indices: [
   *          0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15,
   *          16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23
   *      ]
   *  });
   *
   * if (boxGeometry instanceof SDKError) {
   *     console.log(boxGeometry.message);
   * } else {
   *      const boxGeometryAgain = sceneModel.geometries["boxGeometry"];
   * }
   * ````
   *
   * See {@link scene | @xeokit/sdk/scene}   for more usage info.
   *
   * @param geometryParams Non-compressed geometry parameters.
   * @returns *{@link SceneGeometry}*
   *  * On success.
   * @returns *{@link core!SDKError | SDKError}*
   * * If this SceneModel has already been destroyed.
   * * If this SceneModel has already been built.
   * * Invalid SceneGeometryParams were given.
   * * SceneGeometry of given ID already exists in this SceneModel.
   * * Unsupported primitive type given.
   * * Mandatory vertex positions were not given. Vertex positions are mandatory for all primitive types.
   * * Mandatory indices were not given for primitive type that is not {@link constants!PointsPrimitive}. Indices are mandatory for all primitive types except PointsPrimitive.
   * * Indices out of range of vertex positions.
   * * Indices out of range of vertex UVs.
   * * Mismatch between given quantities of vertex positions and UVs.
   */
  createGeometry(geometryParams) {
    if (this.destroyed) {
      return new SDKError("Failed to create SceneGeometry in SceneModel - SceneModel already destroyed");
    }
    if (this.built) {
      return new SDKError("Failed to create SceneGeometry in SceneModel - SceneModel already built");
    }
    if (!geometryParams) {
      return new SDKError("Failed to create SceneGeometry in SceneModel - Parameters expected: geometryParams");
    }
    if (geometryParams.id === null || geometryParams.id === void 0) {
      return new SDKError("Failed to create SceneGeometry in SceneModel - Parameter expected: geometryParams.id");
    }
    const geometryId = geometryParams.id;
    if (this.geometries[geometryId]) {
      return new SDKError(`Failed to create Geometry in SceneModel - Geometry with this ID already created: ${geometryId}`);
    }
    const primitive = geometryParams.primitive;
    if (primitive !== PointsPrimitive && primitive !== LinesPrimitive && primitive !== TrianglesPrimitive && primitive !== SolidPrimitive && primitive !== SurfacePrimitive) {
      return new SDKError(`Failed to create Geometry in SceneModel - Unsupported value for geometryParams.primitive: '${primitive}' - supported values are PointsPrimitive, LinesPrimitive, TrianglesPrimitive, SolidPrimitive and SurfacePrimitive`);
    }
    if (!geometryParams.positions) {
      return new SDKError("Failed to create SceneGeometry in SceneModel - Param expected: geometryParams.positions");
    }
    if (!geometryParams.indices && primitive !== PointsPrimitive) {
      return new SDKError(`Failed to create Geometry in SceneModel - Param expected: geometryParams.indices (required for primitive type)`);
    }
    if (geometryParams.uvs) {
      if (geometryParams.uvs.length / 2 !== geometryParams.positions.length / 3) {
        return new SDKError("Failed to create SceneGeometry in SceneModel - mismatch between given quantities of vertex positions and UVs");
      }
    }
    if (geometryParams.indices) {
      const lastPositionsIdx = geometryParams.positions.length / 3;
      for (let i = 0, len = geometryParams.indices.length; i < len; i++) {
        const idx = geometryParams.indices[i];
        if (idx < 0 || idx >= lastPositionsIdx) {
          return new SDKError("Failed to create SceneGeometry in SceneModel - indices out of range of vertex positions");
        }
        if (geometryParams.uvs) {
          const lastUVsIdx = geometryParams.uvs.length / 2;
          if (idx < 0 || idx >= lastUVsIdx) {
            return new SDKError("Failed to create SceneGeometry in SceneModel - indices out of range of vertex UVs");
          }
        }
      }
    }
    const geometry = new SceneGeometry(compressGeometryParams(geometryParams));
    this.geometries[geometryId] = geometry;
    this.stats.numGeometries++;
    if (geometryParams.indices) {
      if (geometry.primitive === TrianglesPrimitive) {
        this.stats.numTriangles += geometryParams.indices.length / 3;
      } else if (geometry.primitive === LinesPrimitive) {
        this.stats.numLines += geometryParams.indices.length / 2;
      }
    } else if (geometry.primitive === PointsPrimitive) {
      this.stats.numPoints += geometryParams.positions.length / 3;
    }
    this.stats.numVertices += geometryParams.positions.length / 3;
    return geometry;
  }
  /**
   * Creates a new {@link SceneGeometry} within this SceneModel, from pre-compressed geometry parameters.
   *
   * * Stores the new {@link SceneGeometry} in {@link SceneModel.geometries | SceneModel.geometries}.
   * * Use {@link compressGeometryParams | compressGeometryParams} to pre-compress {@link SceneGeometryParams | SceneGeometryParams}
   * into {@link SceneGeometryCompressedParams | SceneGeometryCompressedParams}.
   *
   * ### Usage
   *
   * ````javascript
   * const boxGeometry = sceneModel.createGeometryCompressed({
   *      id: "boxGeometry",
   *      primitive: TrianglesPrimitive, // @xeokit/constants
   *      aabb: [-1,-1,-1, 1,1,1],
   *      positionsCompressed: [
   *          65525, 65525, 65525, 0, 65525, 65525, 0, 0,
   *          65525, 65525, 0, 65525, 65525, 0, 0, 65525,
   *          65525, 0, 0, 65525, 0, 0, 0, 0
   *      ],
   *      indices: [
   *          0, 1, 2, 0, 2, 3, 0, 3, 4, 0, 4, 5, 0, 5, 6,
   *          0, 6, 1, 1, 6, 7, 1, 7, 2, 7, 4, 3, 7, 3, 2,
   *          4, 7, 6, 4, 6, 5
   *      ]
   * });
   *
   * if (boxGeometry instanceof SDKError) {
   *     console.log(boxGeometry.message);
   * } else {
   *      const boxGeometryAgain = sceneModel.geometries["boxGeometry"];
   * }
   * ````
   *
   * See {@link scene | @xeokit/sdk/scene}   for more usage info.
   *
   * @param geometryCompressedParams Pre-compressed geometry parameters.
   * @returns *{@link SceneGeometry}*
   * * On success.
   * @returns *{@link core!SDKError | SDKError}*
   * * If this SceneModel has already been destroyed.
   * * If this SceneModel has already been built.
   * * Invalid SceneGeometryParams were given.
   * * SceneGeometry of given ID already exists in this SceneModel.
   * * Unsupported primitive type given.
   * * Mandatory vertex positions were not given. Vertex positions are mandatory for all primitive types.
   * * Mandatory indices were not given for primitive type that is not {@link constants!PointsPrimitive}. Indices are mandatory for all primitive types except PointsPrimitive.
   * * Indices out of range of vertex positions.
   * * Indices out of range of vertex UVs.
   * * Mismatch between given quantities of vertex positions and UVs.
   */
  createGeometryCompressed(geometryCompressedParams) {
    if (this.destroyed) {
      return new SDKError("Failed to add compressed SceneGeometry to SceneModel - SceneModel already destroyed");
    }
    if (this.built) {
      return new SDKError("Failed to add compressed SceneGeometry to SceneModel - SceneModel already built");
    }
    if (!geometryCompressedParams) {
      return new SDKError("Failed to add compressed SceneGeometry to SceneModel - Parameters expected: geometryCompressedParams");
    }
    const geometryId = geometryCompressedParams.id;
    if (this.geometries[geometryId]) {
      return new SDKError(`Failed to add compressed Geometry to SceneModel - Geometry with this ID already created: ${geometryId}`);
    }
    const primitive = geometryCompressedParams.primitive;
    if (primitive !== PointsPrimitive && primitive !== LinesPrimitive && primitive !== TrianglesPrimitive && primitive !== SolidPrimitive && primitive !== SurfacePrimitive) {
      return new SDKError(`Failed to add compressed Geometry to SceneModel - Unsupported value for geometryCompressedParams.primitive: '${primitive}' - supported values are PointsPrimitive, LinesPrimitive, TrianglesPrimitive, SolidPrimitive and SurfacePrimitive`);
    }
    const geometry = new SceneGeometry(geometryCompressedParams);
    this.geometries[geometryId] = geometry;
    this.stats.numGeometries++;
    return geometry;
  }
  /**
   * Creates a new {@link SceneMesh} within this SceneModel.
   *
   * * Stores the new {@link SceneMesh} in {@link SceneModel.meshes | SceneModel.meshes}.
   * * A {@link SceneMesh} can be owned by one {@link SceneObject}, which can own multiple {@link SceneMesh}es.
   *
   * ### Usage
   *
   * ````javascript
   * const redBoxMesh = sceneModel.createLayerMesh({
   *      id: "redBoxMesh",
   *      geometryId: "boxGeometry",
   *      textureSetId: "myTextureSet",
   *      position: [-4, -6, -4],
   *      scale: [1, 3, 1],
   *      rotation: [0, 0, 0],
   *      color: [1, 0.3, 0.3]
   * });
   *
   * if (redBoxMesh instanceof SDKError) {
   *      console.log(redBoxMesh.message);
   * } else {
   *      const redBoxMeshAgain = sceneModel.meshes["redBoxMesh"];
   * }
   * ````
   *
   * See {@link scene | @xeokit/sdk/scene}   for more usage info.
   *
   * @param meshParams Pre-compressed mesh parameters.
   * @returns *{@link SceneMesh}*
   *  * On success.
   * @returns *{@link core!SDKError | SDKError}*
   * * If this SceneModel has already been destroyed.
   * * If this SceneModel has already been built.
   * * Invalid SceneMeshParams were given.
   * * SceneMesh of given ID already exists in this SceneModel.
   * * Specified SceneGeometry could not be found in this SceneModel.
   * * Specified SceneTextureSet could not be found in this SceneModel.
   */
  createMesh(meshParams) {
    if (this.destroyed) {
      return new SDKError("Failed to create SceneMesh in SceneModel - SceneModel already destroyed");
    }
    if (this.built) {
      return new SDKError("Failed to create SceneMesh in SceneModel - SceneModel already built");
    }
    if (this.meshes[meshParams.id]) {
      return new SDKError(`Failed to create SceneMesh in SceneModel - SceneMesh already exists with this ID: ${meshParams.id}`);
    }
    const geometry = this.geometries[meshParams.geometryId];
    if (!geometry) {
      return new SDKError(`Failed to create SceneMesh in SceneModel - Geometry not found: ${meshParams.geometryId}`);
    }
    const textureSet = meshParams.textureSetId ? this.textureSets[meshParams.textureSetId] : void 0;
    if (meshParams.textureSetId && !textureSet) {
      return new SDKError(`Failed to create SceneMesh in SceneModel - TextureSet not found: ${meshParams.textureSetId}`);
    }
    let matrix = meshParams.matrix;
    if (!matrix) {
      const position = meshParams.position;
      const scale3 = meshParams.scale;
      const rotation = meshParams.rotation;
      const quaternion = meshParams.quaternion;
      if (position || scale3 || rotation || quaternion) {
        matrix = identityMat4();
        composeMat4(position || [0, 0, 0], quaternion || eulerToQuat(rotation || [0, 0, 0], "XYZ", identityQuat()), scale3 || [1, 1, 1], matrix);
      } else {
        matrix = identityMat4();
      }
    } else {
      matrix = matrix.slice();
    }
    let origin;
    let rtcMatrix;
    if (meshParams.origin) {
      origin = meshParams.origin;
      rtcMatrix = matrix;
    } else {
      origin = createVec3();
      rtcMatrix = createRTCModelMat(matrix, origin);
    }
    const tile = this.scene.getTile(origin);
    if (!this.tiles[tile.id]) {
      this.tiles[tile.id] = tile;
      this.tilesList.push(tile);
    }
    const mesh = new SceneMesh({
      id: meshParams.id,
      geometry,
      textureSet,
      matrix,
      rtcMatrix,
      color: meshParams.color,
      opacity: meshParams.opacity,
      tile
    });
    geometry.numMeshes++;
    this.meshes[meshParams.id] = mesh;
    this.stats.numMeshes++;
    return mesh;
  }
  /**
   * Creates a new {@link SceneObject}.
   *
   * * Stores the new {@link SceneObject} in {@link SceneModel.objects | SceneModel.objects} and {@link Scene.objects | Scene.objects}.
   * * Each {@link SceneMesh} is allowed to belong to one SceneObject.
   * * SceneObject IDs must be unique within the SceneModel's {@link Scene | Scene}.
   *
   * ### Usage
   *
   * ````javascript
   * const redBoxObject = sceneModel.createObject({
   *     id: "redBoxObject",
   *     meshIds: ["redBoxMesh"]
   * });
   *
   * if (redBoxObject instanceof SDKError) {
   *      console.log(redBoxObject.message);
   * } else {
   *      const redBoxObjectAgain = sceneModel.objects["redBoxObject"];
   *      const redBoxObjectOnceMore = scene.objects["redBoxObject"];
   * }
   * ````
   *
   * See {@link scene | @xeokit/sdk/scene}   for more usage info.
   *
   * @param objectParams SceneObject parameters.
   * @returns *{@link SceneObject}*
   * * On success.
   * @returns *{@link core!SDKError | SDKError}*
   * * If this SceneModel has already been destroyed.
   * * If this SceneModel has already been built.
   * * Invalid ObjectParams were given.
   * * SceneObject of given ID already exists in this SceneModel's Scene. Note that SceneObject IDs must be unique within the Scene.
   * * No Meshes were specified.
   * * One or more of the specified Meshes already belong to another SceneObject in this SceneModel.
   * * Specified Meshes could not be found in this SceneModel.
   */
  createObject(objectParams) {
    if (this.destroyed) {
      return new SDKError("Failed to create SceneObject - SceneModel already destroyed");
    }
    if (this.built) {
      return new SDKError("Failed to create SceneObject SceneModel already built");
    }
    if (objectParams.meshIds.length === 0) {
      return new SDKError("Failed to create SceneObject - no meshes specified");
    }
    const objectId = this.globalizedIds ? `${this.id}.${objectParams.id}` : objectParams.id;
    if (this.scene.objects[objectId]) {
      return new SDKError(`Failed to create SceneObject - SceneObject already exists in Scene: ${objectId}`);
    }
    const meshIds = objectParams.meshIds;
    const meshes = [];
    for (let meshIdIdx = 0, meshIdLen = meshIds.length; meshIdIdx < meshIdLen; meshIdIdx++) {
      const meshId = meshIds[meshIdIdx];
      const mesh = this.meshes[meshId];
      if (!mesh) {
        return new SDKError(`Failed to create SceneObject - SceneMesh not found: ${meshId}`);
      }
      if (this.#meshUsedByObject[meshId]) {
        return new SDKError(`Failed to create SceneObject - SceneMesh ${meshId} already belongs to another SceneObject`);
      }
      meshes.push(mesh);
      this.#meshUsedByObject[mesh.id] = true;
    }
    const sceneObject = new SceneObject({
      id: objectId,
      originallSystemId: objectParams.originalSystemId,
      layerId: this.layerId || objectParams.layerId,
      model: this,
      meshes
    });
    for (let i = 0, len = meshes.length; i < len; i++) {
      const mesh = meshes[i];
      mesh.object = sceneObject;
    }
    this.#numObjects++;
    this.objects[objectId] = sceneObject;
    this.objectsList.push(sceneObject);
    this.stats.numObjects++;
    return sceneObject;
  }
  /**
   * Finalizes this SceneModel, readying it for use.
   *
   * * Fires an event via {@link SceneModel.onBuilt | SceneModel.onBuilt} and {@link Scene.onModelCreated | SceneModel.onCreated}, to indicate to subscribers that
   * the SceneModel is complete and ready to use.
   * * Sets {@link SceneModel.built | SceneModel.built} ````true````.
   * * You can only call this method once on a SceneModel.
   * * The SceneModel must have at least one {@link SceneObject}.
   * * Once built, no more components can be created in a SceneModel.
   *
   * ### Usage
   *
   * ````javascript
   * sceneMode.onBuilt.subscribe(()=>{
   *     // Our SceneModel is built and ready to use
   * });
   *
   * myScene.onModelCreated.subscribe((sceneModel)=>{
   *     // Another way to subscribe to SceneModel readiness
   * });
   *
   * mySceneModel.build().then((result) => { // Asynchronous (texture compression etc).
   *      if (result instanceof SDKError) {
   *          console.log(result.message);
   *      }  else {
   *          // Now we can do things with our SceneModel
   *      }
   * }).catch(sdkError) {// SDKError
   *     console.log(sdkError.message);
   * };
   * ````
   *
   * See {@link scene | @xeokit/sdk/scene}   for more usage info.
   *
   * @throws *{@link core!SDKError | SDKError}*
   * * If SceneModel has already been built or destroyed.
   * * If no SceneObjects were created in this SceneModel.
   */
  build() {
    return new Promise((resolve2) => {
      if (this.destroyed) {
        throw new SDKError("Failed to build SceneModel - SceneModel already destroyed");
      }
      if (this.built) {
        throw new SDKError("Failed to build SceneModel - SceneModel already built");
      }
      this.#removeUnusedComponents();
      this.built = true;
      this.onBuilt.dispatch(this, null);
      resolve2(this);
    });
  }
  #removeUnusedComponents() {
    for (let id in this.meshes) {
      const mesh = this.meshes[id];
      if (!mesh.object) {
        mesh.geometry.numMeshes--;
        delete this.meshes[id];
      }
    }
    for (let id in this.geometries) {
      if (this.geometries[id].numMeshes === 0) {
        delete this.geometries[id];
      }
    }
  }
  /**
   * Gets the axis-aligned 3D World-space boundary of this SceneModel.
   */
  get aabb() {
    if (this.objectsList.length === 1) {
      return this.objectsList[0].aabb;
    }
    if (this.#aabbDirty) {
      if (!this.#aabb) {
        this.#aabb = collapseAABB3();
      } else {
        collapseAABB3(this.#aabb);
      }
      for (let i = 0, len = this.objectsList.length; i < len; i++) {
        expandAABB3(this.#aabb, this.objectsList[i].aabb);
      }
      this.#aabbDirty = false;
    }
    return this.#aabb;
  }
  /**
   * Creates components in this SceneModel from SceneModelParams.
   *
   * See {@link scene | @xeokit/sdk/scene} for usage.
   *
   * @param sceneModelParams
   * @returns *void*
   * * On success.
   * @returns *{@link core!SDKError | SDKError}*
   * * If this SceneModel has already been built.
   * * If this SceneModel has already been destroyed.
   * * A duplicate component ({@link SceneObject}, {@link SceneMesh},
   * {@link SceneGeometry}, {@link SceneTexture} etc.) was already created within this SceneModel.
   */
  fromParams(sceneModelParams) {
    if (this.destroyed) {
      return new SDKError("Failed to add components to SceneModel - SceneModel already destroyed");
    }
    if (this.built) {
      return new SDKError("Failed to add components to SceneModel - SceneModel already built");
    }
    if (sceneModelParams.geometries) {
      for (let i = 0, len = sceneModelParams.geometries.length; i < len; i++) {
        this.createGeometry(sceneModelParams.geometries[i]);
      }
    }
    if (sceneModelParams.geometriesCompressed) {
      for (let i = 0, len = sceneModelParams.geometriesCompressed.length; i < len; i++) {
        this.createGeometryCompressed(sceneModelParams.geometriesCompressed[i]);
      }
    }
    if (sceneModelParams.textures) {
      for (let i = 0, len = sceneModelParams.textures.length; i < len; i++) {
        this.createTexture(sceneModelParams.textures[i]);
      }
    }
    if (sceneModelParams.textureSets) {
      for (let i = 0, len = sceneModelParams.textureSets.length; i < len; i++) {
        this.createTextureSet(sceneModelParams.textureSets[i]);
      }
    }
    if (sceneModelParams.meshes) {
      for (let i = 0, len = sceneModelParams.meshes.length; i < len; i++) {
        this.createMesh(sceneModelParams.meshes[i]);
      }
    }
    if (sceneModelParams.objects) {
      for (let i = 0, len = sceneModelParams.objects.length; i < len; i++) {
        this.createObject(sceneModelParams.objects[i]);
      }
    }
  }
  /**
   * Gets this SceneModel as SceneModelParams.
   *
   * See {@link scene | @xeokit/sdk/scene} for usage.
   */
  toParams() {
    const sceneModelParams = {
      id: this.id,
      geometriesCompressed: [],
      textures: [],
      textureSets: [],
      transforms: [],
      meshes: [],
      objects: []
    };
    if (this.streamParams) {
      sceneModelParams.streamParams = this.streamParams;
    }
    Object.entries(this.geometries).forEach(([key, sceneGeometry]) => {
      sceneModelParams.geometriesCompressed.push(sceneGeometry.toParams());
    });
    Object.entries(this.meshes).forEach(([key, sceneMesh]) => {
      sceneModelParams.meshes.push(sceneMesh.toParams());
    });
    Object.entries(this.objects).forEach(([key, sceneObject]) => {
      sceneModelParams.objects.push(sceneObject.toParams());
    });
    return sceneModelParams;
  }
  /**
   * Destroys this SceneModel.
   *
   * Sets {@link Component.destroyed} ````true````.
   */
  destroy() {
    for (let i = 0, len = this.tilesList.length; i < len; i++) {
      this.scene.putTile(this.tilesList[i]);
    }
    this.onDestroyed.dispatch(this, null);
    super.destroy();
  }
  // #compressTextures(): Promise<any> {
  //     let countTextures = this.#texturesList.length;
  //     return new Promise<void>((resolve) => {
  //         if (countTextures === 0) {
  //             resolve();
  //             return;
  //         }
  //         for (let i = 0, leni = this.#texturesList.length; i < leni; i++) {
  //             const texture = this.#texturesList[i];
  //             const encodingOptions = TEXTURE_ENCODING_OPTIONS[texture.channel] || {};
  //             if (texture.src) {  // SceneTexture created with SceneModel#createTexture({ src: ... })
  //                 const src = texture.src;
  //                 const fileExt = src.split('.').pop();
  //                 switch (fileExt) {
  //                     case "jpeg":
  //                     case "jpg":
  //                     case "png":
  //
  //                         load(src, ImageLoader, {
  //                             image: {
  //                                 type: "data"
  //                             }
  //                         }).then((imageData) => {
  //                             if (texture.compressed) {
  //                                 encode(imageData, KTX2BasisWriter, encodingOptions).then((encodedData) => {
  //                                     const encodedImageData = new Uint8Array(encodedData);
  //                                     this.stats.textureBytes += encodedImageData.byteLength;
  //                                     texture.imageData = encodedImageData;
  //                                     if (--countTextures <= 0) {
  //                                         resolve();
  //                                     }
  //                                 }).catch((err) => {
  //                                     return new SDKError(`Failed to compress texture: ${err}`);
  //                                 });
  //                             } else {
  //                                 texture.imageData = new Uint8Array(1);
  //                                 if (--countTextures <= 0) {
  //                                     resolve();
  //                                 }
  //                             }
  //                         }).catch((err) => {
  //                             return new SDKError(`Failed to load texture image: ${err}`);
  //                         });
  //                         break;
  //                     default:
  //                         if (--countTextures <= 0) {
  //                             resolve();
  //                         }
  //                         break;
  //                 }
  //             }
  //             if (texture.imageData) {// SceneTexture created with SceneModel#createTexture({ imageData: ... })
  //                 if (texture.compressed) {
  //                     encode(texture.imageData, KTX2BasisWriter, encodingOptions)
  //                         .then((encodedImageData) => {
  //                             texture.imageData = new Uint8Array(encodedImageData);
  //                             this.stats.textureBytes += texture.imageData.byteLength;
  //                             if (--countTextures <= 0) {
  //                                 resolve();
  //                             }
  //                         }).catch((err) => {
  //                         return new SDKError(`Failed to compress texture: ${err}`);
  //                     });
  //                 } else {
  //                     texture.imageData = new Uint8Array(1);
  //                     if (--countTextures <= 0) {
  //                         resolve();
  //                     }
  //                 }
  //             }
  //         }
  //     });
  // }
};

// ../sdk/src/io/ModelLoader.ts
var ModelLoader = class {
  /**
   * Filename extensions expected on loaded model files.
   */
  fileNameExtensions;
  /**
   * A parser for each supported schema version.
   */
  parsers;
  /**
   * IDs of supported file schema versions.
   */
  versions;
  /**
   * Identifies the MIME type of files loaded by this parser.
   */
  fileDataType;
  /**
   * Gets the schema version of the given file data.
   */
  getVersion;
  /**
   * @protected
   * @param params
   */
  constructor(params2) {
    this.parsers = params2.parsers || {};
    this.versions = Object.keys(this.parsers);
    this.fileDataType = params2.fileDataType;
    this.getVersion = params2.getVersion;
  }
  /**
   * Loads file data into a {@link scene!SceneModel | SceneModel} and/or a {@link data!DataModel | DataModel}.
   *
   * This method expects the following conditions:
   * - The {@link scene!SceneModel.built | SceneModel.built} and {@link scene!SceneModel.destroyed | SceneModel.destroyed} properties must be `false`.
   * - It does not invoke the {@link scene!SceneModel.build | SceneModel.build} and {@link data!DataModel.build | DataModel.build} methods; those are to be managed by the caller.
   *
   * @param params - The parameters used for loading the file data.
   * @param options - Options for customizing the loading process. These are specific to the Loader subclass.
   * @returns {Promise} Resolves when the file data has been successfully loaded into the SceneModel and/or DataModel.
   *
   * @throws {@link core!SDKError | SDKError}
   * - If the SceneModel has already been destroyed.
   * - If the SceneModel has already been built.
   * - If the DataModel has already been destroyed.
   * - If the DataModel has already been built.
   */
  load(params2, options = {}) {
    return new Promise((resolve2, reject) => {
      if (!params2) {
        return reject("Argument expected: params");
      }
      const { fileData, sceneModel, dataModel } = params2;
      if (!fileData) {
        return reject("Argument expected: fileData");
      }
      if (this.fileDataType === "json" && !isJSONObject(fileData)) {
        return reject("Argument type mismatch: params.fileData should be a JSON object");
      }
      if (sceneModel) {
        if (!(sceneModel instanceof SceneModel)) {
          return reject("Argument type mismatch: params.sceneModel should be a SceneModel");
        }
        if (sceneModel.destroyed) {
          return reject("SceneModel already destroyed");
        }
        if (sceneModel.built) {
          return reject("SceneModel already built");
        }
      }
      if (dataModel) {
        if (!(dataModel instanceof DataModel)) {
          return reject("Argument type mismatch: params.dataModel should be a DataModel");
        }
        if (dataModel.destroyed) {
          return reject("DataModel already destroyed");
        }
        if (dataModel.built) {
          return reject("DataModel already built");
        }
      }
      const version2 = this.getVersion(fileData);
      if (!version2) {
        return reject(`Failed to determine schema version of source file`);
      }
      const parser = this.parsers[version2];
      if (!parser) {
        return reject(`Unsupported source file schema version: ${version2} - supported versions are [${this.versions}]`);
      }
      if (sceneModel || dataModel) {
        parser({ fileData, sceneModel, dataModel }, options).then(() => {
          resolve2();
        }).catch((err2) => {
          reject(`Failed to load source file: ${err2}`);
        });
      } else {
        return resolve2();
      }
    });
  }
};

// ../sdk/src/io/ModelExporter.ts
var ModelExporter = class {
  /**
   * An encoder for each supported schema version.
   */
  encoders;
  /**
   * List of supported schema versions.
   */
  versions;
  /**
   * The default supported schema version.
   */
  defaultVersion;
  /**
   * Data type of the file written by this Exporter.
   */
  fileDataType;
  /**
   * @param params
   */
  constructor(params2) {
    this.encoders = params2.encoders || {};
    this.versions = Object.keys(this.encoders);
    this.fileDataType = params2.fileDataType;
    this.defaultVersion = params2.defaultVersion;
  }
  /**
   * Exports a {@link scene!SceneModel | SceneModel} and/or a {@link data!DataModel | DataModel} to file data.
   *
   * This method expects the following conditions:
   * - The {@link scene!SceneModel.built | SceneModel.built} and {@link scene!SceneModel.destroyed | SceneModel.destroyed} properties must be `false`.
   * - It does not invoke the {@link scene!SceneModel.build | SceneModel.build} and {@link data!DataModel.build | DataModel.build} methods; those are to be managed by the caller.
   *
   * @param params - The parameters used for writing the file data.
    * @param params.sceneModel - The {@link scene!SceneModel | SceneModel} to write.
   * @param params.dataModel - The {@link data!DataModel | DataModel} to write.
   * @param options - Options for customizing the loading process. These are specific to the Exporter subclass.
   * @returns {Promise} Resolves when the SceneModel and/or DataModel has been successfully written.
   *
   * @throws {@link core!SDKError | SDKError}
   * - If the SceneModel has already been destroyed.
   * - If the SceneModel has not been built.
   * - If the DataModel has already been destroyed.
   * - If the DataModel has not been built.
   */
  write(params2, options = {}) {
    return new Promise((resolve2, reject) => {
      if (!params2) {
        return reject("Argument expected: params");
      }
      const { sceneModel, dataModel } = params2;
      if (!sceneModel) {
        return reject("Argument expected: params.sceneModel");
      }
      if (sceneModel.destroyed) {
        return reject("SceneModel already destroyed");
      }
      if (!sceneModel.built) {
        return reject("SceneModel not built");
      }
      if (dataModel) {
        if (!(dataModel instanceof DataModel)) {
          return reject("Argument type mismatch: params.dataModel should be a DataModel");
        }
        if (dataModel.destroyed) {
          return reject("DataModel already destroyed");
        }
        if (!dataModel.built) {
          return reject("DataModel not built");
        }
      }
      const version2 = params2.version || this.defaultVersion;
      const encoder = this.encoders[version2];
      if (!encoder) {
        return reject(`Unsupported target file schema version: ${version2} - supported versions are [${this.versions}]`);
      }
      encoder({ sceneModel, dataModel }, options).then((fileData) => {
        resolve2(fileData);
      }).catch((err2) => {
        reject(`Failed to writer source file: ${err2}`);
      });
    });
  }
};

// ../sdk/src/data/DataModelParamsLoader.ts
var DataModelParamsLoader = class extends ModelLoader {
  /**
   * Constructs a DataModelParamsLoader.
   */
  constructor() {
    super({
      fileDataType: "json",
      parsers: {
        "1.0": parse
      },
      getVersion: (fileData) => {
        return fileData.version || "1.0";
      }
    });
  }
};

// ../sdk/src/data/versions/1_0/encode.ts
function encode(params2, options) {
  return new Promise(function(resolve2, reject) {
    const dataModelParams = params2.dataModel ? params2.dataModel.toParams() : {};
    dataModelParams.version = "1.0";
    return resolve2(dataModelParams);
  });
}

// ../sdk/src/data/DataModelParamsExporter.ts
var DataModelParamsExporter = class extends ModelExporter {
  /**
   * Constructs a DataModelParamsExporter.
   */
  constructor() {
    super({
      fileDataType: "json",
      encoders: {
        "1.0": encode
      },
      defaultVersion: "1.0"
    });
  }
};

// ../sdk/src/scene/index.ts
var scene_exports = {};
__export(scene_exports, {
  Scene: () => Scene,
  SceneGeometry: () => SceneGeometry,
  SceneMesh: () => SceneMesh,
  SceneModel: () => SceneModel,
  SceneModelParamsExporter: () => SceneModelParamsExporter,
  SceneModelParamsLoader: () => SceneModelParamsLoader,
  SceneObject: () => SceneObject,
  SceneTexture: () => SceneTexture,
  SceneTextureSet: () => SceneTextureSet,
  SceneTile: () => SceneTile,
  buildMat4: () => buildMat4,
  compressGeometryParams: () => compressGeometryParams,
  getSceneObjectGeometry: () => getSceneObjectGeometry
});

// ../sdk/src/scene/Scene.ts
var import_strongly_typed_events6 = __toESM(require_dist8());

// ../sdk/src/scene/SceneTile.ts
var SceneTile = class {
  /**
   * Unique ID of this SceneTile.
   */
  id;
  /**
   * The Scene that owns this SceneTile.
   */
  scene;
  /**
   * The 3D World-space origin of this SceneTile.
   */
  origin;
  /**
   * The number of {@link SceneMesh | SceneMeshes} associated with this SceneTile.
   */
  numObjects;
  /**
   * The {@link SceneModel | SceneModels} belonging to this SceneTile, each keyed to
   * its {@link SceneModel.id | SceneModel.id}.
   *
   * A SceneModel can belong to more than one SceneTile.
   */
  models;
  /**
   * The {@link SceneObject | SceneObjects} in this SceneTile,
   * mapped to {@link SceneObject.id | SceneObject.id}.
   *
   * A SceneObject can belong to more than one SceneTile.
   */
  objects;
  /**
   * @private
   * @param scene
   * @param id
   * @param origin
   */
  constructor(scene, id, origin) {
    this.scene = scene;
    this.id = id;
    this.origin = origin;
    this.numObjects = 0;
    this.models = {};
    this.objects = {};
  }
};

// ../sdk/src/scene/Scene.ts
var Scene = class extends Component {
  /**
   * The {@link SceneModel | SceneModels} belonging to this Scene, each keyed to
   * its {@link SceneModel.id | SceneModel.id}.
   */
  models;
  /**
   * The {@link SceneObject | SceneObjects} in this Scene, mapped to {@link SceneObject.id | SceneObject.id}.
   */
  objects;
  /**
   * The {@link SceneTile | SceneTiles} in this Scene.
   */
  tiles;
  /**
   * Emits an event each time a {@link SceneModel | SceneModel} is created in this Scene.
   *
   * @event
   */
  onModelCreated;
  /**
   * Emits an event each time a {@link SceneModel | SceneModel} is destroyed in this Scene.
   *
   * @event
   */
  onModelDestroyed;
  /**
   * Emits an event each time a {@link SceneTile} is created in this Scene.
   *
   * @event
   */
  onTileCreated;
  /**
   * Emits an event each time a {@link SceneTile} is destroyed in this Scene.
   *
   * @event
   */
  onTileDestroyed;
  #onModelBuilts;
  #onModelDestroys;
  #center;
  #aabbDirty;
  #aabb;
  /**
   * Creates a new Scene.
   */
  constructor() {
    super(null, {});
    this.#aabb = createAABB3();
    this.#aabbDirty = true;
    this.models = {};
    this.objects = {};
    this.tiles = {};
    this.#onModelBuilts = {};
    this.#onModelDestroys = {};
    this.onModelCreated = new EventEmitter(new import_strongly_typed_events6.EventDispatcher());
    this.onModelDestroyed = new EventEmitter(new import_strongly_typed_events6.EventDispatcher());
    this.onTileCreated = new EventEmitter(new import_strongly_typed_events6.EventDispatcher());
    this.onTileDestroyed = new EventEmitter(new import_strongly_typed_events6.EventDispatcher());
  }
  /**
   * Gets the collective World-space 3D center of all the {@link SceneModel | SceneModels} in this Scene.
   */
  get center() {
    if (this.#aabbDirty) {
      const aabb = this.aabb;
      this.#center[0] = (aabb[0] + aabb[3]) / 2;
      this.#center[1] = (aabb[1] + aabb[4]) / 2;
      this.#center[2] = (aabb[2] + aabb[5]) / 2;
    }
    return this.#center;
  }
  /**
   * Gets the collective World-space 3D [axis-aligned boundary](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#aabb) of all the {@link SceneModel | SceneModels} in this Scene.
   *
   * The boundary will be of the form ````[xMin, yMin, zMin, xMax, yMax, zMax]````.
   */
  get aabb() {
    if (this.#aabbDirty) {
      let xmin = MAX_DOUBLE;
      let ymin = MAX_DOUBLE;
      let zmin = MAX_DOUBLE;
      let xmax = MIN_DOUBLE;
      let ymax = MIN_DOUBLE;
      let zmax = MIN_DOUBLE;
      let aabb;
      const objects = this.objects;
      let valid = false;
      for (const objectId in objects) {
        if (objects.hasOwnProperty(objectId)) {
          const object = objects[objectId];
          aabb = object.aabb;
          if (aabb[0] < xmin) {
            xmin = aabb[0];
          }
          if (aabb[1] < ymin) {
            ymin = aabb[1];
          }
          if (aabb[2] < zmin) {
            zmin = aabb[2];
          }
          if (aabb[3] > xmax) {
            xmax = aabb[3];
          }
          if (aabb[4] > ymax) {
            ymax = aabb[4];
          }
          if (aabb[5] > zmax) {
            zmax = aabb[5];
          }
          valid = true;
        }
      }
      if (!valid) {
        xmin = -100;
        ymin = -100;
        zmin = -100;
        xmax = 100;
        ymax = 100;
        zmax = 100;
      }
      this.#aabb[0] = xmin;
      this.#aabb[1] = ymin;
      this.#aabb[2] = zmin;
      this.#aabb[3] = xmax;
      this.#aabb[4] = ymax;
      this.#aabb[5] = zmax;
      this.#aabbDirty = false;
    }
    return this.#aabb;
  }
  /**
   * Creates a new {@link SceneModel | SceneModel} in this Scene.
   *
   * Remember to call {@link SceneModel.build | SceneModel.build} when you've finished building or
   * loading the SceneModel. That will
   * fire events via {@link Scene.onModelCreated | Scene.onModelCreated} and {@link SceneModel.onBuilt | SceneModel.onBuilt}, to
   * indicate to any subscribers that the SceneModel is built and ready for use.
   *
   * See {@link scene | @xeokit/sdk/scene}   for more details on usage.
   *
   * @param  sceneModelParams Creation parameters for the new {@link SceneModel | SceneModel}.
   * @returns *{@link SceneModel | SceneModel}*
   * * On success.
   * @returns *{@link core!SDKError | SDKError}*
   * * This Scene has already been destroyed.
   * * A SceneModel with the given ID already exists in this Scene.
   */
  createModel(sceneModelParams) {
    if (this.destroyed) {
      return new SDKError("Scene already destroyed");
    }
    const id = sceneModelParams.id;
    if (this.models[id]) {
      return new SDKError(`SceneModel already created in this Scene: ${id}`);
    }
    const sceneModel = new SceneModel(this, sceneModelParams);
    this.models[id] = sceneModel;
    sceneModel.onDestroyed.one(() => {
      delete this.models[sceneModel.id];
      this.#deregisterObjects(sceneModel);
      this.onModelDestroyed.dispatch(this, sceneModel);
    });
    sceneModel.onBuilt.one(() => {
      this.#registerObjects(sceneModel);
      this.onModelCreated.dispatch(this, sceneModel);
    });
    return sceneModel;
  }
  /**
   * @private
   */
  setAABBDirty() {
    if (!this.#aabbDirty) {
      this.#aabbDirty = true;
    }
  }
  /**
   * Destroys all contained {@link SceneModel | SceneModels}.
   *
   * * Fires {@link Scene.onModelDestroyed | Scene.onModelDestroyed} and
   * {@link SceneModel.onDestroyed | SceneModel.onDestroyed} for each existing SceneModel in this Scene.
   *
   * See {@link scene | @xeokit/sdk/scene}   for usage.
   * @returns *void*
   * * On success.
   * @returns *{@link core!SDKError | SDKError}*
   * * This Scene has already been destroyed.
   */
  clear() {
    if (this.destroyed) {
      return new SDKError("Scene already destroyed");
    }
    for (let id in this.models) {
      this.models[id].destroy();
    }
  }
  /**
   * Destroys this Scene and all contained {@link SceneModel | SceneModels}.
   *
   * * Fires {@link Scene.onModelDestroyed | Scene.onModelDestroyed} and {@link SceneModel.onDestroyed | SceneModel.onDestroyed}
   * for each existing SceneModels in this Data.
   * * Unsubscribes all subscribers to {@link Scene.onModelCreated | Scene.onModelCreated}, {@link Scene.onModelDestroyed | Scene.onModelDestroyed}, {@link SceneModel.onDestroyed | SceneModel.onDestroyed}
   *
   * See {@link scene | @xeokit/sdk/scene}   for usage.
   *
   * @returns *void*
   * * On success.
   * @returns *{@link core!SDKError | SDKError}*
   * * This Scene has already been destroyed.
   */
  destroy() {
    this.clear();
    this.onModelCreated.clear();
    this.onModelDestroyed.clear();
    this.onTileCreated.clear();
    this.onTileDestroyed.clear();
    super.destroy();
  }
  #registerObjects(model) {
    const objects = model.objects;
    for (let id in objects) {
      const object = objects[id];
      this.objects[object.id] = object;
    }
    this.#aabbDirty = true;
  }
  #deregisterObjects(model) {
    const objects = model.objects;
    for (let id in objects) {
      const object = objects[id];
      delete this.objects[object.id];
    }
    this.#aabbDirty = true;
  }
  getTile(origin) {
    const tileId = `${origin[0]}-${origin[1]}-${origin[2]}`;
    let tile = this.tiles[tileId];
    if (tile) {
      tile.numObjects++;
    } else {
      tile = new SceneTile(this, tileId, origin);
      tile.numObjects = 1;
      this.tiles[tileId] = tile;
      this.onTileCreated.dispatch(this, tile);
    }
    return tile;
  }
  putTile(tile) {
    if (this.tiles[tile.id] === void 0) {
      return;
    }
    if (--tile.numObjects <= 0) {
      delete this.tiles[tile.id];
      this.onTileDestroyed.dispatch(this, tile);
    }
  }
};

// ../sdk/src/scene/getSceneObjectGeometry.ts
var GeometryViewImpl = class {
  object;
  mesh;
  meshIndex;
  geometry;
  #positionsDecompressed;
  #positionsWorld;
  constructor() {
    this.object = null;
    this.mesh = null;
    this.meshIndex = 0;
    this.geometry = null;
    this.#positionsDecompressed = null;
    this.#positionsWorld = null;
  }
  get numPrimitives() {
    const primitiveType = this.geometry.primitive;
    const elementsPerPrimitiveType = primitiveType === TrianglesPrimitive ? 3 : primitiveType === LinesPrimitive ? 2 : 1;
    return this.geometry.indices.length / elementsPerPrimitiveType;
  }
  get positionsDecompressed() {
    if (!this.#positionsDecompressed) {
      this.#positionsDecompressed = new Float32Array(this.geometry.positionsCompressed.length);
      decompressPositions3WithAABB3(this.geometry.positionsCompressed, this.geometry.aabb, this.#positionsDecompressed);
    }
    return this.#positionsDecompressed;
  }
  get positionsWorld() {
    if (!this.#positionsWorld) {
      const positionsDecompressed = this.positionsDecompressed;
      this.#positionsWorld = new Float64Array(positionsDecompressed.length);
      transformPositions3(positionsDecompressed, this.mesh.matrix, this.#positionsWorld);
    }
    return this.#positionsWorld;
  }
  get uvsDecompressed() {
    return null;
  }
  reset() {
    this.#positionsDecompressed = null;
    this.#positionsWorld = null;
  }
};
var geometryView = new GeometryViewImpl();
function getSceneObjectGeometry(sceneObject, withEachGeometry) {
  return false;
}

// ../sdk/src/scene/buildMat4.ts
var identityQuaternion = identityQuat();
function buildMat4(params2) {
  const matrix = identityMat4();
  const position = params2.position;
  const scale3 = params2.scale;
  const rotation = params2.rotation;
  const quaternion = params2.quaternion;
  if (position || scale3 || rotation || quaternion) {
    composeMat4(
      position || [0, 0, 0],
      quaternion || (rotation ? eulerToQuat(rotation, "XYZ", identityQuat()) : identityQuaternion),
      scale3 || [1, 1, 1],
      matrix
    );
  }
  return matrix;
}

// ../sdk/src/scene/versions/1_0/parse.ts
function parse2(params2, options) {
  return new Promise(function(resolve2, reject) {
    if (params2.sceneModel && params2.fileData) {
      params2.sceneModel.fromParams(params2.fileData);
    }
    return resolve2();
  });
}

// ../sdk/src/scene/SceneModelParamsLoader.ts
var SceneModelParamsLoader = class extends ModelLoader {
  /**
   * Constructs a SceneModelParamsLoader.
   */
  constructor() {
    super({
      fileDataType: "json",
      parsers: {
        "1.0": parse2
      },
      getVersion: (fileData) => {
        return fileData.version || "1.0";
      }
    });
  }
};

// ../sdk/src/scene/versions/1_0/encode.ts
function encode2(params2, options) {
  return new Promise(function(resolve2, reject) {
    const sceneModelParams = params2.sceneModel ? params2.sceneModel.toParams() : {};
    sceneModelParams.version = "1.0";
    return resolve2(sceneModelParams);
  });
}

// ../sdk/src/scene/SceneModelParamsExporter.ts
var SceneModelParamsExporter = class extends ModelExporter {
  /**
   * Constructs a SceneModelParamsExporter.
   */
  constructor() {
    super({
      fileDataType: "json",
      encoders: {
        "1.0": encode2
      },
      defaultVersion: "1.0"
    });
  }
};

// ../sdk/src/kdtree2/index.ts
var kdtree2_exports = {};
__export(kdtree2_exports, {
  KdTree2: () => KdTree2,
  KdVertex2: () => KdVertex2,
  createKdTree2FromSceneObjectVerts: () => createKdTree2FromSceneObjectVerts,
  searchKdTree2ForNearestNeighbor: () => searchKdTree2ForNearestNeighbor
});

// ../sdk/src/kdtree2/KdTree2.ts
var MAX_KD_TREE_DEPTH = 10;
var kdTreeDimLength = new Float32Array(2);
var KdTree2 = class {
  /**
   * The root node in this k-d tree.
   */
  root;
  /**
   * The maximum allowed depth of this 2D k-d tree.
   */
  maxDepth;
  /**
   * Creates a new 2D k-d tree.
   *
   * @param params
   */
  constructor(params2) {
    this.maxDepth = params2?.maxDepth || MAX_KD_TREE_DEPTH;
    this.root = {
      // @ts-ignore
      aabb: params2.aabb.slice()
    };
  }
  /**
   * Inserts a bounded item into this 2D k-d tree.
   *
   * @param item
   * @param aabb
   */
  insertItem(item, aabb) {
    this.#insertItem(this.root, { item }, aabb, 1);
  }
  #insertItem(node, item, aabb, depth) {
    if (depth >= this.maxDepth) {
      node.items = node.items || [];
      node.items.push(item);
      return;
    }
    if (node.left) {
      if (containsAABB2(node.left.aabb, aabb)) {
        this.#insertItem(node.left, item, aabb, depth + 1);
        return;
      }
    }
    if (node.right) {
      if (containsAABB2(node.right.aabb, aabb)) {
        this.#insertItem(node.right, item, aabb, depth + 1);
        return;
      }
    }
    const nodeAABB = node.aabb;
    kdTreeDimLength[0] = nodeAABB[2] - nodeAABB[0];
    kdTreeDimLength[1] = nodeAABB[3] - nodeAABB[1];
    let dim = 0;
    if (kdTreeDimLength[1] > kdTreeDimLength[dim]) {
      dim = 1;
    }
    if (!node.left) {
      const aabbLeft = nodeAABB.slice();
      aabbLeft[dim + 2] = (nodeAABB[dim] + nodeAABB[dim + 2]) / 2;
      node.left = {
        aabb: aabbLeft
      };
      if (containsAABB2(aabbLeft, aabb)) {
        this.#insertItem(node.left, item, aabb, depth + 1);
        return;
      }
    }
    if (!node.right) {
      const aabbRight = nodeAABB.slice();
      aabbRight[dim] = (nodeAABB[dim] + nodeAABB[dim + 2]) / 2;
      node.right = {
        aabb: aabbRight
      };
      if (containsAABB2(aabbRight, aabb)) {
        this.#insertItem(node.right, item, aabb, depth + 1);
        return;
      }
    }
    node.items = node.items || [];
    node.items.push(item);
  }
};

// ../sdk/src/kdtree2/createKdTree2FromSceneObjectVerts.ts
function createKdTree2FromSceneObjectVerts(params2) {
  const kdTree2D = new KdTree2({
    aabb: params2.canvasBoundary
  });
  const viewMatrix = createMat4(params2.viewMatrix);
  const projMatrix = createMat4(params2.projMatrix);
  const frustum = setFrustum3(viewMatrix, projMatrix);
  const canvasBoundary = params2.canvasBoundary;
  const sceneObjects = params2.sceneObjects;
  if (sceneObjects) {
    for (let i = 0, len = sceneObjects.length; i < len; i++) {
      insertSceneObject(sceneObjects[i]);
    }
  }
  function insertSceneObject(sceneObject, intersects = INTERSECT) {
    if (intersects !== INSIDE) {
      intersects = intersectFrustum3AABB3(frustum, sceneObject.aabb);
    }
    if (intersects === OUTSIDE) {
      return;
    }
    getSceneObjectGeometry(sceneObject, (geometryView2) => {
      const positionsWorld = geometryView2.positionsWorld;
      for (let i = 0, len = positionsWorld.length; i < len; i += 3) {
        const worldPos = createVec4();
        worldPos[0] = positionsWorld[i];
        worldPos[1] = positionsWorld[i + 1];
        worldPos[2] = positionsWorld[i + 2];
        worldPos[3] = 1;
        if (intersects === INSIDE || intersectFrustum3Point3(frustum, worldPos)) {
          insertVertex(sceneObject, worldPos);
        }
      }
      return false;
    });
  }
  function insertVertex(sceneObject, worldPos) {
    const viewPos2 = createVec4();
    const projPos = createVec4();
    const canvasPos2 = new Uint16Array(2);
    transformPoint4(viewMatrix, worldPos, viewPos2);
    transformPoint4(projMatrix, viewPos2, projPos);
    canvasPos2[0] = Math.floor((1 + projPos[0] / projPos[3]) * canvasBoundary[2] / 2);
    canvasPos2[1] = Math.floor((1 - projPos[1] / projPos[3]) * canvasBoundary[3] / 2);
    kdTree2D.insertItem({ sceneObject, worldPos, canvasPos: canvasPos2 }, [canvasPos2[0], canvasPos2[1], canvasPos2[0], canvasPos2[1]]);
  }
  return kdTree2D;
}

// ../sdk/src/kdtree2/searchKdTree2ForNearestNeighbor.ts
function searchKdTree2ForNearestNeighbor(params2) {
  const kdTree = params2.kdTree;
  const canvasPos2 = params2.canvasPos;
  const sceneObjects = [];
  return sceneObjects;
}

// ../sdk/src/kdtree2/KdVertex2.ts
var KdVertex2 = class {
  sceneObject;
  worldPos;
  canvasPos;
};

// ../sdk/src/kdtree3/index.ts
var kdtree3_exports = {};
__export(kdtree3_exports, {
  KdTree3: () => KdTree3,
  PrimsKdTree3: () => PrimsKdTree3,
  SceneObjectsKdTree3: () => SceneObjectsKdTree3,
  SceneObjectsPrimsKdTree3: () => SceneObjectsPrimsKdTree3,
  createPrimsKdTree3: () => createPrimsKdTree3,
  createSceneObjectPrimsKdTree3: () => createSceneObjectPrimsKdTree3,
  createSceneObjectsKdTree3: () => createSceneObjectsKdTree3,
  searchKdTree3WithAABB: () => searchKdTree3WithAABB,
  searchKdTree3WithFrustum: () => searchKdTree3WithFrustum,
  searchKdTree3WithRay: () => searchKdTree3WithRay
});

// ../sdk/src/kdtree3/KdTree3.ts
var MAX_KD_TREE_DEPTH2 = 10;
var kdTreeDimLength2 = new Float32Array(3);
var KdTree3 = class {
  #root;
  #maxDepth;
  #numNodes;
  #numObjects;
  /**
   * Creates a new KdTree3.
   *
   * @param params
   */
  constructor(params2) {
    this.#maxDepth = params2?.maxDepth || MAX_KD_TREE_DEPTH2;
    this.#root = {
      index: 0,
      aabb: params2.aabb.slice()
    };
    this.#numNodes = 0;
  }
  get root() {
    return this.#root;
  }
  insertItem(item, aabb) {
    this.#insertItem(this.#root, { index: this.#numObjects++, item }, aabb, 1);
  }
  #insertItem(node, item, aabb, depth) {
    if (depth >= this.#maxDepth) {
      node.items = node.items || [];
      node.items.push(item);
      expandAABB3(node.aabb, aabb);
      return;
    }
    if (node.left) {
      if (containsAABB3(node.left.aabb, aabb)) {
        this.#insertItem(node.left, item, aabb, depth + 1);
        return;
      }
    }
    if (node.right) {
      if (containsAABB3(node.right.aabb, aabb)) {
        this.#insertItem(node.right, item, aabb, depth + 1);
        return;
      }
    }
    const nodeAABB = node.aabb;
    kdTreeDimLength2[0] = nodeAABB[3] - nodeAABB[0];
    kdTreeDimLength2[1] = nodeAABB[4] - nodeAABB[1];
    kdTreeDimLength2[2] = nodeAABB[5] - nodeAABB[2];
    let dim = 0;
    if (kdTreeDimLength2[1] > kdTreeDimLength2[dim]) {
      dim = 1;
    }
    if (kdTreeDimLength2[2] > kdTreeDimLength2[dim]) {
      dim = 2;
    }
    if (!node.left) {
      const aabbLeft = nodeAABB.slice();
      aabbLeft[dim + 3] = (nodeAABB[dim] + nodeAABB[dim + 3]) / 2;
      node.left = {
        index: this.#numNodes++,
        aabb: aabbLeft
      };
      if (containsAABB3(aabbLeft, aabb)) {
        this.#insertItem(node.left, item, aabb, depth + 1);
        return;
      }
    }
    if (!node.right) {
      const aabbRight = nodeAABB.slice();
      aabbRight[dim] = (nodeAABB[dim] + nodeAABB[dim + 3]) / 2;
      node.right = {
        index: this.#numNodes++,
        aabb: aabbRight
      };
      if (containsAABB3(aabbRight, aabb)) {
        this.#insertItem(node.right, item, aabb, depth + 1);
        return;
      }
    }
    node.items = node.items || [];
    node.items.push(item);
    expandAABB3(node.aabb, aabb);
  }
};

// ../sdk/src/kdtree3/sceneObjectsKdTree3.ts
var SceneObjectsKdTree3 = class extends KdTree3 {
};

// ../sdk/src/kdtree3/createSceneObjectsKdTree3.ts
function createSceneObjectsKdTree3(sceneObjects) {
  const aabb = collapseAABB3();
  for (let i = 0, len = sceneObjects.length; i < len; i++) {
    expandAABB3(aabb, sceneObjects[i].aabb);
  }
  const kdTree = new SceneObjectsKdTree3({ aabb });
  for (let i = 0, len = sceneObjects.length; i < len; i++) {
    const sceneObject = sceneObjects[i];
    kdTree.insertItem(sceneObject, sceneObject.aabb);
  }
  return kdTree;
}

// ../sdk/src/kdtree3/createSceneObjectPrimsKdTree3.ts
var SceneObjectsPrimsKdTree3 = class extends KdTree3 {
};
function createSceneObjectPrimsKdTree3(sceneObjects) {
  const tempAABBInt162 = new Int16Array(6);
  function insertPoint2(sceneObject, sceneGeometry, positions, a2, kdTree2) {
    const ax = positions[a2 * 3];
    const ay = positions[a2 * 3 + 1];
    const az = positions[a2 * 3 + 2];
    const aabb2 = tempAABBInt162;
    aabb2[0] = aabb2[3] = ax;
    aabb2[1] = aabb2[4] = ay;
    aabb2[2] = aabb2[5] = az;
    kdTree2.insertItem({ sceneObject, sceneGeometry, prim: { a: a2 } }, aabb2);
  }
  function insertLine2(sceneObject, sceneGeometry, positions, a2, b4, kdTree2) {
    const ax = positions[a2 * 3];
    const ay = positions[a2 * 3 + 1];
    const az = positions[a2 * 3 + 2];
    const bx = positions[b4 * 3];
    const by = positions[b4 * 3 + 1];
    const bz = positions[b4 * 3 + 2];
    const aabb2 = tempAABBInt162;
    aabb2[0] = Math.min(ax, bx);
    aabb2[1] = Math.min(ay, by);
    aabb2[2] = Math.min(az, bz);
    aabb2[3] = Math.max(ax, bx);
    aabb2[4] = Math.max(ay, by);
    aabb2[5] = Math.max(az, bz);
    kdTree2.insertItem({ sceneObject, sceneGeometry, prim: { a: a2, b: b4 } }, aabb2);
  }
  function insertTriangle2(sceneObject, sceneGeometry, positions, a2, b4, c2, kdTree2) {
    const ax = positions[a2 * 3];
    const ay = positions[a2 * 3 + 1];
    const az = positions[a2 * 3 + 2];
    const bx = positions[b4 * 3];
    const by = positions[b4 * 3 + 1];
    const bz = positions[b4 * 3 + 2];
    const cx = positions[c2 * 3];
    const cy = positions[c2 * 3 + 1];
    const cz = positions[c2 * 3 + 2];
    const aabb2 = tempAABBInt162;
    aabb2[0] = Math.min(ax, bx, cx);
    aabb2[1] = Math.min(ay, by, cy);
    aabb2[2] = Math.min(az, bz, cz);
    aabb2[3] = Math.max(ax, bx, cx);
    aabb2[4] = Math.max(ay, by, cy);
    aabb2[5] = Math.max(az, bz, cz);
    kdTree2.insertItem({ sceneObject, sceneGeometry, prim: { a: a2, b: b4, c: c2 } }, aabb2);
  }
  const aabb = collapseAABB3();
  for (let i = 0, len = sceneObjects.length; i < len; i++) {
    const viewObject = sceneObjects[i];
    expandAABB3(aabb, viewObject.aabb);
  }
  const kdTree = new SceneObjectsPrimsKdTree3({
    aabb
  });
  for (let i = 0, len = sceneObjects.length; i < len; i++) {
    const sceneObject = sceneObjects[i];
    getSceneObjectGeometry(sceneObject, (geometryView2) => {
      const sceneGeometry = geometryView2.geometry;
      const positionsWorld = geometryView2.positionsWorld;
      const indices = sceneGeometry.indices;
      switch (sceneGeometry.primitive) {
        case PointsPrimitive:
          for (let j = 0, lenj = positionsWorld.length / 3; j < lenj; j++) {
            insertPoint2(sceneObject, sceneGeometry, positionsWorld, j, kdTree);
          }
          break;
        case TrianglesPrimitive:
          if (indices) {
            for (let j = 0, lenj = indices.length; j < lenj; j += 3) {
              insertTriangle2(sceneObject, sceneGeometry, positionsWorld, indices[j], indices[j + 1], indices[j + 2], kdTree);
            }
          }
          break;
        case LinesPrimitive:
          if (indices) {
            for (let j = 0, lenj = indices.length; j < lenj; j += 2) {
              insertLine2(sceneObject, sceneGeometry, positionsWorld, indices[j], indices[j + 1], kdTree);
            }
          }
          break;
      }
      return true;
    });
  }
  return kdTree;
}

// ../sdk/src/kdtree3/PrimsKdTree3.ts
var PrimsKdTree3 = class extends KdTree3 {
};

// ../sdk/src/kdtree3/createPrimsKdTree3.ts
var tempAABBInt16 = new Int16Array(6);
function createPrimsKdTree3(primitiveType, positions, indices) {
  const kdTree = new PrimsKdTree3({
    aabb: expandAABB3Points3(createAABB3Int16(), positions)
  });
  switch (primitiveType) {
    case PointsPrimitive:
      for (let i = 0, len = positions.length / 3; i < len; i++) {
        insertPoint(positions, i, kdTree);
      }
      break;
    case TrianglesPrimitive:
      if (indices) {
        for (let i = 0, len = indices.length; i < len; i += 3) {
          insertTriangle(positions, indices[i], indices[i + 1], indices[i + 2], kdTree);
        }
      }
      break;
    case LinesPrimitive:
      if (indices) {
        for (let i = 0, len = indices.length; i < len; i += 2) {
          insertLine(positions, indices[i], indices[i + 1], kdTree);
        }
      }
      break;
  }
  return kdTree;
}
function insertPoint(positions, a2, kdTree) {
  const ax = positions[a2 * 3];
  const ay = positions[a2 * 3 + 1];
  const az = positions[a2 * 3 + 2];
  const aabb = tempAABBInt16;
  aabb[0] = aabb[3] = ax;
  aabb[1] = aabb[4] = ay;
  aabb[2] = aabb[5] = az;
  kdTree.insertItem({ a: a2 }, aabb);
}
function insertLine(positions, a2, b4, kdTree) {
  const ax = positions[a2 * 3];
  const ay = positions[a2 * 3 + 1];
  const az = positions[a2 * 3 + 2];
  const bx = positions[b4 * 3];
  const by = positions[b4 * 3 + 1];
  const bz = positions[b4 * 3 + 2];
  const aabb = tempAABBInt16;
  aabb[0] = Math.min(ax, bx);
  aabb[1] = Math.min(ay, by);
  aabb[2] = Math.min(az, bz);
  aabb[3] = Math.max(ax, bx);
  aabb[4] = Math.max(ay, by);
  aabb[5] = Math.max(az, bz);
  kdTree.insertItem({ a: a2, b: b4 }, aabb);
}
function insertTriangle(positions, a2, b4, c2, kdTree) {
  const ax = positions[a2 * 3];
  const ay = positions[a2 * 3 + 1];
  const az = positions[a2 * 3 + 2];
  const bx = positions[b4 * 3];
  const by = positions[b4 * 3 + 1];
  const bz = positions[b4 * 3 + 2];
  const cx = positions[c2 * 3];
  const cy = positions[c2 * 3 + 1];
  const cz = positions[c2 * 3 + 2];
  const aabb = tempAABBInt16;
  aabb[0] = Math.min(ax, bx, cx);
  aabb[1] = Math.min(ay, by, cy);
  aabb[2] = Math.min(az, bz, cz);
  aabb[3] = Math.max(ax, bx, cx);
  aabb[4] = Math.max(ay, by, cy);
  aabb[5] = Math.max(az, bz, cz);
  kdTree.insertItem({ a: a2, b: b4, c: c2 }, aabb);
}

// ../sdk/src/kdtree3/searchKdTree3WithAABB.ts
function searchKdTree3WithAABB(params2) {
  const kdTree = params2.kdTree;
  const aabb = params2.aabb;
  const foundItems = [];
  function visit(node, isect) {
    if (isect === OUTSIDE) {
      return;
    }
    isect = intersectAABB3s(aabb, node.aabb);
    if (isect === OUTSIDE) {
      return;
    }
    const items = node.items;
    if (items && items.length > 0) {
      for (let i = 0, len = items.length; i < len; i++) {
        foundItems.push(items[i].item);
      }
    }
    if (node.left) {
      visit(node.left, isect);
    }
    if (node.right) {
      visit(node.right, isect);
    }
  }
  visit(kdTree.root, INTERSECT);
  return foundItems;
}

// ../sdk/src/kdtree3/searchKdTree3WithFrustum.ts
function searchKdTree3WithFrustum(params2) {
  const kdTree = params2.kdTree;
  const frustum = params2.frustum;
  const foundItems = [];
  function visit(node, isect) {
    if (isect === OUTSIDE) {
      return;
    }
    isect = intersectFrustum3AABB3(frustum, node.aabb);
    if (isect === OUTSIDE) {
      return;
    }
    const items = node.items;
    if (items && items.length > 0) {
      for (let i = 0, len = items.length; i < len; i++) {
        foundItems.push(items[i].item);
      }
    }
    if (node.left) {
      visit(node.left, isect);
    }
    if (node.right) {
      visit(node.right, isect);
    }
  }
  visit(kdTree.root, INTERSECT);
  return foundItems;
}

// ../sdk/src/kdtree3/searchKdTree3WithRay.ts
function searchKdTree3WithRay(params2) {
  const kdTree = params2.kdTree;
  const origin = params2.origin;
  const dir = params2.dir;
  const foundItems = [];
  function testRayIntersectsAABB3(origin2, dir2, aabb) {
    return 0;
  }
  function visit(node, isect) {
    if (isect === OUTSIDE) {
      return;
    }
    isect = testRayIntersectsAABB3(origin, dir, node.aabb);
    if (isect === OUTSIDE) {
      return;
    }
    const items = node.items;
    if (items && items.length > 0) {
      for (let i = 0, len = items.length; i < len; i++) {
        foundItems.push(items[i].item);
      }
    }
    if (node.left) {
      visit(node.left, isect);
    }
    if (node.right) {
      visit(node.right, isect);
    }
  }
  visit(kdTree.root, INTERSECT);
  return foundItems;
}

// ../sdk/src/pick/index.ts
var pick_exports = {};
__export(pick_exports, {
  Picker: () => Picker
});

// ../sdk/src/pick/PickPrimsCache.ts
var PickPrimsCache = class {
  /**
   * TODO
   */
  primitivesKdTrees;
  /**
   * TODO
   */
  constructor() {
    this.primitivesKdTrees = {};
  }
  /**
   * TODO
   */
  clear() {
    this.primitivesKdTrees = {};
  }
};

// ../sdk/src/pick/Picker.ts
var Picker = class {
  #pickPrimsCache;
  constructor() {
    this.#pickPrimsCache = new PickPrimsCache();
  }
  /**
   * TODO
   * @param params
   */
  rayPick(params2) {
    const sceneObjectsKdTree3 = params2.sceneObjectsKdTree3;
    const origin = params2.origin;
    const dir = params2.dir;
    const rayPickResult = {
      sceneObjectHits: []
    };
    return rayPickResult;
  }
  /**
   * Picks a {@link kdtree3!SceneObjectsKdTree3} using a 2D marquee to obtain a {@link MarqueePickResult}
   * containing picked {@link scene!SceneObject | SceneObjects}, {@link scene!SceneMesh | SceneMesh}, {@link scene!SceneGeometry | SceneGeometry},
   * {@link scene!SceneGeometryBucket | GeometryBuckets}, {@link KdTrianglePrim}, {@link KdLinePrim} and {@link KdPointPrim}.
   * @param params
   */
  marqueePick(params2) {
    const sceneObjectsKdTree3 = params2.sceneObjectsKdTree3;
    const pickPrimsCache = this.#pickPrimsCache;
    const marqueePickResult = {
      sceneObjects: []
    };
    const frustum = null;
    const kdItems = searchKdTree3WithFrustum({
      kdTree: sceneObjectsKdTree3,
      frustum
    });
    for (let i = 0, len = kdItems.length; i < len; i++) {
      const kdItem = kdItems[i];
      const sceneObject = kdItem.item;
      const meshes = [];
      for (let j = 0, lenj = sceneObject.meshes.length; j < lenj; j++) {
        const mesh = sceneObject.meshes[j];
        const pickedGeometryMeshes = [];
        const geometry = mesh.geometry;
        for (let k = 0, lenk = geometry.geometryBuckets.length; k < lenk; k++) {
          const prims = [];
          const geometryBucket = geometry.geometryBuckets[k];
          let primsKdTree3 = this.#getPrimsKdTree3(geometry, k);
          const items = searchKdTree3WithFrustum({
            kdTree: primsKdTree3.primitivesKdTree,
            frustum
          });
          if (items.length) {
            switch (geometry.primitive) {
              case TrianglesPrimitive:
                for (let l = 0, lenl = items.length; l < lenl; l++) {
                  const item = items[l];
                  const triangle = item.item.prim;
                  const a2 = triangle.a;
                  const b4 = triangle.b;
                  const c2 = triangle.c;
                  const cx = primsKdTree3.positions[a2 * 3];
                  const cy = primsKdTree3.positions[a2 * 3 + 1];
                  const cz = primsKdTree3.positions[a2 * 3 + 2];
                }
                break;
              case LinesPrimitive:
                for (let l = 0, lenl = items.length; l < lenl; l++) {
                  const item = items[l];
                  const line = item.item.prim;
                }
                break;
              case PointsPrimitive:
                for (let l = 0, lenl = items.length; l < lenl; l++) {
                  const item = items[l];
                  const point = item.item.prim;
                }
                break;
            }
          }
        }
      }
      const selected = false;
      if (selected) {
        marqueePickResult.sceneObjects.push(sceneObject);
      }
    }
    return marqueePickResult;
  }
  #getPrimsKdTree3(geometry, k) {
    const kdTreeId = `${geometry.id}-${k}`;
    let primsKdTree3 = this.#pickPrimsCache[kdTreeId];
    if (!primsKdTree3) {
      const positions = decompressPositions3WithAABB3(
        geometry.positionsCompressed,
        geometry.aabb,
        new Float32Array(geometry.positionsCompressed.length)
      );
      primsKdTree3 = {
        primsKdTree3: createPrimsKdTree3(geometry.primitive, positions, geometry.indices),
        positions
      };
      this.#pickPrimsCache[kdTreeId] = primsKdTree3;
    }
    return primsKdTree3;
  }
};

// ../sdk/src/basictypes/index.ts
var basictypes_exports = {};
__export(basictypes_exports, {
  BasicAggregation: () => BasicAggregation,
  BasicEntity: () => BasicEntity,
  typeCodes: () => typeCodes,
  typeNames: () => typeNames
});
var BasicEntity = 1e3;
var BasicAggregation = 1001;
var typeNames = {
  [BasicEntity]: "BasicEntity",
  [BasicAggregation]: "BasicAggregation"
};
var typeCodes = {
  "BasicEntity": BasicEntity,
  "BasicAggregation": BasicAggregation
};

// ../sdk/src/cityjsontypes_1_1_3/index.ts
var cityjsontypes_1_1_3_exports = {};
__export(cityjsontypes_1_1_3_exports, {
  BasicAggregation: () => BasicAggregation2,
  Bridge: () => Bridge,
  BridgeConstructiveElement: () => BridgeConstructiveElement,
  BridgeFurniture: () => BridgeFurniture,
  BridgeInstallation: () => BridgeInstallation,
  BridgePart: () => BridgePart,
  BridgeRoom: () => BridgeRoom,
  Building: () => Building,
  BuildingConstructiveElement: () => BuildingConstructiveElement,
  BuildingFurniture: () => BuildingFurniture,
  BuildingInstallation: () => BuildingInstallation,
  BuildingPart: () => BuildingPart,
  BuildingRoom: () => BuildingRoom,
  BuildingStorey: () => BuildingStorey,
  BuildingUnit: () => BuildingUnit,
  CityFurniture: () => CityFurniture,
  CityObjectGroup: () => CityObjectGroup,
  LandUse: () => LandUse,
  OtherConstruction: () => OtherConstruction,
  PlantCover: () => PlantCover,
  Railway: () => Railway,
  Road: () => Road,
  SolitaryVegetationObject: () => SolitaryVegetationObject,
  TINRelief: () => TINRelief,
  TransportationSquare: () => TransportationSquare,
  Tunnel: () => Tunnel,
  TunnelConstructiveElement: () => TunnelConstructiveElement,
  TunnelFurniture: () => TunnelFurniture,
  TunnelHollowSpace: () => TunnelHollowSpace,
  TunnelInstallation: () => TunnelInstallation,
  TunnelPart: () => TunnelPart,
  WaterBody: () => WaterBody,
  Waterway: () => Waterway,
  typeCodes: () => typeCodes2,
  typeNames: () => typeNames2
});
var BasicAggregation2 = 2001;
var Bridge = 2e3;
var BridgePart = 2001;
var BridgeInstallation = 2002;
var BridgeConstructiveElement = 2003;
var BridgeRoom = 2004;
var BridgeFurniture = 2005;
var Building = 2006;
var BuildingPart = 2007;
var BuildingInstallation = 2008;
var BuildingConstructiveElement = 2009;
var BuildingFurniture = 2010;
var BuildingStorey = 2011;
var BuildingRoom = 2012;
var BuildingUnit = 2013;
var CityFurniture = 2014;
var CityObjectGroup = 2015;
var LandUse = 2016;
var OtherConstruction = 2017;
var PlantCover = 2018;
var SolitaryVegetationObject = 2019;
var TINRelief = 2020;
var TransportationSquare = 2021;
var Railway = 2022;
var Road = 2023;
var Tunnel = 2024;
var TunnelPart = 2025;
var TunnelInstallation = 2026;
var TunnelConstructiveElement = 2027;
var TunnelHollowSpace = 2028;
var TunnelFurniture = 2029;
var WaterBody = 2030;
var Waterway = 2031;
var typeNames2 = {
  [Bridge]: "Bridge",
  [BridgePart]: "BridgePart",
  [BridgeInstallation]: "BridgeInstallation",
  [BridgeConstructiveElement]: "BridgeConstructiveElement",
  [BridgeRoom]: "BridgeRoom",
  [BridgeFurniture]: "BridgeFurniture",
  [Building]: "Building",
  [BuildingPart]: "BuildingPart",
  [BuildingInstallation]: "BuildingInstallation",
  [BuildingConstructiveElement]: "BuildingConstructiveElement",
  [BuildingFurniture]: "BuildingFurniture",
  [BuildingStorey]: "BuildingStorey",
  [BuildingRoom]: "BuildingRoom",
  [BuildingUnit]: "BuildingUnit",
  [CityFurniture]: "CityFurniture",
  [CityObjectGroup]: "CityObjectGroup",
  [LandUse]: "LandUse",
  [OtherConstruction]: "OtherConstruction",
  [PlantCover]: "PlantCover",
  [SolitaryVegetationObject]: "SolitaryVegetationObject",
  [TINRelief]: "TINRelief",
  [TransportationSquare]: "TransportationSquare",
  [Railway]: "Railway",
  [Road]: "Road",
  [Tunnel]: "Tunnel",
  [TunnelPart]: "TunnelPart",
  [TunnelInstallation]: "TunnelInstallation",
  [TunnelConstructiveElement]: "TunnelInstallation",
  [TunnelHollowSpace]: "TunnelHollowSpace",
  [TunnelFurniture]: "TunnelFurniture",
  [WaterBody]: "WaterBody",
  [Waterway]: "Waterway"
};
var typeCodes2 = {
  "Bridge": Bridge,
  "BridgePart": BridgePart,
  "BridgeInstallation": BridgeInstallation,
  "BridgeConstructiveElement": BridgeConstructiveElement,
  "BridgeRoom": BridgeRoom,
  "BridgeFurniture": BridgeFurniture,
  "Building": Building,
  "BuildingPart": BuildingPart,
  "BuildingInstallation": BuildingInstallation,
  "BuildingConstructiveElement": BuildingConstructiveElement,
  "BuildingFurniture": BuildingFurniture,
  "BuildingStorey": BuildingStorey,
  "BuildingRoom": BuildingRoom,
  "BuildingUnit": BuildingUnit,
  "CityFurniture": CityFurniture,
  "CityObjectGroup": CityObjectGroup,
  "LandUse": LandUse,
  "OtherConstruction": OtherConstruction,
  "PlantCover": PlantCover,
  "SolitaryVegetationObject": SolitaryVegetationObject,
  "TINRelief": TINRelief,
  "TransportationSquare": TransportationSquare,
  "Railway": Railway,
  "Road": Road,
  "Tunnel": Tunnel,
  "TunnelPart": TunnelPart,
  "TunnelInstallation": TunnelInstallation,
  "TunnelConstructiveElement": TunnelInstallation,
  "TunnelHollowSpace": TunnelHollowSpace,
  "TunnelFurniture": TunnelFurniture,
  "WaterBody": WaterBody,
  "Waterway": Waterway
};

// ../sdk/src/ifctypes/index.ts
var ifctypes_exports = {};
__export(ifctypes_exports, {
  IfcActionRequest: () => IfcActionRequest,
  IfcActor: () => IfcActor,
  IfcActorRole: () => IfcActorRole,
  IfcActuator: () => IfcActuator,
  IfcActuatorType: () => IfcActuatorType,
  IfcAddress: () => IfcAddress,
  IfcAdvancedBrep: () => IfcAdvancedBrep,
  IfcAdvancedBrepWithVoids: () => IfcAdvancedBrepWithVoids,
  IfcAdvancedFace: () => IfcAdvancedFace,
  IfcAirTerminal: () => IfcAirTerminal,
  IfcAirTerminalBox: () => IfcAirTerminalBox,
  IfcAirTerminalBoxType: () => IfcAirTerminalBoxType,
  IfcAirTerminalType: () => IfcAirTerminalType,
  IfcAirToAirHeatRecovery: () => IfcAirToAirHeatRecovery,
  IfcAirToAirHeatRecoveryType: () => IfcAirToAirHeatRecoveryType,
  IfcAlarm: () => IfcAlarm,
  IfcAlarmType: () => IfcAlarmType,
  IfcAnnotation: () => IfcAnnotation,
  IfcAnnotationFillArea: () => IfcAnnotationFillArea,
  IfcApplication: () => IfcApplication,
  IfcAppliedValue: () => IfcAppliedValue,
  IfcApproval: () => IfcApproval,
  IfcApprovalRelationship: () => IfcApprovalRelationship,
  IfcArbitraryClosedProfileDef: () => IfcArbitraryClosedProfileDef,
  IfcArbitraryOpenProfileDef: () => IfcArbitraryOpenProfileDef,
  IfcArbitraryProfileDefWithVoids: () => IfcArbitraryProfileDefWithVoids,
  IfcAsset: () => IfcAsset,
  IfcAsymmetricIShapeProfileDef: () => IfcAsymmetricIShapeProfileDef,
  IfcAudioVisualAppliance: () => IfcAudioVisualAppliance,
  IfcAudioVisualApplianceType: () => IfcAudioVisualApplianceType,
  IfcAxis1Placement: () => IfcAxis1Placement,
  IfcAxis2Placement2D: () => IfcAxis2Placement2D,
  IfcAxis2Placement3D: () => IfcAxis2Placement3D,
  IfcBSplineCurve: () => IfcBSplineCurve,
  IfcBSplineCurveWithKnots: () => IfcBSplineCurveWithKnots,
  IfcBSplineSurface: () => IfcBSplineSurface,
  IfcBSplineSurfaceWithKnots: () => IfcBSplineSurfaceWithKnots,
  IfcBeam: () => IfcBeam,
  IfcBeamStandardCase: () => IfcBeamStandardCase,
  IfcBeamType: () => IfcBeamType,
  IfcBlobTexture: () => IfcBlobTexture,
  IfcBlock: () => IfcBlock,
  IfcBoiler: () => IfcBoiler,
  IfcBoilerType: () => IfcBoilerType,
  IfcBooleanClippingResult: () => IfcBooleanClippingResult,
  IfcBooleanResult: () => IfcBooleanResult,
  IfcBoundaryCondition: () => IfcBoundaryCondition,
  IfcBoundaryCurve: () => IfcBoundaryCurve,
  IfcBoundaryEdgeCondition: () => IfcBoundaryEdgeCondition,
  IfcBoundaryFaceCondition: () => IfcBoundaryFaceCondition,
  IfcBoundaryNodeCondition: () => IfcBoundaryNodeCondition,
  IfcBoundaryNodeConditionWarping: () => IfcBoundaryNodeConditionWarping,
  IfcBoundedCurve: () => IfcBoundedCurve,
  IfcBoundedSurface: () => IfcBoundedSurface,
  IfcBoundingBox: () => IfcBoundingBox,
  IfcBoxedHalfSpace: () => IfcBoxedHalfSpace,
  IfcBuilding: () => IfcBuilding,
  IfcBuildingElementPart: () => IfcBuildingElementPart,
  IfcBuildingElementPartType: () => IfcBuildingElementPartType,
  IfcBuildingElementProxy: () => IfcBuildingElementProxy,
  IfcBuildingElementProxyType: () => IfcBuildingElementProxyType,
  IfcBuildingStorey: () => IfcBuildingStorey,
  IfcBuildingSystem: () => IfcBuildingSystem,
  IfcBurner: () => IfcBurner,
  IfcBurnerType: () => IfcBurnerType,
  IfcCShapeProfileDef: () => IfcCShapeProfileDef,
  IfcCableCarrierFitting: () => IfcCableCarrierFitting,
  IfcCableCarrierFittingType: () => IfcCableCarrierFittingType,
  IfcCableCarrierSegment: () => IfcCableCarrierSegment,
  IfcCableCarrierSegmentType: () => IfcCableCarrierSegmentType,
  IfcCableFitting: () => IfcCableFitting,
  IfcCableFittingType: () => IfcCableFittingType,
  IfcCableSegment: () => IfcCableSegment,
  IfcCableSegmentType: () => IfcCableSegmentType,
  IfcCartesianPoint: () => IfcCartesianPoint,
  IfcCartesianPointList: () => IfcCartesianPointList,
  IfcCartesianPointList2D: () => IfcCartesianPointList2D,
  IfcCartesianPointList3D: () => IfcCartesianPointList3D,
  IfcCartesianTransformationOperator: () => IfcCartesianTransformationOperator,
  IfcCartesianTransformationOperator2D: () => IfcCartesianTransformationOperator2D,
  IfcCartesianTransformationOperator2DnonUniform: () => IfcCartesianTransformationOperator2DnonUniform,
  IfcCartesianTransformationOperator3D: () => IfcCartesianTransformationOperator3D,
  IfcCartesianTransformationOperator3DnonUniform: () => IfcCartesianTransformationOperator3DnonUniform,
  IfcCenterLineProfileDef: () => IfcCenterLineProfileDef,
  IfcChiller: () => IfcChiller,
  IfcChillerType: () => IfcChillerType,
  IfcChimney: () => IfcChimney,
  IfcChimneyType: () => IfcChimneyType,
  IfcCircle: () => IfcCircle,
  IfcCircleHollowProfileDef: () => IfcCircleHollowProfileDef,
  IfcCircleProfileDef: () => IfcCircleProfileDef,
  IfcCivilElement: () => IfcCivilElement,
  IfcCivilElementType: () => IfcCivilElementType,
  IfcClassification: () => IfcClassification,
  IfcClassificationReference: () => IfcClassificationReference,
  IfcClosedShell: () => IfcClosedShell,
  IfcCoil: () => IfcCoil,
  IfcCoilType: () => IfcCoilType,
  IfcColourRgb: () => IfcColourRgb,
  IfcColourRgbList: () => IfcColourRgbList,
  IfcColourSpecification: () => IfcColourSpecification,
  IfcColumn: () => IfcColumn,
  IfcColumnStandardCase: () => IfcColumnStandardCase,
  IfcColumnType: () => IfcColumnType,
  IfcCommunicationsAppliance: () => IfcCommunicationsAppliance,
  IfcCommunicationsApplianceType: () => IfcCommunicationsApplianceType,
  IfcComplexProperty: () => IfcComplexProperty,
  IfcComplexPropertyTemplate: () => IfcComplexPropertyTemplate,
  IfcCompositeCurve: () => IfcCompositeCurve,
  IfcCompositeCurveOnSurface: () => IfcCompositeCurveOnSurface,
  IfcCompositeCurveSegment: () => IfcCompositeCurveSegment,
  IfcCompositeProfileDef: () => IfcCompositeProfileDef,
  IfcCompressor: () => IfcCompressor,
  IfcCompressorType: () => IfcCompressorType,
  IfcCondenser: () => IfcCondenser,
  IfcCondenserType: () => IfcCondenserType,
  IfcConic: () => IfcConic,
  IfcConnectedFaceSet: () => IfcConnectedFaceSet,
  IfcConnectionCurveGeometry: () => IfcConnectionCurveGeometry,
  IfcConnectionGeometry: () => IfcConnectionGeometry,
  IfcConnectionPointEccentricity: () => IfcConnectionPointEccentricity,
  IfcConnectionPointGeometry: () => IfcConnectionPointGeometry,
  IfcConnectionSurfaceGeometry: () => IfcConnectionSurfaceGeometry,
  IfcConnectionVolumeGeometry: () => IfcConnectionVolumeGeometry,
  IfcConstraint: () => IfcConstraint,
  IfcConstructionEquipmentResource: () => IfcConstructionEquipmentResource,
  IfcConstructionEquipmentResourceType: () => IfcConstructionEquipmentResourceType,
  IfcConstructionMaterialResource: () => IfcConstructionMaterialResource,
  IfcConstructionMaterialResourceType: () => IfcConstructionMaterialResourceType,
  IfcConstructionProductResource: () => IfcConstructionProductResource,
  IfcConstructionProductResourceType: () => IfcConstructionProductResourceType,
  IfcConstructionResource: () => IfcConstructionResource,
  IfcConstructionResourceType: () => IfcConstructionResourceType,
  IfcContext: () => IfcContext,
  IfcContextDependentUnit: () => IfcContextDependentUnit,
  IfcControl: () => IfcControl,
  IfcController: () => IfcController,
  IfcControllerType: () => IfcControllerType,
  IfcConversionBasedUnit: () => IfcConversionBasedUnit,
  IfcConversionBasedUnitWithOffset: () => IfcConversionBasedUnitWithOffset,
  IfcCooledBeam: () => IfcCooledBeam,
  IfcCooledBeamType: () => IfcCooledBeamType,
  IfcCoolingTower: () => IfcCoolingTower,
  IfcCoolingTowerType: () => IfcCoolingTowerType,
  IfcCoordinateOperation: () => IfcCoordinateOperation,
  IfcCoordinateReferenceSystem: () => IfcCoordinateReferenceSystem,
  IfcCostItem: () => IfcCostItem,
  IfcCostSchedule: () => IfcCostSchedule,
  IfcCostValue: () => IfcCostValue,
  IfcCovering: () => IfcCovering,
  IfcCoveringType: () => IfcCoveringType,
  IfcCrewResource: () => IfcCrewResource,
  IfcCrewResourceType: () => IfcCrewResourceType,
  IfcCsgPrimitive3D: () => IfcCsgPrimitive3D,
  IfcCsgSolid: () => IfcCsgSolid,
  IfcCurrencyRelationship: () => IfcCurrencyRelationship,
  IfcCurtainWall: () => IfcCurtainWall,
  IfcCurtainWallType: () => IfcCurtainWallType,
  IfcCurve: () => IfcCurve,
  IfcCurveBoundedPlane: () => IfcCurveBoundedPlane,
  IfcCurveBoundedSurface: () => IfcCurveBoundedSurface,
  IfcCurveStyle: () => IfcCurveStyle,
  IfcCurveStyleFont: () => IfcCurveStyleFont,
  IfcCurveStyleFontAndScaling: () => IfcCurveStyleFontAndScaling,
  IfcCurveStyleFontPattern: () => IfcCurveStyleFontPattern,
  IfcCylindricalSurface: () => IfcCylindricalSurface,
  IfcDamper: () => IfcDamper,
  IfcDamperType: () => IfcDamperType,
  IfcDerivedProfileDef: () => IfcDerivedProfileDef,
  IfcDerivedUnit: () => IfcDerivedUnit,
  IfcDerivedUnitElement: () => IfcDerivedUnitElement,
  IfcDimensionalExponents: () => IfcDimensionalExponents,
  IfcDirection: () => IfcDirection,
  IfcDiscreteAccessory: () => IfcDiscreteAccessory,
  IfcDiscreteAccessoryType: () => IfcDiscreteAccessoryType,
  IfcDistributionChamberElement: () => IfcDistributionChamberElement,
  IfcDistributionChamberElementType: () => IfcDistributionChamberElementType,
  IfcDistributionCircuit: () => IfcDistributionCircuit,
  IfcDistributionControlElement: () => IfcDistributionControlElement,
  IfcDistributionControlElementType: () => IfcDistributionControlElementType,
  IfcDistributionElement: () => IfcDistributionElement,
  IfcDistributionElementType: () => IfcDistributionElementType,
  IfcDistributionFlowElement: () => IfcDistributionFlowElement,
  IfcDistributionFlowElementType: () => IfcDistributionFlowElementType,
  IfcDistributionPort: () => IfcDistributionPort,
  IfcDistributionSystem: () => IfcDistributionSystem,
  IfcDocumentInformation: () => IfcDocumentInformation,
  IfcDocumentInformationRelationship: () => IfcDocumentInformationRelationship,
  IfcDocumentReference: () => IfcDocumentReference,
  IfcDoor: () => IfcDoor,
  IfcDoorLiningProperties: () => IfcDoorLiningProperties,
  IfcDoorPanelProperties: () => IfcDoorPanelProperties,
  IfcDoorStandardCase: () => IfcDoorStandardCase,
  IfcDoorStyle: () => IfcDoorStyle,
  IfcDoorType: () => IfcDoorType,
  IfcDraughtingPreDefinedColour: () => IfcDraughtingPreDefinedColour,
  IfcDraughtingPreDefinedCurveFont: () => IfcDraughtingPreDefinedCurveFont,
  IfcDuctFitting: () => IfcDuctFitting,
  IfcDuctFittingType: () => IfcDuctFittingType,
  IfcDuctSegment: () => IfcDuctSegment,
  IfcDuctSegmentType: () => IfcDuctSegmentType,
  IfcDuctSilencer: () => IfcDuctSilencer,
  IfcDuctSilencerType: () => IfcDuctSilencerType,
  IfcEdge: () => IfcEdge,
  IfcEdgeCurve: () => IfcEdgeCurve,
  IfcEdgeLoop: () => IfcEdgeLoop,
  IfcElectricAppliance: () => IfcElectricAppliance,
  IfcElectricApplianceType: () => IfcElectricApplianceType,
  IfcElectricDistributionBoard: () => IfcElectricDistributionBoard,
  IfcElectricDistributionBoardType: () => IfcElectricDistributionBoardType,
  IfcElectricFlowStorageDevice: () => IfcElectricFlowStorageDevice,
  IfcElectricFlowStorageDeviceType: () => IfcElectricFlowStorageDeviceType,
  IfcElectricGenerator: () => IfcElectricGenerator,
  IfcElectricGeneratorType: () => IfcElectricGeneratorType,
  IfcElectricMotor: () => IfcElectricMotor,
  IfcElectricMotorType: () => IfcElectricMotorType,
  IfcElectricTimeControl: () => IfcElectricTimeControl,
  IfcElectricTimeControlType: () => IfcElectricTimeControlType,
  IfcElement: () => IfcElement,
  IfcElementAssembly: () => IfcElementAssembly,
  IfcElementAssemblyType: () => IfcElementAssemblyType,
  IfcElementComponent: () => IfcElementComponent,
  IfcElementComponentType: () => IfcElementComponentType,
  IfcElementQuantity: () => IfcElementQuantity,
  IfcElementType: () => IfcElementType,
  IfcElementarySurface: () => IfcElementarySurface,
  IfcEllipse: () => IfcEllipse,
  IfcEllipseProfileDef: () => IfcEllipseProfileDef,
  IfcEnergyConversionDevice: () => IfcEnergyConversionDevice,
  IfcEnergyConversionDeviceType: () => IfcEnergyConversionDeviceType,
  IfcEngine: () => IfcEngine,
  IfcEngineType: () => IfcEngineType,
  IfcEvaporativeCooler: () => IfcEvaporativeCooler,
  IfcEvaporativeCoolerType: () => IfcEvaporativeCoolerType,
  IfcEvaporator: () => IfcEvaporator,
  IfcEvaporatorType: () => IfcEvaporatorType,
  IfcEvent: () => IfcEvent,
  IfcEventTime: () => IfcEventTime,
  IfcEventType: () => IfcEventType,
  IfcExtendedProperties: () => IfcExtendedProperties,
  IfcExternalInformation: () => IfcExternalInformation,
  IfcExternalReference: () => IfcExternalReference,
  IfcExternalReferenceRelationship: () => IfcExternalReferenceRelationship,
  IfcExternalSpatialElement: () => IfcExternalSpatialElement,
  IfcExternalSpatialStructureElement: () => IfcExternalSpatialStructureElement,
  IfcExternallyDefinedHatchStyle: () => IfcExternallyDefinedHatchStyle,
  IfcExternallyDefinedSurfaceStyle: () => IfcExternallyDefinedSurfaceStyle,
  IfcExternallyDefinedTextFont: () => IfcExternallyDefinedTextFont,
  IfcExtrudedAreaSolid: () => IfcExtrudedAreaSolid,
  IfcExtrudedAreaSolidTapered: () => IfcExtrudedAreaSolidTapered,
  IfcFace: () => IfcFace,
  IfcFaceBasedSurfaceModel: () => IfcFaceBasedSurfaceModel,
  IfcFaceBound: () => IfcFaceBound,
  IfcFaceOuterBound: () => IfcFaceOuterBound,
  IfcFaceSurface: () => IfcFaceSurface,
  IfcFacetedBrep: () => IfcFacetedBrep,
  IfcFacetedBrepWithVoids: () => IfcFacetedBrepWithVoids,
  IfcFailureConnectionCondition: () => IfcFailureConnectionCondition,
  IfcFan: () => IfcFan,
  IfcFanType: () => IfcFanType,
  IfcFastener: () => IfcFastener,
  IfcFastenerType: () => IfcFastenerType,
  IfcFeatureElement: () => IfcFeatureElement,
  IfcFeatureElementAddition: () => IfcFeatureElementAddition,
  IfcFeatureElementSubtraction: () => IfcFeatureElementSubtraction,
  IfcFillAreaStyle: () => IfcFillAreaStyle,
  IfcFillAreaStyleHatching: () => IfcFillAreaStyleHatching,
  IfcFillAreaStyleTiles: () => IfcFillAreaStyleTiles,
  IfcFilter: () => IfcFilter,
  IfcFilterType: () => IfcFilterType,
  IfcFireSuppressionTerminal: () => IfcFireSuppressionTerminal,
  IfcFireSuppressionTerminalType: () => IfcFireSuppressionTerminalType,
  IfcFixedReferenceSweptAreaSolid: () => IfcFixedReferenceSweptAreaSolid,
  IfcFlowController: () => IfcFlowController,
  IfcFlowControllerType: () => IfcFlowControllerType,
  IfcFlowFitting: () => IfcFlowFitting,
  IfcFlowFittingType: () => IfcFlowFittingType,
  IfcFlowInstrument: () => IfcFlowInstrument,
  IfcFlowInstrumentType: () => IfcFlowInstrumentType,
  IfcFlowMeter: () => IfcFlowMeter,
  IfcFlowMeterType: () => IfcFlowMeterType,
  IfcFlowMovingDevice: () => IfcFlowMovingDevice,
  IfcFlowMovingDeviceType: () => IfcFlowMovingDeviceType,
  IfcFlowSegment: () => IfcFlowSegment,
  IfcFlowSegmentType: () => IfcFlowSegmentType,
  IfcFlowStorageDevice: () => IfcFlowStorageDevice,
  IfcFlowStorageDeviceType: () => IfcFlowStorageDeviceType,
  IfcFlowTerminal: () => IfcFlowTerminal,
  IfcFlowTerminalType: () => IfcFlowTerminalType,
  IfcFlowTreatmentDevice: () => IfcFlowTreatmentDevice,
  IfcFlowTreatmentDeviceType: () => IfcFlowTreatmentDeviceType,
  IfcFooting: () => IfcFooting,
  IfcFootingType: () => IfcFootingType,
  IfcFurnishingElement: () => IfcFurnishingElement,
  IfcFurnishingElementType: () => IfcFurnishingElementType,
  IfcFurniture: () => IfcFurniture,
  IfcFurnitureType: () => IfcFurnitureType,
  IfcGeographicElement: () => IfcGeographicElement,
  IfcGeographicElementType: () => IfcGeographicElementType,
  IfcGeometricCurveSet: () => IfcGeometricCurveSet,
  IfcGeometricRepresentationContext: () => IfcGeometricRepresentationContext,
  IfcGeometricRepresentationItem: () => IfcGeometricRepresentationItem,
  IfcGeometricRepresentationSubContext: () => IfcGeometricRepresentationSubContext,
  IfcGeometricSet: () => IfcGeometricSet,
  IfcGrid: () => IfcGrid,
  IfcGridAxis: () => IfcGridAxis,
  IfcGridPlacement: () => IfcGridPlacement,
  IfcGroup: () => IfcGroup,
  IfcHalfSpaceSolid: () => IfcHalfSpaceSolid,
  IfcHeatExchanger: () => IfcHeatExchanger,
  IfcHeatExchangerType: () => IfcHeatExchangerType,
  IfcHumidifier: () => IfcHumidifier,
  IfcHumidifierType: () => IfcHumidifierType,
  IfcIShapeProfileDef: () => IfcIShapeProfileDef,
  IfcImageTexture: () => IfcImageTexture,
  IfcIndexedColourMap: () => IfcIndexedColourMap,
  IfcIndexedPolyCurve: () => IfcIndexedPolyCurve,
  IfcIndexedPolygonalFace: () => IfcIndexedPolygonalFace,
  IfcIndexedPolygonalFaceWithVoids: () => IfcIndexedPolygonalFaceWithVoids,
  IfcIndexedTextureMap: () => IfcIndexedTextureMap,
  IfcIndexedTriangleTextureMap: () => IfcIndexedTriangleTextureMap,
  IfcInterceptor: () => IfcInterceptor,
  IfcInterceptorType: () => IfcInterceptorType,
  IfcIntersectionCurve: () => IfcIntersectionCurve,
  IfcInventory: () => IfcInventory,
  IfcIrregularTimeSeries: () => IfcIrregularTimeSeries,
  IfcIrregularTimeSeriesValue: () => IfcIrregularTimeSeriesValue,
  IfcJunctionBox: () => IfcJunctionBox,
  IfcJunctionBoxType: () => IfcJunctionBoxType,
  IfcLShapeProfileDef: () => IfcLShapeProfileDef,
  IfcLaborResource: () => IfcLaborResource,
  IfcLaborResourceType: () => IfcLaborResourceType,
  IfcLagTime: () => IfcLagTime,
  IfcLamp: () => IfcLamp,
  IfcLampType: () => IfcLampType,
  IfcLibraryInformation: () => IfcLibraryInformation,
  IfcLibraryReference: () => IfcLibraryReference,
  IfcLightDistributionData: () => IfcLightDistributionData,
  IfcLightFixture: () => IfcLightFixture,
  IfcLightFixtureType: () => IfcLightFixtureType,
  IfcLightIntensityDistribution: () => IfcLightIntensityDistribution,
  IfcLightSource: () => IfcLightSource,
  IfcLightSourceAmbient: () => IfcLightSourceAmbient,
  IfcLightSourceDirectional: () => IfcLightSourceDirectional,
  IfcLightSourceGoniometric: () => IfcLightSourceGoniometric,
  IfcLightSourcePositional: () => IfcLightSourcePositional,
  IfcLightSourceSpot: () => IfcLightSourceSpot,
  IfcLine: () => IfcLine,
  IfcLocalPlacement: () => IfcLocalPlacement,
  IfcLoop: () => IfcLoop,
  IfcManifoldSolidBrep: () => IfcManifoldSolidBrep,
  IfcMapConversion: () => IfcMapConversion,
  IfcMappedItem: () => IfcMappedItem,
  IfcMaterial: () => IfcMaterial,
  IfcMaterialClassificationRelationship: () => IfcMaterialClassificationRelationship,
  IfcMaterialConstituent: () => IfcMaterialConstituent,
  IfcMaterialConstituentSet: () => IfcMaterialConstituentSet,
  IfcMaterialDefinition: () => IfcMaterialDefinition,
  IfcMaterialDefinitionRepresentation: () => IfcMaterialDefinitionRepresentation,
  IfcMaterialLayer: () => IfcMaterialLayer,
  IfcMaterialLayerSet: () => IfcMaterialLayerSet,
  IfcMaterialLayerSetUsage: () => IfcMaterialLayerSetUsage,
  IfcMaterialLayerWithOffsets: () => IfcMaterialLayerWithOffsets,
  IfcMaterialList: () => IfcMaterialList,
  IfcMaterialProfile: () => IfcMaterialProfile,
  IfcMaterialProfileSet: () => IfcMaterialProfileSet,
  IfcMaterialProfileSetUsage: () => IfcMaterialProfileSetUsage,
  IfcMaterialProfileSetUsageTapering: () => IfcMaterialProfileSetUsageTapering,
  IfcMaterialProfileWithOffsets: () => IfcMaterialProfileWithOffsets,
  IfcMaterialProperties: () => IfcMaterialProperties,
  IfcMaterialRelationship: () => IfcMaterialRelationship,
  IfcMaterialUsageDefinition: () => IfcMaterialUsageDefinition,
  IfcMeasureWithUnit: () => IfcMeasureWithUnit,
  IfcMechanicalFastener: () => IfcMechanicalFastener,
  IfcMechanicalFastenerType: () => IfcMechanicalFastenerType,
  IfcMedicalDevice: () => IfcMedicalDevice,
  IfcMedicalDeviceType: () => IfcMedicalDeviceType,
  IfcMember: () => IfcMember,
  IfcMemberStandardCase: () => IfcMemberStandardCase,
  IfcMemberType: () => IfcMemberType,
  IfcMetric: () => IfcMetric,
  IfcMirroredProfileDef: () => IfcMirroredProfileDef,
  IfcMonetaryUnit: () => IfcMonetaryUnit,
  IfcMotorConnection: () => IfcMotorConnection,
  IfcMotorConnectionType: () => IfcMotorConnectionType,
  IfcNamedUnit: () => IfcNamedUnit,
  IfcObject: () => IfcObject,
  IfcObjectDefinition: () => IfcObjectDefinition,
  IfcObjectPlacement: () => IfcObjectPlacement,
  IfcObjective: () => IfcObjective,
  IfcOccupant: () => IfcOccupant,
  IfcOffsetCurve2D: () => IfcOffsetCurve2D,
  IfcOffsetCurve3D: () => IfcOffsetCurve3D,
  IfcOpenShell: () => IfcOpenShell,
  IfcOpeningElement: () => IfcOpeningElement,
  IfcOpeningStandardCase: () => IfcOpeningStandardCase,
  IfcOrganization: () => IfcOrganization,
  IfcOrganizationRelationship: () => IfcOrganizationRelationship,
  IfcOrientedEdge: () => IfcOrientedEdge,
  IfcOuterBoundaryCurve: () => IfcOuterBoundaryCurve,
  IfcOutlet: () => IfcOutlet,
  IfcOutletType: () => IfcOutletType,
  IfcOwnerHistory: () => IfcOwnerHistory,
  IfcParameterizedProfileDef: () => IfcParameterizedProfileDef,
  IfcPath: () => IfcPath,
  IfcPcurve: () => IfcPcurve,
  IfcPerformanceHistory: () => IfcPerformanceHistory,
  IfcPermeableCoveringProperties: () => IfcPermeableCoveringProperties,
  IfcPermit: () => IfcPermit,
  IfcPerson: () => IfcPerson,
  IfcPersonAndOrganization: () => IfcPersonAndOrganization,
  IfcPhysicalComplexQuantity: () => IfcPhysicalComplexQuantity,
  IfcPhysicalQuantity: () => IfcPhysicalQuantity,
  IfcPhysicalSimpleQuantity: () => IfcPhysicalSimpleQuantity,
  IfcPile: () => IfcPile,
  IfcPileType: () => IfcPileType,
  IfcPipeFitting: () => IfcPipeFitting,
  IfcPipeFittingType: () => IfcPipeFittingType,
  IfcPipeSegment: () => IfcPipeSegment,
  IfcPipeSegmentType: () => IfcPipeSegmentType,
  IfcPixelTexture: () => IfcPixelTexture,
  IfcPlacement: () => IfcPlacement,
  IfcPlanarBox: () => IfcPlanarBox,
  IfcPlanarExtent: () => IfcPlanarExtent,
  IfcPlane: () => IfcPlane,
  IfcPlate: () => IfcPlate,
  IfcPlateStandardCase: () => IfcPlateStandardCase,
  IfcPlateType: () => IfcPlateType,
  IfcPoint: () => IfcPoint,
  IfcPointOnCurve: () => IfcPointOnCurve,
  IfcPointOnSurface: () => IfcPointOnSurface,
  IfcPolyLoop: () => IfcPolyLoop,
  IfcPolygonalBoundedHalfSpace: () => IfcPolygonalBoundedHalfSpace,
  IfcPolygonalFaceSet: () => IfcPolygonalFaceSet,
  IfcPolyline: () => IfcPolyline,
  IfcPort: () => IfcPort,
  IfcPostalAddress: () => IfcPostalAddress,
  IfcPreDefinedColour: () => IfcPreDefinedColour,
  IfcPreDefinedCurveFont: () => IfcPreDefinedCurveFont,
  IfcPreDefinedItem: () => IfcPreDefinedItem,
  IfcPreDefinedProperties: () => IfcPreDefinedProperties,
  IfcPreDefinedPropertySet: () => IfcPreDefinedPropertySet,
  IfcPreDefinedTextFont: () => IfcPreDefinedTextFont,
  IfcPresentationItem: () => IfcPresentationItem,
  IfcPresentationLayerAssignment: () => IfcPresentationLayerAssignment,
  IfcPresentationLayerWithStyle: () => IfcPresentationLayerWithStyle,
  IfcPresentationStyle: () => IfcPresentationStyle,
  IfcPresentationStyleAssignment: () => IfcPresentationStyleAssignment,
  IfcProcedure: () => IfcProcedure,
  IfcProcedureType: () => IfcProcedureType,
  IfcProcess: () => IfcProcess,
  IfcProduct: () => IfcProduct,
  IfcProductDefinitionShape: () => IfcProductDefinitionShape,
  IfcProductRepresentation: () => IfcProductRepresentation,
  IfcProfileDef: () => IfcProfileDef,
  IfcProfileProperties: () => IfcProfileProperties,
  IfcProject: () => IfcProject,
  IfcProjectLibrary: () => IfcProjectLibrary,
  IfcProjectOrder: () => IfcProjectOrder,
  IfcProjectedCRS: () => IfcProjectedCRS,
  IfcProjectionElement: () => IfcProjectionElement,
  IfcProperty: () => IfcProperty,
  IfcPropertyAbstraction: () => IfcPropertyAbstraction,
  IfcPropertyBoundedValue: () => IfcPropertyBoundedValue,
  IfcPropertyDefinition: () => IfcPropertyDefinition,
  IfcPropertyDependencyRelationship: () => IfcPropertyDependencyRelationship,
  IfcPropertyEnumeratedValue: () => IfcPropertyEnumeratedValue,
  IfcPropertyEnumeration: () => IfcPropertyEnumeration,
  IfcPropertyListValue: () => IfcPropertyListValue,
  IfcPropertyReferenceValue: () => IfcPropertyReferenceValue,
  IfcPropertySet: () => IfcPropertySet,
  IfcPropertySetDefinition: () => IfcPropertySetDefinition,
  IfcPropertySetTemplate: () => IfcPropertySetTemplate,
  IfcPropertySingleValue: () => IfcPropertySingleValue,
  IfcPropertyTableValue: () => IfcPropertyTableValue,
  IfcPropertyTemplate: () => IfcPropertyTemplate,
  IfcPropertyTemplateDefinition: () => IfcPropertyTemplateDefinition,
  IfcProtectiveDevice: () => IfcProtectiveDevice,
  IfcProtectiveDeviceTrippingUnit: () => IfcProtectiveDeviceTrippingUnit,
  IfcProtectiveDeviceTrippingUnitType: () => IfcProtectiveDeviceTrippingUnitType,
  IfcProtectiveDeviceType: () => IfcProtectiveDeviceType,
  IfcProxy: () => IfcProxy,
  IfcPump: () => IfcPump,
  IfcPumpType: () => IfcPumpType,
  IfcQuantityArea: () => IfcQuantityArea,
  IfcQuantityCount: () => IfcQuantityCount,
  IfcQuantityLength: () => IfcQuantityLength,
  IfcQuantitySet: () => IfcQuantitySet,
  IfcQuantityTime: () => IfcQuantityTime,
  IfcQuantityVolume: () => IfcQuantityVolume,
  IfcQuantityWeight: () => IfcQuantityWeight,
  IfcRailing: () => IfcRailing,
  IfcRailingType: () => IfcRailingType,
  IfcRamp: () => IfcRamp,
  IfcRampFlight: () => IfcRampFlight,
  IfcRampFlightType: () => IfcRampFlightType,
  IfcRampType: () => IfcRampType,
  IfcRationalBSplineCurveWithKnots: () => IfcRationalBSplineCurveWithKnots,
  IfcRationalBSplineSurfaceWithKnots: () => IfcRationalBSplineSurfaceWithKnots,
  IfcRectangleHollowProfileDef: () => IfcRectangleHollowProfileDef,
  IfcRectangleProfileDef: () => IfcRectangleProfileDef,
  IfcRectangularPyramid: () => IfcRectangularPyramid,
  IfcRectangularTrimmedSurface: () => IfcRectangularTrimmedSurface,
  IfcRecurrencePattern: () => IfcRecurrencePattern,
  IfcReference: () => IfcReference,
  IfcRegularTimeSeries: () => IfcRegularTimeSeries,
  IfcReinforcementBarProperties: () => IfcReinforcementBarProperties,
  IfcReinforcementDefinitionProperties: () => IfcReinforcementDefinitionProperties,
  IfcReinforcingBar: () => IfcReinforcingBar,
  IfcReinforcingBarType: () => IfcReinforcingBarType,
  IfcReinforcingElement: () => IfcReinforcingElement,
  IfcReinforcingElementType: () => IfcReinforcingElementType,
  IfcReinforcingMesh: () => IfcReinforcingMesh,
  IfcReinforcingMeshType: () => IfcReinforcingMeshType,
  IfcRelAggregates: () => IfcRelAggregates,
  IfcRelAssigns: () => IfcRelAssigns,
  IfcRelAssignsToActor: () => IfcRelAssignsToActor,
  IfcRelAssignsToControl: () => IfcRelAssignsToControl,
  IfcRelAssignsToGroup: () => IfcRelAssignsToGroup,
  IfcRelAssignsToGroupByFactor: () => IfcRelAssignsToGroupByFactor,
  IfcRelAssignsToProcess: () => IfcRelAssignsToProcess,
  IfcRelAssignsToProduct: () => IfcRelAssignsToProduct,
  IfcRelAssignsToResource: () => IfcRelAssignsToResource,
  IfcRelAssociates: () => IfcRelAssociates,
  IfcRelAssociatesApproval: () => IfcRelAssociatesApproval,
  IfcRelAssociatesClassification: () => IfcRelAssociatesClassification,
  IfcRelAssociatesConstraint: () => IfcRelAssociatesConstraint,
  IfcRelAssociatesDocument: () => IfcRelAssociatesDocument,
  IfcRelAssociatesLibrary: () => IfcRelAssociatesLibrary,
  IfcRelAssociatesMaterial: () => IfcRelAssociatesMaterial,
  IfcRelConnects: () => IfcRelConnects,
  IfcRelConnectsElements: () => IfcRelConnectsElements,
  IfcRelConnectsPathElements: () => IfcRelConnectsPathElements,
  IfcRelConnectsPortToElement: () => IfcRelConnectsPortToElement,
  IfcRelConnectsPorts: () => IfcRelConnectsPorts,
  IfcRelConnectsStructuralActivity: () => IfcRelConnectsStructuralActivity,
  IfcRelConnectsStructuralMember: () => IfcRelConnectsStructuralMember,
  IfcRelConnectsWithEccentricity: () => IfcRelConnectsWithEccentricity,
  IfcRelConnectsWithRealizingElements: () => IfcRelConnectsWithRealizingElements,
  IfcRelContainedInSpatialStructure: () => IfcRelContainedInSpatialStructure,
  IfcRelCoversBldgElements: () => IfcRelCoversBldgElements,
  IfcRelCoversSpaces: () => IfcRelCoversSpaces,
  IfcRelDeclares: () => IfcRelDeclares,
  IfcRelDecomposes: () => IfcRelDecomposes,
  IfcRelDefines: () => IfcRelDefines,
  IfcRelDefinesByObject: () => IfcRelDefinesByObject,
  IfcRelDefinesByProperties: () => IfcRelDefinesByProperties,
  IfcRelDefinesByTemplate: () => IfcRelDefinesByTemplate,
  IfcRelDefinesByType: () => IfcRelDefinesByType,
  IfcRelFillsElement: () => IfcRelFillsElement,
  IfcRelFlowControlElements: () => IfcRelFlowControlElements,
  IfcRelInterferesElements: () => IfcRelInterferesElements,
  IfcRelNests: () => IfcRelNests,
  IfcRelProjectsElement: () => IfcRelProjectsElement,
  IfcRelReferencedInSpatialStructure: () => IfcRelReferencedInSpatialStructure,
  IfcRelSequence: () => IfcRelSequence,
  IfcRelServicesBuildings: () => IfcRelServicesBuildings,
  IfcRelSpaceBoundary: () => IfcRelSpaceBoundary,
  IfcRelSpaceBoundary1stLevel: () => IfcRelSpaceBoundary1stLevel,
  IfcRelSpaceBoundary2ndLevel: () => IfcRelSpaceBoundary2ndLevel,
  IfcRelVoidsElement: () => IfcRelVoidsElement,
  IfcRelationship: () => IfcRelationship,
  IfcReparametrisedCompositeCurveSegment: () => IfcReparametrisedCompositeCurveSegment,
  IfcRepresentation: () => IfcRepresentation,
  IfcRepresentationContext: () => IfcRepresentationContext,
  IfcRepresentationItem: () => IfcRepresentationItem,
  IfcRepresentationMap: () => IfcRepresentationMap,
  IfcResource: () => IfcResource,
  IfcResourceApprovalRelationship: () => IfcResourceApprovalRelationship,
  IfcResourceConstraintRelationship: () => IfcResourceConstraintRelationship,
  IfcResourceLevelRelationship: () => IfcResourceLevelRelationship,
  IfcResourceTime: () => IfcResourceTime,
  IfcRevolvedAreaSolid: () => IfcRevolvedAreaSolid,
  IfcRevolvedAreaSolidTapered: () => IfcRevolvedAreaSolidTapered,
  IfcRightCircularCone: () => IfcRightCircularCone,
  IfcRightCircularCylinder: () => IfcRightCircularCylinder,
  IfcRoof: () => IfcRoof,
  IfcRoofType: () => IfcRoofType,
  IfcRoot: () => IfcRoot,
  IfcRoundedRectangleProfileDef: () => IfcRoundedRectangleProfileDef,
  IfcSIUnit: () => IfcSIUnit,
  IfcSanitaryTerminal: () => IfcSanitaryTerminal,
  IfcSanitaryTerminalType: () => IfcSanitaryTerminalType,
  IfcSchedulingTime: () => IfcSchedulingTime,
  IfcSeamCurve: () => IfcSeamCurve,
  IfcSectionProperties: () => IfcSectionProperties,
  IfcSectionReinforcementProperties: () => IfcSectionReinforcementProperties,
  IfcSectionedSpine: () => IfcSectionedSpine,
  IfcSensor: () => IfcSensor,
  IfcSensorType: () => IfcSensorType,
  IfcShadingDevice: () => IfcShadingDevice,
  IfcShadingDeviceType: () => IfcShadingDeviceType,
  IfcShapeAspect: () => IfcShapeAspect,
  IfcShapeModel: () => IfcShapeModel,
  IfcShapeRepresentation: () => IfcShapeRepresentation,
  IfcShellBasedSurfaceModel: () => IfcShellBasedSurfaceModel,
  IfcSimpleProperty: () => IfcSimpleProperty,
  IfcSimplePropertyTemplate: () => IfcSimplePropertyTemplate,
  IfcSite: () => IfcSite,
  IfcSlab: () => IfcSlab,
  IfcSlabElementedCase: () => IfcSlabElementedCase,
  IfcSlabStandardCase: () => IfcSlabStandardCase,
  IfcSlabType: () => IfcSlabType,
  IfcSlippageConnectionCondition: () => IfcSlippageConnectionCondition,
  IfcSolarDevice: () => IfcSolarDevice,
  IfcSolarDeviceType: () => IfcSolarDeviceType,
  IfcSolidModel: () => IfcSolidModel,
  IfcSpace: () => IfcSpace,
  IfcSpaceHeater: () => IfcSpaceHeater,
  IfcSpaceHeaterType: () => IfcSpaceHeaterType,
  IfcSpaceType: () => IfcSpaceType,
  IfcSpatialElement: () => IfcSpatialElement,
  IfcSpatialElementType: () => IfcSpatialElementType,
  IfcSpatialStructureElement: () => IfcSpatialStructureElement,
  IfcSpatialStructureElementType: () => IfcSpatialStructureElementType,
  IfcSpatialZone: () => IfcSpatialZone,
  IfcSpatialZoneType: () => IfcSpatialZoneType,
  IfcSphere: () => IfcSphere,
  IfcSphericalSurface: () => IfcSphericalSurface,
  IfcStackTerminal: () => IfcStackTerminal,
  IfcStackTerminalType: () => IfcStackTerminalType,
  IfcStair: () => IfcStair,
  IfcStairFlight: () => IfcStairFlight,
  IfcStairFlightType: () => IfcStairFlightType,
  IfcStairType: () => IfcStairType,
  IfcStructuralAction: () => IfcStructuralAction,
  IfcStructuralActivity: () => IfcStructuralActivity,
  IfcStructuralAnalysisModel: () => IfcStructuralAnalysisModel,
  IfcStructuralConnection: () => IfcStructuralConnection,
  IfcStructuralConnectionCondition: () => IfcStructuralConnectionCondition,
  IfcStructuralCurveAction: () => IfcStructuralCurveAction,
  IfcStructuralCurveConnection: () => IfcStructuralCurveConnection,
  IfcStructuralCurveMember: () => IfcStructuralCurveMember,
  IfcStructuralCurveMemberVarying: () => IfcStructuralCurveMemberVarying,
  IfcStructuralCurveReaction: () => IfcStructuralCurveReaction,
  IfcStructuralItem: () => IfcStructuralItem,
  IfcStructuralLinearAction: () => IfcStructuralLinearAction,
  IfcStructuralLoad: () => IfcStructuralLoad,
  IfcStructuralLoadCase: () => IfcStructuralLoadCase,
  IfcStructuralLoadConfiguration: () => IfcStructuralLoadConfiguration,
  IfcStructuralLoadGroup: () => IfcStructuralLoadGroup,
  IfcStructuralLoadLinearForce: () => IfcStructuralLoadLinearForce,
  IfcStructuralLoadOrResult: () => IfcStructuralLoadOrResult,
  IfcStructuralLoadPlanarForce: () => IfcStructuralLoadPlanarForce,
  IfcStructuralLoadSingleDisplacement: () => IfcStructuralLoadSingleDisplacement,
  IfcStructuralLoadSingleDisplacementDistortion: () => IfcStructuralLoadSingleDisplacementDistortion,
  IfcStructuralLoadSingleForce: () => IfcStructuralLoadSingleForce,
  IfcStructuralLoadSingleForceWarping: () => IfcStructuralLoadSingleForceWarping,
  IfcStructuralLoadStatic: () => IfcStructuralLoadStatic,
  IfcStructuralLoadTemperature: () => IfcStructuralLoadTemperature,
  IfcStructuralMember: () => IfcStructuralMember,
  IfcStructuralPlanarAction: () => IfcStructuralPlanarAction,
  IfcStructuralPointAction: () => IfcStructuralPointAction,
  IfcStructuralPointConnection: () => IfcStructuralPointConnection,
  IfcStructuralPointReaction: () => IfcStructuralPointReaction,
  IfcStructuralReaction: () => IfcStructuralReaction,
  IfcStructuralResultGroup: () => IfcStructuralResultGroup,
  IfcStructuralSurfaceAction: () => IfcStructuralSurfaceAction,
  IfcStructuralSurfaceConnection: () => IfcStructuralSurfaceConnection,
  IfcStructuralSurfaceMember: () => IfcStructuralSurfaceMember,
  IfcStructuralSurfaceMemberVarying: () => IfcStructuralSurfaceMemberVarying,
  IfcStructuralSurfaceReaction: () => IfcStructuralSurfaceReaction,
  IfcStyleModel: () => IfcStyleModel,
  IfcStyledItem: () => IfcStyledItem,
  IfcStyledRepresentation: () => IfcStyledRepresentation,
  IfcSubContractResource: () => IfcSubContractResource,
  IfcSubContractResourceType: () => IfcSubContractResourceType,
  IfcSubedge: () => IfcSubedge,
  IfcSurface: () => IfcSurface,
  IfcSurfaceCurve: () => IfcSurfaceCurve,
  IfcSurfaceCurveSweptAreaSolid: () => IfcSurfaceCurveSweptAreaSolid,
  IfcSurfaceFeature: () => IfcSurfaceFeature,
  IfcSurfaceOfLinearExtrusion: () => IfcSurfaceOfLinearExtrusion,
  IfcSurfaceOfRevolution: () => IfcSurfaceOfRevolution,
  IfcSurfaceReinforcementArea: () => IfcSurfaceReinforcementArea,
  IfcSurfaceStyle: () => IfcSurfaceStyle,
  IfcSurfaceStyleLighting: () => IfcSurfaceStyleLighting,
  IfcSurfaceStyleRefraction: () => IfcSurfaceStyleRefraction,
  IfcSurfaceStyleRendering: () => IfcSurfaceStyleRendering,
  IfcSurfaceStyleShading: () => IfcSurfaceStyleShading,
  IfcSurfaceStyleWithTextures: () => IfcSurfaceStyleWithTextures,
  IfcSurfaceTexture: () => IfcSurfaceTexture,
  IfcSweptAreaSolid: () => IfcSweptAreaSolid,
  IfcSweptDiskSolid: () => IfcSweptDiskSolid,
  IfcSweptDiskSolidPolygonal: () => IfcSweptDiskSolidPolygonal,
  IfcSweptSurface: () => IfcSweptSurface,
  IfcSwitchingDevice: () => IfcSwitchingDevice,
  IfcSwitchingDeviceType: () => IfcSwitchingDeviceType,
  IfcSystem: () => IfcSystem,
  IfcSystemFurnitureElement: () => IfcSystemFurnitureElement,
  IfcSystemFurnitureElementType: () => IfcSystemFurnitureElementType,
  IfcTShapeProfileDef: () => IfcTShapeProfileDef,
  IfcTable: () => IfcTable,
  IfcTableColumn: () => IfcTableColumn,
  IfcTableRow: () => IfcTableRow,
  IfcTank: () => IfcTank,
  IfcTankType: () => IfcTankType,
  IfcTask: () => IfcTask,
  IfcTaskTime: () => IfcTaskTime,
  IfcTaskTimeRecurring: () => IfcTaskTimeRecurring,
  IfcTaskType: () => IfcTaskType,
  IfcTelecomAddress: () => IfcTelecomAddress,
  IfcTendon: () => IfcTendon,
  IfcTendonAnchor: () => IfcTendonAnchor,
  IfcTendonAnchorType: () => IfcTendonAnchorType,
  IfcTendonType: () => IfcTendonType,
  IfcTessellatedFaceSet: () => IfcTessellatedFaceSet,
  IfcTessellatedItem: () => IfcTessellatedItem,
  IfcTextLiteral: () => IfcTextLiteral,
  IfcTextLiteralWithExtent: () => IfcTextLiteralWithExtent,
  IfcTextStyle: () => IfcTextStyle,
  IfcTextStyleFontModel: () => IfcTextStyleFontModel,
  IfcTextStyleForDefinedFont: () => IfcTextStyleForDefinedFont,
  IfcTextStyleTextModel: () => IfcTextStyleTextModel,
  IfcTextureCoordinate: () => IfcTextureCoordinate,
  IfcTextureCoordinateGenerator: () => IfcTextureCoordinateGenerator,
  IfcTextureMap: () => IfcTextureMap,
  IfcTextureVertex: () => IfcTextureVertex,
  IfcTextureVertexList: () => IfcTextureVertexList,
  IfcTimePeriod: () => IfcTimePeriod,
  IfcTimeSeries: () => IfcTimeSeries,
  IfcTimeSeriesValue: () => IfcTimeSeriesValue,
  IfcTopologicalRepresentationItem: () => IfcTopologicalRepresentationItem,
  IfcTopologyRepresentation: () => IfcTopologyRepresentation,
  IfcToroidalSurface: () => IfcToroidalSurface,
  IfcTransformer: () => IfcTransformer,
  IfcTransformerType: () => IfcTransformerType,
  IfcTransportElement: () => IfcTransportElement,
  IfcTransportElementType: () => IfcTransportElementType,
  IfcTrapeziumProfileDef: () => IfcTrapeziumProfileDef,
  IfcTriangulatedFaceSet: () => IfcTriangulatedFaceSet,
  IfcTrimmedCurve: () => IfcTrimmedCurve,
  IfcTubeBundle: () => IfcTubeBundle,
  IfcTubeBundleType: () => IfcTubeBundleType,
  IfcTypeObject: () => IfcTypeObject,
  IfcTypeProcess: () => IfcTypeProcess,
  IfcTypeProduct: () => IfcTypeProduct,
  IfcTypeResource: () => IfcTypeResource,
  IfcUShapeProfileDef: () => IfcUShapeProfileDef,
  IfcUnitAssignment: () => IfcUnitAssignment,
  IfcUnitaryControlElement: () => IfcUnitaryControlElement,
  IfcUnitaryControlElementType: () => IfcUnitaryControlElementType,
  IfcUnitaryEquipment: () => IfcUnitaryEquipment,
  IfcUnitaryEquipmentType: () => IfcUnitaryEquipmentType,
  IfcValve: () => IfcValve,
  IfcValveType: () => IfcValveType,
  IfcVector: () => IfcVector,
  IfcVertex: () => IfcVertex,
  IfcVertexLoop: () => IfcVertexLoop,
  IfcVertexPoint: () => IfcVertexPoint,
  IfcVibrationIsolator: () => IfcVibrationIsolator,
  IfcVibrationIsolatorType: () => IfcVibrationIsolatorType,
  IfcVirtualElement: () => IfcVirtualElement,
  IfcVirtualGridIntersection: () => IfcVirtualGridIntersection,
  IfcVoidingFeature: () => IfcVoidingFeature,
  IfcWall: () => IfcWall,
  IfcWallElementedCase: () => IfcWallElementedCase,
  IfcWallStandardCase: () => IfcWallStandardCase,
  IfcWallType: () => IfcWallType,
  IfcWasteTerminal: () => IfcWasteTerminal,
  IfcWasteTerminalType: () => IfcWasteTerminalType,
  IfcWindow: () => IfcWindow,
  IfcWindowLiningProperties: () => IfcWindowLiningProperties,
  IfcWindowPanelProperties: () => IfcWindowPanelProperties,
  IfcWindowStandardCase: () => IfcWindowStandardCase,
  IfcWindowStyle: () => IfcWindowStyle,
  IfcWindowType: () => IfcWindowType,
  IfcWorkCalendar: () => IfcWorkCalendar,
  IfcWorkControl: () => IfcWorkControl,
  IfcWorkPlan: () => IfcWorkPlan,
  IfcWorkSchedule: () => IfcWorkSchedule,
  IfcWorkTime: () => IfcWorkTime,
  IfcZShapeProfileDef: () => IfcZShapeProfileDef,
  IfcZone: () => IfcZone,
  ifcTypeCodes: () => ifcTypeCodes,
  ifcTypeNames: () => ifcTypeNames
});
var IfcActionRequest = 1e3;
var IfcActor = 1001;
var IfcActorRole = 1002;
var IfcActuator = 1003;
var IfcActuatorType = 1004;
var IfcAddress = 1005;
var IfcAdvancedBrep = 1006;
var IfcAdvancedBrepWithVoids = 1007;
var IfcAdvancedFace = 1008;
var IfcAirTerminal = 1009;
var IfcAirTerminalBox = 1010;
var IfcAirTerminalBoxType = 1011;
var IfcAirTerminalType = 1012;
var IfcAirToAirHeatRecovery = 1013;
var IfcAirToAirHeatRecoveryType = 1014;
var IfcAlarm = 1015;
var IfcAlarmType = 1016;
var IfcAnnotation = 1017;
var IfcAnnotationFillArea = 1018;
var IfcApplication = 1019;
var IfcAppliedValue = 1020;
var IfcApproval = 1021;
var IfcApprovalRelationship = 1022;
var IfcArbitraryClosedProfileDef = 1023;
var IfcArbitraryOpenProfileDef = 1024;
var IfcArbitraryProfileDefWithVoids = 1025;
var IfcAsset = 1026;
var IfcAsymmetricIShapeProfileDef = 1027;
var IfcAudioVisualAppliance = 1028;
var IfcAudioVisualApplianceType = 1029;
var IfcAxis1Placement = 1030;
var IfcAxis2Placement2D = 1031;
var IfcAxis2Placement3D = 1032;
var IfcBeam = 1033;
var IfcBeamStandardCase = 1034;
var IfcBeamType = 1035;
var IfcBlobTexture = 1036;
var IfcBlock = 1037;
var IfcBoiler = 1038;
var IfcBoilerType = 1039;
var IfcBooleanClippingResult = 1040;
var IfcBooleanResult = 1041;
var IfcBoundaryCondition = 1042;
var IfcBoundaryCurve = 1043;
var IfcBoundaryEdgeCondition = 1044;
var IfcBoundaryFaceCondition = 1045;
var IfcBoundaryNodeCondition = 1046;
var IfcBoundaryNodeConditionWarping = 1047;
var IfcBoundedCurve = 1048;
var IfcBoundedSurface = 1049;
var IfcBoundingBox = 1050;
var IfcBoxedHalfSpace = 1051;
var IfcBSplineCurve = 1052;
var IfcBSplineCurveWithKnots = 1053;
var IfcBSplineSurface = 1054;
var IfcBSplineSurfaceWithKnots = 1055;
var IfcBuilding = 1056;
var IfcBuildingElementPart = 1057;
var IfcBuildingElementPartType = 1058;
var IfcBuildingElementProxy = 1059;
var IfcBuildingElementProxyType = 1060;
var IfcBuildingStorey = 1061;
var IfcBuildingSystem = 1062;
var IfcBurner = 1063;
var IfcBurnerType = 1064;
var IfcCableCarrierFitting = 1065;
var IfcCableCarrierFittingType = 1066;
var IfcCableCarrierSegment = 1067;
var IfcCableCarrierSegmentType = 1068;
var IfcCableFitting = 1069;
var IfcCableFittingType = 1070;
var IfcCableSegment = 1071;
var IfcCableSegmentType = 1072;
var IfcCartesianPoint = 1073;
var IfcCartesianPointList = 1074;
var IfcCartesianPointList2D = 1075;
var IfcCartesianPointList3D = 1076;
var IfcCartesianTransformationOperator = 1077;
var IfcCartesianTransformationOperator2D = 1078;
var IfcCartesianTransformationOperator2DnonUniform = 1079;
var IfcCartesianTransformationOperator3D = 1080;
var IfcCartesianTransformationOperator3DnonUniform = 1081;
var IfcCenterLineProfileDef = 1082;
var IfcChiller = 1083;
var IfcChillerType = 1084;
var IfcChimney = 1085;
var IfcChimneyType = 1086;
var IfcCircle = 1087;
var IfcCircleHollowProfileDef = 1088;
var IfcCircleProfileDef = 1089;
var IfcCivilElement = 1090;
var IfcCivilElementType = 1091;
var IfcClassification = 1092;
var IfcClassificationReference = 1093;
var IfcClosedShell = 1094;
var IfcCoil = 1095;
var IfcCoilType = 1096;
var IfcColourRgb = 1097;
var IfcColourRgbList = 1098;
var IfcColourSpecification = 1099;
var IfcColumn = 1100;
var IfcColumnStandardCase = 1101;
var IfcColumnType = 1102;
var IfcCommunicationsAppliance = 1103;
var IfcCommunicationsApplianceType = 1104;
var IfcComplexProperty = 1105;
var IfcComplexPropertyTemplate = 1106;
var IfcCompositeCurve = 1107;
var IfcCompositeCurveOnSurface = 1108;
var IfcCompositeCurveSegment = 1109;
var IfcCompositeProfileDef = 1110;
var IfcCompressor = 1111;
var IfcCompressorType = 1112;
var IfcCondenser = 1113;
var IfcCondenserType = 1114;
var IfcConic = 1115;
var IfcConnectedFaceSet = 1116;
var IfcConnectionCurveGeometry = 1117;
var IfcConnectionGeometry = 1118;
var IfcConnectionPointEccentricity = 1119;
var IfcConnectionPointGeometry = 1120;
var IfcConnectionSurfaceGeometry = 1121;
var IfcConnectionVolumeGeometry = 1122;
var IfcConstraint = 1123;
var IfcConstructionEquipmentResource = 1124;
var IfcConstructionEquipmentResourceType = 1125;
var IfcConstructionMaterialResource = 1126;
var IfcConstructionMaterialResourceType = 1127;
var IfcConstructionProductResource = 1128;
var IfcConstructionProductResourceType = 1129;
var IfcConstructionResource = 1130;
var IfcConstructionResourceType = 1131;
var IfcContext = 1132;
var IfcContextDependentUnit = 1133;
var IfcControl = 1134;
var IfcController = 1135;
var IfcControllerType = 1136;
var IfcConversionBasedUnit = 1137;
var IfcConversionBasedUnitWithOffset = 1138;
var IfcCooledBeam = 1139;
var IfcCooledBeamType = 1140;
var IfcCoolingTower = 1141;
var IfcCoolingTowerType = 1142;
var IfcCoordinateOperation = 1143;
var IfcCoordinateReferenceSystem = 1144;
var IfcCostItem = 1145;
var IfcCostSchedule = 1146;
var IfcCostValue = 1147;
var IfcCovering = 1148;
var IfcCoveringType = 1149;
var IfcCrewResource = 1150;
var IfcCrewResourceType = 1151;
var IfcCsgPrimitive3D = 1152;
var IfcCsgSolid = 1153;
var IfcCShapeProfileDef = 1154;
var IfcCurrencyRelationship = 1155;
var IfcCurtainWall = 1156;
var IfcCurtainWallType = 1157;
var IfcCurve = 1158;
var IfcCurveBoundedPlane = 1159;
var IfcCurveBoundedSurface = 1160;
var IfcCurveStyle = 1161;
var IfcCurveStyleFont = 1162;
var IfcCurveStyleFontAndScaling = 1163;
var IfcCurveStyleFontPattern = 1164;
var IfcCylindricalSurface = 1165;
var IfcDamper = 1166;
var IfcDamperType = 1167;
var IfcDerivedProfileDef = 1168;
var IfcDerivedUnit = 1169;
var IfcDerivedUnitElement = 1170;
var IfcDimensionalExponents = 1171;
var IfcDirection = 1172;
var IfcDiscreteAccessory = 1173;
var IfcDiscreteAccessoryType = 1174;
var IfcDistributionChamberElement = 1175;
var IfcDistributionChamberElementType = 1176;
var IfcDistributionCircuit = 1177;
var IfcDistributionControlElement = 1178;
var IfcDistributionControlElementType = 1179;
var IfcDistributionElement = 1180;
var IfcDistributionElementType = 1181;
var IfcDistributionFlowElement = 1182;
var IfcDistributionFlowElementType = 1183;
var IfcDistributionPort = 1184;
var IfcDistributionSystem = 1185;
var IfcDocumentInformation = 1186;
var IfcDocumentInformationRelationship = 1187;
var IfcDocumentReference = 1188;
var IfcDoor = 1189;
var IfcDoorLiningProperties = 1190;
var IfcDoorPanelProperties = 1191;
var IfcDoorStandardCase = 1192;
var IfcDoorStyle = 1193;
var IfcDoorType = 1194;
var IfcDraughtingPreDefinedColour = 1195;
var IfcDraughtingPreDefinedCurveFont = 1196;
var IfcDuctFitting = 1197;
var IfcDuctFittingType = 1198;
var IfcDuctSegment = 1199;
var IfcDuctSegmentType = 1200;
var IfcDuctSilencer = 1201;
var IfcDuctSilencerType = 1202;
var IfcEdge = 1203;
var IfcEdgeCurve = 1204;
var IfcEdgeLoop = 1205;
var IfcElectricAppliance = 1206;
var IfcElectricApplianceType = 1207;
var IfcElectricDistributionBoard = 1208;
var IfcElectricDistributionBoardType = 1209;
var IfcElectricFlowStorageDevice = 1210;
var IfcElectricFlowStorageDeviceType = 1211;
var IfcElectricGenerator = 1212;
var IfcElectricGeneratorType = 1213;
var IfcElectricMotor = 1214;
var IfcElectricMotorType = 1215;
var IfcElectricTimeControl = 1216;
var IfcElectricTimeControlType = 1217;
var IfcElement = 1218;
var IfcElementarySurface = 1219;
var IfcElementAssembly = 1220;
var IfcElementAssemblyType = 1221;
var IfcElementComponent = 1222;
var IfcElementComponentType = 1223;
var IfcElementQuantity = 1224;
var IfcElementType = 1225;
var IfcEllipse = 1226;
var IfcEllipseProfileDef = 1227;
var IfcEnergyConversionDevice = 1228;
var IfcEnergyConversionDeviceType = 1229;
var IfcEngine = 1230;
var IfcEngineType = 1231;
var IfcEvaporativeCooler = 1232;
var IfcEvaporativeCoolerType = 1233;
var IfcEvaporator = 1234;
var IfcEvaporatorType = 1235;
var IfcEvent = 1236;
var IfcEventTime = 1237;
var IfcEventType = 1238;
var IfcExtendedProperties = 1239;
var IfcExternalInformation = 1240;
var IfcExternallyDefinedHatchStyle = 1241;
var IfcExternallyDefinedSurfaceStyle = 1242;
var IfcExternallyDefinedTextFont = 1243;
var IfcExternalReference = 1244;
var IfcExternalReferenceRelationship = 1245;
var IfcExternalSpatialElement = 1246;
var IfcExternalSpatialStructureElement = 1247;
var IfcExtrudedAreaSolid = 1248;
var IfcExtrudedAreaSolidTapered = 1249;
var IfcFace = 1250;
var IfcFaceBasedSurfaceModel = 1251;
var IfcFaceBound = 1252;
var IfcFaceOuterBound = 1253;
var IfcFaceSurface = 1254;
var IfcFacetedBrep = 1255;
var IfcFacetedBrepWithVoids = 1256;
var IfcFailureConnectionCondition = 1257;
var IfcFan = 1258;
var IfcFanType = 1259;
var IfcFastener = 1260;
var IfcFastenerType = 1261;
var IfcFeatureElement = 1262;
var IfcFeatureElementAddition = 1263;
var IfcFeatureElementSubtraction = 1264;
var IfcFillAreaStyle = 1265;
var IfcFillAreaStyleHatching = 1266;
var IfcFillAreaStyleTiles = 1267;
var IfcFilter = 1268;
var IfcFilterType = 1269;
var IfcFireSuppressionTerminal = 1270;
var IfcFireSuppressionTerminalType = 1271;
var IfcFixedReferenceSweptAreaSolid = 1272;
var IfcFlowController = 1273;
var IfcFlowControllerType = 1274;
var IfcFlowFitting = 1275;
var IfcFlowFittingType = 1276;
var IfcFlowInstrument = 1277;
var IfcFlowInstrumentType = 1278;
var IfcFlowMeter = 1279;
var IfcFlowMeterType = 1280;
var IfcFlowMovingDevice = 1281;
var IfcFlowMovingDeviceType = 1282;
var IfcFlowSegment = 1283;
var IfcFlowSegmentType = 1284;
var IfcFlowStorageDevice = 1285;
var IfcFlowStorageDeviceType = 1286;
var IfcFlowTerminal = 1287;
var IfcFlowTerminalType = 1288;
var IfcFlowTreatmentDevice = 1289;
var IfcFlowTreatmentDeviceType = 1290;
var IfcFooting = 1291;
var IfcFootingType = 1292;
var IfcFurnishingElement = 1293;
var IfcFurnishingElementType = 1294;
var IfcFurniture = 1295;
var IfcFurnitureType = 1296;
var IfcGeographicElement = 1297;
var IfcGeographicElementType = 1298;
var IfcGeometricCurveSet = 1299;
var IfcGeometricRepresentationContext = 1300;
var IfcGeometricRepresentationItem = 1301;
var IfcGeometricRepresentationSubContext = 1302;
var IfcGeometricSet = 1303;
var IfcGrid = 1304;
var IfcGridAxis = 1305;
var IfcGridPlacement = 1306;
var IfcGroup = 1307;
var IfcHalfSpaceSolid = 1308;
var IfcHeatExchanger = 1309;
var IfcHeatExchangerType = 1310;
var IfcHumidifier = 1311;
var IfcHumidifierType = 1312;
var IfcImageTexture = 1313;
var IfcIndexedColourMap = 1314;
var IfcIndexedPolyCurve = 1315;
var IfcIndexedPolygonalFace = 1316;
var IfcIndexedPolygonalFaceWithVoids = 1317;
var IfcIndexedTextureMap = 1318;
var IfcIndexedTriangleTextureMap = 1319;
var IfcInterceptor = 1320;
var IfcInterceptorType = 1321;
var IfcIntersectionCurve = 1322;
var IfcInventory = 1323;
var IfcIrregularTimeSeries = 1324;
var IfcIrregularTimeSeriesValue = 1325;
var IfcIShapeProfileDef = 1326;
var IfcJunctionBox = 1327;
var IfcJunctionBoxType = 1328;
var IfcLaborResource = 1329;
var IfcLaborResourceType = 1330;
var IfcLagTime = 1331;
var IfcLamp = 1332;
var IfcLampType = 1333;
var IfcLibraryInformation = 1334;
var IfcLibraryReference = 1335;
var IfcLightDistributionData = 1336;
var IfcLightFixture = 1337;
var IfcLightFixtureType = 1338;
var IfcLightIntensityDistribution = 1339;
var IfcLightSource = 1340;
var IfcLightSourceAmbient = 1341;
var IfcLightSourceDirectional = 1342;
var IfcLightSourceGoniometric = 1343;
var IfcLightSourcePositional = 1344;
var IfcLightSourceSpot = 1345;
var IfcLine = 1346;
var IfcLocalPlacement = 1347;
var IfcLoop = 1348;
var IfcLShapeProfileDef = 1349;
var IfcManifoldSolidBrep = 1350;
var IfcMapConversion = 1351;
var IfcMappedItem = 1352;
var IfcMaterial = 1353;
var IfcMaterialClassificationRelationship = 1354;
var IfcMaterialConstituent = 1355;
var IfcMaterialConstituentSet = 1356;
var IfcMaterialDefinition = 1357;
var IfcMaterialDefinitionRepresentation = 1358;
var IfcMaterialLayer = 1359;
var IfcMaterialLayerSet = 1360;
var IfcMaterialLayerSetUsage = 1361;
var IfcMaterialLayerWithOffsets = 1362;
var IfcMaterialList = 1363;
var IfcMaterialProfile = 1364;
var IfcMaterialProfileSet = 1365;
var IfcMaterialProfileSetUsage = 1366;
var IfcMaterialProfileSetUsageTapering = 1367;
var IfcMaterialProfileWithOffsets = 1368;
var IfcMaterialProperties = 1369;
var IfcMaterialRelationship = 1370;
var IfcMaterialUsageDefinition = 1371;
var IfcMeasureWithUnit = 1372;
var IfcMechanicalFastener = 1373;
var IfcMechanicalFastenerType = 1374;
var IfcMedicalDevice = 1375;
var IfcMedicalDeviceType = 1376;
var IfcMember = 1377;
var IfcMemberStandardCase = 1378;
var IfcMemberType = 1379;
var IfcMetric = 1380;
var IfcMirroredProfileDef = 1381;
var IfcMonetaryUnit = 1382;
var IfcMotorConnection = 1383;
var IfcMotorConnectionType = 1384;
var IfcNamedUnit = 1385;
var IfcObject = 1386;
var IfcObjectDefinition = 1387;
var IfcObjective = 1388;
var IfcObjectPlacement = 1389;
var IfcOccupant = 1390;
var IfcOffsetCurve2D = 1391;
var IfcOffsetCurve3D = 1392;
var IfcOpeningElement = 1393;
var IfcOpeningStandardCase = 1394;
var IfcOpenShell = 1395;
var IfcOrganization = 1396;
var IfcOrganizationRelationship = 1397;
var IfcOrientedEdge = 1398;
var IfcOuterBoundaryCurve = 1399;
var IfcOutlet = 1400;
var IfcOutletType = 1401;
var IfcOwnerHistory = 1402;
var IfcParameterizedProfileDef = 1403;
var IfcPath = 1404;
var IfcPcurve = 1405;
var IfcPerformanceHistory = 1406;
var IfcPermeableCoveringProperties = 1407;
var IfcPermit = 1408;
var IfcPerson = 1409;
var IfcPersonAndOrganization = 1410;
var IfcPhysicalComplexQuantity = 1411;
var IfcPhysicalQuantity = 1412;
var IfcPhysicalSimpleQuantity = 1413;
var IfcPile = 1414;
var IfcPileType = 1415;
var IfcPipeFitting = 1416;
var IfcPipeFittingType = 1417;
var IfcPipeSegment = 1418;
var IfcPipeSegmentType = 1419;
var IfcPixelTexture = 1420;
var IfcPlacement = 1421;
var IfcPlanarBox = 1422;
var IfcPlanarExtent = 1423;
var IfcPlane = 1424;
var IfcPlate = 1425;
var IfcPlateStandardCase = 1426;
var IfcPlateType = 1427;
var IfcPoint = 1428;
var IfcPointOnCurve = 1429;
var IfcPointOnSurface = 1430;
var IfcPolygonalBoundedHalfSpace = 1431;
var IfcPolygonalFaceSet = 1432;
var IfcPolyline = 1433;
var IfcPolyLoop = 1434;
var IfcPort = 1435;
var IfcPostalAddress = 1436;
var IfcPreDefinedColour = 1437;
var IfcPreDefinedCurveFont = 1438;
var IfcPreDefinedItem = 1439;
var IfcPreDefinedProperties = 1440;
var IfcPreDefinedPropertySet = 1441;
var IfcPreDefinedTextFont = 1442;
var IfcPresentationItem = 1443;
var IfcPresentationLayerAssignment = 1444;
var IfcPresentationLayerWithStyle = 1445;
var IfcPresentationStyle = 1446;
var IfcPresentationStyleAssignment = 1447;
var IfcProcedure = 1448;
var IfcProcedureType = 1449;
var IfcProcess = 1450;
var IfcProduct = 1451;
var IfcProductDefinitionShape = 1452;
var IfcProductRepresentation = 1453;
var IfcProfileDef = 1454;
var IfcProfileProperties = 1455;
var IfcProject = 1456;
var IfcProjectedCRS = 1457;
var IfcProjectionElement = 1458;
var IfcProjectLibrary = 1459;
var IfcProjectOrder = 1460;
var IfcProperty = 1461;
var IfcPropertyAbstraction = 1462;
var IfcPropertyBoundedValue = 1463;
var IfcPropertyDefinition = 1464;
var IfcPropertyDependencyRelationship = 1465;
var IfcPropertyEnumeratedValue = 1466;
var IfcPropertyEnumeration = 1467;
var IfcPropertyListValue = 1468;
var IfcPropertyReferenceValue = 1469;
var IfcPropertySet = 1470;
var IfcPropertySetDefinition = 1471;
var IfcPropertySetTemplate = 1472;
var IfcPropertySingleValue = 1473;
var IfcPropertyTableValue = 1474;
var IfcPropertyTemplate = 1475;
var IfcPropertyTemplateDefinition = 1476;
var IfcProtectiveDevice = 1477;
var IfcProtectiveDeviceTrippingUnit = 1478;
var IfcProtectiveDeviceTrippingUnitType = 1479;
var IfcProtectiveDeviceType = 1480;
var IfcProxy = 1481;
var IfcPump = 1482;
var IfcPumpType = 1483;
var IfcQuantityArea = 1484;
var IfcQuantityCount = 1485;
var IfcQuantityLength = 1486;
var IfcQuantitySet = 1487;
var IfcQuantityTime = 1488;
var IfcQuantityVolume = 1489;
var IfcQuantityWeight = 1490;
var IfcRailing = 1491;
var IfcRailingType = 1492;
var IfcRamp = 1493;
var IfcRampFlight = 1494;
var IfcRampFlightType = 1495;
var IfcRampType = 1496;
var IfcRationalBSplineCurveWithKnots = 1497;
var IfcRationalBSplineSurfaceWithKnots = 1498;
var IfcRectangleHollowProfileDef = 1499;
var IfcRectangleProfileDef = 1500;
var IfcRectangularPyramid = 1501;
var IfcRectangularTrimmedSurface = 1502;
var IfcRecurrencePattern = 1503;
var IfcReference = 1504;
var IfcRegularTimeSeries = 1505;
var IfcReinforcementBarProperties = 1506;
var IfcReinforcementDefinitionProperties = 1507;
var IfcReinforcingBar = 1508;
var IfcReinforcingBarType = 1509;
var IfcReinforcingElement = 1510;
var IfcReinforcingElementType = 1511;
var IfcReinforcingMesh = 1512;
var IfcReinforcingMeshType = 1513;
var IfcRelAggregates = 1514;
var IfcRelAssigns = 1515;
var IfcRelAssignsToActor = 1516;
var IfcRelAssignsToControl = 1517;
var IfcRelAssignsToGroup = 1518;
var IfcRelAssignsToGroupByFactor = 1519;
var IfcRelAssignsToProcess = 1520;
var IfcRelAssignsToProduct = 1521;
var IfcRelAssignsToResource = 1522;
var IfcRelAssociates = 1523;
var IfcRelAssociatesApproval = 1524;
var IfcRelAssociatesClassification = 1525;
var IfcRelAssociatesConstraint = 1526;
var IfcRelAssociatesDocument = 1527;
var IfcRelAssociatesLibrary = 1528;
var IfcRelAssociatesMaterial = 1529;
var IfcRelationship = 1530;
var IfcRelConnects = 1531;
var IfcRelConnectsElements = 1532;
var IfcRelConnectsPathElements = 1533;
var IfcRelConnectsPorts = 1534;
var IfcRelConnectsPortToElement = 1535;
var IfcRelConnectsStructuralActivity = 1536;
var IfcRelConnectsStructuralMember = 1537;
var IfcRelConnectsWithEccentricity = 1538;
var IfcRelConnectsWithRealizingElements = 1539;
var IfcRelContainedInSpatialStructure = 1540;
var IfcRelCoversBldgElements = 1541;
var IfcRelCoversSpaces = 1542;
var IfcRelDeclares = 1543;
var IfcRelDecomposes = 1544;
var IfcRelDefines = 1545;
var IfcRelDefinesByObject = 1546;
var IfcRelDefinesByProperties = 1547;
var IfcRelDefinesByTemplate = 1548;
var IfcRelDefinesByType = 1549;
var IfcRelFillsElement = 1550;
var IfcRelFlowControlElements = 1551;
var IfcRelInterferesElements = 1552;
var IfcRelNests = 1553;
var IfcRelProjectsElement = 1554;
var IfcRelReferencedInSpatialStructure = 1555;
var IfcRelSequence = 1556;
var IfcRelServicesBuildings = 1557;
var IfcRelSpaceBoundary = 1558;
var IfcRelSpaceBoundary1stLevel = 1559;
var IfcRelSpaceBoundary2ndLevel = 1560;
var IfcRelVoidsElement = 1561;
var IfcReparametrisedCompositeCurveSegment = 1562;
var IfcRepresentation = 1563;
var IfcRepresentationContext = 1564;
var IfcRepresentationItem = 1565;
var IfcRepresentationMap = 1566;
var IfcResource = 1567;
var IfcResourceApprovalRelationship = 1568;
var IfcResourceConstraintRelationship = 1569;
var IfcResourceLevelRelationship = 1570;
var IfcResourceTime = 1571;
var IfcRevolvedAreaSolid = 1572;
var IfcRevolvedAreaSolidTapered = 1573;
var IfcRightCircularCone = 1574;
var IfcRightCircularCylinder = 1575;
var IfcRoof = 1576;
var IfcRoofType = 1577;
var IfcRoot = 1578;
var IfcRoundedRectangleProfileDef = 1579;
var IfcSanitaryTerminal = 1580;
var IfcSanitaryTerminalType = 1581;
var IfcSchedulingTime = 1582;
var IfcSeamCurve = 1583;
var IfcSectionedSpine = 1584;
var IfcSectionProperties = 1585;
var IfcSectionReinforcementProperties = 1586;
var IfcSensor = 1587;
var IfcSensorType = 1588;
var IfcShadingDevice = 1589;
var IfcShadingDeviceType = 1590;
var IfcShapeAspect = 1591;
var IfcShapeModel = 1592;
var IfcShapeRepresentation = 1593;
var IfcShellBasedSurfaceModel = 1594;
var IfcSimpleProperty = 1595;
var IfcSimplePropertyTemplate = 1596;
var IfcSite = 1597;
var IfcSIUnit = 1598;
var IfcSlab = 1599;
var IfcSlabElementedCase = 1600;
var IfcSlabStandardCase = 1601;
var IfcSlabType = 1602;
var IfcSlippageConnectionCondition = 1603;
var IfcSolarDevice = 1604;
var IfcSolarDeviceType = 1605;
var IfcSolidModel = 1606;
var IfcSpace = 1607;
var IfcSpaceHeater = 1608;
var IfcSpaceHeaterType = 1609;
var IfcSpaceType = 1610;
var IfcSpatialElement = 1611;
var IfcSpatialElementType = 1612;
var IfcSpatialStructureElement = 1613;
var IfcSpatialStructureElementType = 1614;
var IfcSpatialZone = 1615;
var IfcSpatialZoneType = 1616;
var IfcSphere = 1617;
var IfcSphericalSurface = 1618;
var IfcStackTerminal = 1619;
var IfcStackTerminalType = 1620;
var IfcStair = 1621;
var IfcStairFlight = 1622;
var IfcStairFlightType = 1623;
var IfcStairType = 1624;
var IfcStructuralAction = 1625;
var IfcStructuralActivity = 1626;
var IfcStructuralAnalysisModel = 1627;
var IfcStructuralConnection = 1628;
var IfcStructuralConnectionCondition = 1629;
var IfcStructuralCurveAction = 1630;
var IfcStructuralCurveConnection = 1631;
var IfcStructuralCurveMember = 1632;
var IfcStructuralCurveMemberVarying = 1633;
var IfcStructuralCurveReaction = 1634;
var IfcStructuralItem = 1635;
var IfcStructuralLinearAction = 1636;
var IfcStructuralLoad = 1637;
var IfcStructuralLoadCase = 1638;
var IfcStructuralLoadConfiguration = 1639;
var IfcStructuralLoadGroup = 1640;
var IfcStructuralLoadLinearForce = 1641;
var IfcStructuralLoadOrResult = 1642;
var IfcStructuralLoadPlanarForce = 1643;
var IfcStructuralLoadSingleDisplacement = 1644;
var IfcStructuralLoadSingleDisplacementDistortion = 1645;
var IfcStructuralLoadSingleForce = 1646;
var IfcStructuralLoadSingleForceWarping = 1647;
var IfcStructuralLoadStatic = 1648;
var IfcStructuralLoadTemperature = 1649;
var IfcStructuralMember = 1650;
var IfcStructuralPlanarAction = 1651;
var IfcStructuralPointAction = 1652;
var IfcStructuralPointConnection = 1653;
var IfcStructuralPointReaction = 1654;
var IfcStructuralReaction = 1655;
var IfcStructuralResultGroup = 1656;
var IfcStructuralSurfaceAction = 1657;
var IfcStructuralSurfaceConnection = 1658;
var IfcStructuralSurfaceMember = 1659;
var IfcStructuralSurfaceMemberVarying = 1660;
var IfcStructuralSurfaceReaction = 1661;
var IfcStyledItem = 1662;
var IfcStyledRepresentation = 1663;
var IfcStyleModel = 1664;
var IfcSubContractResource = 1665;
var IfcSubContractResourceType = 1666;
var IfcSubedge = 1667;
var IfcSurface = 1668;
var IfcSurfaceCurve = 1669;
var IfcSurfaceCurveSweptAreaSolid = 1670;
var IfcSurfaceFeature = 1671;
var IfcSurfaceOfLinearExtrusion = 1672;
var IfcSurfaceOfRevolution = 1673;
var IfcSurfaceReinforcementArea = 1674;
var IfcSurfaceStyle = 1675;
var IfcSurfaceStyleLighting = 1676;
var IfcSurfaceStyleRefraction = 1677;
var IfcSurfaceStyleRendering = 1678;
var IfcSurfaceStyleShading = 1679;
var IfcSurfaceStyleWithTextures = 1680;
var IfcSurfaceTexture = 1681;
var IfcSweptAreaSolid = 1682;
var IfcSweptDiskSolid = 1683;
var IfcSweptDiskSolidPolygonal = 1684;
var IfcSweptSurface = 1685;
var IfcSwitchingDevice = 1686;
var IfcSwitchingDeviceType = 1687;
var IfcSystem = 1688;
var IfcSystemFurnitureElement = 1689;
var IfcSystemFurnitureElementType = 1690;
var IfcTable = 1691;
var IfcTableColumn = 1692;
var IfcTableRow = 1693;
var IfcTank = 1694;
var IfcTankType = 1695;
var IfcTask = 1696;
var IfcTaskTime = 1697;
var IfcTaskTimeRecurring = 1698;
var IfcTaskType = 1699;
var IfcTelecomAddress = 1700;
var IfcTendon = 1701;
var IfcTendonAnchor = 1702;
var IfcTendonAnchorType = 1703;
var IfcTendonType = 1704;
var IfcTessellatedFaceSet = 1705;
var IfcTessellatedItem = 1706;
var IfcTextLiteral = 1707;
var IfcTextLiteralWithExtent = 1708;
var IfcTextStyle = 1709;
var IfcTextStyleFontModel = 1710;
var IfcTextStyleForDefinedFont = 1711;
var IfcTextStyleTextModel = 1712;
var IfcTextureCoordinate = 1713;
var IfcTextureCoordinateGenerator = 1714;
var IfcTextureMap = 1715;
var IfcTextureVertex = 1716;
var IfcTextureVertexList = 1717;
var IfcTimePeriod = 1718;
var IfcTimeSeries = 1719;
var IfcTimeSeriesValue = 1720;
var IfcTopologicalRepresentationItem = 1721;
var IfcTopologyRepresentation = 1722;
var IfcToroidalSurface = 1723;
var IfcTransformer = 1724;
var IfcTransformerType = 1725;
var IfcTransportElement = 1726;
var IfcTransportElementType = 1727;
var IfcTrapeziumProfileDef = 1728;
var IfcTriangulatedFaceSet = 1729;
var IfcTrimmedCurve = 1730;
var IfcTShapeProfileDef = 1731;
var IfcTubeBundle = 1732;
var IfcTubeBundleType = 1733;
var IfcTypeObject = 1734;
var IfcTypeProcess = 1735;
var IfcTypeProduct = 1736;
var IfcTypeResource = 1737;
var IfcUnitaryControlElement = 1738;
var IfcUnitaryControlElementType = 1739;
var IfcUnitaryEquipment = 1740;
var IfcUnitaryEquipmentType = 1741;
var IfcUnitAssignment = 1742;
var IfcUShapeProfileDef = 1743;
var IfcValve = 1744;
var IfcValveType = 1745;
var IfcVector = 1746;
var IfcVertex = 1747;
var IfcVertexLoop = 1748;
var IfcVertexPoint = 1749;
var IfcVibrationIsolator = 1750;
var IfcVibrationIsolatorType = 1751;
var IfcVirtualElement = 1752;
var IfcVirtualGridIntersection = 1753;
var IfcVoidingFeature = 1754;
var IfcWall = 1755;
var IfcWallElementedCase = 1756;
var IfcWallStandardCase = 1757;
var IfcWallType = 1758;
var IfcWasteTerminal = 1759;
var IfcWasteTerminalType = 1760;
var IfcWindow = 1761;
var IfcWindowLiningProperties = 1762;
var IfcWindowPanelProperties = 1763;
var IfcWindowStandardCase = 1764;
var IfcWindowStyle = 1765;
var IfcWindowType = 1766;
var IfcWorkCalendar = 1767;
var IfcWorkControl = 1768;
var IfcWorkPlan = 1769;
var IfcWorkSchedule = 1770;
var IfcWorkTime = 1771;
var IfcZone = 1772;
var IfcZShapeProfileDef = 1773;
var ifcTypeCodes = {
  "IfcActionRequest": 1e3,
  "IfcActor": 1001,
  "IfcActorRole": 1002,
  "IfcActuator": 1003,
  "IfcActuatorType": 1004,
  "IfcAddress": 1005,
  "IfcAdvancedBrep": 1006,
  "IfcAdvancedBrepWithVoids": 1007,
  "IfcAdvancedFace": 1008,
  "IfcAirTerminal": 1009,
  "IfcAirTerminalBox": 1010,
  "IfcAirTerminalBoxType": 1011,
  "IfcAirTerminalType": 1012,
  "IfcAirToAirHeatRecovery": 1013,
  "IfcAirToAirHeatRecoveryType": 1014,
  "IfcAlarm": 1015,
  "IfcAlarmType": 1016,
  "IfcAnnotation": 1017,
  "IfcAnnotationFillArea": 1018,
  "IfcApplication": 1019,
  "IfcAppliedValue": 1020,
  "IfcApproval": 1021,
  "IfcApprovalRelationship": 1022,
  "IfcArbitraryClosedProfileDef": 1023,
  "IfcArbitraryOpenProfileDef": 1024,
  "IfcArbitraryProfileDefWithVoids": 1025,
  "IfcAsset": 1026,
  "IfcAsymmetricIShapeProfileDef": 1027,
  "IfcAudioVisualAppliance": 1028,
  "IfcAudioVisualApplianceType": 1029,
  "IfcAxis1Placement": 1030,
  "IfcAxis2Placement2D": 1031,
  "IfcAxis2Placement3D": 1032,
  "IfcBeam": 1033,
  "IfcBeamStandardCase": 1034,
  "IfcBeamType": 1035,
  "IfcBlobTexture": 1036,
  "IfcBlock": 1037,
  "IfcBoiler": 1038,
  "IfcBoilerType": 1039,
  "IfcBooleanClippingResult": 1040,
  "IfcBooleanResult": 1041,
  "IfcBoundaryCondition": 1042,
  "IfcBoundaryCurve": 1043,
  "IfcBoundaryEdgeCondition": 1044,
  "IfcBoundaryFaceCondition": 1045,
  "IfcBoundaryNodeCondition": 1046,
  "IfcBoundaryNodeConditionWarping": 1047,
  "IfcBoundedCurve": 1048,
  "IfcBoundedSurface": 1049,
  "IfcBoundingBox": 1050,
  "IfcBoxedHalfSpace": 1051,
  "IfcBSplineCurve": 1052,
  "IfcBSplineCurveWithKnots": 1053,
  "IfcBSplineSurface": 1054,
  "IfcBSplineSurfaceWithKnots": 1055,
  "IfcBuilding": 1056,
  "IfcBuildingElementPart": 1057,
  "IfcBuildingElementPartType": 1058,
  "IfcBuildingElementProxy": 1059,
  "IfcBuildingElementProxyType": 1060,
  "IfcBuildingStorey": 1061,
  "IfcBuildingSystem": 1062,
  "IfcBurner": 1063,
  "IfcBurnerType": 1064,
  "IfcCableCarrierFitting": 1065,
  "IfcCableCarrierFittingType": 1066,
  "IfcCableCarrierSegment": 1067,
  "IfcCableCarrierSegmentType": 1068,
  "IfcCableFitting": 1069,
  "IfcCableFittingType": 1070,
  "IfcCableSegment": 1071,
  "IfcCableSegmentType": 1072,
  "IfcCartesianPoint": 1073,
  "IfcCartesianPointList": 1074,
  "IfcCartesianPointList2D": 1075,
  "IfcCartesianPointList3D": 1076,
  "IfcCartesianTransformationOperator": 1077,
  "IfcCartesianTransformationOperator2D": 1078,
  "IfcCartesianTransformationOperator2DnonUniform": 1079,
  "IfcCartesianTransformationOperator3D": 1080,
  "IfcCartesianTransformationOperator3DnonUniform": 1081,
  "IfcCenterLineProfileDef": 1082,
  "IfcChiller": 1083,
  "IfcChillerType": 1084,
  "IfcChimney": 1085,
  "IfcChimneyType": 1086,
  "IfcCircle": 1087,
  "IfcCircleHollowProfileDef": 1088,
  "IfcCircleProfileDef": 1089,
  "IfcCivilElement": 1090,
  "IfcCivilElementType": 1091,
  "IfcClassification": 1092,
  "IfcClassificationReference": 1093,
  "IfcClosedShell": 1094,
  "IfcCoil": 1095,
  "IfcCoilType": 1096,
  "IfcColourRgb": 1097,
  "IfcColourRgbList": 1098,
  "IfcColourSpecification": 1099,
  "IfcColumn": 1100,
  "IfcColumnStandardCase": 1101,
  "IfcColumnType": 1102,
  "IfcCommunicationsAppliance": 1103,
  "IfcCommunicationsApplianceType": 1104,
  "IfcComplexProperty": 1105,
  "IfcComplexPropertyTemplate": 1106,
  "IfcCompositeCurve": 1107,
  "IfcCompositeCurveOnSurface": 1108,
  "IfcCompositeCurveSegment": 1109,
  "IfcCompositeProfileDef": 1110,
  "IfcCompressor": 1111,
  "IfcCompressorType": 1112,
  "IfcCondenser": 1113,
  "IfcCondenserType": 1114,
  "IfcConic": 1115,
  "IfcConnectedFaceSet": 1116,
  "IfcConnectionCurveGeometry": 1117,
  "IfcConnectionGeometry": 1118,
  "IfcConnectionPointEccentricity": 1119,
  "IfcConnectionPointGeometry": 1120,
  "IfcConnectionSurfaceGeometry": 1121,
  "IfcConnectionVolumeGeometry": 1122,
  "IfcConstraint": 1123,
  "IfcConstructionEquipmentResource": 1124,
  "IfcConstructionEquipmentResourceType": 1125,
  "IfcConstructionMaterialResource": 1126,
  "IfcConstructionMaterialResourceType": 1127,
  "IfcConstructionProductResource": 1128,
  "IfcConstructionProductResourceType": 1129,
  "IfcConstructionResource": 1130,
  "IfcConstructionResourceType": 1131,
  "IfcContext": 1132,
  "IfcContextDependentUnit": 1133,
  "IfcControl": 1134,
  "IfcController": 1135,
  "IfcControllerType": 1136,
  "IfcConversionBasedUnit": 1137,
  "IfcConversionBasedUnitWithOffset": 1138,
  "IfcCooledBeam": 1139,
  "IfcCooledBeamType": 1140,
  "IfcCoolingTower": 1141,
  "IfcCoolingTowerType": 1142,
  "IfcCoordinateOperation": 1143,
  "IfcCoordinateReferenceSystem": 1144,
  "IfcCostItem": 1145,
  "IfcCostSchedule": 1146,
  "IfcCostValue": 1147,
  "IfcCovering": 1148,
  "IfcCoveringType": 1149,
  "IfcCrewResource": 1150,
  "IfcCrewResourceType": 1151,
  "IfcCsgPrimitive3D": 1152,
  "IfcCsgSolid": 1153,
  "IfcCShapeProfileDef": 1154,
  "IfcCurrencyRelationship": 1155,
  "IfcCurtainWall": 1156,
  "IfcCurtainWallType": 1157,
  "IfcCurve": 1158,
  "IfcCurveBoundedPlane": 1159,
  "IfcCurveBoundedSurface": 1160,
  "IfcCurveStyle": 1161,
  "IfcCurveStyleFont": 1162,
  "IfcCurveStyleFontAndScaling": 1163,
  "IfcCurveStyleFontPattern": 1164,
  "IfcCylindricalSurface": 1165,
  "IfcDamper": 1166,
  "IfcDamperType": 1167,
  "IfcDerivedProfileDef": 1168,
  "IfcDerivedUnit": 1169,
  "IfcDerivedUnitElement": 1170,
  "IfcDimensionalExponents": 1171,
  "IfcDirection": 1172,
  "IfcDiscreteAccessory": 1173,
  "IfcDiscreteAccessoryType": 1174,
  "IfcDistributionChamberElement": 1175,
  "IfcDistributionChamberElementType": 1176,
  "IfcDistributionCircuit": 1177,
  "IfcDistributionControlElement": 1178,
  "IfcDistributionControlElementType": 1179,
  "IfcDistributionElement": 1180,
  "IfcDistributionElementType": 1181,
  "IfcDistributionFlowElement": 1182,
  "IfcDistributionFlowElementType": 1183,
  "IfcDistributionPort": 1184,
  "IfcDistributionSystem": 1185,
  "IfcDocumentInformation": 1186,
  "IfcDocumentInformationRelationship": 1187,
  "IfcDocumentReference": 1188,
  "IfcDoor": 1189,
  "IfcDoorLiningProperties": 1190,
  "IfcDoorPanelProperties": 1191,
  "IfcDoorStandardCase": 1192,
  "IfcDoorStyle": 1193,
  "IfcDoorType": 1194,
  "IfcDraughtingPreDefinedColour": 1195,
  "IfcDraughtingPreDefinedCurveFont": 1196,
  "IfcDuctFitting": 1197,
  "IfcDuctFittingType": 1198,
  "IfcDuctSegment": 1199,
  "IfcDuctSegmentType": 1200,
  "IfcDuctSilencer": 1201,
  "IfcDuctSilencerType": 1202,
  "IfcEdge": 1203,
  "IfcEdgeCurve": 1204,
  "IfcEdgeLoop": 1205,
  "IfcElectricAppliance": 1206,
  "IfcElectricApplianceType": 1207,
  "IfcElectricDistributionBoard": 1208,
  "IfcElectricDistributionBoardType": 1209,
  "IfcElectricFlowStorageDevice": 1210,
  "IfcElectricFlowStorageDeviceType": 1211,
  "IfcElectricGenerator": 1212,
  "IfcElectricGeneratorType": 1213,
  "IfcElectricMotor": 1214,
  "IfcElectricMotorType": 1215,
  "IfcElectricTimeControl": 1216,
  "IfcElectricTimeControlType": 1217,
  "IfcElement": 1218,
  "IfcElementarySurface": 1219,
  "IfcElementAssembly": 1220,
  "IfcElementAssemblyType": 1221,
  "IfcElementComponent": 1222,
  "IfcElementComponentType": 1223,
  "IfcElementQuantity": 1224,
  "IfcElementType": 1225,
  "IfcEllipse": 1226,
  "IfcEllipseProfileDef": 1227,
  "IfcEnergyConversionDevice": 1228,
  "IfcEnergyConversionDeviceType": 1229,
  "IfcEngine": 1230,
  "IfcEngineType": 1231,
  "IfcEvaporativeCooler": 1232,
  "IfcEvaporativeCoolerType": 1233,
  "IfcEvaporator": 1234,
  "IfcEvaporatorType": 1235,
  "IfcEvent": 1236,
  "IfcEventTime": 1237,
  "IfcEventType": 1238,
  "IfcExtendedProperties": 1239,
  "IfcExternalInformation": 1240,
  "IfcExternallyDefinedHatchStyle": 1241,
  "IfcExternallyDefinedSurfaceStyle": 1242,
  "IfcExternallyDefinedTextFont": 1243,
  "IfcExternalReference": 1244,
  "IfcExternalReferenceRelationship": 1245,
  "IfcExternalSpatialElement": 1246,
  "IfcExternalSpatialStructureElement": 1247,
  "IfcExtrudedAreaSolid": 1248,
  "IfcExtrudedAreaSolidTapered": 1249,
  "IfcFace": 1250,
  "IfcFaceBasedSurfaceModel": 1251,
  "IfcFaceBound": 1252,
  "IfcFaceOuterBound": 1253,
  "IfcFaceSurface": 1254,
  "IfcFacetedBrep": 1255,
  "IfcFacetedBrepWithVoids": 1256,
  "IfcFailureConnectionCondition": 1257,
  "IfcFan": 1258,
  "IfcFanType": 1259,
  "IfcFastener": 1260,
  "IfcFastenerType": 1261,
  "IfcFeatureElement": 1262,
  "IfcFeatureElementAddition": 1263,
  "IfcFeatureElementSubtraction": 1264,
  "IfcFillAreaStyle": 1265,
  "IfcFillAreaStyleHatching": 1266,
  "IfcFillAreaStyleTiles": 1267,
  "IfcFilter": 1268,
  "IfcFilterType": 1269,
  "IfcFireSuppressionTerminal": 1270,
  "IfcFireSuppressionTerminalType": 1271,
  "IfcFixedReferenceSweptAreaSolid": 1272,
  "IfcFlowController": 1273,
  "IfcFlowControllerType": 1274,
  "IfcFlowFitting": 1275,
  "IfcFlowFittingType": 1276,
  "IfcFlowInstrument": 1277,
  "IfcFlowInstrumentType": 1278,
  "IfcFlowMeter": 1279,
  "IfcFlowMeterType": 1280,
  "IfcFlowMovingDevice": 1281,
  "IfcFlowMovingDeviceType": 1282,
  "IfcFlowSegment": 1283,
  "IfcFlowSegmentType": 1284,
  "IfcFlowStorageDevice": 1285,
  "IfcFlowStorageDeviceType": 1286,
  "IfcFlowTerminal": 1287,
  "IfcFlowTerminalType": 1288,
  "IfcFlowTreatmentDevice": 1289,
  "IfcFlowTreatmentDeviceType": 1290,
  "IfcFooting": 1291,
  "IfcFootingType": 1292,
  "IfcFurnishingElement": 1293,
  "IfcFurnishingElementType": 1294,
  "IfcFurniture": 1295,
  "IfcFurnitureType": 1296,
  "IfcGeographicElement": 1297,
  "IfcGeographicElementType": 1298,
  "IfcGeometricCurveSet": 1299,
  "IfcGeometricRepresentationContext": 1300,
  "IfcGeometricRepresentationItem": 1301,
  "IfcGeometricRepresentationSubContext": 1302,
  "IfcGeometricSet": 1303,
  "IfcGrid": 1304,
  "IfcGridAxis": 1305,
  "IfcGridPlacement": 1306,
  "IfcGroup": 1307,
  "IfcHalfSpaceSolid": 1308,
  "IfcHeatExchanger": 1309,
  "IfcHeatExchangerType": 1310,
  "IfcHumidifier": 1311,
  "IfcHumidifierType": 1312,
  "IfcImageTexture": 1313,
  "IfcIndexedColourMap": 1314,
  "IfcIndexedPolyCurve": 1315,
  "IfcIndexedPolygonalFace": 1316,
  "IfcIndexedPolygonalFaceWithVoids": 1317,
  "IfcIndexedTextureMap": 1318,
  "IfcIndexedTriangleTextureMap": 1319,
  "IfcInterceptor": 1320,
  "IfcInterceptorType": 1321,
  "IfcIntersectionCurve": 1322,
  "IfcInventory": 1323,
  "IfcIrregularTimeSeries": 1324,
  "IfcIrregularTimeSeriesValue": 1325,
  "IfcIShapeProfileDef": 1326,
  "IfcJunctionBox": 1327,
  "IfcJunctionBoxType": 1328,
  "IfcLaborResource": 1329,
  "IfcLaborResourceType": 1330,
  "IfcLagTime": 1331,
  "IfcLamp": 1332,
  "IfcLampType": 1333,
  "IfcLibraryInformation": 1334,
  "IfcLibraryReference": 1335,
  "IfcLightDistributionData": 1336,
  "IfcLightFixture": 1337,
  "IfcLightFixtureType": 1338,
  "IfcLightIntensityDistribution": 1339,
  "IfcLightSource": 1340,
  "IfcLightSourceAmbient": 1341,
  "IfcLightSourceDirectional": 1342,
  "IfcLightSourceGoniometric": 1343,
  "IfcLightSourcePositional": 1344,
  "IfcLightSourceSpot": 1345,
  "IfcLine": 1346,
  "IfcLocalPlacement": 1347,
  "IfcLoop": 1348,
  "IfcLShapeProfileDef": 1349,
  "IfcManifoldSolidBrep": 1350,
  "IfcMapConversion": 1351,
  "IfcMappedItem": 1352,
  "IfcMaterial": 1353,
  "IfcMaterialClassificationRelationship": 1354,
  "IfcMaterialConstituent": 1355,
  "IfcMaterialConstituentSet": 1356,
  "IfcMaterialDefinition": 1357,
  "IfcMaterialDefinitionRepresentation": 1358,
  "IfcMaterialLayer": 1359,
  "IfcMaterialLayerSet": 1360,
  "IfcMaterialLayerSetUsage": 1361,
  "IfcMaterialLayerWithOffsets": 1362,
  "IfcMaterialList": 1363,
  "IfcMaterialProfile": 1364,
  "IfcMaterialProfileSet": 1365,
  "IfcMaterialProfileSetUsage": 1366,
  "IfcMaterialProfileSetUsageTapering": 1367,
  "IfcMaterialProfileWithOffsets": 1368,
  "IfcMaterialProperties": 1369,
  "IfcMaterialRelationship": 1370,
  "IfcMaterialUsageDefinition": 1371,
  "IfcMeasureWithUnit": 1372,
  "IfcMechanicalFastener": 1373,
  "IfcMechanicalFastenerType": 1374,
  "IfcMedicalDevice": 1375,
  "IfcMedicalDeviceType": 1376,
  "IfcMember": 1377,
  "IfcMemberStandardCase": 1378,
  "IfcMemberType": 1379,
  "IfcMetric": 1380,
  "IfcMirroredProfileDef": 1381,
  "IfcMonetaryUnit": 1382,
  "IfcMotorConnection": 1383,
  "IfcMotorConnectionType": 1384,
  "IfcNamedUnit": 1385,
  "IfcObject": 1386,
  "IfcObjectDefinition": 1387,
  "IfcObjective": 1388,
  "IfcObjectPlacement": 1389,
  "IfcOccupant": 1390,
  "IfcOffsetCurve2D": 1391,
  "IfcOffsetCurve3D": 1392,
  "IfcOpeningElement": 1393,
  "IfcOpeningStandardCase": 1394,
  "IfcOpenShell": 1395,
  "IfcOrganization": 1396,
  "IfcOrganizationRelationship": 1397,
  "IfcOrientedEdge": 1398,
  "IfcOuterBoundaryCurve": 1399,
  "IfcOutlet": 1400,
  "IfcOutletType": 1401,
  "IfcOwnerHistory": 1402,
  "IfcParameterizedProfileDef": 1403,
  "IfcPath": 1404,
  "IfcPcurve": 1405,
  "IfcPerformanceHistory": 1406,
  "IfcPermeableCoveringProperties": 1407,
  "IfcPermit": 1408,
  "IfcPerson": 1409,
  "IfcPersonAndOrganization": 1410,
  "IfcPhysicalComplexQuantity": 1411,
  "IfcPhysicalQuantity": 1412,
  "IfcPhysicalSimpleQuantity": 1413,
  "IfcPile": 1414,
  "IfcPileType": 1415,
  "IfcPipeFitting": 1416,
  "IfcPipeFittingType": 1417,
  "IfcPipeSegment": 1418,
  "IfcPipeSegmentType": 1419,
  "IfcPixelTexture": 1420,
  "IfcPlacement": 1421,
  "IfcPlanarBox": 1422,
  "IfcPlanarExtent": 1423,
  "IfcPlane": 1424,
  "IfcPlate": 1425,
  "IfcPlateStandardCase": 1426,
  "IfcPlateType": 1427,
  "IfcPoint": 1428,
  "IfcPointOnCurve": 1429,
  "IfcPointOnSurface": 1430,
  "IfcPolygonalBoundedHalfSpace": 1431,
  "IfcPolygonalFaceSet": 1432,
  "IfcPolyline": 1433,
  "IfcPolyLoop": 1434,
  "IfcPort": 1435,
  "IfcPostalAddress": 1436,
  "IfcPreDefinedColour": 1437,
  "IfcPreDefinedCurveFont": 1438,
  "IfcPreDefinedItem": 1439,
  "IfcPreDefinedProperties": 1440,
  "IfcPreDefinedPropertySet": 1441,
  "IfcPreDefinedTextFont": 1442,
  "IfcPresentationItem": 1443,
  "IfcPresentationLayerAssignment": 1444,
  "IfcPresentationLayerWithStyle": 1445,
  "IfcPresentationStyle": 1446,
  "IfcPresentationStyleAssignment": 1447,
  "IfcProcedure": 1448,
  "IfcProcedureType": 1449,
  "IfcProcess": 1450,
  "IfcProduct": 1451,
  "IfcProductDefinitionShape": 1452,
  "IfcProductRepresentation": 1453,
  "IfcProfileDef": 1454,
  "IfcProfileProperties": 1455,
  "IfcProject": 1456,
  "IfcProjectedCRS": 1457,
  "IfcProjectionElement": 1458,
  "IfcProjectLibrary": 1459,
  "IfcProjectOrder": 1460,
  "IfcProperty": 1461,
  "IfcPropertyAbstraction": 1462,
  "IfcPropertyBoundedValue": 1463,
  "IfcPropertyDefinition": 1464,
  "IfcPropertyDependencyRelationship": 1465,
  "IfcPropertyEnumeratedValue": 1466,
  "IfcPropertyEnumeration": 1467,
  "IfcPropertyListValue": 1468,
  "IfcPropertyReferenceValue": 1469,
  "IfcPropertySet": 1470,
  "IfcPropertySetDefinition": 1471,
  "IfcPropertySetTemplate": 1472,
  "IfcPropertySingleValue": 1473,
  "IfcPropertyTableValue": 1474,
  "IfcPropertyTemplate": 1475,
  "IfcPropertyTemplateDefinition": 1476,
  "IfcProtectiveDevice": 1477,
  "IfcProtectiveDeviceTrippingUnit": 1478,
  "IfcProtectiveDeviceTrippingUnitType": 1479,
  "IfcProtectiveDeviceType": 1480,
  "IfcProxy": 1481,
  "IfcPump": 1482,
  "IfcPumpType": 1483,
  "IfcQuantityArea": 1484,
  "IfcQuantityCount": 1485,
  "IfcQuantityLength": 1486,
  "IfcQuantitySet": 1487,
  "IfcQuantityTime": 1488,
  "IfcQuantityVolume": 1489,
  "IfcQuantityWeight": 1490,
  "IfcRailing": 1491,
  "IfcRailingType": 1492,
  "IfcRamp": 1493,
  "IfcRampFlight": 1494,
  "IfcRampFlightType": 1495,
  "IfcRampType": 1496,
  "IfcRationalBSplineCurveWithKnots": 1497,
  "IfcRationalBSplineSurfaceWithKnots": 1498,
  "IfcRectangleHollowProfileDef": 1499,
  "IfcRectangleProfileDef": 1500,
  "IfcRectangularPyramid": 1501,
  "IfcRectangularTrimmedSurface": 1502,
  "IfcRecurrencePattern": 1503,
  "IfcReference": 1504,
  "IfcRegularTimeSeries": 1505,
  "IfcReinforcementBarProperties": 1506,
  "IfcReinforcementDefinitionProperties": 1507,
  "IfcReinforcingBar": 1508,
  "IfcReinforcingBarType": 1509,
  "IfcReinforcingElement": 1510,
  "IfcReinforcingElementType": 1511,
  "IfcReinforcingMesh": 1512,
  "IfcReinforcingMeshType": 1513,
  "IfcRelAggregates": 1514,
  "IfcRelAssigns": 1515,
  "IfcRelAssignsToActor": 1516,
  "IfcRelAssignsToControl": 1517,
  "IfcRelAssignsToGroup": 1518,
  "IfcRelAssignsToGroupByFactor": 1519,
  "IfcRelAssignsToProcess": 1520,
  "IfcRelAssignsToProduct": 1521,
  "IfcRelAssignsToResource": 1522,
  "IfcRelAssociates": 1523,
  "IfcRelAssociatesApproval": 1524,
  "IfcRelAssociatesClassification": 1525,
  "IfcRelAssociatesConstraint": 1526,
  "IfcRelAssociatesDocument": 1527,
  "IfcRelAssociatesLibrary": 1528,
  "IfcRelAssociatesMaterial": 1529,
  "IfcRelationship": 1530,
  "IfcRelConnects": 1531,
  "IfcRelConnectsElements": 1532,
  "IfcRelConnectsPathElements": 1533,
  "IfcRelConnectsPorts": 1534,
  "IfcRelConnectsPortToElement": 1535,
  "IfcRelConnectsStructuralActivity": 1536,
  "IfcRelConnectsStructuralMember": 1537,
  "IfcRelConnectsWithEccentricity": 1538,
  "IfcRelConnectsWithRealizingElements": 1539,
  "IfcRelContainedInSpatialStructure": 1540,
  "IfcRelCoversBldgElements": 1541,
  "IfcRelCoversSpaces": 1542,
  "IfcRelDeclares": 1543,
  "IfcRelDecomposes": 1544,
  "IfcRelDefines": 1545,
  "IfcRelDefinesByObject": 1546,
  "IfcRelDefinesByProperties": 1547,
  "IfcRelDefinesByTemplate": 1548,
  "IfcRelDefinesByType": 1549,
  "IfcRelFillsElement": 1550,
  "IfcRelFlowControlElements": 1551,
  "IfcRelInterferesElements": 1552,
  "IfcRelNests": 1553,
  "IfcRelProjectsElement": 1554,
  "IfcRelReferencedInSpatialStructure": 1555,
  "IfcRelSequence": 1556,
  "IfcRelServicesBuildings": 1557,
  "IfcRelSpaceBoundary": 1558,
  "IfcRelSpaceBoundary1stLevel": 1559,
  "IfcRelSpaceBoundary2ndLevel": 1560,
  "IfcRelVoidsElement": 1561,
  "IfcReparametrisedCompositeCurveSegment": 1562,
  "IfcRepresentation": 1563,
  "IfcRepresentationContext": 1564,
  "IfcRepresentationItem": 1565,
  "IfcRepresentationMap": 1566,
  "IfcResource": 1567,
  "IfcResourceApprovalRelationship": 1568,
  "IfcResourceConstraintRelationship": 1569,
  "IfcResourceLevelRelationship": 1570,
  "IfcResourceTime": 1571,
  "IfcRevolvedAreaSolid": 1572,
  "IfcRevolvedAreaSolidTapered": 1573,
  "IfcRightCircularCone": 1574,
  "IfcRightCircularCylinder": 1575,
  "IfcRoof": 1576,
  "IfcRoofType": 1577,
  "IfcRoot": 1578,
  "IfcRoundedRectangleProfileDef": 1579,
  "IfcSanitaryTerminal": 1580,
  "IfcSanitaryTerminalType": 1581,
  "IfcSchedulingTime": 1582,
  "IfcSeamCurve": 1583,
  "IfcSectionedSpine": 1584,
  "IfcSectionProperties": 1585,
  "IfcSectionReinforcementProperties": 1586,
  "IfcSensor": 1587,
  "IfcSensorType": 1588,
  "IfcShadingDevice": 1589,
  "IfcShadingDeviceType": 1590,
  "IfcShapeAspect": 1591,
  "IfcShapeModel": 1592,
  "IfcShapeRepresentation": 1593,
  "IfcShellBasedSurfaceModel": 1594,
  "IfcSimpleProperty": 1595,
  "IfcSimplePropertyTemplate": 1596,
  "IfcSite": 1597,
  "IfcSIUnit": 1598,
  "IfcSlab": 1599,
  "IfcSlabElementedCase": 1600,
  "IfcSlabStandardCase": 1601,
  "IfcSlabType": 1602,
  "IfcSlippageConnectionCondition": 1603,
  "IfcSolarDevice": 1604,
  "IfcSolarDeviceType": 1605,
  "IfcSolidModel": 1606,
  "IfcSpace": 1607,
  "IfcSpaceHeater": 1608,
  "IfcSpaceHeaterType": 1609,
  "IfcSpaceType": 1610,
  "IfcSpatialElement": 1611,
  "IfcSpatialElementType": 1612,
  "IfcSpatialStructureElement": 1613,
  "IfcSpatialStructureElementType": 1614,
  "IfcSpatialZone": 1615,
  "IfcSpatialZoneType": 1616,
  "IfcSphere": 1617,
  "IfcSphericalSurface": 1618,
  "IfcStackTerminal": 1619,
  "IfcStackTerminalType": 1620,
  "IfcStair": 1621,
  "IfcStairFlight": 1622,
  "IfcStairFlightType": 1623,
  "IfcStairType": 1624,
  "IfcStructuralAction": 1625,
  "IfcStructuralActivity": 1626,
  "IfcStructuralAnalysisModel": 1627,
  "IfcStructuralConnection": 1628,
  "IfcStructuralConnectionCondition": 1629,
  "IfcStructuralCurveAction": 1630,
  "IfcStructuralCurveConnection": 1631,
  "IfcStructuralCurveMember": 1632,
  "IfcStructuralCurveMemberVarying": 1633,
  "IfcStructuralCurveReaction": 1634,
  "IfcStructuralItem": 1635,
  "IfcStructuralLinearAction": 1636,
  "IfcStructuralLoad": 1637,
  "IfcStructuralLoadCase": 1638,
  "IfcStructuralLoadConfiguration": 1639,
  "IfcStructuralLoadGroup": 1640,
  "IfcStructuralLoadLinearForce": 1641,
  "IfcStructuralLoadOrResult": 1642,
  "IfcStructuralLoadPlanarForce": 1643,
  "IfcStructuralLoadSingleDisplacement": 1644,
  "IfcStructuralLoadSingleDisplacementDistortion": 1645,
  "IfcStructuralLoadSingleForce": 1646,
  "IfcStructuralLoadSingleForceWarping": 1647,
  "IfcStructuralLoadStatic": 1648,
  "IfcStructuralLoadTemperature": 1649,
  "IfcStructuralMember": 1650,
  "IfcStructuralPlanarAction": 1651,
  "IfcStructuralPointAction": 1652,
  "IfcStructuralPointConnection": 1653,
  "IfcStructuralPointReaction": 1654,
  "IfcStructuralReaction": 1655,
  "IfcStructuralResultGroup": 1656,
  "IfcStructuralSurfaceAction": 1657,
  "IfcStructuralSurfaceConnection": 1658,
  "IfcStructuralSurfaceMember": 1659,
  "IfcStructuralSurfaceMemberVarying": 1660,
  "IfcStructuralSurfaceReaction": 1661,
  "IfcStyledItem": 1662,
  "IfcStyledRepresentation": 1663,
  "IfcStyleModel": 1664,
  "IfcSubContractResource": 1665,
  "IfcSubContractResourceType": 1666,
  "IfcSubedge": 1667,
  "IfcSurface": 1668,
  "IfcSurfaceCurve": 1669,
  "IfcSurfaceCurveSweptAreaSolid": 1670,
  "IfcSurfaceFeature": 1671,
  "IfcSurfaceOfLinearExtrusion": 1672,
  "IfcSurfaceOfRevolution": 1673,
  "IfcSurfaceReinforcementArea": 1674,
  "IfcSurfaceStyle": 1675,
  "IfcSurfaceStyleLighting": 1676,
  "IfcSurfaceStyleRefraction": 1677,
  "IfcSurfaceStyleRendering": 1678,
  "IfcSurfaceStyleShading": 1679,
  "IfcSurfaceStyleWithTextures": 1680,
  "IfcSurfaceTexture": 1681,
  "IfcSweptAreaSolid": 1682,
  "IfcSweptDiskSolid": 1683,
  "IfcSweptDiskSolidPolygonal": 1684,
  "IfcSweptSurface": 1685,
  "IfcSwitchingDevice": 1686,
  "IfcSwitchingDeviceType": 1687,
  "IfcSystem": 1688,
  "IfcSystemFurnitureElement": 1689,
  "IfcSystemFurnitureElementType": 1690,
  "IfcTable": 1691,
  "IfcTableColumn": 1692,
  "IfcTableRow": 1693,
  "IfcTank": 1694,
  "IfcTankType": 1695,
  "IfcTask": 1696,
  "IfcTaskTime": 1697,
  "IfcTaskTimeRecurring": 1698,
  "IfcTaskType": 1699,
  "IfcTelecomAddress": 1700,
  "IfcTendon": 1701,
  "IfcTendonAnchor": 1702,
  "IfcTendonAnchorType": 1703,
  "IfcTendonType": 1704,
  "IfcTessellatedFaceSet": 1705,
  "IfcTessellatedItem": 1706,
  "IfcTextLiteral": 1707,
  "IfcTextLiteralWithExtent": 1708,
  "IfcTextStyle": 1709,
  "IfcTextStyleFontModel": 1710,
  "IfcTextStyleForDefinedFont": 1711,
  "IfcTextStyleTextModel": 1712,
  "IfcTextureCoordinate": 1713,
  "IfcTextureCoordinateGenerator": 1714,
  "IfcTextureMap": 1715,
  "IfcTextureVertex": 1716,
  "IfcTextureVertexList": 1717,
  "IfcTimePeriod": 1718,
  "IfcTimeSeries": 1719,
  "IfcTimeSeriesValue": 1720,
  "IfcTopologicalRepresentationItem": 1721,
  "IfcTopologyRepresentation": 1722,
  "IfcToroidalSurface": 1723,
  "IfcTransformer": 1724,
  "IfcTransformerType": 1725,
  "IfcTransportElement": 1726,
  "IfcTransportElementType": 1727,
  "IfcTrapeziumProfileDef": 1728,
  "IfcTriangulatedFaceSet": 1729,
  "IfcTrimmedCurve": 1730,
  "IfcTShapeProfileDef": 1731,
  "IfcTubeBundle": 1732,
  "IfcTubeBundleType": 1733,
  "IfcTypeObject": 1734,
  "IfcTypeProcess": 1735,
  "IfcTypeProduct": 1736,
  "IfcTypeResource": 1737,
  "IfcUnitaryControlElement": 1738,
  "IfcUnitaryControlElementType": 1739,
  "IfcUnitaryEquipment": 1740,
  "IfcUnitaryEquipmentType": 1741,
  "IfcUnitAssignment": 1742,
  "IfcUShapeProfileDef": 1743,
  "IfcValve": 1744,
  "IfcValveType": 1745,
  "IfcVector": 1746,
  "IfcVertex": 1747,
  "IfcVertexLoop": 1748,
  "IfcVertexPoint": 1749,
  "IfcVibrationIsolator": 1750,
  "IfcVibrationIsolatorType": 1751,
  "IfcVirtualElement": 1752,
  "IfcVirtualGridIntersection": 1753,
  "IfcVoidingFeature": 1754,
  "IfcWall": 1755,
  "IfcWallElementedCase": 1756,
  "IfcWallStandardCase": 1757,
  "IfcWallType": 1758,
  "IfcWasteTerminal": 1759,
  "IfcWasteTerminalType": 1760,
  "IfcWindow": 1761,
  "IfcWindowLiningProperties": 1762,
  "IfcWindowPanelProperties": 1763,
  "IfcWindowStandardCase": 1764,
  "IfcWindowStyle": 1765,
  "IfcWindowType": 1766,
  "IfcWorkCalendar": 1767,
  "IfcWorkControl": 1768,
  "IfcWorkPlan": 1769,
  "IfcWorkSchedule": 1770,
  "IfcWorkTime": 1771,
  "IfcZone": 1772,
  "IfcZShapeProfileDef": 1773
};
var ifcTypeNames = {
  1e3: "IfcActionRequest",
  1001: "IfcActor",
  1002: "IfcActorRole",
  1003: "IfcActuator",
  1004: "IfcActuatorType",
  1005: "IfcAddress",
  1006: "IfcAdvancedBrep",
  1007: "IfcAdvancedBrepWithVoids",
  1008: "IfcAdvancedFace",
  1009: "IfcAirTerminal",
  1010: "IfcAirTerminalBox",
  1011: "IfcAirTerminalBoxType",
  1012: "IfcAirTerminalType",
  1013: "IfcAirToAirHeatRecovery",
  1014: "IfcAirToAirHeatRecoveryType",
  1015: "IfcAlarm",
  1016: "IfcAlarmType",
  1017: "IfcAnnotation",
  1018: "IfcAnnotationFillArea",
  1019: "IfcApplication",
  1020: "IfcAppliedValue",
  1021: "IfcApproval",
  1022: "IfcApprovalRelationship",
  1023: "IfcArbitraryClosedProfileDef",
  1024: "IfcArbitraryOpenProfileDef",
  1025: "IfcArbitraryProfileDefWithVoids",
  1026: "IfcAsset",
  1027: "IfcAsymmetricIShapeProfileDef",
  1028: "IfcAudioVisualAppliance",
  1029: "IfcAudioVisualApplianceType",
  1030: "IfcAxis1Placement",
  1031: "IfcAxis2Placement2D",
  1032: "IfcAxis2Placement3D",
  1033: "IfcBeam",
  1034: "IfcBeamStandardCase",
  1035: "IfcBeamType",
  1036: "IfcBlobTexture",
  1037: "IfcBlock",
  1038: "IfcBoiler",
  1039: "IfcBoilerType",
  1040: "IfcBooleanClippingResult",
  1041: "IfcBooleanResult",
  1042: "IfcBoundaryCondition",
  1043: "IfcBoundaryCurve",
  1044: "IfcBoundaryEdgeCondition",
  1045: "IfcBoundaryFaceCondition",
  1046: "IfcBoundaryNodeCondition",
  1047: "IfcBoundaryNodeConditionWarping",
  1048: "IfcBoundedCurve",
  1049: "IfcBoundedSurface",
  1050: "IfcBoundingBox",
  1051: "IfcBoxedHalfSpace",
  1052: "IfcBSplineCurve",
  1053: "IfcBSplineCurveWithKnots",
  1054: "IfcBSplineSurface",
  1055: "IfcBSplineSurfaceWithKnots",
  1056: "IfcBuilding",
  1057: "IfcBuildingElementPart",
  1058: "IfcBuildingElementPartType",
  1059: "IfcBuildingElementProxy",
  1060: "IfcBuildingElementProxyType",
  1061: "IfcBuildingStorey",
  1062: "IfcBuildingSystem",
  1063: "IfcBurner",
  1064: "IfcBurnerType",
  1065: "IfcCableCarrierFitting",
  1066: "IfcCableCarrierFittingType",
  1067: "IfcCableCarrierSegment",
  1068: "IfcCableCarrierSegmentType",
  1069: "IfcCableFitting",
  1070: "IfcCableFittingType",
  1071: "IfcCableSegment",
  1072: "IfcCableSegmentType",
  1073: "IfcCartesianPoint",
  1074: "IfcCartesianPointList",
  1075: "IfcCartesianPointList2D",
  1076: "IfcCartesianPointList3D",
  1077: "IfcCartesianTransformationOperator",
  1078: "IfcCartesianTransformationOperator2D",
  1079: "IfcCartesianTransformationOperator2DnonUniform",
  1080: "IfcCartesianTransformationOperator3D",
  1081: "IfcCartesianTransformationOperator3DnonUniform",
  1082: "IfcCenterLineProfileDef",
  1083: "IfcChiller",
  1084: "IfcChillerType",
  1085: "IfcChimney",
  1086: "IfcChimneyType",
  1087: "IfcCircle",
  1088: "IfcCircleHollowProfileDef",
  1089: "IfcCircleProfileDef",
  1090: "IfcCivilElement",
  1091: "IfcCivilElementType",
  1092: "IfcClassification",
  1093: "IfcClassificationReference",
  1094: "IfcClosedShell",
  1095: "IfcCoil",
  1096: "IfcCoilType",
  1097: "IfcColourRgb",
  1098: "IfcColourRgbList",
  1099: "IfcColourSpecification",
  1100: "IfcColumn",
  1101: "IfcColumnStandardCase",
  1102: "IfcColumnType",
  1103: "IfcCommunicationsAppliance",
  1104: "IfcCommunicationsApplianceType",
  1105: "IfcComplexProperty",
  1106: "IfcComplexPropertyTemplate",
  1107: "IfcCompositeCurve",
  1108: "IfcCompositeCurveOnSurface",
  1109: "IfcCompositeCurveSegment",
  1110: "IfcCompositeProfileDef",
  1111: "IfcCompressor",
  1112: "IfcCompressorType",
  1113: "IfcCondenser",
  1114: "IfcCondenserType",
  1115: "IfcConic",
  1116: "IfcConnectedFaceSet",
  1117: "IfcConnectionCurveGeometry",
  1118: "IfcConnectionGeometry",
  1119: "IfcConnectionPointEccentricity",
  1120: "IfcConnectionPointGeometry",
  1121: "IfcConnectionSurfaceGeometry",
  1122: "IfcConnectionVolumeGeometry",
  1123: "IfcConstraint",
  1124: "IfcConstructionEquipmentResource",
  1125: "IfcConstructionEquipmentResourceType",
  1126: "IfcConstructionMaterialResource",
  1127: "IfcConstructionMaterialResourceType",
  1128: "IfcConstructionProductResource",
  1129: "IfcConstructionProductResourceType",
  1130: "IfcConstructionResource",
  1131: "IfcConstructionResourceType",
  1132: "IfcContext",
  1133: "IfcContextDependentUnit",
  1134: "IfcControl",
  1135: "IfcController",
  1136: "IfcControllerType",
  1137: "IfcConversionBasedUnit",
  1138: "IfcConversionBasedUnitWithOffset",
  1139: "IfcCooledBeam",
  1140: "IfcCooledBeamType",
  1141: "IfcCoolingTower",
  1142: "IfcCoolingTowerType",
  1143: "IfcCoordinateOperation",
  1144: "IfcCoordinateReferenceSystem",
  1145: "IfcCostItem",
  1146: "IfcCostSchedule",
  1147: "IfcCostValue",
  1148: "IfcCovering",
  1149: "IfcCoveringType",
  1150: "IfcCrewResource",
  1151: "IfcCrewResourceType",
  1152: "IfcCsgPrimitive3D",
  1153: "IfcCsgSolid",
  1154: "IfcCShapeProfileDef",
  1155: "IfcCurrencyRelationship",
  1156: "IfcCurtainWall",
  1157: "IfcCurtainWallType",
  1158: "IfcCurve",
  1159: "IfcCurveBoundedPlane",
  1160: "IfcCurveBoundedSurface",
  1161: "IfcCurveStyle",
  1162: "IfcCurveStyleFont",
  1163: "IfcCurveStyleFontAndScaling",
  1164: "IfcCurveStyleFontPattern",
  1165: "IfcCylindricalSurface",
  1166: "IfcDamper",
  1167: "IfcDamperType",
  1168: "IfcDerivedProfileDef",
  1169: "IfcDerivedUnit",
  1170: "IfcDerivedUnitElement",
  1171: "IfcDimensionalExponents",
  1172: "IfcDirection",
  1173: "IfcDiscreteAccessory",
  1174: "IfcDiscreteAccessoryType",
  1175: "IfcDistributionChamberElement",
  1176: "IfcDistributionChamberElementType",
  1177: "IfcDistributionCircuit",
  1178: "IfcDistributionControlElement",
  1179: "IfcDistributionControlElementType",
  1180: "IfcDistributionElement",
  1181: "IfcDistributionElementType",
  1182: "IfcDistributionFlowElement",
  1183: "IfcDistributionFlowElementType",
  1184: "IfcDistributionPort",
  1185: "IfcDistributionSystem",
  1186: "IfcDocumentInformation",
  1187: "IfcDocumentInformationRelationship",
  1188: "IfcDocumentReference",
  1189: "IfcDoor",
  1190: "IfcDoorLiningProperties",
  1191: "IfcDoorPanelProperties",
  1192: "IfcDoorStandardCase",
  1193: "IfcDoorStyle",
  1194: "IfcDoorType",
  1195: "IfcDraughtingPreDefinedColour",
  1196: "IfcDraughtingPreDefinedCurveFont",
  1197: "IfcDuctFitting",
  1198: "IfcDuctFittingType",
  1199: "IfcDuctSegment",
  1200: "IfcDuctSegmentType",
  1201: "IfcDuctSilencer",
  1202: "IfcDuctSilencerType",
  1203: "IfcEdge",
  1204: "IfcEdgeCurve",
  1205: "IfcEdgeLoop",
  1206: "IfcElectricAppliance",
  1207: "IfcElectricApplianceType",
  1208: "IfcElectricDistributionBoard",
  1209: "IfcElectricDistributionBoardType",
  1210: "IfcElectricFlowStorageDevice",
  1211: "IfcElectricFlowStorageDeviceType",
  1212: "IfcElectricGenerator",
  1213: "IfcElectricGeneratorType",
  1214: "IfcElectricMotor",
  1215: "IfcElectricMotorType",
  1216: "IfcElectricTimeControl",
  1217: "IfcElectricTimeControlType",
  1218: "IfcElement",
  1219: "IfcElementarySurface",
  1220: "IfcElementAssembly",
  1221: "IfcElementAssemblyType",
  1222: "IfcElementComponent",
  1223: "IfcElementComponentType",
  1224: "IfcElementQuantity",
  1225: "IfcElementType",
  1226: "IfcEllipse",
  1227: "IfcEllipseProfileDef",
  1228: "IfcEnergyConversionDevice",
  1229: "IfcEnergyConversionDeviceType",
  1230: "IfcEngine",
  1231: "IfcEngineType",
  1232: "IfcEvaporativeCooler",
  1233: "IfcEvaporativeCoolerType",
  1234: "IfcEvaporator",
  1235: "IfcEvaporatorType",
  1236: "IfcEvent",
  1237: "IfcEventTime",
  1238: "IfcEventType",
  1239: "IfcExtendedProperties",
  1240: "IfcExternalInformation",
  1241: "IfcExternallyDefinedHatchStyle",
  1242: "IfcExternallyDefinedSurfaceStyle",
  1243: "IfcExternallyDefinedTextFont",
  1244: "IfcExternalReference",
  1245: "IfcExternalReferenceRelationship",
  1246: "IfcExternalSpatialElement",
  1247: "IfcExternalSpatialStructureElement",
  1248: "IfcExtrudedAreaSolid",
  1249: "IfcExtrudedAreaSolidTapered",
  1250: "IfcFace",
  1251: "IfcFaceBasedSurfaceModel",
  1252: "IfcFaceBound",
  1253: "IfcFaceOuterBound",
  1254: "IfcFaceSurface",
  1255: "IfcFacetedBrep",
  1256: "IfcFacetedBrepWithVoids",
  1257: "IfcFailureConnectionCondition",
  1258: "IfcFan",
  1259: "IfcFanType",
  1260: "IfcFastener",
  1261: "IfcFastenerType",
  1262: "IfcFeatureElement",
  1263: "IfcFeatureElementAddition",
  1264: "IfcFeatureElementSubtraction",
  1265: "IfcFillAreaStyle",
  1266: "IfcFillAreaStyleHatching",
  1267: "IfcFillAreaStyleTiles",
  1268: "IfcFilter",
  1269: "IfcFilterType",
  1270: "IfcFireSuppressionTerminal",
  1271: "IfcFireSuppressionTerminalType",
  1272: "IfcFixedReferenceSweptAreaSolid",
  1273: "IfcFlowController",
  1274: "IfcFlowControllerType",
  1275: "IfcFlowFitting",
  1276: "IfcFlowFittingType",
  1277: "IfcFlowInstrument",
  1278: "IfcFlowInstrumentType",
  1279: "IfcFlowMeter",
  1280: "IfcFlowMeterType",
  1281: "IfcFlowMovingDevice",
  1282: "IfcFlowMovingDeviceType",
  1283: "IfcFlowSegment",
  1284: "IfcFlowSegmentType",
  1285: "IfcFlowStorageDevice",
  1286: "IfcFlowStorageDeviceType",
  1287: "IfcFlowTerminal",
  1288: "IfcFlowTerminalType",
  1289: "IfcFlowTreatmentDevice",
  1290: "IfcFlowTreatmentDeviceType",
  1291: "IfcFooting",
  1292: "IfcFootingType",
  1293: "IfcFurnishingElement",
  1294: "IfcFurnishingElementType",
  1295: "IfcFurniture",
  1296: "IfcFurnitureType",
  1297: "IfcGeographicElement",
  1298: "IfcGeographicElementType",
  1299: "IfcGeometricCurveSet",
  1300: "IfcGeometricRepresentationContext",
  1301: "IfcGeometricRepresentationItem",
  1302: "IfcGeometricRepresentationSubContext",
  1303: "IfcGeometricSet",
  1304: "IfcGrid",
  1305: "IfcGridAxis",
  1306: "IfcGridPlacement",
  1307: "IfcGroup",
  1308: "IfcHalfSpaceSolid",
  1309: "IfcHeatExchanger",
  1310: "IfcHeatExchangerType",
  1311: "IfcHumidifier",
  1312: "IfcHumidifierType",
  1313: "IfcImageTexture",
  1314: "IfcIndexedColourMap",
  1315: "IfcIndexedPolyCurve",
  1316: "IfcIndexedPolygonalFace",
  1317: "IfcIndexedPolygonalFaceWithVoids",
  1318: "IfcIndexedTextureMap",
  1319: "IfcIndexedTriangleTextureMap",
  1320: "IfcInterceptor",
  1321: "IfcInterceptorType",
  1322: "IfcIntersectionCurve",
  1323: "IfcInventory",
  1324: "IfcIrregularTimeSeries",
  1325: "IfcIrregularTimeSeriesValue",
  1326: "IfcIShapeProfileDef",
  1327: "IfcJunctionBox",
  1328: "IfcJunctionBoxType",
  1329: "IfcLaborResource",
  1330: "IfcLaborResourceType",
  1331: "IfcLagTime",
  1332: "IfcLamp",
  1333: "IfcLampType",
  1334: "IfcLibraryInformation",
  1335: "IfcLibraryReference",
  1336: "IfcLightDistributionData",
  1337: "IfcLightFixture",
  1338: "IfcLightFixtureType",
  1339: "IfcLightIntensityDistribution",
  1340: "IfcLightSource",
  1341: "IfcLightSourceAmbient",
  1342: "IfcLightSourceDirectional",
  1343: "IfcLightSourceGoniometric",
  1344: "IfcLightSourcePositional",
  1345: "IfcLightSourceSpot",
  1346: "IfcLine",
  1347: "IfcLocalPlacement",
  1348: "IfcLoop",
  1349: "IfcLShapeProfileDef",
  1350: "IfcManifoldSolidBrep",
  1351: "IfcMapConversion",
  1352: "IfcMappedItem",
  1353: "IfcMaterial",
  1354: "IfcMaterialClassificationRelationship",
  1355: "IfcMaterialConstituent",
  1356: "IfcMaterialConstituentSet",
  1357: "IfcMaterialDefinition",
  1358: "IfcMaterialDefinitionRepresentation",
  1359: "IfcMaterialLayer",
  1360: "IfcMaterialLayerSet",
  1361: "IfcMaterialLayerSetUsage",
  1362: "IfcMaterialLayerWithOffsets",
  1363: "IfcMaterialList",
  1364: "IfcMaterialProfile",
  1365: "IfcMaterialProfileSet",
  1366: "IfcMaterialProfileSetUsage",
  1367: "IfcMaterialProfileSetUsageTapering",
  1368: "IfcMaterialProfileWithOffsets",
  1369: "IfcMaterialProperties",
  1370: "IfcMaterialRelationship",
  1371: "IfcMaterialUsageDefinition",
  1372: "IfcMeasureWithUnit",
  1373: "IfcMechanicalFastener",
  1374: "IfcMechanicalFastenerType",
  1375: "IfcMedicalDevice",
  1376: "IfcMedicalDeviceType",
  1377: "IfcMember",
  1378: "IfcMemberStandardCase",
  1379: "IfcMemberType",
  1380: "IfcMetric",
  1381: "IfcMirroredProfileDef",
  1382: "IfcMonetaryUnit",
  1383: "IfcMotorConnection",
  1384: "IfcMotorConnectionType",
  1385: "IfcNamedUnit",
  1386: "IfcObject",
  1387: "IfcObjectDefinition",
  1388: "IfcObjective",
  1389: "IfcObjectPlacement",
  1390: "IfcOccupant",
  1391: "IfcOffsetCurve2D",
  1392: "IfcOffsetCurve3D",
  1393: "IfcOpeningElement",
  1394: "IfcOpeningStandardCase",
  1395: "IfcOpenShell",
  1396: "IfcOrganization",
  1397: "IfcOrganizationRelationship",
  1398: "IfcOrientedEdge",
  1399: "IfcOuterBoundaryCurve",
  1400: "IfcOutlet",
  1401: "IfcOutletType",
  1402: "IfcOwnerHistory",
  1403: "IfcParameterizedProfileDef",
  1404: "IfcPath",
  1405: "IfcPcurve",
  1406: "IfcPerformanceHistory",
  1407: "IfcPermeableCoveringProperties",
  1408: "IfcPermit",
  1409: "IfcPerson",
  1410: "IfcPersonAndOrganization",
  1411: "IfcPhysicalComplexQuantity",
  1412: "IfcPhysicalQuantity",
  1413: "IfcPhysicalSimpleQuantity",
  1414: "IfcPile",
  1415: "IfcPileType",
  1416: "IfcPipeFitting",
  1417: "IfcPipeFittingType",
  1418: "IfcPipeSegment",
  1419: "IfcPipeSegmentType",
  1420: "IfcPixelTexture",
  1421: "IfcPlacement",
  1422: "IfcPlanarBox",
  1423: "IfcPlanarExtent",
  1424: "IfcPlane",
  1425: "IfcPlate",
  1426: "IfcPlateStandardCase",
  1427: "IfcPlateType",
  1428: "IfcPoint",
  1429: "IfcPointOnCurve",
  1430: "IfcPointOnSurface",
  1431: "IfcPolygonalBoundedHalfSpace",
  1432: "IfcPolygonalFaceSet",
  1433: "IfcPolyline",
  1434: "IfcPolyLoop",
  1435: "IfcPort",
  1436: "IfcPostalAddress",
  1437: "IfcPreDefinedColour",
  1438: "IfcPreDefinedCurveFont",
  1439: "IfcPreDefinedItem",
  1440: "IfcPreDefinedProperties",
  1441: "IfcPreDefinedPropertySet",
  1442: "IfcPreDefinedTextFont",
  1443: "IfcPresentationItem",
  1444: "IfcPresentationLayerAssignment",
  1445: "IfcPresentationLayerWithStyle",
  1446: "IfcPresentationStyle",
  1447: "IfcPresentationStyleAssignment",
  1448: "IfcProcedure",
  1449: "IfcProcedureType",
  1450: "IfcProcess",
  1451: "IfcProduct",
  1452: "IfcProductDefinitionShape",
  1453: "IfcProductRepresentation",
  1454: "IfcProfileDef",
  1455: "IfcProfileProperties",
  1456: "IfcProject",
  1457: "IfcProjectedCRS",
  1458: "IfcProjectionElement",
  1459: "IfcProjectLibrary",
  1460: "IfcProjectOrder",
  1461: "IfcProperty",
  1462: "IfcPropertyAbstraction",
  1463: "IfcPropertyBoundedValue",
  1464: "IfcPropertyDefinition",
  1465: "IfcPropertyDependencyRelationship",
  1466: "IfcPropertyEnumeratedValue",
  1467: "IfcPropertyEnumeration",
  1468: "IfcPropertyListValue",
  1469: "IfcPropertyReferenceValue",
  1470: "IfcPropertySet",
  1471: "IfcPropertySetDefinition",
  1472: "IfcPropertySetTemplate",
  1473: "IfcPropertySingleValue",
  1474: "IfcPropertyTableValue",
  1475: "IfcPropertyTemplate",
  1476: "IfcPropertyTemplateDefinition",
  1477: "IfcProtectiveDevice",
  1478: "IfcProtectiveDeviceTrippingUnit",
  1479: "IfcProtectiveDeviceTrippingUnitType",
  1480: "IfcProtectiveDeviceType",
  1481: "IfcProxy",
  1482: "IfcPump",
  1483: "IfcPumpType",
  1484: "IfcQuantityArea",
  1485: "IfcQuantityCount",
  1486: "IfcQuantityLength",
  1487: "IfcQuantitySet",
  1488: "IfcQuantityTime",
  1489: "IfcQuantityVolume",
  1490: "IfcQuantityWeight",
  1491: "IfcRailing",
  1492: "IfcRailingType",
  1493: "IfcRamp",
  1494: "IfcRampFlight",
  1495: "IfcRampFlightType",
  1496: "IfcRampType",
  1497: "IfcRationalBSplineCurveWithKnots",
  1498: "IfcRationalBSplineSurfaceWithKnots",
  1499: "IfcRectangleHollowProfileDef",
  1500: "IfcRectangleProfileDef",
  1501: "IfcRectangularPyramid",
  1502: "IfcRectangularTrimmedSurface",
  1503: "IfcRecurrencePattern",
  1504: "IfcReference",
  1505: "IfcRegularTimeSeries",
  1506: "IfcReinforcementBarProperties",
  1507: "IfcReinforcementDefinitionProperties",
  1508: "IfcReinforcingBar",
  1509: "IfcReinforcingBarType",
  1510: "IfcReinforcingElement",
  1511: "IfcReinforcingElementType",
  1512: "IfcReinforcingMesh",
  1513: "IfcReinforcingMeshType",
  1514: "IfcRelAggregates",
  1515: "IfcRelAssigns",
  1516: "IfcRelAssignsToActor",
  1517: "IfcRelAssignsToControl",
  1518: "IfcRelAssignsToGroup",
  1519: "IfcRelAssignsToGroupByFactor",
  1520: "IfcRelAssignsToProcess",
  1521: "IfcRelAssignsToProduct",
  1522: "IfcRelAssignsToResource",
  1523: "IfcRelAssociates",
  1524: "IfcRelAssociatesApproval",
  1525: "IfcRelAssociatesClassification",
  1526: "IfcRelAssociatesConstraint",
  1527: "IfcRelAssociatesDocument",
  1528: "IfcRelAssociatesLibrary",
  1529: "IfcRelAssociatesMaterial",
  1530: "IfcRelationship",
  1531: "IfcRelConnects",
  1532: "IfcRelConnectsElements",
  1533: "IfcRelConnectsPathElements",
  1534: "IfcRelConnectsPorts",
  1535: "IfcRelConnectsPortToElement",
  1536: "IfcRelConnectsStructuralActivity",
  1537: "IfcRelConnectsStructuralMember",
  1538: "IfcRelConnectsWithEccentricity",
  1539: "IfcRelConnectsWithRealizingElements",
  1540: "IfcRelContainedInSpatialStructure",
  1541: "IfcRelCoversBldgElements",
  1542: "IfcRelCoversSpaces",
  1543: "IfcRelDeclares",
  1544: "IfcRelDecomposes",
  1545: "IfcRelDefines",
  1546: "IfcRelDefinesByObject",
  1547: "IfcRelDefinesByProperties",
  1548: "IfcRelDefinesByTemplate",
  1549: "IfcRelDefinesByType",
  1550: "IfcRelFillsElement",
  1551: "IfcRelFlowControlElements",
  1552: "IfcRelInterferesElements",
  1553: "IfcRelNests",
  1554: "IfcRelProjectsElement",
  1555: "IfcRelReferencedInSpatialStructure",
  1556: "IfcRelSequence",
  1557: "IfcRelServicesBuildings",
  1558: "IfcRelSpaceBoundary",
  1559: "IfcRelSpaceBoundary1stLevel",
  1560: "IfcRelSpaceBoundary2ndLevel",
  1561: "IfcRelVoidsElement",
  1562: "IfcReparametrisedCompositeCurveSegment",
  1563: "IfcRepresentation",
  1564: "IfcRepresentationContext",
  1565: "IfcRepresentationItem",
  1566: "IfcRepresentationMap",
  1567: "IfcResource",
  1568: "IfcResourceApprovalRelationship",
  1569: "IfcResourceConstraintRelationship",
  1570: "IfcResourceLevelRelationship",
  1571: "IfcResourceTime",
  1572: "IfcRevolvedAreaSolid",
  1573: "IfcRevolvedAreaSolidTapered",
  1574: "IfcRightCircularCone",
  1575: "IfcRightCircularCylinder",
  1576: "IfcRoof",
  1577: "IfcRoofType",
  1578: "IfcRoot",
  1579: "IfcRoundedRectangleProfileDef",
  1580: "IfcSanitaryTerminal",
  1581: "IfcSanitaryTerminalType",
  1582: "IfcSchedulingTime",
  1583: "IfcSeamCurve",
  1584: "IfcSectionedSpine",
  1585: "IfcSectionProperties",
  1586: "IfcSectionReinforcementProperties",
  1587: "IfcSensor",
  1588: "IfcSensorType",
  1589: "IfcShadingDevice",
  1590: "IfcShadingDeviceType",
  1591: "IfcShapeAspect",
  1592: "IfcShapeModel",
  1593: "IfcShapeRepresentation",
  1594: "IfcShellBasedSurfaceModel",
  1595: "IfcSimpleProperty",
  1596: "IfcSimplePropertyTemplate",
  1597: "IfcSite",
  1598: "IfcSIUnit",
  1599: "IfcSlab",
  1600: "IfcSlabElementedCase",
  1601: "IfcSlabStandardCase",
  1602: "IfcSlabType",
  1603: "IfcSlippageConnectionCondition",
  1604: "IfcSolarDevice",
  1605: "IfcSolarDeviceType",
  1606: "IfcSolidModel",
  1607: "IfcSpace",
  1608: "IfcSpaceHeater",
  1609: "IfcSpaceHeaterType",
  1610: "IfcSpaceType",
  1611: "IfcSpatialElement",
  1612: "IfcSpatialElementType",
  1613: "IfcSpatialStructureElement",
  1614: "IfcSpatialStructureElementType",
  1615: "IfcSpatialZone",
  1616: "IfcSpatialZoneType",
  1617: "IfcSphere",
  1618: "IfcSphericalSurface",
  1619: "IfcStackTerminal",
  1620: "IfcStackTerminalType",
  1621: "IfcStair",
  1622: "IfcStairFlight",
  1623: "IfcStairFlightType",
  1624: "IfcStairType",
  1625: "IfcStructuralAction",
  1626: "IfcStructuralActivity",
  1627: "IfcStructuralAnalysisModel",
  1628: "IfcStructuralConnection",
  1629: "IfcStructuralConnectionCondition",
  1630: "IfcStructuralCurveAction",
  1631: "IfcStructuralCurveConnection",
  1632: "IfcStructuralCurveMember",
  1633: "IfcStructuralCurveMemberVarying",
  1634: "IfcStructuralCurveReaction",
  1635: "IfcStructuralItem",
  1636: "IfcStructuralLinearAction",
  1637: "IfcStructuralLoad",
  1638: "IfcStructuralLoadCase",
  1639: "IfcStructuralLoadConfiguration",
  1640: "IfcStructuralLoadGroup",
  1641: "IfcStructuralLoadLinearForce",
  1642: "IfcStructuralLoadOrResult",
  1643: "IfcStructuralLoadPlanarForce",
  1644: "IfcStructuralLoadSingleDisplacement",
  1645: "IfcStructuralLoadSingleDisplacementDistortion",
  1646: "IfcStructuralLoadSingleForce",
  1647: "IfcStructuralLoadSingleForceWarping",
  1648: "IfcStructuralLoadStatic",
  1649: "IfcStructuralLoadTemperature",
  1650: "IfcStructuralMember",
  1651: "IfcStructuralPlanarAction",
  1652: "IfcStructuralPointAction",
  1653: "IfcStructuralPointConnection",
  1654: "IfcStructuralPointReaction",
  1655: "IfcStructuralReaction",
  1656: "IfcStructuralResultGroup",
  1657: "IfcStructuralSurfaceAction",
  1658: "IfcStructuralSurfaceConnection",
  1659: "IfcStructuralSurfaceMember",
  1660: "IfcStructuralSurfaceMemberVarying",
  1661: "IfcStructuralSurfaceReaction",
  1662: "IfcStyledItem",
  1663: "IfcStyledRepresentation",
  1664: "IfcStyleModel",
  1665: "IfcSubContractResource",
  1666: "IfcSubContractResourceType",
  1667: "IfcSubedge",
  1668: "IfcSurface",
  1669: "IfcSurfaceCurve",
  1670: "IfcSurfaceCurveSweptAreaSolid",
  1671: "IfcSurfaceFeature",
  1672: "IfcSurfaceOfLinearExtrusion",
  1673: "IfcSurfaceOfRevolution",
  1674: "IfcSurfaceReinforcementArea",
  1675: "IfcSurfaceStyle",
  1676: "IfcSurfaceStyleLighting",
  1677: "IfcSurfaceStyleRefraction",
  1678: "IfcSurfaceStyleRendering",
  1679: "IfcSurfaceStyleShading",
  1680: "IfcSurfaceStyleWithTextures",
  1681: "IfcSurfaceTexture",
  1682: "IfcSweptAreaSolid",
  1683: "IfcSweptDiskSolid",
  1684: "IfcSweptDiskSolidPolygonal",
  1685: "IfcSweptSurface",
  1686: "IfcSwitchingDevice",
  1687: "IfcSwitchingDeviceType",
  1688: "IfcSystem",
  1689: "IfcSystemFurnitureElement",
  1690: "IfcSystemFurnitureElementType",
  1691: "IfcTable",
  1692: "IfcTableColumn",
  1693: "IfcTableRow",
  1694: "IfcTank",
  1695: "IfcTankType",
  1696: "IfcTask",
  1697: "IfcTaskTime",
  1698: "IfcTaskTimeRecurring",
  1699: "IfcTaskType",
  1700: "IfcTelecomAddress",
  1701: "IfcTendon",
  1702: "IfcTendonAnchor",
  1703: "IfcTendonAnchorType",
  1704: "IfcTendonType",
  1705: "IfcTessellatedFaceSet",
  1706: "IfcTessellatedItem",
  1707: "IfcTextLiteral",
  1708: "IfcTextLiteralWithExtent",
  1709: "IfcTextStyle",
  1710: "IfcTextStyleFontModel",
  1711: "IfcTextStyleForDefinedFont",
  1712: "IfcTextStyleTextModel",
  1713: "IfcTextureCoordinate",
  1714: "IfcTextureCoordinateGenerator",
  1715: "IfcTextureMap",
  1716: "IfcTextureVertex",
  1717: "IfcTextureVertexList",
  1718: "IfcTimePeriod",
  1719: "IfcTimeSeries",
  1720: "IfcTimeSeriesValue",
  1721: "IfcTopologicalRepresentationItem",
  1722: "IfcTopologyRepresentation",
  1723: "IfcToroidalSurface",
  1724: "IfcTransformer",
  1725: "IfcTransformerType",
  1726: "IfcTransportElement",
  1727: "IfcTransportElementType",
  1728: "IfcTrapeziumProfileDef",
  1729: "IfcTriangulatedFaceSet",
  1730: "IfcTrimmedCurve",
  1731: "IfcTShapeProfileDef",
  1732: "IfcTubeBundle",
  1733: "IfcTubeBundleType",
  1734: "IfcTypeObject",
  1735: "IfcTypeProcess",
  1736: "IfcTypeProduct",
  1737: "IfcTypeResource",
  1738: "IfcUnitaryControlElement",
  1739: "IfcUnitaryControlElementType",
  1740: "IfcUnitaryEquipment",
  1741: "IfcUnitaryEquipmentType",
  1742: "IfcUnitAssignment",
  1743: "IfcUShapeProfileDef",
  1744: "IfcValve",
  1745: "IfcValveType",
  1746: "IfcVector",
  1747: "IfcVertex",
  1748: "IfcVertexLoop",
  1749: "IfcVertexPoint",
  1750: "IfcVibrationIsolator",
  1751: "IfcVibrationIsolatorType",
  1752: "IfcVirtualElement",
  1753: "IfcVirtualGridIntersection",
  1754: "IfcVoidingFeature",
  1755: "IfcWall",
  1756: "IfcWallElementedCase",
  1757: "IfcWallStandardCase",
  1758: "IfcWallType",
  1759: "IfcWasteTerminal",
  1760: "IfcWasteTerminalType",
  1761: "IfcWindow",
  1762: "IfcWindowLiningProperties",
  1763: "IfcWindowPanelProperties",
  1764: "IfcWindowStandardCase",
  1765: "IfcWindowStyle",
  1766: "IfcWindowType",
  1767: "IfcWorkCalendar",
  1768: "IfcWorkControl",
  1769: "IfcWorkPlan",
  1770: "IfcWorkSchedule",
  1771: "IfcWorkTime",
  1772: "IfcZone",
  1773: "IfcZShapeProfileDef"
};

// ../sdk/src/cityjson/index.ts
var cityjson_exports = {};
__export(cityjson_exports, {
  CityJSONLoader: () => CityJSONLoader
});

// ../sdk/src/cityjson/versions/v1_0/earcut.ts
var earcut = /* @__PURE__ */ (() => {
  class Node {
    i;
    x;
    y;
    prev;
    next;
    z;
    prevZ;
    nextZ;
    steiner;
    constructor(i, x, y) {
      this.i = i;
      this.x = x;
      this.y = y;
      this.prev = null;
      this.next = null;
      this.z = null;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
    }
  }
  ;
  const earcut2 = (data, holeIndices, dim = 2) => {
    dim = dim || 2;
    const hasHoles = holeIndices && holeIndices.length > 0;
    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    let outerNode = linkedList(data, 0, outerLen, dim, true);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev)
      return triangles;
    let minX;
    let minY;
    let maxX;
    let maxY;
    let x;
    let y;
    let invSize;
    if (hasHoles) {
      outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    }
    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];
      for (var i = dim; i < outerLen; i += dim) {
        x = data[i];
        y = data[i + 1];
        if (x < minX)
          minX = x;
        if (y < minY)
          minY = y;
        if (x > maxX)
          maxX = x;
        if (y > maxY)
          maxY = y;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 1 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
    return triangles;
  };
  const linkedList = (data, start, end, dim, clockwise) => {
    var i;
    var last;
    if (clockwise === signedArea(data, start, end, dim) > 0) {
      for (i = start; i < end; i += dim) {
        last = insertNode(i, data[i], data[i + 1], last);
      }
    } else {
      for (i = end - dim; i >= start; i -= dim) {
        last = insertNode(i, data[i], data[i + 1], last);
      }
    }
    if (last && equals2(last, last.next)) {
      removeNode(last);
      last = last.next;
    }
    return last;
  };
  const filterPoints = (start, end) => {
    if (!start)
      return start;
    if (!end)
      end = start;
    let p = start;
    let again = false;
    do {
      again = false;
      if (!p.steiner && (equals2(p, p.next) || area(p.prev, p, p.next) === 0)) {
        removeNode(p);
        p = end = p.prev;
        if (p === p.next)
          break;
        again = true;
      } else {
        p = p.next;
      }
    } while (again || p !== end);
    return end;
  };
  const earcutLinked = (ear, triangles, dim, minX, minY, invSize, pass) => {
    if (!ear)
      return;
    if (!pass && invSize) {
      indexCurve(ear, minX, minY, invSize);
    }
    let stop = ear;
    let prev;
    let next;
    while (ear.prev !== ear.next) {
      prev = ear.prev;
      next = ear.next;
      if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
        triangles.push(prev.i / dim);
        triangles.push(ear.i / dim);
        triangles.push(next.i / dim);
        removeNode(ear);
        ear = next.next;
        stop = next.next;
        continue;
      }
      ear = next;
      if (ear === stop) {
        if (!pass) {
          earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
        } else if (pass === 1) {
          ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
          earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
        } else if (pass === 2) {
          splitEarcut(ear, triangles, dim, minX, minY, invSize);
        }
        break;
      }
    }
  };
  const isEar = (ear) => {
    const a2 = ear.prev;
    const b4 = ear;
    const c2 = ear.next;
    if (area(a2, b4, c2) >= 0)
      return false;
    var p = ear.next.next;
    while (p !== ear.prev) {
      if (pointInTriangle(a2.x, a2.y, b4.x, b4.y, c2.x, c2.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
        return false;
      p = p.next;
    }
    return true;
  };
  const isEarHashed = (ear, minX, minY, invSize) => {
    var a2 = ear.prev;
    var b4 = ear;
    var c2 = ear.next;
    if (area(a2, b4, c2) >= 0)
      return false;
    var minTX = a2.x < b4.x ? a2.x < c2.x ? a2.x : c2.x : b4.x < c2.x ? b4.x : c2.x, minTY = a2.y < b4.y ? a2.y < c2.y ? a2.y : c2.y : b4.y < c2.y ? b4.y : c2.y, maxTX = a2.x > b4.x ? a2.x > c2.x ? a2.x : c2.x : b4.x > c2.x ? b4.x : c2.x, maxTY = a2.y > b4.y ? a2.y > c2.y ? a2.y : c2.y : b4.y > c2.y ? b4.y : c2.y;
    var minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
    var p = ear.prevZ, n = ear.nextZ;
    while (p && p.z >= minZ && n && n.z <= maxZ) {
      if (p !== ear.prev && p !== ear.next && // TODO: use Triangle.utils.pointIsInTriangle
      pointInTriangle(a2.x, a2.y, b4.x, b4.y, c2.x, c2.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
        return false;
      p = p.prevZ;
      if (n !== ear.prev && n !== ear.next && // TODO: use Triangle.utils.pointIsInTriangle
      pointInTriangle(a2.x, a2.y, b4.x, b4.y, c2.x, c2.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
        return false;
      n = n.nextZ;
    }
    while (p && p.z >= minZ) {
      if (p !== ear.prev && p !== ear.next && // TODO: use Triangle.utils.pointIsInTriangle
      pointInTriangle(a2.x, a2.y, b4.x, b4.y, c2.x, c2.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
        return false;
      p = p.prevZ;
    }
    while (n && n.z <= maxZ) {
      if (n !== ear.prev && n !== ear.next && // TODO: use Triangle.utils.pointIsInTriangle
      pointInTriangle(a2.x, a2.y, b4.x, b4.y, c2.x, c2.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
        return false;
      n = n.nextZ;
    }
    return true;
  };
  const cureLocalIntersections = (start, triangles, dim) => {
    let p = start;
    do {
      let a2 = p.prev;
      let b4 = p.next.next;
      if (!equals2(a2, b4) && intersects(a2, p, p.next, b4) && locallyInside(a2, b4) && locallyInside(b4, a2)) {
        triangles.push(a2.i / dim);
        triangles.push(p.i / dim);
        triangles.push(b4.i / dim);
        removeNode(p);
        removeNode(p.next);
        p = start = b4;
      }
      p = p.next;
    } while (p !== start);
    return filterPoints(p);
  };
  const splitEarcut = (start, triangles, dim, minX, minY, invSize) => {
    let a2 = start;
    do {
      let b4 = a2.next.next;
      while (b4 !== a2.prev) {
        if (a2.i !== b4.i && isValidDiagonal(a2, b4)) {
          var c2 = splitPolygon(a2, b4);
          a2 = filterPoints(a2, a2.next);
          c2 = filterPoints(c2, c2.next);
          earcutLinked(a2, triangles, dim, minX, minY, invSize);
          earcutLinked(c2, triangles, dim, minX, minY, invSize);
          return;
        }
        b4 = b4.next;
      }
      a2 = a2.next;
    } while (a2 !== start);
  };
  const eliminateHoles = (data, holeIndices, outerNode, dim) => {
    const queue = [];
    let i;
    const len = holeIndices.length;
    let start;
    let end;
    let list;
    for (i = 0; i < len; i++) {
      start = holeIndices[i] * dim;
      end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
      list = linkedList(data, start, end, dim, false);
      if (list === list.next)
        list.steiner = true;
      queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    for (i = 0; i < queue.length; i++) {
      eliminateHole(queue[i], outerNode);
      outerNode = filterPoints(outerNode, outerNode.next);
    }
    return outerNode;
  };
  const compareX = (a2, b4) => {
    return a2.x - b4.x;
  };
  const eliminateHole = (hole, outerNode) => {
    var bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
      return outerNode;
    }
    var bridgeReverse = splitPolygon(bridge, hole);
    var filteredBridge = filterPoints(bridge, bridge.next);
    filterPoints(bridgeReverse, bridgeReverse.next);
    return outerNode === bridge ? filteredBridge : outerNode;
  };
  const findHoleBridge = (hole, outerNode) => {
    let p = outerNode;
    let hx = hole.x;
    let hy = hole.y;
    let qx = -Infinity;
    let m;
    do {
      if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
        var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
        if (x <= hx && x > qx) {
          qx = x;
          if (x === hx) {
            if (hy === p.y)
              return p;
            if (hy === p.next.y)
              return p.next;
          }
          m = p.x < p.next.x ? p : p.next;
        }
      }
      p = p.next;
    } while (p !== outerNode);
    if (!m) {
      return null;
    }
    if (hx === qx) {
      return m;
    }
    let stop = m;
    let mx = m.x;
    let my = m.y;
    let tanMin = Infinity;
    let tan;
    p = m;
    do {
      if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
        tan = Math.abs(hy - p.y) / (hx - p.x);
        if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
          m = p;
          tanMin = tan;
        }
      }
      p = p.next;
    } while (p !== stop);
    return m;
  };
  const sectorContainsSector = (m, p) => {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
  };
  const indexCurve = (start, minX, minY, invSize) => {
    var p = start;
    do {
      if (p.z === null)
        p.z = zOrder(p.x, p.y, minX, minY, invSize);
      p.prevZ = p.prev;
      p.nextZ = p.next;
      p = p.next;
    } while (p !== start);
    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked(p);
  };
  const sortLinked = (list) => {
    let i;
    let p;
    let q;
    let e;
    let tail;
    let numMerges;
    let pSize;
    let qSize;
    let inSize = 1;
    do {
      p = list;
      list = null;
      tail = null;
      numMerges = 0;
      while (p) {
        numMerges++;
        q = p;
        pSize = 0;
        for (i = 0; i < inSize; i++) {
          pSize++;
          q = q.nextZ;
          if (!q)
            break;
        }
        qSize = inSize;
        while (pSize > 0 || qSize > 0 && q) {
          if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
            e = p;
            p = p.nextZ;
            pSize--;
          } else {
            e = q;
            q = q.nextZ;
            qSize--;
          }
          if (tail)
            tail.nextZ = e;
          else
            list = e;
          e.prevZ = tail;
          tail = e;
        }
        p = q;
      }
      tail.nextZ = null;
      inSize *= 2;
    } while (numMerges > 1);
    return list;
  };
  const zOrder = (x, y, minX, minY, invSize) => {
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;
    x = (x | x << 8) & 16711935;
    x = (x | x << 4) & 252645135;
    x = (x | x << 2) & 858993459;
    x = (x | x << 1) & 1431655765;
    y = (y | y << 8) & 16711935;
    y = (y | y << 4) & 252645135;
    y = (y | y << 2) & 858993459;
    y = (y | y << 1) & 1431655765;
    return x | y << 1;
  };
  const getLeftmost = (start) => {
    let p = start;
    let leftmost = start;
    do {
      if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) {
        leftmost = p;
      }
      p = p.next;
    } while (p !== start);
    return leftmost;
  };
  const pointInTriangle = (ax, ay, bx, by, cx, cy, px, py) => {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
  };
  const isValidDiagonal = (a2, b4) => {
    return a2.next.i !== b4.i && a2.prev.i !== b4.i && !intersectsPolygon(a2, b4) && // dones't intersect other edges
    (locallyInside(a2, b4) && locallyInside(b4, a2) && middleInside(a2, b4) && // locally visible
    (area(a2.prev, a2, b4.prev) != 0 || area(a2, b4.prev, b4)) != 0 || // does not create opposite-facing sectors
    equals2(a2, b4) && area(a2.prev, a2, a2.next) > 0 && area(b4.prev, b4, b4.next) > 0);
  };
  const area = (p, q, r) => {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
  };
  const equals2 = (p1, p2) => {
    return p1.x === p2.x && p1.y === p2.y;
  };
  const intersects = (p1, q1, p2, q2) => {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4)
      return true;
    if (o1 === 0 && onSegment(p1, p2, q1))
      return true;
    if (o2 === 0 && onSegment(p1, q2, q1))
      return true;
    if (o3 === 0 && onSegment(p2, p1, q2))
      return true;
    if (o4 === 0 && onSegment(p2, q1, q2))
      return true;
    return false;
  };
  const onSegment = (p, q, r) => {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
  };
  const sign = (num) => {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
  };
  const intersectsPolygon = (a2, b4) => {
    let p = a2;
    do {
      if (p.i !== a2.i && p.next.i !== a2.i && p.i !== b4.i && p.next.i !== b4.i && intersects(p, p.next, a2, b4)) {
        return true;
      }
      p = p.next;
    } while (p !== a2);
    return false;
  };
  const locallyInside = (a2, b4) => {
    return area(a2.prev, a2, a2.next) < 0 ? area(a2, b4, a2.next) >= 0 && area(a2, a2.prev, b4) >= 0 : area(a2, b4, a2.prev) < 0 || area(a2, a2.next, b4) < 0;
  };
  const middleInside = (a2, b4) => {
    let p = a2;
    let inside = false;
    const px = (a2.x + b4.x) / 2;
    const py = (a2.y + b4.y) / 2;
    do {
      if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
        inside = !inside;
      p = p.next;
    } while (p !== a2);
    return inside;
  };
  const splitPolygon = (a2, b4) => {
    const a22 = new Node(a2.i, a2.x, a2.y);
    const b22 = new Node(b4.i, b4.x, b4.y);
    const an = a2.next;
    const bp = b4.prev;
    a2.next = b4;
    b4.prev = a2;
    a22.next = an;
    an.prev = a22;
    b22.next = a22;
    a22.prev = b22;
    bp.next = b22;
    b22.prev = bp;
    return b22;
  };
  const insertNode = (i, x, y, last) => {
    var p = new Node(i, x, y);
    if (!last) {
      p.prev = p;
      p.next = p;
    } else {
      p.next = last.next;
      p.prev = last;
      last.next.prev = p;
      last.next = p;
    }
    return p;
  };
  const removeNode = (p) => {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ)
      p.prevZ.nextZ = p.nextZ;
    if (p.nextZ)
      p.nextZ.prevZ = p.prevZ;
  };
  const signedArea = (data, start, end, dim) => {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
      sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
      j = i;
    }
    return sum;
  };
  return earcut2;
})();

// ../sdk/src/cityjson/versions/v1_0/parse.ts
var tempVec2a = createVec2();
var tempVec3a3 = createVec3();
var tempVec3b3 = createVec3();
var tempVec3c3 = createVec3();
var parse3 = async (params2, options = { rotateX: false }) => {
  return new Promise((resolve2, reject) => {
    const { fileData, sceneModel, dataModel } = params2;
    if (sceneModel || dataModel) {
      const ctx = {
        fileData,
        vertices: fileData.transform && sceneModel ? transformVertices(fileData.vertices, fileData.transform, options.rotateX) : fileData.vertices,
        sceneModel,
        dataModel,
        nextId: 0
      };
      parseCityJSON(ctx);
    }
    resolve2();
  });
};
function transformVertices(vertices, transform, rotateX2) {
  const transformedVertices = [];
  const scale3 = transform.scale || createVec3([1, 1, 1]);
  const translate3 = transform.translate || createVec3([0, 0, 0]);
  for (let i = 0, j = 0; i < vertices.length; i++, j += 3) {
    const x = vertices[i][0] * scale3[0] + translate3[0];
    const y = vertices[i][1] * scale3[1] + translate3[1];
    const z = vertices[i][2] * scale3[2] + translate3[2];
    if (rotateX2) {
      transformedVertices.push([x, z, y]);
    } else {
      transformedVertices.push([x, y, z]);
    }
  }
  return transformedVertices;
}
function parseCityJSON(ctx) {
  const fileData = ctx.fileData;
  const cityObjects = fileData.CityObjects;
  for (const objectId in cityObjects) {
    parseCityObject(ctx, cityObjects[objectId], objectId);
  }
  if (ctx.dataModel) {
    for (const objectId in cityObjects) {
      parseRelationship(ctx, cityObjects[objectId], objectId);
    }
  }
}
function parseCityObject(ctx, cityObject, objectId) {
  if (ctx.dataModel) {
    ctx.dataModel.createObject({
      id: objectId,
      name: cityObject.type + " : " + objectId,
      type: typeCodes2[cityObject.type] | 0,
      parent: cityObject.parents ? cityObject.parents[0] : null
    });
  }
  if (ctx.sceneModel) {
    if (!(cityObject.geometry && cityObject.geometry.length > 0)) {
      return;
    }
    const meshIds = [];
    for (let i = 0, len = cityObject.geometry.length; i < len; i++) {
      const geometry = cityObject.geometry[i];
      let objectMaterial;
      let surfaceMaterials;
      const appearance = ctx.fileData.appearance;
      if (appearance) {
        const materials = appearance.materials;
        if (materials) {
          const geometryMaterial = geometry.material;
          if (geometryMaterial) {
            const themeIds = Object.keys(geometryMaterial);
            if (themeIds.length > 0) {
              const themeId = themeIds[0];
              const theme = geometryMaterial[themeId];
              if (theme.value !== void 0) {
                objectMaterial = materials[theme.value];
              } else {
                const values = theme.values;
                if (values) {
                  surfaceMaterials = [];
                  for (let j = 0, lenj = values.length; j < lenj; j++) {
                    const value = values[i];
                    const surfaceMaterial = materials[value];
                    surfaceMaterials.push(surfaceMaterial);
                  }
                }
              }
            }
          }
        }
      }
      if (surfaceMaterials) {
        parseGeometrySurfacesWithOwnMaterials(ctx, geometry, surfaceMaterials, meshIds);
      } else {
        parseGeometrySurfacesWithSharedMaterial(ctx, geometry, objectMaterial, meshIds);
      }
    }
    if (meshIds.length > 0) {
      ctx.sceneModel.createObject({
        id: objectId,
        meshIds
      });
    }
  }
}
function parseRelationship(ctx, cityObject, objectId) {
  if (cityObject.parents) {
    ctx.dataModel.createRelationship({
      relatingObjectId: cityObject.parents[0],
      relatedObjectId: objectId,
      type: BasicAggregation
    });
  }
}
function parseGeometrySurfacesWithOwnMaterials(ctx, geometry, surfaceMaterials, meshIds) {
  const geomType = geometry.type;
  switch (geomType) {
    case "MultiPoint":
      break;
    case "MultiLineString":
      break;
    case "MultiSurface":
    case "CompositeSurface":
      const surfaces = geometry.boundaries;
      parseSurfacesWithOwnMaterials(ctx, surfaceMaterials, surfaces, meshIds);
      break;
    case "Solid":
      const shells = geometry.boundaries;
      for (let j = 0; j < shells.length; j++) {
        const surfaces2 = shells[j];
        parseSurfacesWithOwnMaterials(ctx, surfaceMaterials, surfaces2, meshIds);
      }
      break;
    case "MultiSolid":
    case "CompositeSolid":
      const solids = geometry.boundaries;
      for (let j = 0; j < solids.length; j++) {
        for (let k = 0; k < solids[j].length; k++) {
          const surfaces2 = solids[j][k];
          parseSurfacesWithOwnMaterials(ctx, surfaceMaterials, surfaces2, meshIds);
        }
      }
      break;
    case "GeometryInstance":
      break;
  }
}
function parseSurfacesWithOwnMaterials(ctx, surfaceMaterials, surfaces, meshIds) {
  const vertices = ctx.vertices;
  const sceneModel = ctx.sceneModel;
  for (let i = 0; i < surfaces.length; i++) {
    const surface = surfaces[i];
    const surfaceMaterial = surfaceMaterials[i] || { diffuseColor: [0.8, 0.8, 0.8], transparency: 1 };
    const face = [];
    const holes = [];
    const sharedIndices = [];
    const geometryCfg = {
      positions: [],
      indices: []
    };
    for (let j = 0; j < surface.length; j++) {
      if (face.length > 0) {
        holes.push(face.length);
      }
      const newFace = extractLocalIndices(ctx, surface[j], sharedIndices, geometryCfg);
      face.push(...newFace);
    }
    if (face.length === 3) {
      geometryCfg.indices.push(face[0]);
      geometryCfg.indices.push(face[1]);
      geometryCfg.indices.push(face[2]);
    } else if (face.length > 3) {
      const pList = [];
      for (let k = 0; k < face.length; k++) {
        pList.push({
          x: vertices[sharedIndices[face[k]]][0],
          y: vertices[sharedIndices[face[k]]][1],
          z: vertices[sharedIndices[face[k]]][2]
        });
      }
      const normal2 = getNormalOfPositions(pList, createVec3());
      let pv = [];
      for (let k = 0; k < pList.length; k++) {
        to2D(pList[k], normal2, tempVec2a);
        pv.unshift(tempVec2a[0]);
        pv.unshift(tempVec2a[1]);
      }
      const tr = earcut(pv, holes, 2);
      for (let k = 0; k < tr.length; k += 3) {
        geometryCfg.indices.unshift(face[tr[k]]);
        geometryCfg.indices.unshift(face[tr[k + 1]]);
        geometryCfg.indices.unshift(face[tr[k + 2]]);
      }
    }
    const geometryId = "" + ctx.nextId++;
    sceneModel.createGeometry({
      id: geometryId,
      primitive: TrianglesPrimitive,
      positions: geometryCfg.positions,
      indices: geometryCfg.indices
    });
    const meshId = "" + ctx.nextId++;
    sceneModel.createMesh({
      id: meshId,
      geometryId,
      color: surfaceMaterial && surfaceMaterial.diffuseColor ? surfaceMaterial.diffuseColor : [0.8, 0.8, 0.8],
      opacity: surfaceMaterial && surfaceMaterial.transparency !== void 0 ? 1 - surfaceMaterial.transparency : 1
    });
    meshIds.push(meshId);
  }
}
function parseGeometrySurfacesWithSharedMaterial(ctx, geometry, objectMaterial, meshIds) {
  const sceneModel = ctx.sceneModel;
  const sharedIndices = [];
  const geometryCfg = {
    positions: [],
    indices: []
  };
  const geomType = geometry.type;
  switch (geomType) {
    case "MultiPoint":
      break;
    case "MultiLineString":
      break;
    case "MultiSurface":
    case "CompositeSurface":
      const surfaces = geometry.boundaries;
      parseSurfacesWithSharedMaterial(ctx, surfaces, sharedIndices, geometryCfg);
      break;
    case "Solid":
      const shells = geometry.boundaries;
      for (let j = 0; j < shells.length; j++) {
        const surfaces2 = shells[j];
        parseSurfacesWithSharedMaterial(ctx, surfaces2, sharedIndices, geometryCfg);
      }
      break;
    case "MultiSolid":
    case "CompositeSolid":
      const solids = geometry.boundaries;
      for (let j = 0; j < solids.length; j++) {
        for (let k = 0; k < solids[j].length; k++) {
          const surfaces2 = solids[j][k];
          parseSurfacesWithSharedMaterial(ctx, surfaces2, sharedIndices, geometryCfg);
        }
      }
      break;
    case "GeometryInstance":
      break;
  }
  if (geometryCfg.positions.length > 0 && geometryCfg.indices.length > 0) {
    const geometryId = "" + ctx.nextId++;
    sceneModel.createGeometry({
      id: geometryId,
      primitive: TrianglesPrimitive,
      positions: geometryCfg.positions,
      indices: geometryCfg.indices
    });
    const meshId = "" + ctx.nextId++;
    sceneModel.createMesh({
      id: meshId,
      geometryId,
      color: objectMaterial && objectMaterial.diffuseColor ? objectMaterial.diffuseColor : [0.8, 0.8, 0.8],
      opacity: 1
    });
    meshIds.push(meshId);
  }
}
function parseSurfacesWithSharedMaterial(ctx, surfaces, sharedIndices, primitiveCfg) {
  const vertices = ctx.vertices;
  for (let i = 0; i < surfaces.length; i++) {
    let boundary = [];
    let holes = [];
    for (let j = 0; j < surfaces[i].length; j++) {
      if (boundary.length > 0) {
        holes.push(boundary.length);
      }
      const newBoundary = extractLocalIndices(ctx, surfaces[i][j], sharedIndices, primitiveCfg);
      boundary.push(...newBoundary);
    }
    if (boundary.length === 3) {
      primitiveCfg.indices.push(boundary[0]);
      primitiveCfg.indices.push(boundary[1]);
      primitiveCfg.indices.push(boundary[2]);
    } else if (boundary.length > 3) {
      let pList = [];
      for (let k = 0; k < boundary.length; k++) {
        pList.push({
          x: vertices[sharedIndices[boundary[k]]][0],
          y: vertices[sharedIndices[boundary[k]]][1],
          z: vertices[sharedIndices[boundary[k]]][2]
        });
      }
      const normal2 = getNormalOfPositions(pList, createVec3());
      let pv = [];
      for (let k = 0; k < pList.length; k++) {
        to2D(pList[k], normal2, tempVec2a);
        pv.unshift(tempVec2a[0]);
        pv.unshift(tempVec2a[1]);
      }
      const tr = earcut(pv, holes, 2);
      for (let k = 0; k < tr.length; k += 3) {
        primitiveCfg.indices.unshift(boundary[tr[k]]);
        primitiveCfg.indices.unshift(boundary[tr[k + 1]]);
        primitiveCfg.indices.unshift(boundary[tr[k + 2]]);
      }
    }
  }
}
function extractLocalIndices(ctx, boundary, sharedIndices, geometryCfg) {
  const vertices = ctx.vertices;
  const newBoundary = [];
  for (let i = 0, len = boundary.length; i < len; i++) {
    const index = boundary[i];
    if (sharedIndices.includes(index)) {
      const vertexIndex = sharedIndices.indexOf(index);
      newBoundary.push(vertexIndex);
    } else {
      geometryCfg.positions.push(vertices[index][0]);
      geometryCfg.positions.push(vertices[index][1]);
      geometryCfg.positions.push(vertices[index][2]);
      newBoundary.push(sharedIndices.length);
      sharedIndices.push(index);
    }
  }
  return newBoundary;
}
function getNormalOfPositions(positions, normal2) {
  for (let i = 0; i < positions.length; i++) {
    let nexti = i + 1;
    if (nexti === positions.length) {
      nexti = 0;
    }
    normal2[0] += (positions[i].y - positions[nexti].y) * (positions[i].z + positions[nexti].z);
    normal2[1] += (positions[i].z - positions[nexti].z) * (positions[i].x + positions[nexti].x);
    normal2[2] += (positions[i].x - positions[nexti].x) * (positions[i].y + positions[nexti].y);
  }
  return normalizeVec3(normal2);
}
function to2D(_p, _n, re) {
  const p = tempVec3a3;
  const n = tempVec3b3;
  const x3 = tempVec3c3;
  p[0] = _p.x;
  p[1] = _p.y;
  p[2] = _p.z;
  n[0] = _n.x;
  n[1] = _n.y;
  n[2] = _n.z;
  x3[0] = 1.1;
  x3[1] = 1.1;
  x3[2] = 1.1;
  const dist = lenVec3(subVec3(x3, n));
  if (dist < 0.01) {
    x3[0] += 1;
    x3[1] += 2;
    x3[2] += 3;
  }
  const dot3 = dotVec3(x3, n);
  const tmp2 = mulVec3Scalar(n, dot3, createVec3());
  x3[0] -= tmp2[0];
  x3[1] -= tmp2[1];
  x3[2] -= tmp2[2];
  normalizeVec3(x3);
  const y3 = cross3Vec3(n, x3, createVec3());
  const x = dotVec3(p, x3);
  const y = dotVec3(p, y3);
  re[0] = x;
  re[1] = y;
}

// ../sdk/src/cityjson/CityJSONLoader.ts
var CityJSONLoader = class extends ModelLoader {
  /**
   * Constructs a CityJSONLoader.
   */
  constructor() {
    super({
      fileDataType: "json",
      parsers: {
        "1.0": parse3
      },
      getVersion: (fileData) => {
        return fileData.version || "1.0";
      }
    });
  }
};

// ../sdk/src/dotbim/index.ts
var dotbim_exports = {};
__export(dotbim_exports, {
  DotBIMExporter: () => DotBIMExporter,
  DotBIMLoader: () => DotBIMLoader
});

// ../sdk/src/dotbim/versions/1_0_0/parse.ts
var parse4 = async (params2, options = {
  translate: void 0
}) => {
  return new Promise((resolve2, reject) => {
    const fileData = params2.fileData;
    if (params2.sceneModel) {
      const meshes = fileData.meshes;
      for (let i = 0, len = meshes.length; i < len; i++) {
        const mesh = meshes[i];
        const geometry = params2.sceneModel.createGeometry({
          id: mesh.mesh_id,
          primitive: TrianglesPrimitive,
          positions: mesh.coordinates,
          indices: mesh.indices
        });
        if (geometry instanceof SDKError) {
        }
      }
    }
    const elements = fileData.elements;
    for (let i = 0, len = elements.length; i < len; i++) {
      const element = elements[i];
      const info = element.info;
      const objectId = element.guid !== void 0 ? `${element.guid}` : info !== void 0 && info.id !== void 0 ? info.id : i;
      if (params2.sceneModel) {
        const geometryId = element.mesh_id;
        const meshId = `${objectId}-mesh`;
        const vector = element.vector;
        const rotation = element.rotation;
        const color2 = element.color;
        const mesh = params2.sceneModel.createMesh({
          id: meshId,
          geometryId,
          color: color2 ? [color2.r, color2.g, color2.b] : void 0,
          opacity: color2 ? color2.a : 1,
          quaternion: rotation ? [rotation.qx, rotation.qy, rotation.qz, rotation.qw] : void 0,
          position: vector ? options.translate ? [vector.x + options.translate[0], vector.y + options.translate[1], vector.z + options.translate[2]] : [vector.x, vector.y, vector.z] : options.translate ? options.translate : void 0
        });
        if (mesh instanceof SDKError) {
          continue;
        }
        const sceneObject = params2.sceneModel.createObject({
          id: objectId,
          meshIds: [meshId]
        });
        if (sceneObject instanceof SDKError) {
          continue;
        }
      }
      if (params2.dataModel) {
        if (!params2.dataModel.objects[element.guid]) {
          const dataObject = params2.dataModel.createObject({
            id: objectId,
            type: ifcTypeCodes[element.type],
            name: info.Name,
            description: info.Description
          });
          if (dataObject instanceof SDKError) {
          }
        }
      }
    }
    resolve2();
  });
};

// ../sdk/src/dotbim/versions/1_1_0/parse.ts
var parse5 = async (params2, options = {
  translate: void 0
}) => {
  return new Promise((resolve2, reject) => {
    const fileData = params2.fileData;
    if (params2.sceneModel) {
      const meshes = fileData.meshes;
      for (let i = 0, len = meshes.length; i < len; i++) {
        const mesh = meshes[i];
        const geometry = params2.sceneModel.createGeometry({
          id: mesh.mesh_id,
          primitive: TrianglesPrimitive,
          positions: mesh.coordinates,
          indices: mesh.indices
        });
        if (geometry instanceof SDKError) {
        }
      }
    }
    const elements = fileData.elements;
    for (let i = 0, len = elements.length; i < len; i++) {
      const element = elements[i];
      const info = element.info;
      const objectId = element.guid !== void 0 ? `${element.guid}` : info !== void 0 && info.id !== void 0 ? info.id : i;
      if (params2.sceneModel) {
        const geometryId = element.mesh_id;
        const meshId = `${objectId}-mesh`;
        const vector = element.vector;
        const rotation = element.rotation;
        const color2 = element.color;
        const mesh = params2.sceneModel.createMesh({
          id: meshId,
          geometryId,
          color: color2 ? [color2.r, color2.g, color2.b] : void 0,
          opacity: color2 ? color2.a : 1,
          quaternion: rotation ? [rotation.qx, rotation.qy, rotation.qz, rotation.qw] : void 0,
          position: vector ? options.translate ? [vector.x + options.translate[0], vector.y + options.translate[1], vector.z + options.translate[2]] : [vector.x, vector.y, vector.z] : options.translate ? options.translate : void 0
        });
        if (mesh instanceof SDKError) {
          continue;
        }
        const sceneObject = params2.sceneModel.createObject({
          id: objectId,
          meshIds: [meshId]
        });
        if (sceneObject instanceof SDKError) {
          continue;
        }
      }
      if (params2.dataModel) {
        if (!params2.dataModel.objects[element.guid]) {
          const dataObject = params2.dataModel.createObject({
            id: objectId,
            type: ifcTypeCodes[element.type],
            name: info.Name,
            description: info.Description
          });
          if (dataObject instanceof SDKError) {
          }
        }
      }
    }
    resolve2();
  });
};

// ../sdk/src/dotbim/DotBIMLoader.ts
var DotBIMLoader = class extends ModelLoader {
  constructor() {
    super({
      fileDataType: "json",
      parsers: {
        "1.0.0": parse4,
        "1.1.0": parse5
      },
      getVersion: (sourceFileData) => {
        return sourceFileData.schema_version || "1.0.0";
      }
    });
  }
};

// ../sdk/src/dotbim/versions/1_1_0/encode.ts
var tempVec3a4 = createVec3();
var tempVec3b4 = createVec3();
function encode3(params2, options) {
  return new Promise(function(resolve2, reject) {
    const { sceneModel, dataModel } = params2;
    const dotBim = {
      meshes: [],
      elements: []
    };
    const geometries = Object.values(sceneModel.geometries);
    const meshLookup = {};
    for (let i = 0, len = geometries.length; i < len; i++) {
      const geometry = geometries[i];
      const aabb = geometry.aabb;
      const coordinates = [];
      const positionsCompressed = geometry.positionsCompressed;
      for (let k = 0, lenk = positionsCompressed.length; k < lenk; k += 3) {
        tempVec3a4[0] = positionsCompressed[k];
        tempVec3a4[1] = positionsCompressed[k + 1];
        tempVec3a4[2] = positionsCompressed[k + 2];
        decompressPoint3WithAABB3(tempVec3a4, aabb, tempVec3b4);
        coordinates.push(tempVec3b4[0]);
        coordinates.push(tempVec3b4[1]);
        coordinates.push(tempVec3b4[2]);
      }
      meshLookup[geometry.id] = {
        mesh_id: geometry.id,
        coordinates,
        indices: geometry.indices ? Array.from(geometry.indices) : []
      };
    }
    const sceneObjects = Object.values(sceneModel.objects);
    for (let i = 0, len = sceneObjects.length; i < len; i++) {
      const sceneObject = sceneObjects[i];
      const meshes = sceneObject.meshes;
      let meshId;
      let dbMesh;
      if (meshes.length === 1) {
        const mesh = meshes[0];
        const geometry = mesh.geometry;
        dbMesh = meshLookup[geometry.id];
        dotBim.meshes.push(dbMesh);
        meshId = geometry.id;
      } else {
        dbMesh = {
          mesh_id: sceneObject.id,
          coordinates: [],
          indices: []
        };
        let indicesOffset = 0;
        for (let j = 0, lenj = meshes.length; j < lenj; j++) {
          const sceneMesh = meshes[j];
          const geometry = sceneMesh.geometry;
          const lookupGeometry = meshLookup[geometry.id];
          const coordinates = lookupGeometry.coordinates;
          for (let k = 0, lenk = coordinates.length; k < lenk; k++) {
            dbMesh.coordinates.push(coordinates[k]);
          }
          const indices = lookupGeometry.indices;
          for (let k = 0, lenk = indices.length; k < lenk; k++) {
            dbMesh.indices.push(indices[k] + indicesOffset);
          }
          indicesOffset += coordinates.length / 3;
        }
        dotBim.meshes.push(dbMesh);
        meshId = sceneObject.id;
      }
      const firstMesh = meshes[0];
      const color2 = firstMesh.color;
      const position = createVec3();
      const quaternion = createVec4();
      const scale3 = createVec3();
      decomposeMat4(firstMesh.matrix, position, quaternion, scale3);
      const info = {
        id: sceneObject.id,
        Tag: "None"
      };
      let dataObject;
      if (dataModel) {
        dataObject = dataModel.objects[sceneObject.id];
        if (dataObject) {
          info.type = ifcTypeNames[dataObject.type];
          info.Name = dataObject.name;
          info.Description = dataObject.description;
        }
      }
      if (!dataObject) {
        info.type = "None";
        info.Name = "None";
        info.Description = "None";
      }
      dotBim.elements.push({
        info,
        mesh_id: dbMesh.mesh_id,
        type: info.type,
        color: {
          r: color2[0],
          g: color2[1],
          b: color2[2],
          a: firstMesh.opacity
        },
        vector: {
          x: position[0],
          y: position[1],
          z: position[2]
        },
        rotation: {
          qx: quaternion[0],
          qy: quaternion[0],
          qz: quaternion[0],
          qw: quaternion[0]
        },
        qy: quaternion[1],
        qz: quaternion[2],
        qw: quaternion[3]
      });
    }
    return resolve2(dotBim);
  });
}

// ../sdk/src/dotbim/versions/1_0_0/encode.ts
var tempVec3a5 = createVec3();
var tempVec3b5 = createVec3();
function encode4(params2, options) {
  return new Promise(function(resolve2, reject) {
    const { sceneModel, dataModel } = params2;
    const dotBim = {
      meshes: [],
      elements: []
    };
    const geometries = Object.values(sceneModel.geometries);
    const meshLookup = {};
    for (let i = 0, len = geometries.length; i < len; i++) {
      const geometry = geometries[i];
      const aabb = geometry.aabb;
      const coordinates = [];
      const positionsCompressed = geometry.positionsCompressed;
      for (let k = 0, lenk = positionsCompressed.length; k < lenk; k += 3) {
        tempVec3a5[0] = positionsCompressed[k];
        tempVec3a5[1] = positionsCompressed[k + 1];
        tempVec3a5[2] = positionsCompressed[k + 2];
        decompressPoint3WithAABB3(tempVec3a5, aabb, tempVec3b5);
        coordinates.push(tempVec3b5[0]);
        coordinates.push(tempVec3b5[1]);
        coordinates.push(tempVec3b5[2]);
      }
      meshLookup[geometry.id] = {
        mesh_id: geometry.id,
        coordinates,
        indices: geometry.indices ? Array.from(geometry.indices) : []
      };
    }
    const sceneObjects = Object.values(sceneModel.objects);
    for (let i = 0, len = sceneObjects.length; i < len; i++) {
      const sceneObject = sceneObjects[i];
      const meshes = sceneObject.meshes;
      let meshId;
      let dbMesh;
      if (meshes.length === 1) {
        const mesh = meshes[0];
        const geometry = mesh.geometry;
        dbMesh = meshLookup[geometry.id];
        dotBim.meshes.push(dbMesh);
        meshId = geometry.id;
      } else {
        dbMesh = {
          mesh_id: sceneObject.id,
          coordinates: [],
          indices: []
        };
        let indicesOffset = 0;
        for (let j = 0, lenj = meshes.length; j < lenj; j++) {
          const sceneMesh = meshes[j];
          const geometry = sceneMesh.geometry;
          const lookupGeometry = meshLookup[geometry.id];
          const coordinates = lookupGeometry.coordinates;
          for (let k = 0, lenk = coordinates.length; k < lenk; k++) {
            dbMesh.coordinates.push(coordinates[k]);
          }
          const indices = lookupGeometry.indices;
          for (let k = 0, lenk = indices.length; k < lenk; k++) {
            dbMesh.indices.push(indices[k] + indicesOffset);
          }
          indicesOffset += coordinates.length / 3;
        }
        dotBim.meshes.push(dbMesh);
        meshId = sceneObject.id;
      }
      const firstMesh = meshes[0];
      const color2 = firstMesh.color;
      const position = createVec3();
      const quaternion = createVec4();
      const scale3 = createVec3();
      decomposeMat4(firstMesh.matrix, position, quaternion, scale3);
      const info = {
        id: sceneObject.id,
        Tag: "None"
      };
      let dataObject;
      if (dataModel) {
        dataObject = dataModel.objects[sceneObject.id];
        if (dataObject) {
          info.type = ifcTypeNames[dataObject.type];
          info.Name = dataObject.name;
          info.Description = dataObject.description;
        }
      }
      if (!dataObject) {
        info.type = "None";
        info.Name = "None";
        info.Description = "None";
      }
      dotBim.elements.push({
        info,
        mesh_id: dbMesh.mesh_id,
        type: info.type,
        color: {
          r: color2[0],
          g: color2[1],
          b: color2[2],
          a: firstMesh.opacity
        },
        vector: {
          x: position[0],
          y: position[1],
          z: position[2]
        },
        rotation: {
          qx: quaternion[0],
          qy: quaternion[0],
          qz: quaternion[0],
          qw: quaternion[0]
        },
        qy: quaternion[1],
        qz: quaternion[2],
        qw: quaternion[3]
      });
    }
    return resolve2(dotBim);
  });
}

// ../sdk/src/dotbim/DotBIMExporter.ts
var DotBIMExporter = class extends ModelExporter {
  constructor() {
    super({
      fileDataType: "json",
      encoders: {
        "1.0.0": encode4,
        "1.1.0": encode3
      },
      defaultVersion: "1.1.0"
    });
  }
};

// ../sdk/src/xgf/index.ts
var xgf_exports = {};
__export(xgf_exports, {
  XGFExporter: () => XGFExporter,
  XGFLoader: () => XGFLoader
});

// ../sdk/src/xgf/versions/v1/unpackXGF.ts
function unpackXGF(arrayBuffer) {
  const requiresSwapFromLittleEndian = function() {
    const buffer = new ArrayBuffer(2);
    new Uint16Array(buffer)[0] = 1;
    return new Uint8Array(buffer)[0] !== 1;
  }();
  const nextArray = function() {
    let i = 0;
    const dataView = new DataView(arrayBuffer);
    return function(type) {
      const idx = 1 + 2 * i++;
      const byteOffset = dataView.getUint32(idx * 4, true);
      const byteLength = dataView.getUint32((idx + 1) * 4, true);
      const BPE = type.BYTES_PER_ELEMENT;
      if (requiresSwapFromLittleEndian && BPE > 1) {
        const subarray = new Uint8Array(arrayBuffer, byteOffset, byteLength);
        const swaps = BPE / 2;
        const cnt = subarray.length / BPE;
        for (let b4 = 0; b4 < cnt; b4++) {
          const offset = b4 * BPE;
          for (let j = 0; j < swaps; j++) {
            const i1 = offset + j;
            const i2 = offset - j + BPE - 1;
            const tmp = subarray[i1];
            subarray[i1] = subarray[i2];
            subarray[i2] = tmp;
          }
        }
      }
      return new type(arrayBuffer, byteOffset, byteLength / BPE);
    };
  }();
  const nextObject = function() {
    const decoder = new TextDecoder();
    return () => JSON.parse(decoder.decode(nextArray(Uint8Array)));
  }();
  return {
    positions: nextArray(Uint16Array),
    colors: nextArray(Uint8Array),
    indices: nextArray(Uint32Array),
    edgeIndices: nextArray(Uint32Array),
    aabbs: nextArray(Float32Array),
    eachGeometryPositionsBase: nextArray(Uint32Array),
    eachGeometryColorsBase: nextArray(Uint32Array),
    eachGeometryIndicesBase: nextArray(Uint32Array),
    eachGeometryEdgeIndicesBase: nextArray(Uint32Array),
    eachGeometryPrimitiveType: nextArray(Uint8Array),
    eachGeometryAABBBase: nextArray(Uint32Array),
    matrices: nextArray(Float64Array),
    eachMeshGeometriesBase: nextArray(Uint32Array),
    eachMeshMatricesBase: nextArray(Uint32Array),
    eachMeshMaterialAttributes: nextArray(Uint8Array),
    eachObjectId: nextObject(),
    eachObjectMeshesBase: nextArray(Uint32Array)
  };
}

// ../sdk/src/xgf/versions/v1/xgfToModel.ts
function xgfToModel(params2) {
  const { xgfData, sceneModel, dataModel } = params2;
  const defaultId = sceneModel ? sceneModel.id : createUUID2();
  if (dataModel) {
    dataModel.createObject({
      id: defaultId,
      name: defaultId,
      type: BasicEntity
    });
  }
  const numGeometries = xgfData.eachGeometryPositionsBase.length;
  const numMeshes = xgfData.eachMeshGeometriesBase.length;
  const numObjects = xgfData.eachObjectMeshesBase.length;
  let nextMeshId = 0;
  const geometryCreated = {};
  for (let objectIdx = 0; objectIdx < numObjects; objectIdx++) {
    const objectId = xgfData.eachObjectId[objectIdx];
    const lastObjectIdx = numObjects - 1;
    const atLastObject = objectIdx === lastObjectIdx;
    const firstMeshIdx = xgfData.eachObjectMeshesBase[objectIdx];
    const lastMeshIdx = atLastObject ? numMeshes - 1 : xgfData.eachObjectMeshesBase[objectIdx + 1] - 1;
    const meshIds = [];
    for (let meshIdx = firstMeshIdx; meshIdx <= lastMeshIdx; meshIdx++) {
      const meshId = `${nextMeshId++}`;
      if (sceneModel) {
        const geometryIdx = xgfData.eachMeshGeometriesBase[meshIdx];
        const color2 = decompressColor(xgfData.eachMeshMaterialAttributes.subarray(meshIdx * 4, meshIdx * 4 + 3));
        const opacity = xgfData.eachMeshMaterialAttributes[meshIdx * 4 + 3] / 255;
        const matricesBase = xgfData.eachMeshMatricesBase[meshIdx];
        const matrix = xgfData.matrices.subarray(matricesBase, matricesBase + 16);
        const geometryId = `${geometryIdx}`;
        if (!geometryCreated[geometryId]) {
          const geometryCompressedParams = {
            id: geometryId
          };
          const primitiveType = xgfData.eachGeometryPrimitiveType[geometryIdx];
          switch (primitiveType) {
            case 0:
              geometryCompressedParams.primitive = TrianglesPrimitive;
              break;
            case 1:
              geometryCompressedParams.primitive = SolidPrimitive;
              break;
            case 2:
              geometryCompressedParams.primitive = SurfacePrimitive;
              break;
            case 3:
              geometryCompressedParams.primitive = LinesPrimitive;
              break;
            case 5:
              geometryCompressedParams.primitive = PointsPrimitive;
              break;
          }
          const aabbsBase = xgfData.eachGeometryAABBBase[geometryIdx];
          geometryCompressedParams.aabb = xgfData.aabbs.subarray(aabbsBase, aabbsBase + 6);
          let geometryValid = false;
          const atLastGeometry = geometryIdx === numGeometries - 1;
          switch (geometryCompressedParams.primitive) {
            case TrianglesPrimitive:
            case SurfacePrimitive:
            case SolidPrimitive:
              geometryCompressedParams.positionsCompressed = xgfData.positions.subarray(xgfData.eachGeometryPositionsBase[geometryIdx], atLastGeometry ? xgfData.positions.length : xgfData.eachGeometryPositionsBase[geometryIdx + 1]);
              geometryCompressedParams.indices = xgfData.indices.subarray(xgfData.eachGeometryIndicesBase[geometryIdx], atLastGeometry ? xgfData.indices.length : xgfData.eachGeometryIndicesBase[geometryIdx + 1]);
              geometryCompressedParams.edgeIndices = xgfData.edgeIndices.subarray(xgfData.eachGeometryEdgeIndicesBase[geometryIdx], atLastGeometry ? xgfData.edgeIndices.length : xgfData.eachGeometryEdgeIndicesBase[geometryIdx + 1]);
              geometryValid = geometryCompressedParams.positionsCompressed.length > 0 && geometryCompressedParams.indices.length > 0;
              break;
            case PointsPrimitive:
              geometryCompressedParams.positionsCompressed = xgfData.positions.subarray(xgfData.eachGeometryPositionsBase[geometryIdx], atLastGeometry ? xgfData.positions.length : xgfData.eachGeometryPositionsBase[geometryIdx + 1]);
              geometryValid = geometryCompressedParams.positionsCompressed.length > 0;
              break;
            case LinesPrimitive:
              geometryCompressedParams.positionsCompressed = xgfData.positions.subarray(xgfData.eachGeometryPositionsBase[geometryIdx], atLastGeometry ? xgfData.positions.length : xgfData.eachGeometryPositionsBase[geometryIdx + 1]);
              geometryCompressedParams.indices = xgfData.indices.subarray(xgfData.eachGeometryIndicesBase[geometryIdx], atLastGeometry ? xgfData.indices.length : xgfData.eachGeometryIndicesBase[geometryIdx + 1]);
              geometryValid = geometryCompressedParams.positionsCompressed.length > 0 && geometryCompressedParams.indices.length > 0;
              break;
            default:
              continue;
          }
          if (geometryValid) {
            sceneModel.createGeometryCompressed(geometryCompressedParams);
            geometryCreated[geometryId] = true;
          }
        }
        sceneModel.createMesh({
          id: meshId,
          geometryId,
          matrix,
          color: color2,
          opacity
        });
      }
      meshIds.push(meshId);
    }
    if (meshIds.length > 0) {
      if (sceneModel) {
        sceneModel.createObject({
          id: objectId,
          meshIds
        });
      }
      if (dataModel) {
        dataModel.createObject({
          id: objectId,
          name: objectId,
          type: BasicEntity
        });
        dataModel.createRelationship({
          type: BasicAggregation,
          relatingObjectId: defaultId,
          relatedObjectId: objectId
        });
      }
    }
  }
}
var decompressColor = function() {
  const floatColor = new Float32Array(3);
  return function(intColor) {
    floatColor[0] = intColor[0] / 255;
    floatColor[1] = intColor[1] / 255;
    floatColor[2] = intColor[2] / 255;
    return floatColor;
  };
}();

// ../sdk/src/xgf/versions/v1/parse.ts
function parse6(params2, options) {
  return new Promise(function(resolve2, reject) {
    const { fileData, sceneModel, dataModel } = params2;
    xgfToModel({
      xgfData: unpackXGF(fileData),
      sceneModel,
      dataModel
    });
    resolve2();
  });
}

// ../sdk/src/xgf/XGFLoader.ts
var XGFLoader = class extends ModelLoader {
  constructor() {
    super({
      fileDataType: "arraybuffer",
      parsers: {
        "1": parse6
      },
      getVersion: (fileData) => {
        return "" + new DataView(fileData).getUint32(0, true);
      }
    });
  }
};

// ../sdk/src/xgf/versions/v1/modelToXGF.ts
var NUM_MATERIAL_ATTRIBUTES = 4;
function modelToXGF(params2) {
  const sceneModel = params2.sceneModel;
  const geometriesList = Object.values(sceneModel.geometries);
  const meshesList = Object.values(sceneModel.meshes);
  const objectsList = Object.values(sceneModel.objects);
  const numGeometries = geometriesList.length;
  const numMeshes = meshesList.length;
  const numObjects = objectsList.length;
  let identityMatrixAdded = false;
  let identityMatrixBase = 0;
  let sizePositions = 0;
  let sizeColors = 0;
  let sizeIndices = 0;
  let sizeEdgeIndices = 0;
  const geometryIndices = {};
  for (let geometryIdx = 0; geometryIdx < numGeometries; geometryIdx++) {
    const geometry = geometriesList[geometryIdx];
    if (geometry) {
      if (geometry.positionsCompressed) {
        sizePositions += geometry.positionsCompressed.length;
        if (geometry.indices) {
          sizeIndices += geometry.indices.length;
        }
        if (geometry.edgeIndices) {
          sizeEdgeIndices += geometry.edgeIndices.length;
        }
        if (geometry.colorsCompressed) {
          sizeColors += geometry.colorsCompressed.length;
        }
      }
    }
  }
  const xgfData = {
    positions: new Uint16Array(sizePositions),
    colors: new Uint8Array(sizeColors),
    indices: new Uint32Array(sizeIndices),
    edgeIndices: new Uint32Array(sizeEdgeIndices),
    aabbs: null,
    eachGeometryPositionsBase: new Uint32Array(numGeometries),
    // For each geometry, an index to its first element in xgfData.positions. Every primitive type has positions.
    eachGeometryColorsBase: new Uint32Array(numGeometries),
    // For each geometry, an index to its first element in xgfData.colors. If the next geometry has the same index, then this geometry has no colors.
    eachGeometryIndicesBase: new Uint32Array(numGeometries),
    // For each geometry, an index to its first element in xgfData.indices. If the next geometry has the same index, then this geometry has no indices.
    eachGeometryEdgeIndicesBase: new Uint32Array(numGeometries),
    // For each geometry, an index to its first element in xgfData.edgeIndices. If the next geometry has the same index, then this geometry has no edge indices.
    eachGeometryPrimitiveType: new Uint8Array(numGeometries),
    // Primitive type for each geometry (0=solid triangles, 1=surface triangles, 2=lines, 3=points)
    eachGeometryAABBBase: new Uint32Array(numGeometries),
    // Positions dequantization matrices
    matrices: null,
    // Modeling matrices
    eachMeshGeometriesBase: new Uint32Array(numMeshes),
    // For each mesh, an index into the eachGeometry* arrays
    eachMeshMatricesBase: new Uint32Array(numMeshes),
    // For each mesh that shares its geometry, an index to its first element in xgfData.matrices, to indicate the modeling matrix that transforms the shared geometry Local-space vertex positions. This is ignored for meshes that don't share geometries, because the vertex positions of non-shared geometries are pre-transformed into World-space.
    eachMeshMaterialAttributes: new Uint8Array(numMeshes * NUM_MATERIAL_ATTRIBUTES),
    // For each mesh, an RGBA integer color of format [0..255, 0..255, 0..255, 0..255], and PBR metallic and roughness factors, of format [0..255, 0..255]
    eachObjectId: [],
    // For each object, an ID string
    eachObjectMeshesBase: new Uint32Array(numObjects)
    // For each object, the index of the first element of meshes used by the object
  };
  let positionsBase = 0;
  let colorsBase = 0;
  let indicesBase = 0;
  let edgeIndicesBase = 0;
  let aabbsBase = 0;
  const aabbIdxMap = {};
  const aabbs = [];
  const matrices = [];
  for (let geometryIdx = 0; geometryIdx < numGeometries; geometryIdx++) {
    const geometry = geometriesList[geometryIdx];
    let primitiveType;
    switch (geometry.primitive) {
      case TrianglesPrimitive:
        primitiveType = 0;
        break;
      case SolidPrimitive:
        primitiveType = 1;
        break;
      case SurfacePrimitive:
        primitiveType = 2;
        break;
      case LinesPrimitive:
        primitiveType = 3;
        break;
      case PointsPrimitive:
        primitiveType = 4;
        break;
    }
    xgfData.eachGeometryPrimitiveType[geometryIdx] = primitiveType;
    const aabb = geometry.aabb;
    const aabbHash = `${aabb[0]}-${aabb[1]}-${aabb[2]}-${aabb[3]}-${aabb[4]}-${aabb[5]}`;
    let aabbIdx = aabbIdxMap[aabbHash];
    if (aabbIdx === void 0) {
      aabbIdx = aabbsBase;
      aabbIdxMap[aabbHash] = aabbIdx;
      aabbs.push(...aabb);
      aabbsBase += 6;
    }
    xgfData.eachGeometryAABBBase[geometryIdx] = aabbIdx;
    xgfData.eachGeometryPositionsBase[geometryIdx] = positionsBase;
    xgfData.eachGeometryColorsBase[geometryIdx] = colorsBase;
    xgfData.positions.set(geometry.positionsCompressed, positionsBase);
    positionsBase += geometry.positionsCompressed.length;
    if (geometry.indices) {
      xgfData.indices.set(geometry.indices, indicesBase);
      xgfData.eachGeometryIndicesBase[geometryIdx] = indicesBase;
      indicesBase += geometry.indices.length;
    }
    if (geometry.edgeIndices) {
      xgfData.edgeIndices.set(geometry.edgeIndices, edgeIndicesBase);
      xgfData.eachGeometryEdgeIndicesBase[geometryIdx] = edgeIndicesBase;
      edgeIndicesBase += geometry.edgeIndices.length;
    }
    if (geometry.colorsCompressed) {
      xgfData.colors.set(geometry.colorsCompressed, colorsBase);
      xgfData.eachGeometryColorsBase[geometryIdx] = colorsBase;
      colorsBase += geometry.colorsCompressed.length;
    }
    geometryIndices[geometry.id] = geometryIdx;
  }
  let eachMeshMaterialAttributesBase = 0;
  let matricesBase = 0;
  let meshesBase = 0;
  for (let objectIdx = 0; objectIdx < numObjects; objectIdx++) {
    const object = objectsList[objectIdx];
    xgfData.eachObjectId[objectIdx] = object.id;
    xgfData.eachObjectMeshesBase[objectIdx] = meshesBase;
    for (let objectMeshIdx = 0; objectMeshIdx < object.meshes.length; objectMeshIdx++) {
      const mesh = object.meshes[objectMeshIdx];
      xgfData.eachMeshGeometriesBase[meshesBase] = geometryIndices[mesh.geometry.id];
      if (isIdentityMat4(mesh.matrix)) {
        if (!identityMatrixAdded) {
          matrices.push(...mesh.matrix);
          xgfData.eachMeshMatricesBase[meshesBase] = matricesBase;
          identityMatrixBase = matricesBase;
          matricesBase += 16;
          identityMatrixAdded = true;
        } else {
          xgfData.eachMeshMatricesBase[meshesBase] = identityMatrixBase;
        }
      } else {
        matrices.push(...mesh.matrix);
        xgfData.eachMeshMatricesBase[meshesBase] = matricesBase;
        matricesBase += 16;
      }
      xgfData.eachMeshMaterialAttributes[eachMeshMaterialAttributesBase++] = mesh.color[0] * 255;
      xgfData.eachMeshMaterialAttributes[eachMeshMaterialAttributesBase++] = mesh.color[1] * 255;
      xgfData.eachMeshMaterialAttributes[eachMeshMaterialAttributesBase++] = mesh.color[2] * 255;
      xgfData.eachMeshMaterialAttributes[eachMeshMaterialAttributesBase++] = mesh.opacity * 255;
      meshesBase++;
    }
  }
  xgfData.aabbs = new Float32Array(aabbs);
  xgfData.matrices = new Float64Array(matrices);
  return xgfData;
}

// ../sdk/src/xgf/versions/v1/XGF_INFO.ts
var XGF_INFO = {
  /**
   * The [XGF](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#xgf) version generated by {@link xgf!XKFWriter | XKFWriter}.
   *
   * @property xgfVersion
   * @type {number}
   */
  xgfVersion: 1
};

// ../sdk/src/xgf/versions/v1/packXGF.ts
var object2Array = function() {
  const encoder = new TextEncoder();
  return (obj) => encoder.encode(JSON.stringify(obj));
}();
function toArrayBuffer(arrays) {
  const arraysCnt = arrays.length;
  const dataView = new DataView(new ArrayBuffer((1 + 2 * arraysCnt) * 4));
  dataView.setUint32(0, XGF_INFO.xgfVersion, true);
  let byteOffset = dataView.byteLength;
  const offsets = [];
  for (let i = 0; i < arraysCnt; i++) {
    const arr = arrays[i];
    const BPE = arr.BYTES_PER_ELEMENT;
    byteOffset = Math.ceil(byteOffset / BPE) * BPE;
    const byteLength = arr.byteLength;
    const idx = 1 + 2 * i;
    dataView.setUint32(idx * 4, byteOffset, true);
    dataView.setUint32((idx + 1) * 4, byteLength, true);
    offsets.push(byteOffset);
    byteOffset += byteLength;
  }
  const dataArray = new Uint8Array(byteOffset);
  dataArray.set(new Uint8Array(dataView.buffer), 0);
  const requiresSwapToLittleEndian = function() {
    const buffer = new ArrayBuffer(2);
    new Uint16Array(buffer)[0] = 1;
    return new Uint8Array(buffer)[0] !== 1;
  }();
  for (let i = 0; i < arraysCnt; i++) {
    const arr = arrays[i];
    const subarray = new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    const BPE = arr.BYTES_PER_ELEMENT;
    if (requiresSwapToLittleEndian && BPE > 1) {
      const swaps = BPE / 2;
      const cnt = subarray.length / BPE;
      for (let b4 = 0; b4 < cnt; b4++) {
        const offset = b4 * BPE;
        for (let j = 0; j < swaps; j++) {
          const i1 = offset + j;
          const i2 = offset - j + BPE - 1;
          const tmp = subarray[i1];
          subarray[i1] = subarray[i2];
          subarray[i2] = tmp;
        }
      }
    }
    dataArray.set(subarray, offsets[i]);
  }
  return dataArray.buffer;
}
function packXGF(xgfData) {
  return toArrayBuffer([
    xgfData.positions,
    xgfData.colors,
    xgfData.indices,
    xgfData.edgeIndices,
    xgfData.aabbs,
    xgfData.eachGeometryPositionsBase,
    xgfData.eachGeometryColorsBase,
    xgfData.eachGeometryIndicesBase,
    xgfData.eachGeometryEdgeIndicesBase,
    xgfData.eachGeometryPrimitiveType,
    xgfData.eachGeometryAABBBase,
    xgfData.matrices,
    xgfData.eachMeshGeometriesBase,
    xgfData.eachMeshMatricesBase,
    xgfData.eachMeshMaterialAttributes,
    object2Array(xgfData.eachObjectId),
    xgfData.eachObjectMeshesBase
  ]);
}

// ../sdk/src/xgf/versions/v1/encode.ts
function encode5(params2, options) {
  return new Promise(function(resolve2, reject) {
    resolve2(packXGF(modelToXGF({ sceneModel: params2.sceneModel })));
  });
}

// ../sdk/src/xgf/XGFExporter.ts
var XGFExporter = class extends ModelExporter {
  constructor() {
    super({
      fileDataType: "json",
      encoders: {
        "1.0.0": encode5
      },
      defaultVersion: "1.0.0"
    });
  }
};

// ../sdk/src/las/index.ts
var las_exports = {};
__export(las_exports, {
  LASLoader: () => LASLoader4
});

// ../../node_modules/.pnpm/@loaders.gl+loader-utils@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/loader-utils/dist/loader-types.js
async function parseFromContext(data, loaders, options, context) {
  return context._parse(data, loaders, options, context);
}

// ../../node_modules/.pnpm/@loaders.gl+loader-utils@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/assert.js
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || "loader assertion failed.");
  }
}

// ../../node_modules/.pnpm/@loaders.gl+loader-utils@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/globals.js
var globals = {
  self: typeof self !== "undefined" && self,
  window: typeof window !== "undefined" && window,
  global: typeof global !== "undefined" && global,
  document: typeof document !== "undefined" && document
};
var self_ = globals.self || globals.window || globals.global || {};
var window_ = globals.window || globals.self || globals.global || {};
var global_ = globals.global || globals.self || globals.window || {};
var document_ = globals.document || {};
var isBrowser = (
  // @ts-ignore process does not exist on browser
  Boolean(typeof process !== "object" || String(process) !== "[object process]" || process.browser)
);
var matches = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
var nodeVersion = matches && parseFloat(matches[1]) || 0;

// ../../node_modules/.pnpm/@probe.gl+env@4.1.0/node_modules/@probe.gl/env/dist/lib/globals.js
var window_2 = globalThis;
var document_2 = globalThis.document || {};
var process_ = globalThis.process || {};
var console_ = globalThis.console;
var navigator_ = globalThis.navigator || {};

// ../../node_modules/.pnpm/@probe.gl+env@4.1.0/node_modules/@probe.gl/env/dist/lib/is-electron.js
function isElectron(mockUserAgent) {
  if (typeof window !== "undefined" && window.process?.type === "renderer") {
    return true;
  }
  if (typeof process !== "undefined" && Boolean(process.versions?.["electron"])) {
    return true;
  }
  const realUserAgent = typeof navigator !== "undefined" && navigator.userAgent;
  const userAgent = mockUserAgent || realUserAgent;
  return Boolean(userAgent && userAgent.indexOf("Electron") >= 0);
}

// ../../node_modules/.pnpm/@probe.gl+env@4.1.0/node_modules/@probe.gl/env/dist/lib/is-browser.js
function isBrowser2() {
  const isNode = (
    // @ts-expect-error
    typeof process === "object" && String(process) === "[object process]" && !process?.browser
  );
  return !isNode || isElectron();
}

// ../../node_modules/.pnpm/@probe.gl+env@4.1.0/node_modules/@probe.gl/env/dist/index.js
var VERSION = true ? "4.1.0" : "untranspiled source";

// ../../node_modules/.pnpm/@probe.gl+log@4.1.0/node_modules/@probe.gl/log/dist/utils/local-storage.js
function getStorage(type) {
  try {
    const storage = window[type];
    const x = "__storage_test__";
    storage.setItem(x, x);
    storage.removeItem(x);
    return storage;
  } catch (e) {
    return null;
  }
}
var LocalStorage = class {
  constructor(id, defaultConfig, type = "sessionStorage") {
    this.storage = getStorage(type);
    this.id = id;
    this.config = defaultConfig;
    this._loadConfiguration();
  }
  getConfiguration() {
    return this.config;
  }
  setConfiguration(configuration) {
    Object.assign(this.config, configuration);
    if (this.storage) {
      const serialized = JSON.stringify(this.config);
      this.storage.setItem(this.id, serialized);
    }
  }
  // Get config from persistent store, if available
  _loadConfiguration() {
    let configuration = {};
    if (this.storage) {
      const serializedConfiguration = this.storage.getItem(this.id);
      configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
    }
    Object.assign(this.config, configuration);
    return this;
  }
};

// ../../node_modules/.pnpm/@probe.gl+log@4.1.0/node_modules/@probe.gl/log/dist/utils/formatters.js
function formatTime(ms) {
  let formatted;
  if (ms < 10) {
    formatted = `${ms.toFixed(2)}ms`;
  } else if (ms < 100) {
    formatted = `${ms.toFixed(1)}ms`;
  } else if (ms < 1e3) {
    formatted = `${ms.toFixed(0)}ms`;
  } else {
    formatted = `${(ms / 1e3).toFixed(2)}s`;
  }
  return formatted;
}
function leftPad(string, length = 8) {
  const padLength = Math.max(length - string.length, 0);
  return `${" ".repeat(padLength)}${string}`;
}

// ../../node_modules/.pnpm/@probe.gl+log@4.1.0/node_modules/@probe.gl/log/dist/utils/color.js
var COLOR;
(function(COLOR2) {
  COLOR2[COLOR2["BLACK"] = 30] = "BLACK";
  COLOR2[COLOR2["RED"] = 31] = "RED";
  COLOR2[COLOR2["GREEN"] = 32] = "GREEN";
  COLOR2[COLOR2["YELLOW"] = 33] = "YELLOW";
  COLOR2[COLOR2["BLUE"] = 34] = "BLUE";
  COLOR2[COLOR2["MAGENTA"] = 35] = "MAGENTA";
  COLOR2[COLOR2["CYAN"] = 36] = "CYAN";
  COLOR2[COLOR2["WHITE"] = 37] = "WHITE";
  COLOR2[COLOR2["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
  COLOR2[COLOR2["BRIGHT_RED"] = 91] = "BRIGHT_RED";
  COLOR2[COLOR2["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
  COLOR2[COLOR2["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
  COLOR2[COLOR2["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
  COLOR2[COLOR2["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
  COLOR2[COLOR2["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
  COLOR2[COLOR2["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
})(COLOR || (COLOR = {}));
var BACKGROUND_INCREMENT = 10;
function getColor(color2) {
  if (typeof color2 !== "string") {
    return color2;
  }
  color2 = color2.toUpperCase();
  return COLOR[color2] || COLOR.WHITE;
}
function addColor(string, color2, background) {
  if (!isBrowser2 && typeof string === "string") {
    if (color2) {
      const colorCode = getColor(color2);
      string = `\x1B[${colorCode}m${string}\x1B[39m`;
    }
    if (background) {
      const colorCode = getColor(background);
      string = `\x1B[${colorCode + BACKGROUND_INCREMENT}m${string}\x1B[49m`;
    }
  }
  return string;
}

// ../../node_modules/.pnpm/@probe.gl+log@4.1.0/node_modules/@probe.gl/log/dist/utils/autobind.js
function autobind(obj, predefined = ["constructor"]) {
  const proto = Object.getPrototypeOf(obj);
  const propNames = Object.getOwnPropertyNames(proto);
  const object = obj;
  for (const key of propNames) {
    const value = object[key];
    if (typeof value === "function") {
      if (!predefined.find((name12) => key === name12)) {
        object[key] = value.bind(obj);
      }
    }
  }
}

// ../../node_modules/.pnpm/@probe.gl+log@4.1.0/node_modules/@probe.gl/log/dist/utils/assert.js
function assert2(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}

// ../../node_modules/.pnpm/@probe.gl+log@4.1.0/node_modules/@probe.gl/log/dist/utils/hi-res-timestamp.js
function getHiResTimestamp() {
  let timestamp;
  if (isBrowser2() && window_2.performance) {
    timestamp = window_2?.performance?.now?.();
  } else if ("hrtime" in process_) {
    const timeParts = process_?.hrtime?.();
    timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }
  return timestamp;
}

// ../../node_modules/.pnpm/@probe.gl+log@4.1.0/node_modules/@probe.gl/log/dist/log.js
var originalConsole = {
  debug: isBrowser2() ? console.debug || console.log : console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
};
var DEFAULT_LOG_CONFIGURATION = {
  enabled: true,
  level: 0
};
function noop() {
}
var cache = {};
var ONCE = { once: true };
var Log = class {
  constructor({ id } = { id: "" }) {
    this.VERSION = VERSION;
    this._startTs = getHiResTimestamp();
    this._deltaTs = getHiResTimestamp();
    this.userData = {};
    this.LOG_THROTTLE_TIMEOUT = 0;
    this.id = id;
    this.userData = {};
    this._storage = new LocalStorage(`__probe-${this.id}__`, DEFAULT_LOG_CONFIGURATION);
    this.timeStamp(`${this.id} started`);
    autobind(this);
    Object.seal(this);
  }
  set level(newLevel) {
    this.setLevel(newLevel);
  }
  get level() {
    return this.getLevel();
  }
  isEnabled() {
    return this._storage.config.enabled;
  }
  getLevel() {
    return this._storage.config.level;
  }
  /** @return milliseconds, with fractions */
  getTotal() {
    return Number((getHiResTimestamp() - this._startTs).toPrecision(10));
  }
  /** @return milliseconds, with fractions */
  getDelta() {
    return Number((getHiResTimestamp() - this._deltaTs).toPrecision(10));
  }
  /** @deprecated use logLevel */
  set priority(newPriority) {
    this.level = newPriority;
  }
  /** @deprecated use logLevel */
  get priority() {
    return this.level;
  }
  /** @deprecated use logLevel */
  getPriority() {
    return this.level;
  }
  // Configure
  enable(enabled2 = true) {
    this._storage.setConfiguration({ enabled: enabled2 });
    return this;
  }
  setLevel(level) {
    this._storage.setConfiguration({ level });
    return this;
  }
  /** return the current status of the setting */
  get(setting) {
    return this._storage.config[setting];
  }
  // update the status of the setting
  set(setting, value) {
    this._storage.setConfiguration({ [setting]: value });
  }
  /** Logs the current settings as a table */
  settings() {
    if (console.table) {
      console.table(this._storage.config);
    } else {
      console.log(this._storage.config);
    }
  }
  // Unconditional logging
  assert(condition, message) {
    if (!condition) {
      throw new Error(message || "Assertion failed");
    }
  }
  warn(message) {
    return this._getLogFunction(0, message, originalConsole.warn, arguments, ONCE);
  }
  error(message) {
    return this._getLogFunction(0, message, originalConsole.error, arguments);
  }
  /** Print a deprecation warning */
  deprecated(oldUsage, newUsage) {
    return this.warn(`\`${oldUsage}\` is deprecated and will be removed in a later version. Use \`${newUsage}\` instead`);
  }
  /** Print a removal warning */
  removed(oldUsage, newUsage) {
    return this.error(`\`${oldUsage}\` has been removed. Use \`${newUsage}\` instead`);
  }
  probe(logLevel, message) {
    return this._getLogFunction(logLevel, message, originalConsole.log, arguments, {
      time: true,
      once: true
    });
  }
  log(logLevel, message) {
    return this._getLogFunction(logLevel, message, originalConsole.debug, arguments);
  }
  info(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.info, arguments);
  }
  once(logLevel, message) {
    return this._getLogFunction(logLevel, message, originalConsole.debug || originalConsole.info, arguments, ONCE);
  }
  /** Logs an object as a table */
  table(logLevel, table, columns) {
    if (table) {
      return this._getLogFunction(logLevel, table, console.table || noop, columns && [columns], {
        tag: getTableHeader(table)
      });
    }
    return noop;
  }
  time(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
  }
  timeEnd(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
  }
  timeStamp(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.timeStamp || noop);
  }
  group(logLevel, message, opts = { collapsed: false }) {
    const options = normalizeArguments({ logLevel, message, opts });
    const { collapsed } = opts;
    options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
    return this._getLogFunction(options);
  }
  groupCollapsed(logLevel, message, opts = {}) {
    return this.group(logLevel, message, Object.assign({}, opts, { collapsed: true }));
  }
  groupEnd(logLevel) {
    return this._getLogFunction(logLevel, "", console.groupEnd || noop);
  }
  // EXPERIMENTAL
  withGroup(logLevel, message, func) {
    this.group(logLevel, message)();
    try {
      func();
    } finally {
      this.groupEnd(logLevel)();
    }
  }
  trace() {
    if (console.trace) {
      console.trace();
    }
  }
  // PRIVATE METHODS
  /** Deduces log level from a variety of arguments */
  _shouldLog(logLevel) {
    return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
  }
  _getLogFunction(logLevel, message, method, args, opts) {
    if (this._shouldLog(logLevel)) {
      opts = normalizeArguments({ logLevel, message, args, opts });
      method = method || opts.method;
      assert2(method);
      opts.total = this.getTotal();
      opts.delta = this.getDelta();
      this._deltaTs = getHiResTimestamp();
      const tag = opts.tag || opts.message;
      if (opts.once && tag) {
        if (!cache[tag]) {
          cache[tag] = getHiResTimestamp();
        } else {
          return noop;
        }
      }
      message = decorateMessage(this.id, opts.message, opts);
      return method.bind(console, message, ...opts.args);
    }
    return noop;
  }
};
Log.VERSION = VERSION;
function normalizeLogLevel(logLevel) {
  if (!logLevel) {
    return 0;
  }
  let resolvedLevel;
  switch (typeof logLevel) {
    case "number":
      resolvedLevel = logLevel;
      break;
    case "object":
      resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
      break;
    default:
      return 0;
  }
  assert2(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
  return resolvedLevel;
}
function normalizeArguments(opts) {
  const { logLevel, message } = opts;
  opts.logLevel = normalizeLogLevel(logLevel);
  const args = opts.args ? Array.from(opts.args) : [];
  while (args.length && args.shift() !== message) {
  }
  switch (typeof logLevel) {
    case "string":
    case "function":
      if (message !== void 0) {
        args.unshift(message);
      }
      opts.message = logLevel;
      break;
    case "object":
      Object.assign(opts, logLevel);
      break;
    default:
  }
  if (typeof opts.message === "function") {
    opts.message = opts.message();
  }
  const messageType = typeof opts.message;
  assert2(messageType === "string" || messageType === "object");
  return Object.assign(opts, { args }, opts.opts);
}
function decorateMessage(id, message, opts) {
  if (typeof message === "string") {
    const time = opts.time ? leftPad(formatTime(opts.total)) : "";
    message = opts.time ? `${id}: ${time}  ${message}` : `${id}: ${message}`;
    message = addColor(message, opts.color, opts.background);
  }
  return message;
}
function getTableHeader(table) {
  for (const key in table) {
    for (const title in table[key]) {
      return title || "untitled";
    }
  }
  return "empty";
}

// ../../node_modules/.pnpm/@probe.gl+log@4.1.0/node_modules/@probe.gl/log/dist/init.js
globalThis.probe = {};

// ../../node_modules/.pnpm/@probe.gl+log@4.1.0/node_modules/@probe.gl/log/dist/index.js
var dist_default = new Log({ id: "@probe.gl/log" });

// ../../node_modules/.pnpm/@loaders.gl+loader-utils@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/loader-utils/dist/lib/log-utils/log.js
var VERSION2 = true ? "4.3.2" : "latest";
var version = VERSION2[0] >= "0" && VERSION2[0] <= "9" ? `v${VERSION2}` : "";
function createLog() {
  const log2 = new Log({ id: "loaders.gl" });
  globalThis.loaders = globalThis.loaders || {};
  globalThis.loaders.log = log2;
  globalThis.loaders.version = version;
  globalThis.probe = globalThis.probe || {};
  globalThis.probe.loaders = log2;
  return log2;
}
var log = createLog();

// ../../node_modules/.pnpm/@loaders.gl+loader-utils@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/loader-utils/dist/lib/option-utils/merge-loader-options.js
function mergeLoaderOptions(baseOptions, newOptions) {
  return mergeOptionsRecursively(baseOptions || {}, newOptions);
}
function mergeOptionsRecursively(baseOptions, newOptions, level = 0) {
  if (level > 3) {
    return newOptions;
  }
  const options = { ...baseOptions };
  for (const [key, newValue] of Object.entries(newOptions)) {
    if (newValue && typeof newValue === "object" && !Array.isArray(newValue)) {
      options[key] = mergeOptionsRecursively(options[key] || {}, newOptions[key], level + 1);
    } else {
      options[key] = newOptions[key];
    }
  }
  return options;
}

// ../../node_modules/.pnpm/@loaders.gl+loader-utils@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/loader-utils/dist/lib/module-utils/js-module-utils.js
function registerJSModules(modules) {
  globalThis.loaders ||= {};
  globalThis.loaders.modules ||= {};
  Object.assign(globalThis.loaders.modules, modules);
}
function getJSModuleOrNull(name12) {
  const module2 = globalThis.loaders?.modules?.[name12];
  return module2 || null;
}

// ../../node_modules/.pnpm/@loaders.gl+worker-utils@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/version.js
var NPM_TAG = "latest";
function getVersion() {
  if (!globalThis._loadersgl_?.version) {
    globalThis._loadersgl_ = globalThis._loadersgl_ || {};
    if (false) {
      console.warn("loaders.gl: The __VERSION__ variable is not injected using babel plugin. Latest unstable workers would be fetched from the CDN.");
      globalThis._loadersgl_.version = NPM_TAG;
    } else {
      globalThis._loadersgl_.version = "4.3.2";
    }
  }
  return globalThis._loadersgl_.version;
}
var VERSION3 = getVersion();

// ../../node_modules/.pnpm/@loaders.gl+worker-utils@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js
function assert3(condition, message) {
  if (!condition) {
    throw new Error(message || "loaders.gl assertion failed.");
  }
}

// ../../node_modules/.pnpm/@loaders.gl+worker-utils@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/globals.js
var globals2 = {
  self: typeof self !== "undefined" && self,
  window: typeof window !== "undefined" && window,
  global: typeof global !== "undefined" && global,
  document: typeof document !== "undefined" && document
};
var self_2 = globals2.self || globals2.window || globals2.global || {};
var window_3 = globals2.window || globals2.self || globals2.global || {};
var global_3 = globals2.global || globals2.self || globals2.window || {};
var document_3 = globals2.document || {};
var isBrowser3 = (
  // @ts-ignore process.browser
  typeof process !== "object" || String(process) !== "[object process]" || process.browser
);
var isWorker = typeof importScripts === "function";
var isMobile = typeof window !== "undefined" && typeof window.orientation !== "undefined";
var matches2 = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
var nodeVersion2 = matches2 && parseFloat(matches2[1]) || 0;

// ../../node_modules/.pnpm/@loaders.gl+worker-utils@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-job.js
var WorkerJob = class {
  name;
  workerThread;
  isRunning = true;
  /** Promise that resolves when Job is done */
  result;
  _resolve = () => {
  };
  _reject = () => {
  };
  constructor(jobName, workerThread) {
    this.name = jobName;
    this.workerThread = workerThread;
    this.result = new Promise((resolve2, reject) => {
      this._resolve = resolve2;
      this._reject = reject;
    });
  }
  /**
   * Send a message to the job's worker thread
   * @param data any data structure, ideally consisting mostly of transferrable objects
   */
  postMessage(type, payload) {
    this.workerThread.postMessage({
      source: "loaders.gl",
      // Lets worker ignore unrelated messages
      type,
      payload
    });
  }
  /**
   * Call to resolve the `result` Promise with the supplied value
   */
  done(value) {
    assert3(this.isRunning);
    this.isRunning = false;
    this._resolve(value);
  }
  /**
   * Call to reject the `result` Promise with the supplied error
   */
  error(error) {
    assert3(this.isRunning);
    this.isRunning = false;
    this._reject(error);
  }
};

// ../../node_modules/.pnpm/@loaders.gl+worker-utils@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/worker-utils/dist/lib/node/worker_threads-browser.js
var NodeWorker = class {
  terminate() {
  }
};

// ../../node_modules/.pnpm/@loaders.gl+worker-utils@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-loadable-worker-url.js
var workerURLCache = /* @__PURE__ */ new Map();
function getLoadableWorkerURL(props) {
  assert3(props.source && !props.url || !props.source && props.url);
  let workerURL = workerURLCache.get(props.source || props.url);
  if (!workerURL) {
    if (props.url) {
      workerURL = getLoadableWorkerURLFromURL(props.url);
      workerURLCache.set(props.url, workerURL);
    }
    if (props.source) {
      workerURL = getLoadableWorkerURLFromSource(props.source);
      workerURLCache.set(props.source, workerURL);
    }
  }
  assert3(workerURL);
  return workerURL;
}
function getLoadableWorkerURLFromURL(url) {
  if (!url.startsWith("http")) {
    return url;
  }
  const workerSource = buildScriptSource(url);
  return getLoadableWorkerURLFromSource(workerSource);
}
function getLoadableWorkerURLFromSource(workerSource) {
  const blob = new Blob([workerSource], { type: "application/javascript" });
  return URL.createObjectURL(blob);
}
function buildScriptSource(workerUrl) {
  return `try {
  importScripts('${workerUrl}');
} catch (error) {
  console.error(error);
  throw error;
}`;
}

// ../../node_modules/.pnpm/@loaders.gl+worker-utils@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-transfer-list.js
function getTransferList(object, recursive = true, transfers) {
  const transfersSet = transfers || /* @__PURE__ */ new Set();
  if (!object) {
  } else if (isTransferable(object)) {
    transfersSet.add(object);
  } else if (isTransferable(object.buffer)) {
    transfersSet.add(object.buffer);
  } else if (ArrayBuffer.isView(object)) {
  } else if (recursive && typeof object === "object") {
    for (const key in object) {
      getTransferList(object[key], recursive, transfersSet);
    }
  }
  return transfers === void 0 ? Array.from(transfersSet) : [];
}
function isTransferable(object) {
  if (!object) {
    return false;
  }
  if (object instanceof ArrayBuffer) {
    return true;
  }
  if (typeof MessagePort !== "undefined" && object instanceof MessagePort) {
    return true;
  }
  if (typeof ImageBitmap !== "undefined" && object instanceof ImageBitmap) {
    return true;
  }
  if (typeof OffscreenCanvas !== "undefined" && object instanceof OffscreenCanvas) {
    return true;
  }
  return false;
}

// ../../node_modules/.pnpm/@loaders.gl+worker-utils@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-thread.js
var NOOP = () => {
};
var WorkerThread = class {
  name;
  source;
  url;
  terminated = false;
  worker;
  onMessage;
  onError;
  _loadableURL = "";
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return typeof Worker !== "undefined" && isBrowser3 || typeof NodeWorker !== "undefined" && !isBrowser3;
  }
  constructor(props) {
    const { name: name12, source, url } = props;
    assert3(source || url);
    this.name = name12;
    this.source = source;
    this.url = url;
    this.onMessage = NOOP;
    this.onError = (error) => console.log(error);
    this.worker = isBrowser3 ? this._createBrowserWorker() : this._createNodeWorker();
  }
  /**
   * Terminate this worker thread
   * @note Can free up significant memory
   */
  destroy() {
    this.onMessage = NOOP;
    this.onError = NOOP;
    this.worker.terminate();
    this.terminated = true;
  }
  get isRunning() {
    return Boolean(this.onMessage);
  }
  /**
   * Send a message to this worker thread
   * @param data any data structure, ideally consisting mostly of transferrable objects
   * @param transferList If not supplied, calculated automatically by traversing data
   */
  postMessage(data, transferList) {
    transferList = transferList || getTransferList(data);
    this.worker.postMessage(data, transferList);
  }
  // PRIVATE
  /**
   * Generate a standard Error from an ErrorEvent
   * @param event
   */
  _getErrorFromErrorEvent(event) {
    let message = "Failed to load ";
    message += `worker ${this.name} from ${this.url}. `;
    if (event.message) {
      message += `${event.message} in `;
    }
    if (event.lineno) {
      message += `:${event.lineno}:${event.colno}`;
    }
    return new Error(message);
  }
  /**
   * Creates a worker thread on the browser
   */
  _createBrowserWorker() {
    this._loadableURL = getLoadableWorkerURL({ source: this.source, url: this.url });
    const worker = new Worker(this._loadableURL, { name: this.name });
    worker.onmessage = (event) => {
      if (!event.data) {
        this.onError(new Error("No data received"));
      } else {
        this.onMessage(event.data);
      }
    };
    worker.onerror = (error) => {
      this.onError(this._getErrorFromErrorEvent(error));
      this.terminated = true;
    };
    worker.onmessageerror = (event) => console.error(event);
    return worker;
  }
  /**
   * Creates a worker thread in node.js
   * @todo https://nodejs.org/api/async_hooks.html#async-resource-worker-pool
   */
  _createNodeWorker() {
    let worker;
    if (this.url) {
      const absolute = this.url.includes(":/") || this.url.startsWith("/");
      const url = absolute ? this.url : `./${this.url}`;
      worker = new NodeWorker(url, { eval: false });
    } else if (this.source) {
      worker = new NodeWorker(this.source, { eval: true });
    } else {
      throw new Error("no worker");
    }
    worker.on("message", (data) => {
      this.onMessage(data);
    });
    worker.on("error", (error) => {
      this.onError(error);
    });
    worker.on("exit", (code) => {
    });
    return worker;
  }
};

// ../../node_modules/.pnpm/@loaders.gl+worker-utils@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-pool.js
var WorkerPool2 = class {
  name = "unnamed";
  source;
  // | Function;
  url;
  maxConcurrency = 1;
  maxMobileConcurrency = 1;
  onDebug = () => {
  };
  reuseWorkers = true;
  props = {};
  jobQueue = [];
  idleQueue = [];
  count = 0;
  isDestroyed = false;
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return WorkerThread.isSupported();
  }
  /**
   * @param processor - worker function
   * @param maxConcurrency - max count of workers
   */
  constructor(props) {
    this.source = props.source;
    this.url = props.url;
    this.setProps(props);
  }
  /**
   * Terminates all workers in the pool
   * @note Can free up significant memory
   */
  destroy() {
    this.idleQueue.forEach((worker) => worker.destroy());
    this.isDestroyed = true;
  }
  setProps(props) {
    this.props = { ...this.props, ...props };
    if (props.name !== void 0) {
      this.name = props.name;
    }
    if (props.maxConcurrency !== void 0) {
      this.maxConcurrency = props.maxConcurrency;
    }
    if (props.maxMobileConcurrency !== void 0) {
      this.maxMobileConcurrency = props.maxMobileConcurrency;
    }
    if (props.reuseWorkers !== void 0) {
      this.reuseWorkers = props.reuseWorkers;
    }
    if (props.onDebug !== void 0) {
      this.onDebug = props.onDebug;
    }
  }
  async startJob(name12, onMessage2 = (job, type, data) => job.done(data), onError = (job, error) => job.error(error)) {
    const startPromise = new Promise((onStart) => {
      this.jobQueue.push({ name: name12, onMessage: onMessage2, onError, onStart });
      return this;
    });
    this._startQueuedJob();
    return await startPromise;
  }
  // PRIVATE
  /**
   * Starts first queued job if worker is available or can be created
   * Called when job is started and whenever a worker returns to the idleQueue
   */
  async _startQueuedJob() {
    if (!this.jobQueue.length) {
      return;
    }
    const workerThread = this._getAvailableWorker();
    if (!workerThread) {
      return;
    }
    const queuedJob = this.jobQueue.shift();
    if (queuedJob) {
      this.onDebug({
        message: "Starting job",
        name: queuedJob.name,
        workerThread,
        backlog: this.jobQueue.length
      });
      const job = new WorkerJob(queuedJob.name, workerThread);
      workerThread.onMessage = (data) => queuedJob.onMessage(job, data.type, data.payload);
      workerThread.onError = (error) => queuedJob.onError(job, error);
      queuedJob.onStart(job);
      try {
        await job.result;
      } catch (error) {
        console.error(`Worker exception: ${error}`);
      } finally {
        this.returnWorkerToQueue(workerThread);
      }
    }
  }
  /**
   * Returns a worker to the idle queue
   * Destroys the worker if
   *  - pool is destroyed
   *  - if this pool doesn't reuse workers
   *  - if maxConcurrency has been lowered
   * @param worker
   */
  returnWorkerToQueue(worker) {
    const shouldDestroyWorker = (
      // Workers on Node.js prevent the process from exiting.
      // Until we figure out how to close them before exit, we always destroy them
      !isBrowser3 || // If the pool is destroyed, there is no reason to keep the worker around
      this.isDestroyed || // If the app has disabled worker reuse, any completed workers should be destroyed
      !this.reuseWorkers || // If concurrency has been lowered, this worker might be surplus to requirements
      this.count > this._getMaxConcurrency()
    );
    if (shouldDestroyWorker) {
      worker.destroy();
      this.count--;
    } else {
      this.idleQueue.push(worker);
    }
    if (!this.isDestroyed) {
      this._startQueuedJob();
    }
  }
  /**
   * Returns idle worker or creates new worker if maxConcurrency has not been reached
   */
  _getAvailableWorker() {
    if (this.idleQueue.length > 0) {
      return this.idleQueue.shift() || null;
    }
    if (this.count < this._getMaxConcurrency()) {
      this.count++;
      const name12 = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;
      return new WorkerThread({ name: name12, source: this.source, url: this.url });
    }
    return null;
  }
  _getMaxConcurrency() {
    return isMobile ? this.maxMobileConcurrency : this.maxConcurrency;
  }
};

// ../../node_modules/.pnpm/@loaders.gl+worker-utils@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-farm.js
var DEFAULT_PROPS = {
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: true,
  onDebug: () => {
  }
};
var WorkerFarm = class _WorkerFarm {
  props;
  workerPools = /* @__PURE__ */ new Map();
  // singleton
  static _workerFarm;
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return WorkerThread.isSupported();
  }
  /** Get the singleton instance of the global worker farm */
  static getWorkerFarm(props = {}) {
    _WorkerFarm._workerFarm = _WorkerFarm._workerFarm || new _WorkerFarm({});
    _WorkerFarm._workerFarm.setProps(props);
    return _WorkerFarm._workerFarm;
  }
  /** get global instance with WorkerFarm.getWorkerFarm() */
  constructor(props) {
    this.props = { ...DEFAULT_PROPS };
    this.setProps(props);
    this.workerPools = /* @__PURE__ */ new Map();
  }
  /**
   * Terminate all workers in the farm
   * @note Can free up significant memory
   */
  destroy() {
    for (const workerPool of this.workerPools.values()) {
      workerPool.destroy();
    }
    this.workerPools = /* @__PURE__ */ new Map();
  }
  /**
   * Set props used when initializing worker pools
   * @param props
   */
  setProps(props) {
    this.props = { ...this.props, ...props };
    for (const workerPool of this.workerPools.values()) {
      workerPool.setProps(this._getWorkerPoolProps());
    }
  }
  /**
   * Returns a worker pool for the specified worker
   * @param options - only used first time for a specific worker name
   * @param options.name - the name of the worker - used to identify worker pool
   * @param options.url -
   * @param options.source -
   * @example
   *   const job = WorkerFarm.getWorkerFarm().getWorkerPool({name, url}).startJob(...);
   */
  getWorkerPool(options) {
    const { name: name12, source, url } = options;
    let workerPool = this.workerPools.get(name12);
    if (!workerPool) {
      workerPool = new WorkerPool2({
        name: name12,
        source,
        url
      });
      workerPool.setProps(this._getWorkerPoolProps());
      this.workerPools.set(name12, workerPool);
    }
    return workerPool;
  }
  _getWorkerPoolProps() {
    return {
      maxConcurrency: this.props.maxConcurrency,
      maxMobileConcurrency: this.props.maxMobileConcurrency,
      reuseWorkers: this.props.reuseWorkers,
      onDebug: this.props.onDebug
    };
  }
};

// ../../node_modules/.pnpm/@loaders.gl+worker-utils@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/get-worker-url.js
function getWorkerURL(worker, options = {}) {
  const workerOptions = options[worker.id] || {};
  const workerFile = isBrowser3 ? `${worker.id}-worker.js` : `${worker.id}-worker-node.js`;
  let url = workerOptions.workerUrl;
  if (!url && worker.id === "compression") {
    url = options.workerUrl;
  }
  if (options._workerType === "test") {
    if (isBrowser3) {
      url = `modules/${worker.module}/dist/${workerFile}`;
    } else {
      url = `modules/${worker.module}/src/workers/${worker.id}-worker-node.ts`;
    }
  }
  if (!url) {
    let version2 = worker.version;
    if (version2 === "latest") {
      version2 = NPM_TAG;
    }
    const versionTag = version2 ? `@${version2}` : "";
    url = `https://unpkg.com/@loaders.gl/${worker.module}${versionTag}/dist/${workerFile}`;
  }
  assert3(url);
  return url;
}

// ../../node_modules/.pnpm/@loaders.gl+worker-utils@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/validate-worker-version.js
function validateWorkerVersion(worker, coreVersion = VERSION3) {
  assert3(worker, "no worker provided");
  const workerVersion = worker.version;
  if (!coreVersion || !workerVersion) {
    return false;
  }
  return true;
}

// ../../node_modules/.pnpm/@loaders.gl+worker-utils@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/worker-utils/dist/lib/library-utils/library-utils.js
var loadLibraryPromises = {};
async function loadLibrary(libraryUrl, moduleName = null, options = {}, libraryName = null) {
  if (moduleName) {
    libraryUrl = getLibraryUrl(libraryUrl, moduleName, options, libraryName);
  }
  loadLibraryPromises[libraryUrl] = // eslint-disable-next-line @typescript-eslint/no-misused-promises
  loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);
  return await loadLibraryPromises[libraryUrl];
}
function getLibraryUrl(library, moduleName, options = {}, libraryName = null) {
  if (!options.useLocalLibraries && library.startsWith("http")) {
    return library;
  }
  libraryName = libraryName || library;
  const modules = options.modules || {};
  if (modules[libraryName]) {
    return modules[libraryName];
  }
  if (!isBrowser3) {
    return `modules/${moduleName}/dist/libs/${libraryName}`;
  }
  if (options.CDN) {
    assert3(options.CDN.startsWith("http"));
    return `${options.CDN}/${moduleName}@${VERSION3}/dist/libs/${libraryName}`;
  }
  if (isWorker) {
    return `../src/libs/${libraryName}`;
  }
  return `modules/${moduleName}/src/libs/${libraryName}`;
}
async function loadLibraryFromFile(libraryUrl) {
  if (libraryUrl.endsWith("wasm")) {
    return await loadAsArrayBuffer(libraryUrl);
  }
  if (!isBrowser3) {
    try {
      const { requireFromFile } = globalThis.loaders || {};
      return await requireFromFile?.(libraryUrl);
    } catch (error) {
      console.error(error);
      return null;
    }
  }
  if (isWorker) {
    return importScripts(libraryUrl);
  }
  const scriptSource = await loadAsText(libraryUrl);
  return loadLibraryFromString(scriptSource, libraryUrl);
}
function loadLibraryFromString(scriptSource, id) {
  if (!isBrowser3) {
    const { requireFromString } = globalThis.loaders || {};
    return requireFromString?.(scriptSource, id);
  }
  if (isWorker) {
    eval.call(globalThis, scriptSource);
    return null;
  }
  const script = document.createElement("script");
  script.id = id;
  try {
    script.appendChild(document.createTextNode(scriptSource));
  } catch (e) {
    script.text = scriptSource;
  }
  document.body.appendChild(script);
  return null;
}
async function loadAsArrayBuffer(url) {
  const { readFileAsArrayBuffer } = globalThis.loaders || {};
  if (isBrowser3 || !readFileAsArrayBuffer || url.startsWith("http")) {
    const response = await fetch(url);
    return await response.arrayBuffer();
  }
  return await readFileAsArrayBuffer(url);
}
async function loadAsText(url) {
  const { readFileAsText } = globalThis.loaders || {};
  if (isBrowser3 || !readFileAsText || url.startsWith("http")) {
    const response = await fetch(url);
    return await response.text();
  }
  return await readFileAsText(url);
}

// ../../node_modules/.pnpm/@loaders.gl+loader-utils@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/loader-utils/dist/lib/worker-loader-utils/parse-with-worker.js
function canParseWithWorker(loader, options) {
  if (!WorkerFarm.isSupported()) {
    return false;
  }
  if (!isBrowser3 && !options?._nodeWorkers) {
    return false;
  }
  return loader.worker && options?.worker;
}
async function parseWithWorker(loader, data, options, context, parseOnMainThread) {
  const name12 = loader.id;
  const url = getWorkerURL(loader, options);
  const workerFarm = WorkerFarm.getWorkerFarm(options);
  const workerPool = workerFarm.getWorkerPool({ name: name12, url });
  options = JSON.parse(JSON.stringify(options));
  context = JSON.parse(JSON.stringify(context || {}));
  const job = await workerPool.startJob(
    "process-on-worker",
    // @ts-expect-error
    onMessage.bind(null, parseOnMainThread)
    // eslint-disable-line @typescript-eslint/no-misused-promises
  );
  job.postMessage("process", {
    // @ts-ignore
    input: data,
    options,
    context
  });
  const result = await job.result;
  return await result.result;
}
async function onMessage(parseOnMainThread, job, type, payload) {
  switch (type) {
    case "done":
      job.done(payload);
      break;
    case "error":
      job.error(new Error(payload.error));
      break;
    case "process":
      const { id, input, options } = payload;
      try {
        const result = await parseOnMainThread(input, options);
        job.postMessage("done", { id, result });
      } catch (error) {
        const message = error instanceof Error ? error.message : "unknown error";
        job.postMessage("error", { id, error: message });
      }
      break;
    default:
      console.warn(`parse-with-worker unknown message ${type}`);
  }
}

// ../../node_modules/.pnpm/@loaders.gl+loader-utils@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/get-first-characters.js
function getFirstCharacters(data, length = 5) {
  if (typeof data === "string") {
    return data.slice(0, length);
  } else if (ArrayBuffer.isView(data)) {
    return getMagicString(data.buffer, data.byteOffset, length);
  } else if (data instanceof ArrayBuffer) {
    const byteOffset = 0;
    return getMagicString(data, byteOffset, length);
  }
  return "";
}
function getMagicString(arrayBuffer, byteOffset, length) {
  if (arrayBuffer.byteLength <= byteOffset + length) {
    return "";
  }
  const dataView = new DataView(arrayBuffer);
  let magic = "";
  for (let i = 0; i < length; i++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
  }
  return magic;
}

// ../../node_modules/.pnpm/@loaders.gl+loader-utils@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/loader-utils/dist/lib/parser-utils/parse-json.js
function parseJSON(string) {
  try {
    return JSON.parse(string);
  } catch (_) {
    throw new Error(`Failed to parse JSON from data starting with "${getFirstCharacters(string)}"`);
  }
}

// ../../node_modules/.pnpm/@loaders.gl+loader-utils@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/array-buffer-utils.js
function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {
  byteLength = byteLength || arrayBuffer1.byteLength;
  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {
    return false;
  }
  const array1 = new Uint8Array(arrayBuffer1);
  const array2 = new Uint8Array(arrayBuffer2);
  for (let i = 0; i < array1.length; ++i) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}
function concatenateArrayBuffers(...sources) {
  return concatenateArrayBuffersFromArray(sources);
}
function concatenateArrayBuffersFromArray(sources) {
  const sourceArrays = sources.map((source2) => source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2);
  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);
  const result = new Uint8Array(byteLength);
  let offset = 0;
  for (const sourceArray of sourceArrays) {
    result.set(sourceArray, offset);
    offset += sourceArray.byteLength;
  }
  return result.buffer;
}
function sliceArrayBuffer(arrayBuffer, byteOffset, byteLength) {
  const subArray = byteLength !== void 0 ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength) : new Uint8Array(arrayBuffer).subarray(byteOffset);
  const arrayCopy = new Uint8Array(subArray);
  return arrayCopy.buffer;
}

// ../../node_modules/.pnpm/@loaders.gl+loader-utils@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-copy-utils.js
function padToNBytes(byteLength, padding) {
  assert(byteLength >= 0);
  assert(padding > 0);
  return byteLength + (padding - 1) & ~(padding - 1);
}
function copyToArray(source, target, targetOffset) {
  let sourceArray;
  if (source instanceof ArrayBuffer) {
    sourceArray = new Uint8Array(source);
  } else {
    const srcByteOffset = source.byteOffset;
    const srcByteLength = source.byteLength;
    sourceArray = new Uint8Array(source.buffer || source.arrayBuffer, srcByteOffset, srcByteLength);
  }
  target.set(sourceArray, targetOffset);
  return targetOffset + padToNBytes(sourceArray.byteLength, 4);
}

// ../../node_modules/.pnpm/@loaders.gl+loader-utils@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/loader-utils/dist/lib/iterators/async-iteration.js
async function concatenateArrayBuffersAsync(asyncIterator) {
  const arrayBuffers = [];
  for await (const chunk of asyncIterator) {
    arrayBuffers.push(chunk);
  }
  return concatenateArrayBuffers(...arrayBuffers);
}

// ../../node_modules/.pnpm/@loaders.gl+loader-utils@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/file-aliases.js
var pathPrefix = "";
var fileAliases = {};
function resolvePath2(filename2) {
  for (const alias in fileAliases) {
    if (filename2.startsWith(alias)) {
      const replacement = fileAliases[alias];
      filename2 = filename2.replace(alias, replacement);
    }
  }
  if (!filename2.startsWith("http://") && !filename2.startsWith("https://")) {
    filename2 = `${pathPrefix}${filename2}`;
  }
  return filename2;
}

// ../../node_modules/.pnpm/@loaders.gl+loader-utils@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/loader-utils/dist/lib/node/buffer.browser.js
function toArrayBuffer2(buffer) {
  return buffer;
}

// ../../node_modules/.pnpm/@loaders.gl+loader-utils@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-conversion-utils.js
function isBuffer(value) {
  return value && typeof value === "object" && value.isBuffer;
}
function toArrayBuffer3(data) {
  if (isBuffer(data)) {
    return toArrayBuffer2(data);
  }
  if (data instanceof ArrayBuffer) {
    return data;
  }
  if (ArrayBuffer.isView(data)) {
    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
      return data.buffer;
    }
    return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
  }
  if (typeof data === "string") {
    const text = data;
    const uint8Array = new TextEncoder().encode(text);
    return uint8Array.buffer;
  }
  if (data && typeof data === "object" && data._toArrayBuffer) {
    return data._toArrayBuffer();
  }
  throw new Error("toArrayBuffer");
}

// ../../node_modules/.pnpm/@loaders.gl+loader-utils@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js
var path_exports = {};
__export(path_exports, {
  dirname: () => dirname,
  filename: () => filename,
  join: () => join,
  resolve: () => resolve
});

// ../../node_modules/.pnpm/@loaders.gl+loader-utils@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/get-cwd.js
function getCWD() {
  if (typeof process !== "undefined" && typeof process.cwd !== "undefined") {
    return process.cwd();
  }
  const pathname = window.location?.pathname;
  return pathname?.slice(0, pathname.lastIndexOf("/") + 1) || "";
}

// ../../node_modules/.pnpm/@loaders.gl+loader-utils@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js
function filename(url) {
  const slashIndex = url ? url.lastIndexOf("/") : -1;
  return slashIndex >= 0 ? url.substr(slashIndex + 1) : "";
}
function dirname(url) {
  const slashIndex = url ? url.lastIndexOf("/") : -1;
  return slashIndex >= 0 ? url.substr(0, slashIndex) : "";
}
function join(...parts) {
  const separator = "/";
  parts = parts.map((part, index) => {
    if (index) {
      part = part.replace(new RegExp(`^${separator}`), "");
    }
    if (index !== parts.length - 1) {
      part = part.replace(new RegExp(`${separator}$`), "");
    }
    return part;
  });
  return parts.join(separator);
}
function resolve(...components) {
  const paths = [];
  for (let _i = 0; _i < components.length; _i++) {
    paths[_i] = components[_i];
  }
  let resolvedPath = "";
  let resolvedAbsolute = false;
  let cwd;
  for (let i = paths.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    let path;
    if (i >= 0) {
      path = paths[i];
    } else {
      if (cwd === void 0) {
        cwd = getCWD();
      }
      path = cwd;
    }
    if (path.length === 0) {
      continue;
    }
    resolvedPath = `${path}/${resolvedPath}`;
    resolvedAbsolute = path.charCodeAt(0) === SLASH;
  }
  resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
  if (resolvedAbsolute) {
    return `/${resolvedPath}`;
  } else if (resolvedPath.length > 0) {
    return resolvedPath;
  }
  return ".";
}
var SLASH = 47;
var DOT = 46;
function normalizeStringPosix(path, allowAboveRoot) {
  let res = "";
  let lastSlash = -1;
  let dots = 0;
  let code;
  let isAboveRoot = false;
  for (let i = 0; i <= path.length; ++i) {
    if (i < path.length) {
      code = path.charCodeAt(i);
    } else if (code === SLASH) {
      break;
    } else {
      code = SLASH;
    }
    if (code === SLASH) {
      if (lastSlash === i - 1 || dots === 1) {
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || !isAboveRoot || res.charCodeAt(res.length - 1) !== DOT || res.charCodeAt(res.length - 2) !== DOT) {
          if (res.length > 2) {
            const start = res.length - 1;
            let j = start;
            for (; j >= 0; --j) {
              if (res.charCodeAt(j) === SLASH) {
                break;
              }
            }
            if (j !== start) {
              res = j === -1 ? "" : res.slice(0, j);
              lastSlash = i;
              dots = 0;
              isAboveRoot = false;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSlash = i;
            dots = 0;
            isAboveRoot = false;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) {
            res += "/..";
          } else {
            res = "..";
          }
          isAboveRoot = true;
        }
      } else {
        const slice = path.slice(lastSlash + 1, i);
        if (res.length > 0) {
          res += `/${slice}`;
        } else {
          res = slice;
        }
        isAboveRoot = false;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === DOT && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}

// ../../node_modules/.pnpm/@loaders.gl+core@4.3.3/node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js
var isBoolean = (x) => typeof x === "boolean";
var isFunction2 = (x) => typeof x === "function";
var isObject2 = (x) => x !== null && typeof x === "object";
var isPureObject = (x) => isObject2(x) && x.constructor === {}.constructor;
var isIterable = (x) => Boolean(x) && typeof x[Symbol.iterator] === "function";
var isAsyncIterable = (x) => x && typeof x[Symbol.asyncIterator] === "function";
var isResponse = (x) => typeof Response !== "undefined" && x instanceof Response || x && x.arrayBuffer && x.text && x.json;
var isBlob = (x) => typeof Blob !== "undefined" && x instanceof Blob;
var isBuffer2 = (x) => x && typeof x === "object" && x.isBuffer;
var isReadableDOMStream = (x) => typeof ReadableStream !== "undefined" && x instanceof ReadableStream || isObject2(x) && isFunction2(x.tee) && isFunction2(x.cancel) && isFunction2(x.getReader);
var isReadableNodeStream = (x) => isObject2(x) && isFunction2(x.read) && isFunction2(x.pipe) && isBoolean(x.readable);
var isReadableStream = (x) => isReadableDOMStream(x) || isReadableNodeStream(x);

// ../../node_modules/.pnpm/@loaders.gl+core@4.3.3/node_modules/@loaders.gl/core/dist/lib/fetch/fetch-error.js
var FetchError = class extends Error {
  constructor(message, info) {
    super(message);
    this.reason = info.reason;
    this.url = info.url;
    this.response = info.response;
  }
  /** A best effort reason for why the fetch failed */
  reason;
  /** The URL that failed to load. Empty string if not available. */
  url;
  /** The Response object, if any. */
  response;
};

// ../../node_modules/.pnpm/@loaders.gl+core@4.3.3/node_modules/@loaders.gl/core/dist/lib/utils/mime-type-utils.js
var DATA_URL_PATTERN = /^data:([-\w.]+\/[-\w.+]+)(;|,)/;
var MIME_TYPE_PATTERN = /^([-\w.]+\/[-\w.+]+)/;
function compareMIMETypes(mimeType1, mimeType2) {
  if (mimeType1.toLowerCase() === mimeType2.toLowerCase()) {
    return true;
  }
  return false;
}
function parseMIMEType(mimeString) {
  const matches3 = MIME_TYPE_PATTERN.exec(mimeString);
  if (matches3) {
    return matches3[1];
  }
  return mimeString;
}
function parseMIMETypeFromURL(url) {
  const matches3 = DATA_URL_PATTERN.exec(url);
  if (matches3) {
    return matches3[1];
  }
  return "";
}

// ../../node_modules/.pnpm/@loaders.gl+core@4.3.3/node_modules/@loaders.gl/core/dist/lib/utils/url-utils.js
var QUERY_STRING_PATTERN = /\?.*/;
function extractQueryString(url) {
  const matches3 = url.match(QUERY_STRING_PATTERN);
  return matches3 && matches3[0];
}
function stripQueryString(url) {
  return url.replace(QUERY_STRING_PATTERN, "");
}
function shortenUrlForDisplay(url) {
  if (url.length < 50) {
    return url;
  }
  const urlEnd = url.slice(url.length - 15);
  const urlStart = url.substr(0, 32);
  return `${urlStart}...${urlEnd}`;
}

// ../../node_modules/.pnpm/@loaders.gl+core@4.3.3/node_modules/@loaders.gl/core/dist/lib/utils/resource-utils.js
function getResourceUrl(resource) {
  if (isResponse(resource)) {
    const response = resource;
    return response.url;
  }
  if (isBlob(resource)) {
    const blob = resource;
    return blob.name || "";
  }
  if (typeof resource === "string") {
    return resource;
  }
  return "";
}
function getResourceMIMEType(resource) {
  if (isResponse(resource)) {
    const response = resource;
    const contentTypeHeader = response.headers.get("content-type") || "";
    const noQueryUrl = stripQueryString(response.url);
    return parseMIMEType(contentTypeHeader) || parseMIMETypeFromURL(noQueryUrl);
  }
  if (isBlob(resource)) {
    const blob = resource;
    return blob.type || "";
  }
  if (typeof resource === "string") {
    return parseMIMETypeFromURL(resource);
  }
  return "";
}
function getResourceContentLength(resource) {
  if (isResponse(resource)) {
    const response = resource;
    return response.headers["content-length"] || -1;
  }
  if (isBlob(resource)) {
    const blob = resource;
    return blob.size;
  }
  if (typeof resource === "string") {
    return resource.length;
  }
  if (resource instanceof ArrayBuffer) {
    return resource.byteLength;
  }
  if (ArrayBuffer.isView(resource)) {
    return resource.byteLength;
  }
  return -1;
}

// ../../node_modules/.pnpm/@loaders.gl+core@4.3.3/node_modules/@loaders.gl/core/dist/lib/utils/response-utils.js
async function makeResponse(resource) {
  if (isResponse(resource)) {
    return resource;
  }
  const headers = {};
  const contentLength = getResourceContentLength(resource);
  if (contentLength >= 0) {
    headers["content-length"] = String(contentLength);
  }
  const url = getResourceUrl(resource);
  const type = getResourceMIMEType(resource);
  if (type) {
    headers["content-type"] = type;
  }
  const initialDataUrl = await getInitialDataUrl(resource);
  if (initialDataUrl) {
    headers["x-first-bytes"] = initialDataUrl;
  }
  if (typeof resource === "string") {
    resource = new TextEncoder().encode(resource);
  }
  const response = new Response(resource, { headers });
  Object.defineProperty(response, "url", { value: url });
  return response;
}
async function checkResponse(response) {
  if (!response.ok) {
    const error = await getResponseError(response);
    throw error;
  }
}
async function getResponseError(response) {
  const shortUrl = shortenUrlForDisplay(response.url);
  let message = `Failed to fetch resource (${response.status}) ${response.statusText}: ${shortUrl}`;
  message = message.length > 100 ? `${message.slice(0, 100)}...` : message;
  const info = {
    reason: response.statusText,
    url: response.url,
    response
  };
  try {
    const contentType = response.headers.get("Content-Type");
    info.reason = !response.bodyUsed && contentType?.includes("application/json") ? await response.json() : await response.text();
  } catch (error) {
  }
  return new FetchError(message, info);
}
async function getInitialDataUrl(resource) {
  const INITIAL_DATA_LENGTH = 5;
  if (typeof resource === "string") {
    return `data:,${resource.slice(0, INITIAL_DATA_LENGTH)}`;
  }
  if (resource instanceof Blob) {
    const blobSlice = resource.slice(0, 5);
    return await new Promise((resolve2) => {
      const reader = new FileReader();
      reader.onload = (event) => resolve2(event?.target?.result);
      reader.readAsDataURL(blobSlice);
    });
  }
  if (resource instanceof ArrayBuffer) {
    const slice = resource.slice(0, INITIAL_DATA_LENGTH);
    const base64 = arrayBufferToBase64(slice);
    return `data:base64,${base64}`;
  }
  return null;
}
function arrayBufferToBase64(buffer) {
  let binary = "";
  const bytes = new Uint8Array(buffer);
  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}

// ../../node_modules/.pnpm/@loaders.gl+core@4.3.3/node_modules/@loaders.gl/core/dist/lib/fetch/fetch-file.js
function isNodePath(url) {
  return !isRequestURL(url) && !isDataURL(url);
}
function isRequestURL(url) {
  return url.startsWith("http:") || url.startsWith("https:");
}
function isDataURL(url) {
  return url.startsWith("data:");
}
async function fetchFile(urlOrData, fetchOptions) {
  if (typeof urlOrData === "string") {
    const url = resolvePath2(urlOrData);
    if (isNodePath(url)) {
      if (globalThis.loaders?.fetchNode) {
        return globalThis.loaders?.fetchNode(url, fetchOptions);
      }
    }
    return await fetch(url, fetchOptions);
  }
  return await makeResponse(urlOrData);
}

// ../../node_modules/.pnpm/@loaders.gl+core@4.3.3/node_modules/@loaders.gl/core/dist/lib/loader-utils/loggers.js
var probeLog = new Log({ id: "loaders.gl" });
var NullLog = class {
  log() {
    return () => {
    };
  }
  info() {
    return () => {
    };
  }
  warn() {
    return () => {
    };
  }
  error() {
    return () => {
    };
  }
};
var ConsoleLog = class {
  console;
  constructor() {
    this.console = console;
  }
  log(...args) {
    return this.console.log.bind(this.console, ...args);
  }
  info(...args) {
    return this.console.info.bind(this.console, ...args);
  }
  warn(...args) {
    return this.console.warn.bind(this.console, ...args);
  }
  error(...args) {
    return this.console.error.bind(this.console, ...args);
  }
};

// ../../node_modules/.pnpm/@loaders.gl+core@4.3.3/node_modules/@loaders.gl/core/dist/lib/loader-utils/option-defaults.js
var DEFAULT_LOADER_OPTIONS = {
  // baseUri
  fetch: null,
  mimeType: void 0,
  nothrow: false,
  log: new ConsoleLog(),
  // A probe.gl compatible (`log.log()()` syntax) that just logs to console
  useLocalLibraries: false,
  CDN: "https://unpkg.com/@loaders.gl",
  worker: true,
  // By default, use worker if provided by loader.
  maxConcurrency: 3,
  // How many worker instances should be created for each loader.
  maxMobileConcurrency: 1,
  // How many worker instances should be created for each loader on mobile devices.
  reuseWorkers: isBrowser,
  // By default reuse workers in browser (Node.js refuses to terminate if browsers are running)
  _nodeWorkers: false,
  // By default do not support node workers
  _workerType: "",
  // 'test' to use locally generated workers
  limit: 0,
  _limitMB: 0,
  batchSize: "auto",
  batchDebounceMs: 0,
  metadata: false,
  // TODO - currently only implemented for parseInBatches, adds initial metadata batch,
  transforms: []
};
var REMOVED_LOADER_OPTIONS = {
  throws: "nothrow",
  dataType: "(no longer used)",
  uri: "baseUri",
  // Warn if fetch options are used on top-level
  method: "fetch.method",
  headers: "fetch.headers",
  body: "fetch.body",
  mode: "fetch.mode",
  credentials: "fetch.credentials",
  cache: "fetch.cache",
  redirect: "fetch.redirect",
  referrer: "fetch.referrer",
  referrerPolicy: "fetch.referrerPolicy",
  integrity: "fetch.integrity",
  keepalive: "fetch.keepalive",
  signal: "fetch.signal"
};

// ../../node_modules/.pnpm/@loaders.gl+core@4.3.3/node_modules/@loaders.gl/core/dist/lib/loader-utils/option-utils.js
function getGlobalLoaderState() {
  globalThis.loaders = globalThis.loaders || {};
  const { loaders } = globalThis;
  if (!loaders._state) {
    loaders._state = {};
  }
  return loaders._state;
}
function getGlobalLoaderOptions() {
  const state = getGlobalLoaderState();
  state.globalOptions = state.globalOptions || { ...DEFAULT_LOADER_OPTIONS };
  return state.globalOptions;
}
function normalizeOptions(options, loader, loaders, url) {
  loaders = loaders || [];
  loaders = Array.isArray(loaders) ? loaders : [loaders];
  validateOptions(options, loaders);
  return normalizeOptionsInternal(loader, options, url);
}
function validateOptions(options, loaders) {
  validateOptionsObject(options, null, DEFAULT_LOADER_OPTIONS, REMOVED_LOADER_OPTIONS, loaders);
  for (const loader of loaders) {
    const idOptions = options && options[loader.id] || {};
    const loaderOptions = loader.options && loader.options[loader.id] || {};
    const deprecatedOptions = loader.deprecatedOptions && loader.deprecatedOptions[loader.id] || {};
    validateOptionsObject(idOptions, loader.id, loaderOptions, deprecatedOptions, loaders);
  }
}
function validateOptionsObject(options, id, defaultOptions, deprecatedOptions, loaders) {
  const loaderName = id || "Top level";
  const prefix = id ? `${id}.` : "";
  for (const key in options) {
    const isSubOptions = !id && isObject2(options[key]);
    const isBaseUriOption = key === "baseUri" && !id;
    const isWorkerUrlOption = key === "workerUrl" && id;
    if (!(key in defaultOptions) && !isBaseUriOption && !isWorkerUrlOption) {
      if (key in deprecatedOptions) {
        probeLog.warn(`${loaderName} loader option '${prefix}${key}' no longer supported, use '${deprecatedOptions[key]}'`)();
      } else if (!isSubOptions) {
        const suggestion = findSimilarOption(key, loaders);
        probeLog.warn(`${loaderName} loader option '${prefix}${key}' not recognized. ${suggestion}`)();
      }
    }
  }
}
function findSimilarOption(optionKey, loaders) {
  const lowerCaseOptionKey = optionKey.toLowerCase();
  let bestSuggestion = "";
  for (const loader of loaders) {
    for (const key in loader.options) {
      if (optionKey === key) {
        return `Did you mean '${loader.id}.${key}'?`;
      }
      const lowerCaseKey = key.toLowerCase();
      const isPartialMatch = lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey);
      if (isPartialMatch) {
        bestSuggestion = bestSuggestion || `Did you mean '${loader.id}.${key}'?`;
      }
    }
  }
  return bestSuggestion;
}
function normalizeOptionsInternal(loader, options, url) {
  const loaderDefaultOptions = loader.options || {};
  const mergedOptions = { ...loaderDefaultOptions };
  addUrlOptions(mergedOptions, url);
  if (mergedOptions.log === null) {
    mergedOptions.log = new NullLog();
  }
  mergeNestedFields(mergedOptions, getGlobalLoaderOptions());
  mergeNestedFields(mergedOptions, options);
  return mergedOptions;
}
function mergeNestedFields(mergedOptions, options) {
  for (const key in options) {
    if (key in options) {
      const value = options[key];
      if (isPureObject(value) && isPureObject(mergedOptions[key])) {
        mergedOptions[key] = {
          ...mergedOptions[key],
          ...options[key]
        };
      } else {
        mergedOptions[key] = options[key];
      }
    }
  }
}
function addUrlOptions(options, url) {
  if (url && !("baseUri" in options)) {
    options.baseUri = url;
  }
}

// ../../node_modules/.pnpm/@loaders.gl+core@4.3.3/node_modules/@loaders.gl/core/dist/lib/loader-utils/normalize-loader.js
function isLoaderObject(loader) {
  if (!loader) {
    return false;
  }
  if (Array.isArray(loader)) {
    loader = loader[0];
  }
  const hasExtensions = Array.isArray(loader?.extensions);
  return hasExtensions;
}
function normalizeLoader(loader) {
  assert(loader, "null loader");
  assert(isLoaderObject(loader), "invalid loader");
  let options;
  if (Array.isArray(loader)) {
    options = loader[1];
    loader = loader[0];
    loader = {
      ...loader,
      options: { ...loader.options, ...options }
    };
  }
  if (loader?.parseTextSync || loader?.parseText) {
    loader.text = true;
  }
  if (!loader.text) {
    loader.binary = true;
  }
  return loader;
}

// ../../node_modules/.pnpm/@loaders.gl+core@4.3.3/node_modules/@loaders.gl/core/dist/lib/api/register-loaders.js
var getGlobalLoaderRegistry = () => {
  const state = getGlobalLoaderState();
  state.loaderRegistry = state.loaderRegistry || [];
  return state.loaderRegistry;
};
function getRegisteredLoaders() {
  return getGlobalLoaderRegistry();
}

// ../../node_modules/.pnpm/@loaders.gl+core@4.3.3/node_modules/@loaders.gl/core/dist/lib/api/select-loader.js
var EXT_PATTERN = /\.([^.]+)$/;
async function selectLoader(data, loaders = [], options, context) {
  if (!validHTTPResponse(data)) {
    return null;
  }
  let loader = selectLoaderSync(data, loaders, { ...options, nothrow: true }, context);
  if (loader) {
    return loader;
  }
  if (isBlob(data)) {
    data = await data.slice(0, 10).arrayBuffer();
    loader = selectLoaderSync(data, loaders, options, context);
  }
  if (!loader && !options?.nothrow) {
    throw new Error(getNoValidLoaderMessage(data));
  }
  return loader;
}
function selectLoaderSync(data, loaders = [], options, context) {
  if (!validHTTPResponse(data)) {
    return null;
  }
  if (loaders && !Array.isArray(loaders)) {
    return normalizeLoader(loaders);
  }
  let candidateLoaders = [];
  if (loaders) {
    candidateLoaders = candidateLoaders.concat(loaders);
  }
  if (!options?.ignoreRegisteredLoaders) {
    candidateLoaders.push(...getRegisteredLoaders());
  }
  normalizeLoaders(candidateLoaders);
  const loader = selectLoaderInternal(data, candidateLoaders, options, context);
  if (!loader && !options?.nothrow) {
    throw new Error(getNoValidLoaderMessage(data));
  }
  return loader;
}
function selectLoaderInternal(data, loaders, options, context) {
  const url = getResourceUrl(data);
  const type = getResourceMIMEType(data);
  const testUrl = stripQueryString(url) || context?.url;
  let loader = null;
  let reason = "";
  if (options?.mimeType) {
    loader = findLoaderByMIMEType(loaders, options?.mimeType);
    reason = `match forced by supplied MIME type ${options?.mimeType}`;
  }
  loader = loader || findLoaderByUrl(loaders, testUrl);
  reason = reason || (loader ? `matched url ${testUrl}` : "");
  loader = loader || findLoaderByMIMEType(loaders, type);
  reason = reason || (loader ? `matched MIME type ${type}` : "");
  loader = loader || findLoaderByInitialBytes(loaders, data);
  reason = reason || (loader ? `matched initial data ${getFirstCharacters2(data)}` : "");
  if (options?.fallbackMimeType) {
    loader = loader || findLoaderByMIMEType(loaders, options?.fallbackMimeType);
    reason = reason || (loader ? `matched fallback MIME type ${type}` : "");
  }
  if (reason) {
    log.log(1, `selectLoader selected ${loader?.name}: ${reason}.`);
  }
  return loader;
}
function validHTTPResponse(data) {
  if (data instanceof Response) {
    if (data.status === 204) {
      return false;
    }
  }
  return true;
}
function getNoValidLoaderMessage(data) {
  const url = getResourceUrl(data);
  const type = getResourceMIMEType(data);
  let message = "No valid loader found (";
  message += url ? `${path_exports.filename(url)}, ` : "no url provided, ";
  message += `MIME type: ${type ? `"${type}"` : "not provided"}, `;
  const firstCharacters = data ? getFirstCharacters2(data) : "";
  message += firstCharacters ? ` first bytes: "${firstCharacters}"` : "first bytes: not available";
  message += ")";
  return message;
}
function normalizeLoaders(loaders) {
  for (const loader of loaders) {
    normalizeLoader(loader);
  }
}
function findLoaderByUrl(loaders, url) {
  const match = url && EXT_PATTERN.exec(url);
  const extension = match && match[1];
  return extension ? findLoaderByExtension(loaders, extension) : null;
}
function findLoaderByExtension(loaders, extension) {
  extension = extension.toLowerCase();
  for (const loader of loaders) {
    for (const loaderExtension of loader.extensions) {
      if (loaderExtension.toLowerCase() === extension) {
        return loader;
      }
    }
  }
  return null;
}
function findLoaderByMIMEType(loaders, mimeType) {
  for (const loader of loaders) {
    if (loader.mimeTypes?.some((mimeType1) => compareMIMETypes(mimeType, mimeType1))) {
      return loader;
    }
    if (compareMIMETypes(mimeType, `application/x.${loader.id}`)) {
      return loader;
    }
  }
  return null;
}
function findLoaderByInitialBytes(loaders, data) {
  if (!data) {
    return null;
  }
  for (const loader of loaders) {
    if (typeof data === "string") {
      if (testDataAgainstText(data, loader)) {
        return loader;
      }
    } else if (ArrayBuffer.isView(data)) {
      if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {
        return loader;
      }
    } else if (data instanceof ArrayBuffer) {
      const byteOffset = 0;
      if (testDataAgainstBinary(data, byteOffset, loader)) {
        return loader;
      }
    }
  }
  return null;
}
function testDataAgainstText(data, loader) {
  if (loader.testText) {
    return loader.testText(data);
  }
  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
  return tests.some((test) => data.startsWith(test));
}
function testDataAgainstBinary(data, byteOffset, loader) {
  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
  return tests.some((test) => testBinary(data, byteOffset, loader, test));
}
function testBinary(data, byteOffset, loader, test) {
  if (test instanceof ArrayBuffer) {
    return compareArrayBuffers(test, data, test.byteLength);
  }
  switch (typeof test) {
    case "function":
      return test(data);
    case "string":
      const magic = getMagicString2(data, byteOffset, test.length);
      return test === magic;
    default:
      return false;
  }
}
function getFirstCharacters2(data, length = 5) {
  if (typeof data === "string") {
    return data.slice(0, length);
  } else if (ArrayBuffer.isView(data)) {
    return getMagicString2(data.buffer, data.byteOffset, length);
  } else if (data instanceof ArrayBuffer) {
    const byteOffset = 0;
    return getMagicString2(data, byteOffset, length);
  }
  return "";
}
function getMagicString2(arrayBuffer, byteOffset, length) {
  if (arrayBuffer.byteLength < byteOffset + length) {
    return "";
  }
  const dataView = new DataView(arrayBuffer);
  let magic = "";
  for (let i = 0; i < length; i++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
  }
  return magic;
}

// ../../node_modules/.pnpm/@loaders.gl+core@4.3.3/node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-string-iterator.js
var DEFAULT_CHUNK_SIZE = 256 * 1024;
function* makeStringIterator(string, options) {
  const chunkSize = options?.chunkSize || DEFAULT_CHUNK_SIZE;
  let offset = 0;
  const textEncoder = new TextEncoder();
  while (offset < string.length) {
    const chunkLength = Math.min(string.length - offset, chunkSize);
    const chunk = string.slice(offset, offset + chunkLength);
    offset += chunkLength;
    yield textEncoder.encode(chunk);
  }
}

// ../../node_modules/.pnpm/@loaders.gl+core@4.3.3/node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-array-buffer-iterator.js
var DEFAULT_CHUNK_SIZE2 = 256 * 1024;
function* makeArrayBufferIterator(arrayBuffer, options = {}) {
  const { chunkSize = DEFAULT_CHUNK_SIZE2 } = options;
  let byteOffset = 0;
  while (byteOffset < arrayBuffer.byteLength) {
    const chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);
    const chunk = new ArrayBuffer(chunkByteLength);
    const sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);
    const chunkArray = new Uint8Array(chunk);
    chunkArray.set(sourceArray);
    byteOffset += chunkByteLength;
    yield chunk;
  }
}

// ../../node_modules/.pnpm/@loaders.gl+core@4.3.3/node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-blob-iterator.js
var DEFAULT_CHUNK_SIZE3 = 1024 * 1024;
async function* makeBlobIterator(blob, options) {
  const chunkSize = options?.chunkSize || DEFAULT_CHUNK_SIZE3;
  let offset = 0;
  while (offset < blob.size) {
    const end = offset + chunkSize;
    const chunk = await blob.slice(offset, end).arrayBuffer();
    offset = end;
    yield chunk;
  }
}

// ../../node_modules/.pnpm/@loaders.gl+core@4.3.3/node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-stream-iterator.js
function makeStreamIterator(stream, options) {
  return isBrowser ? makeBrowserStreamIterator(stream, options) : makeNodeStreamIterator(stream, options);
}
async function* makeBrowserStreamIterator(stream, options) {
  const reader = stream.getReader();
  let nextBatchPromise;
  try {
    while (true) {
      const currentBatchPromise = nextBatchPromise || reader.read();
      if (options?._streamReadAhead) {
        nextBatchPromise = reader.read();
      }
      const { done, value } = await currentBatchPromise;
      if (done) {
        return;
      }
      yield toArrayBuffer3(value);
    }
  } catch (error) {
    reader.releaseLock();
  }
}
async function* makeNodeStreamIterator(stream, options) {
  for await (const chunk of stream) {
    yield toArrayBuffer3(chunk);
  }
}

// ../../node_modules/.pnpm/@loaders.gl+core@4.3.3/node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-iterator.js
function makeIterator(data, options) {
  if (typeof data === "string") {
    return makeStringIterator(data, options);
  }
  if (data instanceof ArrayBuffer) {
    return makeArrayBufferIterator(data, options);
  }
  if (isBlob(data)) {
    return makeBlobIterator(data, options);
  }
  if (isReadableStream(data)) {
    return makeStreamIterator(data, options);
  }
  if (isResponse(data)) {
    const response = data;
    return makeStreamIterator(response.body, options);
  }
  throw new Error("makeIterator");
}

// ../../node_modules/.pnpm/@loaders.gl+core@4.3.3/node_modules/@loaders.gl/core/dist/lib/loader-utils/get-data.js
var ERR_DATA = "Cannot convert supplied data type";
function getArrayBufferOrStringFromDataSync(data, loader, options) {
  if (loader.text && typeof data === "string") {
    return data;
  }
  if (isBuffer2(data)) {
    data = data.buffer;
  }
  if (data instanceof ArrayBuffer) {
    const arrayBuffer = data;
    if (loader.text && !loader.binary) {
      const textDecoder = new TextDecoder("utf8");
      return textDecoder.decode(arrayBuffer);
    }
    return arrayBuffer;
  }
  if (ArrayBuffer.isView(data)) {
    if (loader.text && !loader.binary) {
      const textDecoder = new TextDecoder("utf8");
      return textDecoder.decode(data);
    }
    let arrayBuffer = data.buffer;
    const byteLength = data.byteLength || data.length;
    if (data.byteOffset !== 0 || byteLength !== arrayBuffer.byteLength) {
      arrayBuffer = arrayBuffer.slice(data.byteOffset, data.byteOffset + byteLength);
    }
    return arrayBuffer;
  }
  throw new Error(ERR_DATA);
}
async function getArrayBufferOrStringFromData(data, loader, options) {
  const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);
  if (typeof data === "string" || isArrayBuffer) {
    return getArrayBufferOrStringFromDataSync(data, loader, options);
  }
  if (isBlob(data)) {
    data = await makeResponse(data);
  }
  if (isResponse(data)) {
    const response = data;
    await checkResponse(response);
    return loader.binary ? await response.arrayBuffer() : await response.text();
  }
  if (isReadableStream(data)) {
    data = makeIterator(data, options);
  }
  if (isIterable(data) || isAsyncIterable(data)) {
    return concatenateArrayBuffersAsync(data);
  }
  throw new Error(ERR_DATA);
}

// ../../node_modules/.pnpm/@loaders.gl+core@4.3.3/node_modules/@loaders.gl/core/dist/lib/loader-utils/get-fetch-function.js
function getFetchFunction(options, context) {
  const globalOptions = getGlobalLoaderOptions();
  const loaderOptions = options || globalOptions;
  if (typeof loaderOptions.fetch === "function") {
    return loaderOptions.fetch;
  }
  if (isObject2(loaderOptions.fetch)) {
    return (url) => fetchFile(url, loaderOptions.fetch);
  }
  if (context?.fetch) {
    return context?.fetch;
  }
  return fetchFile;
}

// ../../node_modules/.pnpm/@loaders.gl+core@4.3.3/node_modules/@loaders.gl/core/dist/lib/loader-utils/loader-context.js
function getLoaderContext(context, options, parentContext) {
  if (parentContext) {
    return parentContext;
  }
  const newContext = {
    fetch: getFetchFunction(options, context),
    ...context
  };
  if (newContext.url) {
    const baseUrl = stripQueryString(newContext.url);
    newContext.baseUrl = baseUrl;
    newContext.queryString = extractQueryString(newContext.url);
    newContext.filename = path_exports.filename(baseUrl);
    newContext.baseUrl = path_exports.dirname(baseUrl);
  }
  if (!Array.isArray(newContext.loaders)) {
    newContext.loaders = null;
  }
  return newContext;
}
function getLoadersFromContext(loaders, context) {
  if (loaders && !Array.isArray(loaders)) {
    return loaders;
  }
  let candidateLoaders;
  if (loaders) {
    candidateLoaders = Array.isArray(loaders) ? loaders : [loaders];
  }
  if (context && context.loaders) {
    const contextLoaders = Array.isArray(context.loaders) ? context.loaders : [context.loaders];
    candidateLoaders = candidateLoaders ? [...candidateLoaders, ...contextLoaders] : contextLoaders;
  }
  return candidateLoaders && candidateLoaders.length ? candidateLoaders : void 0;
}

// ../../node_modules/.pnpm/@loaders.gl+core@4.3.3/node_modules/@loaders.gl/core/dist/lib/api/parse.js
async function parse7(data, loaders, options, context) {
  if (loaders && !Array.isArray(loaders) && !isLoaderObject(loaders)) {
    context = void 0;
    options = loaders;
    loaders = void 0;
  }
  data = await data;
  options = options || {};
  const url = getResourceUrl(data);
  const typedLoaders = loaders;
  const candidateLoaders = getLoadersFromContext(typedLoaders, context);
  const loader = await selectLoader(data, candidateLoaders, options);
  if (!loader) {
    return null;
  }
  options = normalizeOptions(options, loader, candidateLoaders, url);
  context = getLoaderContext(
    // @ts-expect-error
    { url, _parse: parse7, loaders: candidateLoaders },
    options,
    context || null
  );
  return await parseWithLoader(loader, data, options, context);
}
async function parseWithLoader(loader, data, options, context) {
  validateWorkerVersion(loader);
  options = mergeLoaderOptions(loader.options, options);
  if (isResponse(data)) {
    const response = data;
    const { ok, redirected, status, statusText, type, url } = response;
    const headers = Object.fromEntries(response.headers.entries());
    context.response = { headers, ok, redirected, status, statusText, type, url };
  }
  data = await getArrayBufferOrStringFromData(data, loader, options);
  const loaderWithParser = loader;
  if (loaderWithParser.parseTextSync && typeof data === "string") {
    return loaderWithParser.parseTextSync(data, options, context);
  }
  if (canParseWithWorker(loader, options)) {
    return await parseWithWorker(loader, data, options, context, parse7);
  }
  if (loaderWithParser.parseText && typeof data === "string") {
    return await loaderWithParser.parseText(data, options, context);
  }
  if (loaderWithParser.parse) {
    return await loaderWithParser.parse(data, options, context);
  }
  assert3(!loaderWithParser.parseSync);
  throw new Error(`${loader.id} loader - no parser found and worker is disabled`);
}

// ../../node_modules/.pnpm/@loaders.gl+schema@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/schema/dist/lib/table/simple-table/data-type.js
function getDataTypeFromTypedArray(array) {
  switch (array.constructor) {
    case Int8Array:
      return "int8";
    case Uint8Array:
    case Uint8ClampedArray:
      return "uint8";
    case Int16Array:
      return "int16";
    case Uint16Array:
      return "uint16";
    case Int32Array:
      return "int32";
    case Uint32Array:
      return "uint32";
    case Float32Array:
      return "float32";
    case Float64Array:
      return "float64";
    default:
      return "null";
  }
}

// ../../node_modules/.pnpm/@loaders.gl+schema@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/schema/dist/lib/mesh/mesh-utils.js
function getMeshBoundingBox(attributes) {
  let minX = Infinity;
  let minY = Infinity;
  let minZ = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  let maxZ = -Infinity;
  const positions = attributes.POSITION ? attributes.POSITION.value : [];
  const len = positions && positions.length;
  for (let i = 0; i < len; i += 3) {
    const x = positions[i];
    const y = positions[i + 1];
    const z = positions[i + 2];
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    minZ = z < minZ ? z : minZ;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    maxZ = z > maxZ ? z : maxZ;
  }
  return [
    [minX, minY, minZ],
    [maxX, maxY, maxZ]
  ];
}

// ../../node_modules/.pnpm/@loaders.gl+schema@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/schema/dist/lib/mesh/deduce-mesh-schema.js
function deduceMeshSchema(attributes, metadata = {}) {
  const fields = deduceMeshFields(attributes);
  return { fields, metadata };
}
function deduceMeshField(name12, attribute, optionalMetadata) {
  const type = getDataTypeFromTypedArray(attribute.value);
  const metadata = optionalMetadata ? optionalMetadata : makeMeshAttributeMetadata(attribute);
  return {
    name: name12,
    type: { type: "fixed-size-list", listSize: attribute.size, children: [{ name: "value", type }] },
    nullable: false,
    metadata
  };
}
function deduceMeshFields(attributes) {
  const fields = [];
  for (const attributeName in attributes) {
    const attribute = attributes[attributeName];
    fields.push(deduceMeshField(attributeName, attribute));
  }
  return fields;
}
function makeMeshAttributeMetadata(attribute) {
  const result = {};
  if ("byteOffset" in attribute) {
    result.byteOffset = attribute.byteOffset.toString(10);
  }
  if ("byteStride" in attribute) {
    result.byteStride = attribute.byteStride.toString(10);
  }
  if ("normalized" in attribute) {
    result.normalized = attribute.normalized.toString();
  }
  return result;
}

// ../../node_modules/.pnpm/@loaders.gl+las@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/las/dist/las-loader.js
var VERSION4 = true ? "4.3.2" : "latest";
var LASLoader = {
  dataType: null,
  batchType: null,
  name: "LAS",
  id: "las",
  module: "las",
  version: VERSION4,
  worker: true,
  extensions: ["las", "laz"],
  // LAZ is the "compressed" flavor of LAS,
  mimeTypes: ["application/octet-stream"],
  // TODO - text version?
  text: true,
  binary: true,
  tests: ["LAS"],
  options: {
    las: {
      shape: "mesh",
      fp64: false,
      skip: 1,
      colorDepth: 8
    }
  }
};

// ../../node_modules/.pnpm/@loaders.gl+las@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/las/dist/lib/libs/laz-perf.js
function getModule() {
  var Module2 = typeof Module2 !== "undefined" ? Module2 : {};
  var moduleOverrides = {};
  var key;
  for (key in Module2) {
    if (Module2.hasOwnProperty(key)) {
      moduleOverrides[key] = Module2[key];
    }
  }
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = function(status, toThrow) {
    throw toThrow;
  };
  var ENVIRONMENT_IS_WEB = false;
  var ENVIRONMENT_IS_WORKER = false;
  var ENVIRONMENT_IS_NODE = false;
  var ENVIRONMENT_IS_SHELL = false;
  ENVIRONMENT_IS_WEB = typeof window === "object";
  ENVIRONMENT_IS_WORKER = typeof importScripts === "function";
  ENVIRONMENT_IS_NODE = typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node === "string";
  ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
  var scriptDirectory = "";
  function locateFile(path) {
    if (Module2["locateFile"]) {
      return Module2["locateFile"](path, scriptDirectory);
    }
    return scriptDirectory + path;
  }
  var read_, readAsync, readBinary, setWindowTitle;
  var nodeFS;
  var nodePath;
  if (ENVIRONMENT_IS_NODE) {
    if (ENVIRONMENT_IS_WORKER) {
      scriptDirectory = require_path().dirname(scriptDirectory) + "/";
    } else {
      const dirname2 = typeof __dirname !== "undefined" ? __dirname : "";
      scriptDirectory = dirname2 + "/";
    }
    read_ = function shell_read(filename2, binary) {
      var ret = tryParseAsDataURI(filename2);
      if (ret) {
        return binary ? ret : ret.toString();
      }
      if (!nodeFS)
        nodeFS = require_fs();
      if (!nodePath)
        nodePath = require_path();
      filename2 = nodePath["normalize"](filename2);
      return nodeFS["readFileSync"](filename2, binary ? null : "utf8");
    };
    readBinary = function readBinary2(filename2) {
      var ret = read_(filename2, true);
      if (!ret.buffer) {
        ret = new Uint8Array(ret);
      }
      assert6(ret.buffer);
      return ret;
    };
    if (process["argv"].length > 1) {
      thisProgram = process["argv"][1].replace(/\\/g, "/");
    }
    arguments_ = process["argv"].slice(2);
    if (typeof module !== "undefined") {
      module["exports"] = Module2;
    }
    process["on"]("uncaughtException", function(ex) {
      if (!(ex instanceof ExitStatus)) {
        throw ex;
      }
    });
    process["on"]("unhandledRejection", abort);
    quit_ = function(status) {
      process["exit"](status);
    };
    Module2["inspect"] = function() {
      return "[Emscripten Module object]";
    };
  } else if (ENVIRONMENT_IS_SHELL) {
    if (typeof read != "undefined") {
      read_ = function shell_read(f) {
        var data2 = tryParseAsDataURI(f);
        if (data2) {
          return intArrayToString(data2);
        }
        return read(f);
      };
    }
    readBinary = function readBinary2(f) {
      var data2;
      data2 = tryParseAsDataURI(f);
      if (data2) {
        return data2;
      }
      if (typeof readbuffer === "function") {
        return new Uint8Array(readbuffer(f));
      }
      data2 = read(f, "binary");
      assert6(typeof data2 === "object");
      return data2;
    };
    if (typeof scriptArgs != "undefined") {
      arguments_ = scriptArgs;
    } else if (typeof arguments != "undefined") {
      arguments_ = arguments;
    }
    if (typeof quit === "function") {
      quit_ = function(status) {
        quit(status);
      };
    }
    if (typeof print !== "undefined") {
      if (typeof console === "undefined")
        console = {};
      console.log = print;
      console.warn = console.error = typeof printErr !== "undefined" ? printErr : print;
    }
  } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
    if (ENVIRONMENT_IS_WORKER) {
      scriptDirectory = self.location.href;
    } else if (document.currentScript) {
      scriptDirectory = document.currentScript.src;
    }
    if (scriptDirectory.indexOf("blob:") !== 0) {
      scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1);
    } else {
      scriptDirectory = "";
    }
    {
      read_ = function shell_read(url) {
        try {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", url, false);
          xhr.send(null);
          return xhr.responseText;
        } catch (err3) {
          var data2 = tryParseAsDataURI(url);
          if (data2) {
            return intArrayToString(data2);
          }
          throw err3;
        }
      };
      if (ENVIRONMENT_IS_WORKER) {
        readBinary = function readBinary2(url) {
          try {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, false);
            xhr.responseType = "arraybuffer";
            xhr.send(null);
            return new Uint8Array(xhr.response);
          } catch (err3) {
            var data2 = tryParseAsDataURI(url);
            if (data2) {
              return data2;
            }
            throw err3;
          }
        };
      }
      readAsync = function readAsync2(url, onload, onerror) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", url, true);
        xhr.responseType = "arraybuffer";
        xhr.onload = function xhr_onload() {
          if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
            onload(xhr.response);
            return;
          }
          var data2 = tryParseAsDataURI(url);
          if (data2) {
            onload(data2.buffer);
            return;
          }
          onerror();
        };
        xhr.onerror = onerror;
        xhr.send(null);
      };
    }
    setWindowTitle = function(title) {
      document.title = title;
    };
  } else {
  }
  var out = Module2["print"] || console.log.bind(console);
  var err2 = Module2["printErr"] || console.warn.bind(console);
  for (key in moduleOverrides) {
    if (moduleOverrides.hasOwnProperty(key)) {
      Module2[key] = moduleOverrides[key];
    }
  }
  moduleOverrides = null;
  if (Module2["arguments"])
    arguments_ = Module2["arguments"];
  if (Module2["thisProgram"])
    thisProgram = Module2["thisProgram"];
  if (Module2["quit"])
    quit_ = Module2["quit"];
  var STACK_ALIGN = 16;
  function dynamicAlloc(size) {
    var ret = HEAP32[DYNAMICTOP_PTR >> 2];
    var end = ret + size + 15 & -16;
    HEAP32[DYNAMICTOP_PTR >> 2] = end;
    return ret;
  }
  function getNativeTypeSize(type) {
    switch (type) {
      case "i1":
      case "i8":
        return 1;
      case "i16":
        return 2;
      case "i32":
        return 4;
      case "i64":
        return 8;
      case "float":
        return 4;
      case "double":
        return 8;
      default: {
        if (type[type.length - 1] === "*") {
          return 4;
        } else if (type[0] === "i") {
          var bits = Number(type.substr(1));
          assert6(bits % 8 === 0, "getNativeTypeSize invalid bits " + bits + ", type " + type);
          return bits / 8;
        } else {
          return 0;
        }
      }
    }
  }
  function warnOnce(text) {
    if (!warnOnce.shown)
      warnOnce.shown = {};
    if (!warnOnce.shown[text]) {
      warnOnce.shown[text] = 1;
      err2(text);
    }
  }
  var jsCallStartIndex = 1;
  var functionPointers = new Array(0);
  var funcWrappers = {};
  function dynCall(sig, ptr, args) {
    if (args && args.length) {
      return Module2["dynCall_" + sig].apply(null, [ptr].concat(args));
    } else {
      return Module2["dynCall_" + sig].call(null, ptr);
    }
  }
  var tempRet0 = 0;
  var setTempRet0 = function(value) {
    tempRet0 = value;
  };
  var getTempRet0 = function() {
    return tempRet0;
  };
  var GLOBAL_BASE = 8;
  var wasmBinary;
  if (Module2["wasmBinary"])
    wasmBinary = Module2["wasmBinary"];
  var noExitRuntime;
  if (Module2["noExitRuntime"])
    noExitRuntime = Module2["noExitRuntime"];
  function setValue(ptr, value, type, noSafe) {
    type = type || "i8";
    if (type.charAt(type.length - 1) === "*")
      type = "i32";
    switch (type) {
      case "i1":
        HEAP8[ptr >> 0] = value;
        break;
      case "i8":
        HEAP8[ptr >> 0] = value;
        break;
      case "i16":
        HEAP16[ptr >> 1] = value;
        break;
      case "i32":
        HEAP32[ptr >> 2] = value;
        break;
      case "i64":
        tempI64 = [
          value >>> 0,
          (tempDouble = value, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)
        ], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];
        break;
      case "float":
        HEAPF32[ptr >> 2] = value;
        break;
      case "double":
        HEAPF64[ptr >> 3] = value;
        break;
      default:
        abort("invalid type for setValue: " + type);
    }
  }
  var ABORT = false;
  var EXITSTATUS = 0;
  function assert6(condition, text) {
    if (!condition) {
      abort("Assertion failed: " + text);
    }
  }
  function getCFunc(ident) {
    var func = Module2["_" + ident];
    assert6(func, "Cannot call unknown function " + ident + ", make sure it is exported");
    return func;
  }
  function ccall(ident, returnType, argTypes, args, opts) {
    var toC = {
      string: function(str) {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          var len = (str.length << 2) + 1;
          ret2 = stackAlloc(len);
          stringToUTF8(str, ret2, len);
        }
        return ret2;
      },
      array: function(arr) {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string")
        return UTF8ToString(ret2);
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var ret = func.apply(null, cArgs);
    ret = convertReturnValue(ret);
    if (stack !== 0)
      stackRestore(stack);
    return ret;
  }
  var ALLOC_NONE = 3;
  var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : void 0;
  function UTF8ArrayToString(heap, idx, maxBytesToRead) {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heap[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
      return UTF8Decoder.decode(heap.subarray(idx, endPtr));
    } else {
      var str = "";
      while (idx < endPtr) {
        var u0 = heap[idx++];
        if (!(u0 & 128)) {
          str += String.fromCharCode(u0);
          continue;
        }
        var u1 = heap[idx++] & 63;
        if ((u0 & 224) == 192) {
          str += String.fromCharCode((u0 & 31) << 6 | u1);
          continue;
        }
        var u2 = heap[idx++] & 63;
        if ((u0 & 240) == 224) {
          u0 = (u0 & 15) << 12 | u1 << 6 | u2;
        } else {
          u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;
        }
        if (u0 < 65536) {
          str += String.fromCharCode(u0);
        } else {
          var ch = u0 - 65536;
          str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
        }
      }
    }
    return str;
  }
  function UTF8ToString(ptr, maxBytesToRead) {
    return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  }
  function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  }
  function stringToUTF8(str, outPtr, maxBytesToWrite) {
    return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  }
  function lengthBytesUTF8(str) {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343)
        u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
      if (u <= 127)
        ++len;
      else if (u <= 2047)
        len += 2;
      else if (u <= 65535)
        len += 3;
      else
        len += 4;
    }
    return len;
  }
  var UTF16Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : void 0;
  function UTF16ToString(ptr, maxBytesToRead) {
    var endPtr = ptr;
    var idx = endPtr >> 1;
    var maxIdx = idx + maxBytesToRead / 2;
    while (!(idx >= maxIdx) && HEAPU16[idx])
      ++idx;
    endPtr = idx << 1;
    if (endPtr - ptr > 32 && UTF16Decoder) {
      return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
    } else {
      var i = 0;
      var str = "";
      while (1) {
        var codeUnit = HEAP16[ptr + i * 2 >> 1];
        if (codeUnit == 0 || i == maxBytesToRead / 2)
          return str;
        ++i;
        str += String.fromCharCode(codeUnit);
      }
    }
  }
  function stringToUTF16(str, outPtr, maxBytesToWrite) {
    if (maxBytesToWrite === void 0) {
      maxBytesToWrite = 2147483647;
    }
    if (maxBytesToWrite < 2)
      return 0;
    maxBytesToWrite -= 2;
    var startPtr = outPtr;
    var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
    for (var i = 0; i < numCharsToWrite; ++i) {
      var codeUnit = str.charCodeAt(i);
      HEAP16[outPtr >> 1] = codeUnit;
      outPtr += 2;
    }
    HEAP16[outPtr >> 1] = 0;
    return outPtr - startPtr;
  }
  function lengthBytesUTF16(str) {
    return str.length * 2;
  }
  function UTF32ToString(ptr, maxBytesToRead) {
    var i = 0;
    var str = "";
    while (!(i >= maxBytesToRead / 4)) {
      var utf32 = HEAP32[ptr + i * 4 >> 2];
      if (utf32 == 0)
        break;
      ++i;
      if (utf32 >= 65536) {
        var ch = utf32 - 65536;
        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
      } else {
        str += String.fromCharCode(utf32);
      }
    }
    return str;
  }
  function stringToUTF32(str, outPtr, maxBytesToWrite) {
    if (maxBytesToWrite === void 0) {
      maxBytesToWrite = 2147483647;
    }
    if (maxBytesToWrite < 4)
      return 0;
    var startPtr = outPtr;
    var endPtr = startPtr + maxBytesToWrite - 4;
    for (var i = 0; i < str.length; ++i) {
      var codeUnit = str.charCodeAt(i);
      if (codeUnit >= 55296 && codeUnit <= 57343) {
        var trailSurrogate = str.charCodeAt(++i);
        codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;
      }
      HEAP32[outPtr >> 2] = codeUnit;
      outPtr += 4;
      if (outPtr + 4 > endPtr)
        break;
    }
    HEAP32[outPtr >> 2] = 0;
    return outPtr - startPtr;
  }
  function lengthBytesUTF32(str) {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var codeUnit = str.charCodeAt(i);
      if (codeUnit >= 55296 && codeUnit <= 57343)
        ++i;
      len += 4;
    }
    return len;
  }
  function writeArrayToMemory(array, buffer2) {
    HEAP8.set(array, buffer2);
  }
  function writeAsciiToMemory(str, buffer2, dontAddNull) {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer2++ >> 0] = str.charCodeAt(i);
    }
    if (!dontAddNull)
      HEAP8[buffer2 >> 0] = 0;
  }
  var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
  function updateGlobalBufferAndViews(buf) {
    buffer = buf;
    Module2["HEAP8"] = HEAP8 = new Int8Array(buf);
    Module2["HEAP16"] = HEAP16 = new Int16Array(buf);
    Module2["HEAP32"] = HEAP32 = new Int32Array(buf);
    Module2["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
    Module2["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
    Module2["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
    Module2["HEAPF32"] = HEAPF32 = new Float32Array(buf);
    Module2["HEAPF64"] = HEAPF64 = new Float64Array(buf);
  }
  var STACK_BASE = 22384, DYNAMIC_BASE = 5265264, DYNAMICTOP_PTR = 22176;
  var INITIAL_INITIAL_MEMORY = Module2["INITIAL_MEMORY"] || 167772160;
  if (Module2["buffer"]) {
    buffer = Module2["buffer"];
  } else {
    buffer = new ArrayBuffer(INITIAL_INITIAL_MEMORY);
  }
  INITIAL_INITIAL_MEMORY = buffer.byteLength;
  updateGlobalBufferAndViews(buffer);
  HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;
  function callRuntimeCallbacks(callbacks) {
    while (callbacks.length > 0) {
      var callback = callbacks.shift();
      if (typeof callback == "function") {
        callback(Module2);
        continue;
      }
      var func = callback.func;
      if (typeof func === "number") {
        if (callback.arg === void 0) {
          Module2["dynCall_v"](func);
        } else {
          Module2["dynCall_vi"](func, callback.arg);
        }
      } else {
        func(callback.arg === void 0 ? null : callback.arg);
      }
    }
  }
  var __ATPRERUN__ = [];
  var __ATINIT__ = [];
  var __ATMAIN__ = [];
  var __ATPOSTRUN__ = [];
  var runtimeInitialized = false;
  var runtimeExited = false;
  function preRun() {
    if (Module2["preRun"]) {
      if (typeof Module2["preRun"] == "function")
        Module2["preRun"] = [Module2["preRun"]];
      while (Module2["preRun"].length) {
        addOnPreRun(Module2["preRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPRERUN__);
  }
  function initRuntime() {
    runtimeInitialized = true;
    callRuntimeCallbacks(__ATINIT__);
  }
  function preMain() {
    callRuntimeCallbacks(__ATMAIN__);
  }
  function exitRuntime() {
    runtimeExited = true;
  }
  function postRun() {
    if (Module2["postRun"]) {
      if (typeof Module2["postRun"] == "function")
        Module2["postRun"] = [Module2["postRun"]];
      while (Module2["postRun"].length) {
        addOnPostRun(Module2["postRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPOSTRUN__);
  }
  function addOnPreRun(cb2) {
    __ATPRERUN__.unshift(cb2);
  }
  function addOnPostRun(cb2) {
    __ATPOSTRUN__.unshift(cb2);
  }
  var Math_abs = Math.abs;
  var Math_ceil = Math.ceil;
  var Math_floor = Math.floor;
  var Math_min = Math.min;
  var runDependencies = 0;
  var runDependencyWatcher = null;
  var dependenciesFulfilled = null;
  function addRunDependency(id) {
    runDependencies++;
    if (Module2["monitorRunDependencies"]) {
      Module2["monitorRunDependencies"](runDependencies);
    }
  }
  function removeRunDependency(id) {
    runDependencies--;
    if (Module2["monitorRunDependencies"]) {
      Module2["monitorRunDependencies"](runDependencies);
    }
    if (runDependencies == 0) {
      if (runDependencyWatcher !== null) {
        clearInterval(runDependencyWatcher);
        runDependencyWatcher = null;
      }
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  Module2["preloadedImages"] = {};
  Module2["preloadedAudios"] = {};
  function abort(what) {
    if (Module2["onAbort"]) {
      Module2["onAbort"](what);
    }
    what += "";
    out(what);
    err2(what);
    ABORT = true;
    EXITSTATUS = 1;
    what = "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
    throw what;
  }
  var memoryInitializer = null;
  function hasPrefix(str, prefix) {
    return String.prototype.startsWith ? str.startsWith(prefix) : str.indexOf(prefix) === 0;
  }
  var dataURIPrefix = "data:application/octet-stream;base64,";
  function isDataURI(filename2) {
    return hasPrefix(filename2, dataURIPrefix);
  }
  var fileURIPrefix = "file://";
  var tempDouble;
  var tempI64;
  __ATINIT__.push({
    func: function() {
      globalCtors();
    }
  });
  memoryInitializer = "data:application/octet-stream;base64,AAAAAAAAAAAPDg0MCwoJCA4AAQMGCgoJDQECBAcLCwoMAwQFCAwMCwsGBwgJDQ0MCgoLDA0ODg0JCgsMDQ4PDggJCgsMDQ4PAAECAwQFBgcBAAECAwQFBgIBAAECAwQFAwIBAAECAwQEAwIBAAECAwUEAwIBAAECBgUEAwIBAAEHBgUEAwIBAMgPAAAoDQAAEBAAACAQAADIDwAAUA0AABAQAAAgEAAAEQAKABEREQAAAAAFAAAAAAAACQAAAAALAAAAAAAAAAARAA8KERERAwoHAAEACQsLAAAJBgsAAAsABhEAAAAREREAAAAAAAAAAAAAAAAAAAAACwAAAAAAAAAAEQAKChEREQAKAAACAAkLAAAACQALAAALAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAADAAAAAAJDAAAAAAADAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAANAAAABA0AAAAACQ4AAAAAAA4AAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAADwAAAAAPAAAAAAkQAAAAAAAQAAAQAAASAAAAEhISAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAASEhIAAAAAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALAAAAAAAAAAAAAAAKAAAAAAoAAAAACQsAAAAAAAsAAAsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAMAAAAAAkMAAAAAAAMAAAMAAAwMTIzNDU2Nzg5QUJDREVGGRJEOwI/LEcUPTMwChsGRktFNw9JDo4XA0AdPGkrNh9KLRwBICUpIQgMFRYiLhA4Pgs0MRhkdHV2L0EJfzkRI0MyQomKiwUEJignDSoeNYwHGkiTE5SVAAAAAAAAAAAASWxsZWdhbCBieXRlIHNlcXVlbmNlAERvbWFpbiBlcnJvcgBSZXN1bHQgbm90IHJlcHJlc2VudGFibGUATm90IGEgdHR5AFBlcm1pc3Npb24gZGVuaWVkAE9wZXJhdGlvbiBub3QgcGVybWl0dGVkAE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnkATm8gc3VjaCBwcm9jZXNzAEZpbGUgZXhpc3RzAFZhbHVlIHRvbyBsYXJnZSBmb3IgZGF0YSB0eXBlAE5vIHNwYWNlIGxlZnQgb24gZGV2aWNlAE91dCBvZiBtZW1vcnkAUmVzb3VyY2UgYnVzeQBJbnRlcnJ1cHRlZCBzeXN0ZW0gY2FsbABSZXNvdXJjZSB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZQBJbnZhbGlkIHNlZWsAQ3Jvc3MtZGV2aWNlIGxpbmsAUmVhZC1vbmx5IGZpbGUgc3lzdGVtAERpcmVjdG9yeSBub3QgZW1wdHkAQ29ubmVjdGlvbiByZXNldCBieSBwZWVyAE9wZXJhdGlvbiB0aW1lZCBvdXQAQ29ubmVjdGlvbiByZWZ1c2VkAEhvc3QgaXMgZG93bgBIb3N0IGlzIHVucmVhY2hhYmxlAEFkZHJlc3MgaW4gdXNlAEJyb2tlbiBwaXBlAEkvTyBlcnJvcgBObyBzdWNoIGRldmljZSBvciBhZGRyZXNzAEJsb2NrIGRldmljZSByZXF1aXJlZABObyBzdWNoIGRldmljZQBOb3QgYSBkaXJlY3RvcnkASXMgYSBkaXJlY3RvcnkAVGV4dCBmaWxlIGJ1c3kARXhlYyBmb3JtYXQgZXJyb3IASW52YWxpZCBhcmd1bWVudABBcmd1bWVudCBsaXN0IHRvbyBsb25nAFN5bWJvbGljIGxpbmsgbG9vcABGaWxlbmFtZSB0b28gbG9uZwBUb28gbWFueSBvcGVuIGZpbGVzIGluIHN5c3RlbQBObyBmaWxlIGRlc2NyaXB0b3JzIGF2YWlsYWJsZQBCYWQgZmlsZSBkZXNjcmlwdG9yAE5vIGNoaWxkIHByb2Nlc3MAQmFkIGFkZHJlc3MARmlsZSB0b28gbGFyZ2UAVG9vIG1hbnkgbGlua3MATm8gbG9ja3MgYXZhaWxhYmxlAFJlc291cmNlIGRlYWRsb2NrIHdvdWxkIG9jY3VyAFN0YXRlIG5vdCByZWNvdmVyYWJsZQBQcmV2aW91cyBvd25lciBkaWVkAE9wZXJhdGlvbiBjYW5jZWxlZABGdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQATm8gbWVzc2FnZSBvZiBkZXNpcmVkIHR5cGUASWRlbnRpZmllciByZW1vdmVkAERldmljZSBub3QgYSBzdHJlYW0ATm8gZGF0YSBhdmFpbGFibGUARGV2aWNlIHRpbWVvdXQAT3V0IG9mIHN0cmVhbXMgcmVzb3VyY2VzAExpbmsgaGFzIGJlZW4gc2V2ZXJlZABQcm90b2NvbCBlcnJvcgBCYWQgbWVzc2FnZQBGaWxlIGRlc2NyaXB0b3IgaW4gYmFkIHN0YXRlAE5vdCBhIHNvY2tldABEZXN0aW5hdGlvbiBhZGRyZXNzIHJlcXVpcmVkAE1lc3NhZ2UgdG9vIGxhcmdlAFByb3RvY29sIHdyb25nIHR5cGUgZm9yIHNvY2tldABQcm90b2NvbCBub3QgYXZhaWxhYmxlAFByb3RvY29sIG5vdCBzdXBwb3J0ZWQAU29ja2V0IHR5cGUgbm90IHN1cHBvcnRlZABOb3Qgc3VwcG9ydGVkAFByb3RvY29sIGZhbWlseSBub3Qgc3VwcG9ydGVkAEFkZHJlc3MgZmFtaWx5IG5vdCBzdXBwb3J0ZWQgYnkgcHJvdG9jb2wAQWRkcmVzcyBub3QgYXZhaWxhYmxlAE5ldHdvcmsgaXMgZG93bgBOZXR3b3JrIHVucmVhY2hhYmxlAENvbm5lY3Rpb24gcmVzZXQgYnkgbmV0d29yawBDb25uZWN0aW9uIGFib3J0ZWQATm8gYnVmZmVyIHNwYWNlIGF2YWlsYWJsZQBTb2NrZXQgaXMgY29ubmVjdGVkAFNvY2tldCBub3QgY29ubmVjdGVkAENhbm5vdCBzZW5kIGFmdGVyIHNvY2tldCBzaHV0ZG93bgBPcGVyYXRpb24gYWxyZWFkeSBpbiBwcm9ncmVzcwBPcGVyYXRpb24gaW4gcHJvZ3Jlc3MAU3RhbGUgZmlsZSBoYW5kbGUAUmVtb3RlIEkvTyBlcnJvcgBRdW90YSBleGNlZWRlZABObyBtZWRpdW0gZm91bmQAV3JvbmcgbWVkaXVtIHR5cGUATm8gZXJyb3IgaW5mb3JtYXRpb24AAAAAAADgFgAAmRgAAGAQAAAAAAAA4BYAAEIZAABgEAAAAAAAAOAWAAAqGgAASA8AAAAAAAC4FgAANBsAAOAWAACfGgAAMAoAAAAAAADgFgAAaRsAAEgPAAAAAAAA4BYAAIobAABIDwAAAAAAALgWAAAPHAAA4BYAAHwcAABIDwAAAAAAAOAWAACVHAAASA8AAAAAAADgFgAAHh0AAEgPAAAAAAAA4BYAAHcdAABIDwAAAAAAAOAWAACQHQAASA8AAAAAAADgFgAAQh4AAEgPAAAAAAAA4BYAAIceAABgEAAAAAAAAOAWAACkHwAASA8AAAAAAAC4FgAAZyAAAOAWAADkHwAA8AoAAAAAAADgFgAAjyAAAGAQAAAAAAAAuBYAAMMiAADgFgAAAiIAABgLAAAAAAAA4BYAAOEiAABgEAAAAAAAAOAWAADQJAAAGAsAAAAAAADgFgAAkSUAAGAQAAAAAAAA4BYAAIAnAAAYCwAAAAAAAOAWAAA9KAAAYBAAAAAAAADgFgAAJCoAABgLAAAAAAAA4BYAAOkqAABgEAAAAAAAAOAWAADgLAAA8AoAAAAAAADgFgAAui0AAGAQAAAAAAAA4BYAANsvAADwCgAAAAAAAOAWAADTMAAAYBAAAAAAAADgFgAAMDMAAPAKAAAAAAAA4BYAACQ0AABgEAAAAAAAAOAWAAB5NgAA8AoAAAAAAADgFgAAizcAAGAQAAAAAAAA4BYAABw6AABgEAAAAAAAAOAWAACdOgAAYBAAAAAAAADgFgAAXjsAAPAKAAAAAAAA4BYAALU7AABgEAAAAAAAAOAWAADMPAAAGAsAAAAAAADgFgAATz0AAGAQAAAAAAAA4BYAAL4+AAAYCwAAAAAAAOAWAABBPwAAYBAAAAAAAADgFgAAsEAAABgLAAAAAAAA4BYAADNBAABgEAAAAAAAAOAWAACiQgAAGAsAAAAAAADgFgAAJUMAAGAQAAAAAAAA4BYAAJREAAAYCwAAAAAAAOAWAAAXRQAAYBAAAAAAAADgFgAAhkYAABgLAAAAAAAA4BYAAAlHAABgEAAAAAAAALgWAAB4SAAAiBcAAIBIAAAAAAAAIA0AAIgXAACJSAAAAQAAACANAAC4FgAAqkgAAIgXAAC6SAAAAAAAAEgNAACIFwAAy0gAAAEAAABIDQAAuBYAABhMAAC4FgAAN0wAALgWAABWTAAAuBYAAHVMAAC4FgAAlEwAALgWAACzTAAAuBYAANJMAAC4FgAA8UwAALgWAAAQTQAAuBYAAC9NAAC4FgAATk0AALgWAABtTQAAuBYAAIxNAACkFwAAn00AAAAAAAABAAAA8A0AAAAAAAC4FgAA4U0AAKQXAAAHTgAAAAAAAAEAAADwDQAAAAAAAKQXAABJTgAAAAAAAAEAAADwDQAAAAAAAKQXAACITgAAAAAAAAEAAADwDQAAAAAAAKQXAADHTgAAAAAAAAEAAADwDQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP//////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALgWAADNTwAA4BYAAC1QAAAADwAAAAAAAOAWAADaTwAAEA8AAAAAAAC4FgAA+08AAOAWAAAIUAAA8A4AAAAAAADgFgAAhlAAAOgOAAAAAAAA4BYAAJNQAADoDgAAAAAAAOAWAACjUAAA6A4AAAAAAADgFgAAtVAAADgPAAAAAAAA4BYAAMZQAAA4DwAAAAAAAOAWAADXUAAAAA8AAAAAAADgFgAA+VAAAHgPAAAAAAAA4BYAAB1RAAAADwAAAAAAAOAWAABCUQAAeA8AAAAAAADgFgAAjlEAAAAPAAAAAAAAbBcAALZRAABsFwAAuFEAAGwXAAC7UQAAbBcAAL1RAABsFwAAv1EAAGwXAADBUQAAbBcAAMNRAABsFwAAxVEAAGwXAADHUQAAbBcAAMlRAABsFwAAy1EAAGwXAADNUQAAbBcAAM9RAABsFwAA0VEAAOAWAADTUQAA8A4AAAAAAADgFgAARlIAAOgOAAAAAAAAuBYAAGJSAACkFwAAe1IAAAAAAAABAAAAWBAAAAAAAADgFgAA9FIAAIgQAAAAAAAA4BYAABdTAACYEAAAAAAAALgWAAAuUwAA4BYAAHBTAACIEAAAAAAAAOAWAACSUwAASA8AAAAAAAAAAAAAAAoAAAEAAAACAAAAAwAAAAEAAAAEAAAAAAAAABAKAAABAAAABQAAAAYAAAACAAAABwAAAAAAAAAgCgAACAAAAAkAAAABAAAAAAAAADgKAAAKAAAACwAAAAIAAAABAAAADAAAAA0AAAACAAAAAwAAAAMAAAAAAAAASAoAAAgAAAAOAAAAAQAAAAAAAABYCgAACAAAAA8AAAABAAAAAAAAAIAKAAAIAAAAEAAAAAEAAAAAAAAAcAoAAAgAAAARAAAAAQAAAAAAAACQCgAACAAAABIAAAABAAAAAAAAAKAKAAAIAAAAEwAAAAEAAAAAAAAAsAoAAAgAAAAUAAAAAQAAAAAAAADACgAACAAAABUAAAABAAAAAAAAANAKAAABAAAAFgAAABcAAAAEAAAAGAAAAAAAAADgCgAACAAAABkAAAABAAAAAAAAAPgKAAAFAAAAGgAAABsAAAAAAAAA8AoAAAEAAAAcAAAAHQAAAAAAAAAICwAAAQAAAB4AAAAfAAAABgAAACAAAAAAAAAAIAsAACEAAAAiAAAABwAAAAgAAAAAAAAAGAsAACMAAAAkAAAABwAAAAkAAAAAAAAAMAsAAAEAAAAlAAAAJgAAAAoAAAAnAAAAAAAAAEALAAAoAAAAKQAAAAcAAAALAAAAAAAAAFALAAABAAAAKgAAACsAAAAMAAAALAAAAAAAAABgCwAALQAAAC4AAAAHAAAADQAAAAAAAABwCwAAAQAAAC8AAAAwAAAADgAAADEAAAAAAAAAgAsAADIAAAAzAAAABwAAAA8AAAAAAAAAkAsAAAEAAAA0AAAANQAAABAAAAA2AAAAAAAAAKALAAARAAAANwAAADgAAAAAAAAAsAsAAAEAAAA5AAAAOgAAABIAAAA7AAAAAAAAAMALAAATAAAAPAAAAD0AAAAAAAAA0AsAAAEAAAA+AAAAPwAAABQAAABAAAAAAAAAAOALAAAVAAAAQQAAAEIAAAAAAAAA8AsAAAEAAABDAAAARAAAABYAAABFAAAAAAAAAAAMAAAXAAAARgAAAEcAAAAAAAAAEAwAAAEAAABIAAAASQAAABgAAABKAAAAAAAAACAMAAABAAAASwAAAEwAAAAZAAAATQAAAAAAAAAwDAAAAQAAAE4AAABPAAAAGgAAAFAAAAAAAAAAQAwAABsAAABRAAAAUgAAAAAAAABQDAAAAQAAAFMAAABUAAAAHAAAAFUAAAAAAAAAYAwAAFYAAABXAAAABwAAAB0AAAAAAAAAcAwAAAEAAABYAAAAWQAAAB4AAABaAAAAAAAAAIAMAABbAAAAXAAAAAcAAAAfAAAAAAAAAJAMAAABAAAAXQAAAF4AAAAgAAAAXwAAAAAAAACgDAAAYAAAAGEAAAAHAAAAIQAAAAAAAACwDAAAAQAAAGIAAABjAAAAIgAAAGQAAAAAAAAAwAwAAGUAAABmAAAABwAAACMAAAAAAAAA0AwAAAEAAABnAAAAaAAAACQAAABpAAAAAAAAAOAMAABqAAAAawAAAAcAAAAlAAAAAAAAAPAMAAABAAAAbAAAAG0AAAAmAAAAbgAAAAAAAAAADQAAbwAAAHAAAAAHAAAAJwAAAAAAAAAQDQAAAQAAAHEAAAByAAAAKAAAAHMAAAAoDQAAyA8AACgNAAAIEAAAEBAAACgNAABQDQAAyA8AAFANAAAgEAAAyA8AAFANAAAIEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwDgAAdAAAAHUAAAB2AAAAdwAAAAIAAAABAAAAAQAAAAEAAAAAAAAAGA8AAHQAAAB4AAAAdgAAAHcAAAACAAAAAgAAAAIAAAACAAAAAAAAACgPAAB5AAAAegAAAAQAAAAAAAAAOA8AAHsAAAB8AAAABQAAAAAAAABIDwAACAAAAH0AAAABAAAAAAAAAFgPAAB7AAAAfgAAAAUAAAAAAAAAaA8AAHsAAAB/AAAABQAAAAAAAAC4DwAAdAAAAIAAAAB2AAAAdwAAAAMAAAAAAAAAiA8AAHQAAACBAAAAdgAAAHcAAAAEAAAAAAAAADgQAAB0AAAAggAAAHYAAAB3AAAAAgAAAAMAAAADAAAAAwAAAAAAAABIEAAAgwAAAIQAAAAGAAAAAAAAAHgQAACFAAAAhgAAAAcAAAABAAAABQAAAAYAAAACAAAAAAAAAKAQAACFAAAAhwAAAAgAAAADAAAABQAAAAYAAAAEAAAA4BcAAAQYAAAAAAAAsBAAAIgAAACJAAAAAQAAAExBU1ppcABvcGVuAGdldFBvaW50AGdldENvdW50AER5bmFtaWNMQVNaaXAAYWRkRmllbGRGbG9hdGluZwBhZGRGaWVsZFNpZ25lZABhZGRGaWVsZFVuc2lnbmVkAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9wb2ludGVySVBONmxhc3ppcDdzdHJlYW1zMTNtZW1vcnlfc3RyZWFtRU5TXzE0ZGVmYXVsdF9kZWxldGVJUzNfRUVOU185YWxsb2NhdG9ySVMzX0VFRUUATlN0M19fMjE0ZGVmYXVsdF9kZWxldGVJTjZsYXN6aXA3c3RyZWFtczEzbWVtb3J5X3N0cmVhbUVFRQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfcG9pbnRlcklQTjZsYXN6aXAyaW82cmVhZGVyMTBiYXNpY19maWxlSU5TMV83c3RyZWFtczEzbWVtb3J5X3N0cmVhbUVFRU5TXzE0ZGVmYXVsdF9kZWxldGVJUzdfRUVOU185YWxsb2NhdG9ySVM3X0VFRUUATlN0M19fMjE0ZGVmYXVsdF9kZWxldGVJTjZsYXN6aXAyaW82cmVhZGVyMTBiYXNpY19maWxlSU5TMV83c3RyZWFtczEzbWVtb3J5X3N0cmVhbUVFRUVFAExBU0YATjZsYXN6aXAxM2ludmFsaWRfbWFnaWNFAGFsbG9jYXRvcjxUPjo6YWxsb2NhdGUoc2l6ZV90IG4pICduJyBleGNlZWRzIG1heGltdW0gc3VwcG9ydGVkIHNpemUARmlsZSBtYWdpYyBpcyBub3QgdmFsaWQATlN0M19fMjEwX19mdW5jdGlvbjZfX2Z1bmNJWk42bGFzemlwMmlvNnJlYWRlcjEwYmFzaWNfZmlsZUlOUzJfN3N0cmVhbXMxM21lbW9yeV9zdHJlYW1FRTExX3ZhbGlkYXRvcnNFdkVVbFJOUzNfNmhlYWRlckVFX05TXzlhbGxvY2F0b3JJU0JfRUVGdlNBX0VFRQBOU3QzX18yMTBfX2Z1bmN0aW9uNl9fYmFzZUlGdlJONmxhc3ppcDJpbzZoZWFkZXJFRUVFAE42bGFzemlwMjFvbGRfc3R5bGVfY29tcHJlc3Npb25FAE42bGFzemlwMTRub3RfY29tcHJlc3NlZEUAVGhlIGZpbGUgc2VlbXMgdG8gaGF2ZSBvbGQgc3R5bGUgY29tcHJlc3Npb24gd2hpY2ggaXMgbm90IHN1cHBvcnRlZABUaGUgZmlsZSBkb2Vzbid0IHNlZW0gdG8gYmUgY29tcHJlc3NlZABaTjZsYXN6aXAyaW82cmVhZGVyMTBiYXNpY19maWxlSU5TXzdzdHJlYW1zMTNtZW1vcnlfc3RyZWFtRUUxMV92YWxpZGF0b3JzRXZFVWxSTlMwXzZoZWFkZXJFRV8AbGFzemlwIGVuY29kZWQATjZsYXN6aXAxM25vX2xhc3ppcF92bHJFAE42bGFzemlwMjVsYXN6aXBfZm9ybWF0X3Vuc3VwcG9ydGVkRQBPbmx5IExBU3ppcCBQT0lOVFdJU0UgQ0hVTktFRCBkZWNvbXByZXNzb3IgaXMgc3VwcG9ydGVkAE5vIExBU3ppcCBWTFIgd2FzIGZvdW5kIGluIHRoZSBWTFJzIHNlY3Rpb24ATjZsYXN6aXAyMmNodW5rX3RhYmxlX3JlYWRfZXJyb3JFAENodW5rIHRhYmxlIG9mZnNldCA9PSAtMSBpcyBub3Qgc3VwcG9ydGVkIGF0IHRoaXMgdGltZQBONmxhc3ppcDEzbm90X3N1cHBvcnRlZEUATjZsYXN6aXAyNnVua25vd25fY2h1bmtfdGFibGVfZm9ybWF0RQBjaHVua19zaXplID09IHVpbnQubWF4IGlzIG5vdCBzdXBwb3J0ZWQgYXQgdGhpcyB0aW1lLgBUaGVyZSB3YXMgYSBwcm9ibGVtIHJlYWRpbmcgdGhlIGNodW5rIHRhYmxlAFRoZSBjaHVuayB0YWJsZSB2ZXJzaW9uIG51bWJlciBpcyB1bmtub3duAE42bGFzemlwMTFlbmRfb2ZfZmlsZUUAUmVhY2hlZCBFbmQgb2YgZmlsZQBJbnZhbGlkIG51bWJlciBvZiBzeW1ib2xzAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9wb2ludGVySVBONmxhc3ppcDhkZWNvZGVyczEwYXJpdGhtZXRpY0lOUzFfMmlvMThfX2lmc3RyZWFtX3dyYXBwZXJJTlMxXzdzdHJlYW1zMTNtZW1vcnlfc3RyZWFtRUVFRUVOU18xNGRlZmF1bHRfZGVsZXRlSVM5X0VFTlNfOWFsbG9jYXRvcklTOV9FRUVFAE5TdDNfXzIxNGRlZmF1bHRfZGVsZXRlSU42bGFzemlwOGRlY29kZXJzMTBhcml0aG1ldGljSU5TMV8yaW8xOF9faWZzdHJlYW1fd3JhcHBlcklOUzFfN3N0cmVhbXMxM21lbW9yeV9zdHJlYW1FRUVFRUVFAE42bGFzemlwMTl1bmtub3duX3NjaGVtYV90eXBlRQBUaGUgTEFaIHNjaGVtYSBpcyBub3QgcmVjb2duaXplZABONmxhc3ppcDdmb3JtYXRzMjZkeW5hbWljX2ZpZWxkX2RlY29tcHJlc3NvcklOU184ZGVjb2RlcnMxMGFyaXRobWV0aWNJTlNfMmlvMThfX2lmc3RyZWFtX3dyYXBwZXJJTlNfN3N0cmVhbXMxM21lbW9yeV9zdHJlYW1FRUVFRUVFAE42bGFzemlwN2Zvcm1hdHMyMGR5bmFtaWNfZGVjb21wcmVzc29yRQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfcG9pbnRlcklQTjZsYXN6aXA3Zm9ybWF0czI2ZHluYW1pY19maWVsZF9kZWNvbXByZXNzb3JJTlMxXzhkZWNvZGVyczEwYXJpdGhtZXRpY0lOUzFfMmlvMThfX2lmc3RyZWFtX3dyYXBwZXJJTlMxXzdzdHJlYW1zMTNtZW1vcnlfc3RyZWFtRUVFRUVFRU5TXzE0ZGVmYXVsdF9kZWxldGVJU0NfRUVOU185YWxsb2NhdG9ySVNDX0VFRUUATlN0M19fMjE0ZGVmYXVsdF9kZWxldGVJTjZsYXN6aXA3Zm9ybWF0czI2ZHluYW1pY19maWVsZF9kZWNvbXByZXNzb3JJTlMxXzhkZWNvZGVyczEwYXJpdGhtZXRpY0lOUzFfMmlvMThfX2lmc3RyZWFtX3dyYXBwZXJJTlMxXzdzdHJlYW1zMTNtZW1vcnlfc3RyZWFtRUVFRUVFRUVFAE42bGFzemlwN2Zvcm1hdHMyNmR5bmFtaWNfZGVjb21wcmVzc29yX2ZpZWxkSU5TXzhkZWNvZGVyczEwYXJpdGhtZXRpY0lOU18yaW8xOF9faWZzdHJlYW1fd3JhcHBlcklOU183c3RyZWFtczEzbWVtb3J5X3N0cmVhbUVFRUVFTlMwXzVmaWVsZElOUzBfM2xhczdwb2ludDEwRU5TMF8yMHN0YW5kYXJkX2RpZmZfbWV0aG9kSVNDX0VFRUVFRQBONmxhc3ppcDdmb3JtYXRzMTBiYXNlX2ZpZWxkRQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfcG9pbnRlcklQTjZsYXN6aXA3Zm9ybWF0czI2ZHluYW1pY19kZWNvbXByZXNzb3JfZmllbGRJTlMxXzhkZWNvZGVyczEwYXJpdGhtZXRpY0lOUzFfMmlvMThfX2lmc3RyZWFtX3dyYXBwZXJJTlMxXzdzdHJlYW1zMTNtZW1vcnlfc3RyZWFtRUVFRUVOUzJfNWZpZWxkSU5TMl8zbGFzN3BvaW50MTBFTlMyXzIwc3RhbmRhcmRfZGlmZl9tZXRob2RJU0VfRUVFRUVFTlNfMTRkZWZhdWx0X2RlbGV0ZUlTSV9FRU5TXzlhbGxvY2F0b3JJU0lfRUVFRQBOU3QzX18yMTRkZWZhdWx0X2RlbGV0ZUlONmxhc3ppcDdmb3JtYXRzMjZkeW5hbWljX2RlY29tcHJlc3Nvcl9maWVsZElOUzFfOGRlY29kZXJzMTBhcml0aG1ldGljSU5TMV8yaW8xOF9faWZzdHJlYW1fd3JhcHBlcklOUzFfN3N0cmVhbXMxM21lbW9yeV9zdHJlYW1FRUVFRU5TMl81ZmllbGRJTlMyXzNsYXM3cG9pbnQxMEVOUzJfMjBzdGFuZGFyZF9kaWZmX21ldGhvZElTRV9FRUVFRUVFRQBONmxhc3ppcDdmb3JtYXRzMjZkeW5hbWljX2RlY29tcHJlc3Nvcl9maWVsZElOU184ZGVjb2RlcnMxMGFyaXRobWV0aWNJTlNfMmlvMThfX2lmc3RyZWFtX3dyYXBwZXJJTlNfN3N0cmVhbXMxM21lbW9yeV9zdHJlYW1FRUVFRU5TMF81ZmllbGRJTlMwXzNsYXM3Z3BzdGltZUVOUzBfMjBzdGFuZGFyZF9kaWZmX21ldGhvZElTQ19FRUVFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX3BvaW50ZXJJUE42bGFzemlwN2Zvcm1hdHMyNmR5bmFtaWNfZGVjb21wcmVzc29yX2ZpZWxkSU5TMV84ZGVjb2RlcnMxMGFyaXRobWV0aWNJTlMxXzJpbzE4X19pZnN0cmVhbV93cmFwcGVySU5TMV83c3RyZWFtczEzbWVtb3J5X3N0cmVhbUVFRUVFTlMyXzVmaWVsZElOUzJfM2xhczdncHN0aW1lRU5TMl8yMHN0YW5kYXJkX2RpZmZfbWV0aG9kSVNFX0VFRUVFRU5TXzE0ZGVmYXVsdF9kZWxldGVJU0lfRUVOU185YWxsb2NhdG9ySVNJX0VFRUUATlN0M19fMjE0ZGVmYXVsdF9kZWxldGVJTjZsYXN6aXA3Zm9ybWF0czI2ZHluYW1pY19kZWNvbXByZXNzb3JfZmllbGRJTlMxXzhkZWNvZGVyczEwYXJpdGhtZXRpY0lOUzFfMmlvMThfX2lmc3RyZWFtX3dyYXBwZXJJTlMxXzdzdHJlYW1zMTNtZW1vcnlfc3RyZWFtRUVFRUVOUzJfNWZpZWxkSU5TMl8zbGFzN2dwc3RpbWVFTlMyXzIwc3RhbmRhcmRfZGlmZl9tZXRob2RJU0VfRUVFRUVFRUUATjZsYXN6aXA3Zm9ybWF0czI2ZHluYW1pY19kZWNvbXByZXNzb3JfZmllbGRJTlNfOGRlY29kZXJzMTBhcml0aG1ldGljSU5TXzJpbzE4X19pZnN0cmVhbV93cmFwcGVySU5TXzdzdHJlYW1zMTNtZW1vcnlfc3RyZWFtRUVFRUVOUzBfNWZpZWxkSU5TMF8zbGFzM3JnYkVOUzBfMjBzdGFuZGFyZF9kaWZmX21ldGhvZElTQ19FRUVFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX3BvaW50ZXJJUE42bGFzemlwN2Zvcm1hdHMyNmR5bmFtaWNfZGVjb21wcmVzc29yX2ZpZWxkSU5TMV84ZGVjb2RlcnMxMGFyaXRobWV0aWNJTlMxXzJpbzE4X19pZnN0cmVhbV93cmFwcGVySU5TMV83c3RyZWFtczEzbWVtb3J5X3N0cmVhbUVFRUVFTlMyXzVmaWVsZElOUzJfM2xhczNyZ2JFTlMyXzIwc3RhbmRhcmRfZGlmZl9tZXRob2RJU0VfRUVFRUVFTlNfMTRkZWZhdWx0X2RlbGV0ZUlTSV9FRU5TXzlhbGxvY2F0b3JJU0lfRUVFRQBOU3QzX18yMTRkZWZhdWx0X2RlbGV0ZUlONmxhc3ppcDdmb3JtYXRzMjZkeW5hbWljX2RlY29tcHJlc3Nvcl9maWVsZElOUzFfOGRlY29kZXJzMTBhcml0aG1ldGljSU5TMV8yaW8xOF9faWZzdHJlYW1fd3JhcHBlcklOUzFfN3N0cmVhbXMxM21lbW9yeV9zdHJlYW1FRUVFRU5TMl81ZmllbGRJTlMyXzNsYXMzcmdiRU5TMl8yMHN0YW5kYXJkX2RpZmZfbWV0aG9kSVNFX0VFRUVFRUVFAE42bGFzemlwN2Zvcm1hdHMyNmR5bmFtaWNfZGVjb21wcmVzc29yX2ZpZWxkSU5TXzhkZWNvZGVyczEwYXJpdGhtZXRpY0lOU18yaW8xOF9faWZzdHJlYW1fd3JhcHBlcklOU183c3RyZWFtczEzbWVtb3J5X3N0cmVhbUVFRUVFTlMwXzVmaWVsZElOUzBfM2xhczEwZXh0cmFieXRlc0VOUzBfMjBzdGFuZGFyZF9kaWZmX21ldGhvZElTQ19FRUVFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX3BvaW50ZXJJUE42bGFzemlwN2Zvcm1hdHMyNmR5bmFtaWNfZGVjb21wcmVzc29yX2ZpZWxkSU5TMV84ZGVjb2RlcnMxMGFyaXRobWV0aWNJTlMxXzJpbzE4X19pZnN0cmVhbV93cmFwcGVySU5TMV83c3RyZWFtczEzbWVtb3J5X3N0cmVhbUVFRUVFTlMyXzVmaWVsZElOUzJfM2xhczEwZXh0cmFieXRlc0VOUzJfMjBzdGFuZGFyZF9kaWZmX21ldGhvZElTRV9FRUVFRUVOU18xNGRlZmF1bHRfZGVsZXRlSVNJX0VFTlNfOWFsbG9jYXRvcklTSV9FRUVFAE5TdDNfXzIxNGRlZmF1bHRfZGVsZXRlSU42bGFzemlwN2Zvcm1hdHMyNmR5bmFtaWNfZGVjb21wcmVzc29yX2ZpZWxkSU5TMV84ZGVjb2RlcnMxMGFyaXRobWV0aWNJTlMxXzJpbzE4X19pZnN0cmVhbV93cmFwcGVySU5TMV83c3RyZWFtczEzbWVtb3J5X3N0cmVhbUVFRUVFTlMyXzVmaWVsZElOUzJfM2xhczEwZXh0cmFieXRlc0VOUzJfMjBzdGFuZGFyZF9kaWZmX21ldGhvZElTRV9FRUVFRUVFRQBONmxhc3ppcDdmb3JtYXRzMjFkeW5hbWljX2RlY29tcHJlc3NvcjFJTlNfOGRlY29kZXJzMTBhcml0aG1ldGljSU5TXzJpbzE4X19pZnN0cmVhbV93cmFwcGVySU5TXzdzdHJlYW1zMTNtZW1vcnlfc3RyZWFtRUVFRUVOUzBfMTlyZWNvcmRfZGVjb21wcmVzc29ySUpOUzBfNWZpZWxkSU5TMF8zbGFzN3BvaW50MTBFTlMwXzIwc3RhbmRhcmRfZGlmZl9tZXRob2RJU0RfRUVFRUVFRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9wb2ludGVySVBONmxhc3ppcDdmb3JtYXRzMjFkeW5hbWljX2RlY29tcHJlc3NvcjFJTlMxXzhkZWNvZGVyczEwYXJpdGhtZXRpY0lOUzFfMmlvMThfX2lmc3RyZWFtX3dyYXBwZXJJTlMxXzdzdHJlYW1zMTNtZW1vcnlfc3RyZWFtRUVFRUVOUzJfMTlyZWNvcmRfZGVjb21wcmVzc29ySUpOUzJfNWZpZWxkSU5TMl8zbGFzN3BvaW50MTBFTlMyXzIwc3RhbmRhcmRfZGlmZl9tZXRob2RJU0ZfRUVFRUVFRUVFTlNfMTRkZWZhdWx0X2RlbGV0ZUlTS19FRU5TXzlhbGxvY2F0b3JJU0tfRUVFRQBOU3QzX18yMTRkZWZhdWx0X2RlbGV0ZUlONmxhc3ppcDdmb3JtYXRzMjFkeW5hbWljX2RlY29tcHJlc3NvcjFJTlMxXzhkZWNvZGVyczEwYXJpdGhtZXRpY0lOUzFfMmlvMThfX2lmc3RyZWFtX3dyYXBwZXJJTlMxXzdzdHJlYW1zMTNtZW1vcnlfc3RyZWFtRUVFRUVOUzJfMTlyZWNvcmRfZGVjb21wcmVzc29ySUpOUzJfNWZpZWxkSU5TMl8zbGFzN3BvaW50MTBFTlMyXzIwc3RhbmRhcmRfZGlmZl9tZXRob2RJU0ZfRUVFRUVFRUVFRUUATjZsYXN6aXA3Zm9ybWF0czIxZHluYW1pY19kZWNvbXByZXNzb3IxSU5TXzhkZWNvZGVyczEwYXJpdGhtZXRpY0lOU18yaW8xOF9faWZzdHJlYW1fd3JhcHBlcklOU183c3RyZWFtczEzbWVtb3J5X3N0cmVhbUVFRUVFTlMwXzE5cmVjb3JkX2RlY29tcHJlc3NvcklKTlMwXzVmaWVsZElOUzBfM2xhczdwb2ludDEwRU5TMF8yMHN0YW5kYXJkX2RpZmZfbWV0aG9kSVNEX0VFRUVOU0JfSU5TQ183Z3BzdGltZUVOU0VfSVNIX0VFRUVFRUVFRQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfcG9pbnRlcklQTjZsYXN6aXA3Zm9ybWF0czIxZHluYW1pY19kZWNvbXByZXNzb3IxSU5TMV84ZGVjb2RlcnMxMGFyaXRobWV0aWNJTlMxXzJpbzE4X19pZnN0cmVhbV93cmFwcGVySU5TMV83c3RyZWFtczEzbWVtb3J5X3N0cmVhbUVFRUVFTlMyXzE5cmVjb3JkX2RlY29tcHJlc3NvcklKTlMyXzVmaWVsZElOUzJfM2xhczdwb2ludDEwRU5TMl8yMHN0YW5kYXJkX2RpZmZfbWV0aG9kSVNGX0VFRUVOU0RfSU5TRV83Z3BzdGltZUVOU0dfSVNKX0VFRUVFRUVFRU5TXzE0ZGVmYXVsdF9kZWxldGVJU05fRUVOU185YWxsb2NhdG9ySVNOX0VFRUUATlN0M19fMjE0ZGVmYXVsdF9kZWxldGVJTjZsYXN6aXA3Zm9ybWF0czIxZHluYW1pY19kZWNvbXByZXNzb3IxSU5TMV84ZGVjb2RlcnMxMGFyaXRobWV0aWNJTlMxXzJpbzE4X19pZnN0cmVhbV93cmFwcGVySU5TMV83c3RyZWFtczEzbWVtb3J5X3N0cmVhbUVFRUVFTlMyXzE5cmVjb3JkX2RlY29tcHJlc3NvcklKTlMyXzVmaWVsZElOUzJfM2xhczdwb2ludDEwRU5TMl8yMHN0YW5kYXJkX2RpZmZfbWV0aG9kSVNGX0VFRUVOU0RfSU5TRV83Z3BzdGltZUVOU0dfSVNKX0VFRUVFRUVFRUVFAE42bGFzemlwN2Zvcm1hdHMyMWR5bmFtaWNfZGVjb21wcmVzc29yMUlOU184ZGVjb2RlcnMxMGFyaXRobWV0aWNJTlNfMmlvMThfX2lmc3RyZWFtX3dyYXBwZXJJTlNfN3N0cmVhbXMxM21lbW9yeV9zdHJlYW1FRUVFRU5TMF8xOXJlY29yZF9kZWNvbXByZXNzb3JJSk5TMF81ZmllbGRJTlMwXzNsYXM3cG9pbnQxMEVOUzBfMjBzdGFuZGFyZF9kaWZmX21ldGhvZElTRF9FRUVFTlNCX0lOU0NfM3JnYkVOU0VfSVNIX0VFRUVFRUVFRQBOU3QzX18yMjBfX3NoYXJlZF9wdHJfcG9pbnRlcklQTjZsYXN6aXA3Zm9ybWF0czIxZHluYW1pY19kZWNvbXByZXNzb3IxSU5TMV84ZGVjb2RlcnMxMGFyaXRobWV0aWNJTlMxXzJpbzE4X19pZnN0cmVhbV93cmFwcGVySU5TMV83c3RyZWFtczEzbWVtb3J5X3N0cmVhbUVFRUVFTlMyXzE5cmVjb3JkX2RlY29tcHJlc3NvcklKTlMyXzVmaWVsZElOUzJfM2xhczdwb2ludDEwRU5TMl8yMHN0YW5kYXJkX2RpZmZfbWV0aG9kSVNGX0VFRUVOU0RfSU5TRV8zcmdiRU5TR19JU0pfRUVFRUVFRUVFTlNfMTRkZWZhdWx0X2RlbGV0ZUlTTl9FRU5TXzlhbGxvY2F0b3JJU05fRUVFRQBOU3QzX18yMTRkZWZhdWx0X2RlbGV0ZUlONmxhc3ppcDdmb3JtYXRzMjFkeW5hbWljX2RlY29tcHJlc3NvcjFJTlMxXzhkZWNvZGVyczEwYXJpdGhtZXRpY0lOUzFfMmlvMThfX2lmc3RyZWFtX3dyYXBwZXJJTlMxXzdzdHJlYW1zMTNtZW1vcnlfc3RyZWFtRUVFRUVOUzJfMTlyZWNvcmRfZGVjb21wcmVzc29ySUpOUzJfNWZpZWxkSU5TMl8zbGFzN3BvaW50MTBFTlMyXzIwc3RhbmRhcmRfZGlmZl9tZXRob2RJU0ZfRUVFRU5TRF9JTlNFXzNyZ2JFTlNHX0lTSl9FRUVFRUVFRUVFRQBONmxhc3ppcDdmb3JtYXRzMjFkeW5hbWljX2RlY29tcHJlc3NvcjFJTlNfOGRlY29kZXJzMTBhcml0aG1ldGljSU5TXzJpbzE4X19pZnN0cmVhbV93cmFwcGVySU5TXzdzdHJlYW1zMTNtZW1vcnlfc3RyZWFtRUVFRUVOUzBfMTlyZWNvcmRfZGVjb21wcmVzc29ySUpOUzBfNWZpZWxkSU5TMF8zbGFzN3BvaW50MTBFTlMwXzIwc3RhbmRhcmRfZGlmZl9tZXRob2RJU0RfRUVFRU5TQl9JTlNDXzdncHN0aW1lRU5TRV9JU0hfRUVFRU5TQl9JTlNDXzNyZ2JFTlNFX0lTS19FRUVFRUVFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX3BvaW50ZXJJUE42bGFzemlwN2Zvcm1hdHMyMWR5bmFtaWNfZGVjb21wcmVzc29yMUlOUzFfOGRlY29kZXJzMTBhcml0aG1ldGljSU5TMV8yaW8xOF9faWZzdHJlYW1fd3JhcHBlcklOUzFfN3N0cmVhbXMxM21lbW9yeV9zdHJlYW1FRUVFRU5TMl8xOXJlY29yZF9kZWNvbXByZXNzb3JJSk5TMl81ZmllbGRJTlMyXzNsYXM3cG9pbnQxMEVOUzJfMjBzdGFuZGFyZF9kaWZmX21ldGhvZElTRl9FRUVFTlNEX0lOU0VfN2dwc3RpbWVFTlNHX0lTSl9FRUVFTlNEX0lOU0VfM3JnYkVOU0dfSVNNX0VFRUVFRUVFRU5TXzE0ZGVmYXVsdF9kZWxldGVJU1FfRUVOU185YWxsb2NhdG9ySVNRX0VFRUUATlN0M19fMjE0ZGVmYXVsdF9kZWxldGVJTjZsYXN6aXA3Zm9ybWF0czIxZHluYW1pY19kZWNvbXByZXNzb3IxSU5TMV84ZGVjb2RlcnMxMGFyaXRobWV0aWNJTlMxXzJpbzE4X19pZnN0cmVhbV93cmFwcGVySU5TMV83c3RyZWFtczEzbWVtb3J5X3N0cmVhbUVFRUVFTlMyXzE5cmVjb3JkX2RlY29tcHJlc3NvcklKTlMyXzVmaWVsZElOUzJfM2xhczdwb2ludDEwRU5TMl8yMHN0YW5kYXJkX2RpZmZfbWV0aG9kSVNGX0VFRUVOU0RfSU5TRV83Z3BzdGltZUVOU0dfSVNKX0VFRUVOU0RfSU5TRV8zcmdiRU5TR19JU01fRUVFRUVFRUVFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX3BvaW50ZXJJUDEwYnVmX3N0cmVhbU5TXzE0ZGVmYXVsdF9kZWxldGVJUzFfRUVOU185YWxsb2NhdG9ySVMxX0VFRUUATlN0M19fMjE0ZGVmYXVsdF9kZWxldGVJMTBidWZfc3RyZWFtRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX3BvaW50ZXJJUE42bGFzemlwOGRlY29kZXJzMTBhcml0aG1ldGljSTEwYnVmX3N0cmVhbUVFTlNfMTRkZWZhdWx0X2RlbGV0ZUlTNV9FRU5TXzlhbGxvY2F0b3JJUzVfRUVFRQBOU3QzX18yMTRkZWZhdWx0X2RlbGV0ZUlONmxhc3ppcDhkZWNvZGVyczEwYXJpdGhtZXRpY0kxMGJ1Zl9zdHJlYW1FRUVFAE42bGFzemlwN2Zvcm1hdHMyNmR5bmFtaWNfZmllbGRfZGVjb21wcmVzc29ySU5TXzhkZWNvZGVyczEwYXJpdGhtZXRpY0kxMGJ1Zl9zdHJlYW1FRUVFAE5TdDNfXzIyMF9fc2hhcmVkX3B0cl9wb2ludGVySVBONmxhc3ppcDdmb3JtYXRzMjZkeW5hbWljX2ZpZWxkX2RlY29tcHJlc3NvcklOUzFfOGRlY29kZXJzMTBhcml0aG1ldGljSTEwYnVmX3N0cmVhbUVFRUVOU18xNGRlZmF1bHRfZGVsZXRlSVM4X0VFTlNfOWFsbG9jYXRvcklTOF9FRUVFAE5TdDNfXzIxNGRlZmF1bHRfZGVsZXRlSU42bGFzemlwN2Zvcm1hdHMyNmR5bmFtaWNfZmllbGRfZGVjb21wcmVzc29ySU5TMV84ZGVjb2RlcnMxMGFyaXRobWV0aWNJMTBidWZfc3RyZWFtRUVFRUVFAE42bGFzemlwN2Zvcm1hdHMyNmR5bmFtaWNfZGVjb21wcmVzc29yX2ZpZWxkSU5TXzhkZWNvZGVyczEwYXJpdGhtZXRpY0kxMGJ1Zl9zdHJlYW1FRU5TMF81ZmllbGRJaU5TMF8yMHN0YW5kYXJkX2RpZmZfbWV0aG9kSWlFRUVFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX3BvaW50ZXJJUE42bGFzemlwN2Zvcm1hdHMyNmR5bmFtaWNfZGVjb21wcmVzc29yX2ZpZWxkSU5TMV84ZGVjb2RlcnMxMGFyaXRobWV0aWNJMTBidWZfc3RyZWFtRUVOUzJfNWZpZWxkSWlOUzJfMjBzdGFuZGFyZF9kaWZmX21ldGhvZElpRUVFRUVFTlNfMTRkZWZhdWx0X2RlbGV0ZUlTQ19FRU5TXzlhbGxvY2F0b3JJU0NfRUVFRQBOU3QzX18yMTRkZWZhdWx0X2RlbGV0ZUlONmxhc3ppcDdmb3JtYXRzMjZkeW5hbWljX2RlY29tcHJlc3Nvcl9maWVsZElOUzFfOGRlY29kZXJzMTBhcml0aG1ldGljSTEwYnVmX3N0cmVhbUVFTlMyXzVmaWVsZElpTlMyXzIwc3RhbmRhcmRfZGlmZl9tZXRob2RJaUVFRUVFRUVFAE42bGFzemlwN2Zvcm1hdHMyNmR5bmFtaWNfZGVjb21wcmVzc29yX2ZpZWxkSU5TXzhkZWNvZGVyczEwYXJpdGhtZXRpY0kxMGJ1Zl9zdHJlYW1FRU5TMF81ZmllbGRJak5TMF8yMHN0YW5kYXJkX2RpZmZfbWV0aG9kSWpFRUVFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX3BvaW50ZXJJUE42bGFzemlwN2Zvcm1hdHMyNmR5bmFtaWNfZGVjb21wcmVzc29yX2ZpZWxkSU5TMV84ZGVjb2RlcnMxMGFyaXRobWV0aWNJMTBidWZfc3RyZWFtRUVOUzJfNWZpZWxkSWpOUzJfMjBzdGFuZGFyZF9kaWZmX21ldGhvZElqRUVFRUVFTlNfMTRkZWZhdWx0X2RlbGV0ZUlTQ19FRU5TXzlhbGxvY2F0b3JJU0NfRUVFRQBOU3QzX18yMTRkZWZhdWx0X2RlbGV0ZUlONmxhc3ppcDdmb3JtYXRzMjZkeW5hbWljX2RlY29tcHJlc3Nvcl9maWVsZElOUzFfOGRlY29kZXJzMTBhcml0aG1ldGljSTEwYnVmX3N0cmVhbUVFTlMyXzVmaWVsZElqTlMyXzIwc3RhbmRhcmRfZGlmZl9tZXRob2RJakVFRUVFRUVFAE42bGFzemlwN2Zvcm1hdHMyNmR5bmFtaWNfZGVjb21wcmVzc29yX2ZpZWxkSU5TXzhkZWNvZGVyczEwYXJpdGhtZXRpY0kxMGJ1Zl9zdHJlYW1FRU5TMF81ZmllbGRJYU5TMF8yMHN0YW5kYXJkX2RpZmZfbWV0aG9kSWFFRUVFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX3BvaW50ZXJJUE42bGFzemlwN2Zvcm1hdHMyNmR5bmFtaWNfZGVjb21wcmVzc29yX2ZpZWxkSU5TMV84ZGVjb2RlcnMxMGFyaXRobWV0aWNJMTBidWZfc3RyZWFtRUVOUzJfNWZpZWxkSWFOUzJfMjBzdGFuZGFyZF9kaWZmX21ldGhvZElhRUVFRUVFTlNfMTRkZWZhdWx0X2RlbGV0ZUlTQ19FRU5TXzlhbGxvY2F0b3JJU0NfRUVFRQBOU3QzX18yMTRkZWZhdWx0X2RlbGV0ZUlONmxhc3ppcDdmb3JtYXRzMjZkeW5hbWljX2RlY29tcHJlc3Nvcl9maWVsZElOUzFfOGRlY29kZXJzMTBhcml0aG1ldGljSTEwYnVmX3N0cmVhbUVFTlMyXzVmaWVsZElhTlMyXzIwc3RhbmRhcmRfZGlmZl9tZXRob2RJYUVFRUVFRUVFAE42bGFzemlwN2Zvcm1hdHMyNmR5bmFtaWNfZGVjb21wcmVzc29yX2ZpZWxkSU5TXzhkZWNvZGVyczEwYXJpdGhtZXRpY0kxMGJ1Zl9zdHJlYW1FRU5TMF81ZmllbGRJc05TMF8yMHN0YW5kYXJkX2RpZmZfbWV0aG9kSXNFRUVFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX3BvaW50ZXJJUE42bGFzemlwN2Zvcm1hdHMyNmR5bmFtaWNfZGVjb21wcmVzc29yX2ZpZWxkSU5TMV84ZGVjb2RlcnMxMGFyaXRobWV0aWNJMTBidWZfc3RyZWFtRUVOUzJfNWZpZWxkSXNOUzJfMjBzdGFuZGFyZF9kaWZmX21ldGhvZElzRUVFRUVFTlNfMTRkZWZhdWx0X2RlbGV0ZUlTQ19FRU5TXzlhbGxvY2F0b3JJU0NfRUVFRQBOU3QzX18yMTRkZWZhdWx0X2RlbGV0ZUlONmxhc3ppcDdmb3JtYXRzMjZkeW5hbWljX2RlY29tcHJlc3Nvcl9maWVsZElOUzFfOGRlY29kZXJzMTBhcml0aG1ldGljSTEwYnVmX3N0cmVhbUVFTlMyXzVmaWVsZElzTlMyXzIwc3RhbmRhcmRfZGlmZl9tZXRob2RJc0VFRUVFRUVFAE42bGFzemlwN2Zvcm1hdHMyNmR5bmFtaWNfZGVjb21wcmVzc29yX2ZpZWxkSU5TXzhkZWNvZGVyczEwYXJpdGhtZXRpY0kxMGJ1Zl9zdHJlYW1FRU5TMF81ZmllbGRJaE5TMF8yMHN0YW5kYXJkX2RpZmZfbWV0aG9kSWhFRUVFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX3BvaW50ZXJJUE42bGFzemlwN2Zvcm1hdHMyNmR5bmFtaWNfZGVjb21wcmVzc29yX2ZpZWxkSU5TMV84ZGVjb2RlcnMxMGFyaXRobWV0aWNJMTBidWZfc3RyZWFtRUVOUzJfNWZpZWxkSWhOUzJfMjBzdGFuZGFyZF9kaWZmX21ldGhvZEloRUVFRUVFTlNfMTRkZWZhdWx0X2RlbGV0ZUlTQ19FRU5TXzlhbGxvY2F0b3JJU0NfRUVFRQBOU3QzX18yMTRkZWZhdWx0X2RlbGV0ZUlONmxhc3ppcDdmb3JtYXRzMjZkeW5hbWljX2RlY29tcHJlc3Nvcl9maWVsZElOUzFfOGRlY29kZXJzMTBhcml0aG1ldGljSTEwYnVmX3N0cmVhbUVFTlMyXzVmaWVsZEloTlMyXzIwc3RhbmRhcmRfZGlmZl9tZXRob2RJaEVFRUVFRUVFAE42bGFzemlwN2Zvcm1hdHMyNmR5bmFtaWNfZGVjb21wcmVzc29yX2ZpZWxkSU5TXzhkZWNvZGVyczEwYXJpdGhtZXRpY0kxMGJ1Zl9zdHJlYW1FRU5TMF81ZmllbGRJdE5TMF8yMHN0YW5kYXJkX2RpZmZfbWV0aG9kSXRFRUVFRUUATlN0M19fMjIwX19zaGFyZWRfcHRyX3BvaW50ZXJJUE42bGFzemlwN2Zvcm1hdHMyNmR5bmFtaWNfZGVjb21wcmVzc29yX2ZpZWxkSU5TMV84ZGVjb2RlcnMxMGFyaXRobWV0aWNJMTBidWZfc3RyZWFtRUVOUzJfNWZpZWxkSXROUzJfMjBzdGFuZGFyZF9kaWZmX21ldGhvZEl0RUVFRUVFTlNfMTRkZWZhdWx0X2RlbGV0ZUlTQ19FRU5TXzlhbGxvY2F0b3JJU0NfRUVFRQBOU3QzX18yMTRkZWZhdWx0X2RlbGV0ZUlONmxhc3ppcDdmb3JtYXRzMjZkeW5hbWljX2RlY29tcHJlc3Nvcl9maWVsZElOUzFfOGRlY29kZXJzMTBhcml0aG1ldGljSTEwYnVmX3N0cmVhbUVFTlMyXzVmaWVsZEl0TlMyXzIwc3RhbmRhcmRfZGlmZl9tZXRob2RJdEVFRUVFRUVFADZMQVNaaXAAUDZMQVNaaXAAUEs2TEFTWmlwAGlpAHYAdmkAdmlpaWkAdmlpaQBpaWkAMTNEeW5hbWljTEFTWmlwAFAxM0R5bmFtaWNMQVNaaXAAUEsxM0R5bmFtaWNMQVNaaXAAdm9pZABib29sAGNoYXIAc2lnbmVkIGNoYXIAdW5zaWduZWQgY2hhcgBzaG9ydAB1bnNpZ25lZCBzaG9ydABpbnQAdW5zaWduZWQgaW50AGxvbmcAdW5zaWduZWQgbG9uZwBmbG9hdABkb3VibGUAc3RkOjpzdHJpbmcAc3RkOjpiYXNpY19zdHJpbmc8dW5zaWduZWQgY2hhcj4Ac3RkOjp3c3RyaW5nAHN0ZDo6dTE2c3RyaW5nAHN0ZDo6dTMyc3RyaW5nAGVtc2NyaXB0ZW46OnZhbABlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxzaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8bG9uZz4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgbG9uZz4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGZsb2F0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxkb3VibGU+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGxvbmcgZG91YmxlPgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0llRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZEVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWZFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ltRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbEVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWpFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lpRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJdEVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXNFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0loRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJYUVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWNFRQBOMTBlbXNjcmlwdGVuM3ZhbEUATlN0M19fMjEyYmFzaWNfc3RyaW5nSURpTlNfMTFjaGFyX3RyYWl0c0lEaUVFTlNfOWFsbG9jYXRvcklEaUVFRUUATlN0M19fMjIxX19iYXNpY19zdHJpbmdfY29tbW9uSUxiMUVFRQBOU3QzX18yMTJiYXNpY19zdHJpbmdJRHNOU18xMWNoYXJfdHJhaXRzSURzRUVOU185YWxsb2NhdG9ySURzRUVFRQBOU3QzX18yMTJiYXNpY19zdHJpbmdJd05TXzExY2hhcl90cmFpdHNJd0VFTlNfOWFsbG9jYXRvckl3RUVFRQBOU3QzX18yMTJiYXNpY19zdHJpbmdJaE5TXzExY2hhcl90cmFpdHNJaEVFTlNfOWFsbG9jYXRvckloRUVFRQBOU3QzX18yMTJiYXNpY19zdHJpbmdJY05TXzExY2hhcl90cmFpdHNJY0VFTlNfOWFsbG9jYXRvckljRUVFRQAtKyAgIDBYMHgAKG51bGwpAC0wWCswWCAwWC0weCsweCAweABpbmYASU5GAG5hbgBOQU4ALgB0ZXJtaW5hdGluZyB3aXRoICVzIGV4Y2VwdGlvbiBvZiB0eXBlICVzOiAlcwB0ZXJtaW5hdGluZyB3aXRoICVzIGV4Y2VwdGlvbiBvZiB0eXBlICVzAHRlcm1pbmF0aW5nIHdpdGggJXMgZm9yZWlnbiBleGNlcHRpb24AdGVybWluYXRpbmcAdW5jYXVnaHQAU3Q5ZXhjZXB0aW9uAE4xMF9fY3h4YWJpdjExNl9fc2hpbV90eXBlX2luZm9FAFN0OXR5cGVfaW5mbwBOMTBfX2N4eGFiaXYxMjBfX3NpX2NsYXNzX3R5cGVfaW5mb0UATjEwX19jeHhhYml2MTE3X19jbGFzc190eXBlX2luZm9FAHRlcm1pbmF0ZV9oYW5kbGVyIHVuZXhwZWN0ZWRseSByZXR1cm5lZABzdGQ6OmJhZF9hbGxvYwBTdDliYWRfYWxsb2MAU3QxMWxvZ2ljX2Vycm9yAFN0MTNydW50aW1lX2Vycm9yAFN0MTJsZW5ndGhfZXJyb3IAU3QxMm91dF9vZl9yYW5nZQBOMTBfX2N4eGFiaXYxMTdfX3BiYXNlX3R5cGVfaW5mb0UATjEwX19jeHhhYml2MTE5X19wb2ludGVyX3R5cGVfaW5mb0UATjEwX19jeHhhYml2MTIwX19mdW5jdGlvbl90eXBlX2luZm9FAE4xMF9fY3h4YWJpdjEyOV9fcG9pbnRlcl90b19tZW1iZXJfdHlwZV9pbmZvRQBQdXJlIHZpcnR1YWwgZnVuY3Rpb24gY2FsbGVkIQBOMTBfX2N4eGFiaXYxMjNfX2Z1bmRhbWVudGFsX3R5cGVfaW5mb0UAdgBEbgBiAGMAaABhAHMAdABpAGoAbABtAGYAZABOMTBfX2N4eGFiaXYxMjFfX3ZtaV9jbGFzc190eXBlX2luZm9FAF9fY3hhX2d1YXJkX2FjcXVpcmUgZGV0ZWN0ZWQgcmVjdXJzaXZlIGluaXRpYWxpemF0aW9uAHN0ZDo6YmFkX2Z1bmN0aW9uX2NhbGwATlN0M19fMjE3YmFkX2Z1bmN0aW9uX2NhbGxFAE5TdDNfXzIxNF9fc2hhcmVkX2NvdW50RQBOU3QzX18yMTlfX3NoYXJlZF93ZWFrX2NvdW50RQBtdXRleCBsb2NrIGZhaWxlZABiYXNpY19zdHJpbmcAdW5zcGVjaWZpZWQgZ2VuZXJpY19jYXRlZ29yeSBlcnJvcgBVbmtub3duIGVycm9yICVkAGdlbmVyaWMATlN0M19fMjI0X19nZW5lcmljX2Vycm9yX2NhdGVnb3J5RQBOU3QzX18yMTJfX2RvX21lc3NhZ2VFAE5TdDNfXzIxNGVycm9yX2NhdGVnb3J5RQB1bnNwZWNpZmllZCBzeXN0ZW1fY2F0ZWdvcnkgZXJyb3IAc3lzdGVtAE5TdDNfXzIyM19fc3lzdGVtX2Vycm9yX2NhdGVnb3J5RQBOU3QzX18yMTJzeXN0ZW1fZXJyb3JFADogAHZlY3Rvcg==";
  var tempDoublePtr = 22368;
  function demangle(func) {
    return func;
  }
  function demangleAll(text) {
    var regex = /\b__Z[\w\d_]+/g;
    return text.replace(regex, function(x) {
      var y = demangle(x);
      return x === y ? x : y + " [" + x + "]";
    });
  }
  function jsStackTrace() {
    var err3 = new Error();
    if (!err3.stack) {
      try {
        throw new Error();
      } catch (e) {
        err3 = e;
      }
      if (!err3.stack) {
        return "(no stack trace available)";
      }
    }
    return err3.stack.toString();
  }
  function ___cxa_allocate_exception(size) {
    return _malloc(size);
  }
  var ___exception_infos = {};
  var ___exception_caught = [];
  function ___exception_addRef(ptr) {
    if (!ptr)
      return;
    var info = ___exception_infos[ptr];
    info.refcount++;
  }
  function ___exception_deAdjust(adjusted) {
    if (!adjusted || ___exception_infos[adjusted])
      return adjusted;
    for (var key2 in ___exception_infos) {
      var ptr = +key2;
      var adj = ___exception_infos[ptr].adjusted;
      var len = adj.length;
      for (var i = 0; i < len; i++) {
        if (adj[i] === adjusted) {
          return ptr;
        }
      }
    }
    return adjusted;
  }
  function ___cxa_begin_catch(ptr) {
    var info = ___exception_infos[ptr];
    if (info && !info.caught) {
      info.caught = true;
      __ZSt18uncaught_exceptionv.uncaught_exceptions--;
    }
    if (info)
      info.rethrown = false;
    ___exception_caught.push(ptr);
    ___exception_addRef(___exception_deAdjust(ptr));
    return ptr;
  }
  var ___exception_last = 0;
  function ___cxa_throw(ptr, type, destructor) {
    ___exception_infos[ptr] = {
      ptr,
      adjusted: [ptr],
      type,
      destructor,
      refcount: 0,
      caught: false,
      rethrown: false
    };
    ___exception_last = ptr;
    if (!("uncaught_exception" in __ZSt18uncaught_exceptionv)) {
      __ZSt18uncaught_exceptionv.uncaught_exceptions = 1;
    } else {
      __ZSt18uncaught_exceptionv.uncaught_exceptions++;
    }
    throw ptr;
  }
  function ___cxa_uncaught_exceptions() {
    return __ZSt18uncaught_exceptionv.uncaught_exceptions;
  }
  function ___gxx_personality_v0() {
  }
  function getShiftFromSize(size) {
    switch (size) {
      case 1:
        return 0;
      case 2:
        return 1;
      case 4:
        return 2;
      case 8:
        return 3;
      default:
        throw new TypeError("Unknown type size: " + size);
    }
  }
  function embind_init_charCodes() {
    var codes = new Array(256);
    for (var i = 0; i < 256; ++i) {
      codes[i] = String.fromCharCode(i);
    }
    embind_charCodes = codes;
  }
  var embind_charCodes = void 0;
  function readLatin1String(ptr) {
    var ret = "";
    var c2 = ptr;
    while (HEAPU8[c2]) {
      ret += embind_charCodes[HEAPU8[c2++]];
    }
    return ret;
  }
  var awaitingDependencies = {};
  var registeredTypes = {};
  var typeDependencies = {};
  var char_0 = 48;
  var char_9 = 57;
  function makeLegalFunctionName(name12) {
    if (void 0 === name12) {
      return "_unknown";
    }
    name12 = name12.replace(/[^a-zA-Z0-9_]/g, "$");
    var f = name12.charCodeAt(0);
    if (f >= char_0 && f <= char_9) {
      return "_" + name12;
    } else {
      return name12;
    }
  }
  function createNamedFunction(name12, body) {
    name12 = makeLegalFunctionName(name12);
    return new Function("body", "return function " + name12 + '() {\n    "use strict";    return body.apply(this, arguments);\n};\n')(body);
  }
  function extendError(baseErrorType, errorName) {
    var errorClass = createNamedFunction(errorName, function(message) {
      this.name = errorName;
      this.message = message;
      var stack = new Error(message).stack;
      if (stack !== void 0) {
        this.stack = this.toString() + "\n" + stack.replace(/^Error(:[^\n]*)?\n/, "");
      }
    });
    errorClass.prototype = Object.create(baseErrorType.prototype);
    errorClass.prototype.constructor = errorClass;
    errorClass.prototype.toString = function() {
      if (this.message === void 0) {
        return this.name;
      } else {
        return this.name + ": " + this.message;
      }
    };
    return errorClass;
  }
  var BindingError = void 0;
  function throwBindingError(message) {
    throw new BindingError(message);
  }
  var InternalError = void 0;
  function throwInternalError(message) {
    throw new InternalError(message);
  }
  function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
    myTypes.forEach(function(type) {
      typeDependencies[type] = dependentTypes;
    });
    function onComplete(typeConverters2) {
      var myTypeConverters = getTypeConverters(typeConverters2);
      if (myTypeConverters.length !== myTypes.length) {
        throwInternalError("Mismatched type converter count");
      }
      for (var i = 0; i < myTypes.length; ++i) {
        registerType(myTypes[i], myTypeConverters[i]);
      }
    }
    var typeConverters = new Array(dependentTypes.length);
    var unregisteredTypes = [];
    var registered = 0;
    dependentTypes.forEach(function(dt, i) {
      if (registeredTypes.hasOwnProperty(dt)) {
        typeConverters[i] = registeredTypes[dt];
      } else {
        unregisteredTypes.push(dt);
        if (!awaitingDependencies.hasOwnProperty(dt)) {
          awaitingDependencies[dt] = [];
        }
        awaitingDependencies[dt].push(function() {
          typeConverters[i] = registeredTypes[dt];
          ++registered;
          if (registered === unregisteredTypes.length) {
            onComplete(typeConverters);
          }
        });
      }
    });
    if (0 === unregisteredTypes.length) {
      onComplete(typeConverters);
    }
  }
  function registerType(rawType, registeredInstance, options) {
    options = options || {};
    if (!("argPackAdvance" in registeredInstance)) {
      throw new TypeError("registerType registeredInstance requires argPackAdvance");
    }
    var name12 = registeredInstance.name;
    if (!rawType) {
      throwBindingError('type "' + name12 + '" must have a positive integer typeid pointer');
    }
    if (registeredTypes.hasOwnProperty(rawType)) {
      if (options.ignoreDuplicateRegistrations) {
        return;
      } else {
        throwBindingError("Cannot register type '" + name12 + "' twice");
      }
    }
    registeredTypes[rawType] = registeredInstance;
    delete typeDependencies[rawType];
    if (awaitingDependencies.hasOwnProperty(rawType)) {
      var callbacks = awaitingDependencies[rawType];
      delete awaitingDependencies[rawType];
      callbacks.forEach(function(cb2) {
        cb2();
      });
    }
  }
  function __embind_register_bool(rawType, name12, size, trueValue, falseValue) {
    var shift = getShiftFromSize(size);
    name12 = readLatin1String(name12);
    registerType(rawType, {
      name: name12,
      fromWireType: function(wt) {
        return !!wt;
      },
      toWireType: function(destructors, o) {
        return o ? trueValue : falseValue;
      },
      argPackAdvance: 8,
      readValueFromPointer: function(pointer) {
        var heap;
        if (size === 1) {
          heap = HEAP8;
        } else if (size === 2) {
          heap = HEAP16;
        } else if (size === 4) {
          heap = HEAP32;
        } else {
          throw new TypeError("Unknown boolean type size: " + name12);
        }
        return this["fromWireType"](heap[pointer >> shift]);
      },
      destructorFunction: null
    });
  }
  function ClassHandle_isAliasOf(other) {
    if (!(this instanceof ClassHandle)) {
      return false;
    }
    if (!(other instanceof ClassHandle)) {
      return false;
    }
    var leftClass = this.$$.ptrType.registeredClass;
    var left = this.$$.ptr;
    var rightClass = other.$$.ptrType.registeredClass;
    var right = other.$$.ptr;
    while (leftClass.baseClass) {
      left = leftClass.upcast(left);
      leftClass = leftClass.baseClass;
    }
    while (rightClass.baseClass) {
      right = rightClass.upcast(right);
      rightClass = rightClass.baseClass;
    }
    return leftClass === rightClass && left === right;
  }
  function shallowCopyInternalPointer(o) {
    return {
      count: o.count,
      deleteScheduled: o.deleteScheduled,
      preservePointerOnDelete: o.preservePointerOnDelete,
      ptr: o.ptr,
      ptrType: o.ptrType,
      smartPtr: o.smartPtr,
      smartPtrType: o.smartPtrType
    };
  }
  function throwInstanceAlreadyDeleted(obj) {
    function getInstanceTypeName(handle) {
      return handle.$$.ptrType.registeredClass.name;
    }
    throwBindingError(getInstanceTypeName(obj) + " instance already deleted");
  }
  var finalizationGroup = false;
  function detachFinalizer(handle) {
  }
  function runDestructor($$) {
    if ($$.smartPtr) {
      $$.smartPtrType.rawDestructor($$.smartPtr);
    } else {
      $$.ptrType.registeredClass.rawDestructor($$.ptr);
    }
  }
  function releaseClassHandle($$) {
    $$.count.value -= 1;
    var toDelete = 0 === $$.count.value;
    if (toDelete) {
      runDestructor($$);
    }
  }
  function attachFinalizer(handle) {
    if ("undefined" === typeof FinalizationGroup) {
      attachFinalizer = function(handle2) {
        return handle2;
      };
      return handle;
    }
    finalizationGroup = new FinalizationGroup(function(iter) {
      for (var result = iter.next(); !result.done; result = iter.next()) {
        var $$ = result.value;
        if (!$$.ptr) {
          console.warn("object already deleted: " + $$.ptr);
        } else {
          releaseClassHandle($$);
        }
      }
    });
    attachFinalizer = function(handle2) {
      finalizationGroup.register(handle2, handle2.$$, handle2.$$);
      return handle2;
    };
    detachFinalizer = function(handle2) {
      finalizationGroup.unregister(handle2.$$);
    };
    return attachFinalizer(handle);
  }
  function ClassHandle_clone() {
    if (!this.$$.ptr) {
      throwInstanceAlreadyDeleted(this);
    }
    if (this.$$.preservePointerOnDelete) {
      this.$$.count.value += 1;
      return this;
    } else {
      var clone2 = attachFinalizer(Object.create(Object.getPrototypeOf(this), {
        $$: {
          value: shallowCopyInternalPointer(this.$$)
        }
      }));
      clone2.$$.count.value += 1;
      clone2.$$.deleteScheduled = false;
      return clone2;
    }
  }
  function ClassHandle_delete() {
    if (!this.$$.ptr) {
      throwInstanceAlreadyDeleted(this);
    }
    if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
      throwBindingError("Object already scheduled for deletion");
    }
    detachFinalizer(this);
    releaseClassHandle(this.$$);
    if (!this.$$.preservePointerOnDelete) {
      this.$$.smartPtr = void 0;
      this.$$.ptr = void 0;
    }
  }
  function ClassHandle_isDeleted() {
    return !this.$$.ptr;
  }
  var delayFunction = void 0;
  var deletionQueue = [];
  function flushPendingDeletes() {
    while (deletionQueue.length) {
      var obj = deletionQueue.pop();
      obj.$$.deleteScheduled = false;
      obj["delete"]();
    }
  }
  function ClassHandle_deleteLater() {
    if (!this.$$.ptr) {
      throwInstanceAlreadyDeleted(this);
    }
    if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
      throwBindingError("Object already scheduled for deletion");
    }
    deletionQueue.push(this);
    if (deletionQueue.length === 1 && delayFunction) {
      delayFunction(flushPendingDeletes);
    }
    this.$$.deleteScheduled = true;
    return this;
  }
  function init_ClassHandle() {
    ClassHandle.prototype["isAliasOf"] = ClassHandle_isAliasOf;
    ClassHandle.prototype["clone"] = ClassHandle_clone;
    ClassHandle.prototype["delete"] = ClassHandle_delete;
    ClassHandle.prototype["isDeleted"] = ClassHandle_isDeleted;
    ClassHandle.prototype["deleteLater"] = ClassHandle_deleteLater;
  }
  function ClassHandle() {
  }
  var registeredPointers = {};
  function ensureOverloadTable(proto, methodName, humanName) {
    if (void 0 === proto[methodName].overloadTable) {
      var prevFunc = proto[methodName];
      proto[methodName] = function() {
        if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
          throwBindingError("Function '" + humanName + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + proto[methodName].overloadTable + ")!");
        }
        return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
      };
      proto[methodName].overloadTable = [];
      proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
    }
  }
  function exposePublicSymbol(name12, value, numArguments) {
    if (Module2.hasOwnProperty(name12)) {
      if (void 0 === numArguments || void 0 !== Module2[name12].overloadTable && void 0 !== Module2[name12].overloadTable[numArguments]) {
        throwBindingError("Cannot register public name '" + name12 + "' twice");
      }
      ensureOverloadTable(Module2, name12, name12);
      if (Module2.hasOwnProperty(numArguments)) {
        throwBindingError("Cannot register multiple overloads of a function with the same number of arguments (" + numArguments + ")!");
      }
      Module2[name12].overloadTable[numArguments] = value;
    } else {
      Module2[name12] = value;
      if (void 0 !== numArguments) {
        Module2[name12].numArguments = numArguments;
      }
    }
  }
  function RegisteredClass(name12, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {
    this.name = name12;
    this.constructor = constructor;
    this.instancePrototype = instancePrototype;
    this.rawDestructor = rawDestructor;
    this.baseClass = baseClass;
    this.getActualType = getActualType;
    this.upcast = upcast;
    this.downcast = downcast;
    this.pureVirtualFunctions = [];
  }
  function upcastPointer(ptr, ptrClass, desiredClass) {
    while (ptrClass !== desiredClass) {
      if (!ptrClass.upcast) {
        throwBindingError("Expected null or instance of " + desiredClass.name + ", got an instance of " + ptrClass.name);
      }
      ptr = ptrClass.upcast(ptr);
      ptrClass = ptrClass.baseClass;
    }
    return ptr;
  }
  function constNoSmartPtrRawPointerToWireType(destructors, handle) {
    if (handle === null) {
      if (this.isReference) {
        throwBindingError("null is not a valid " + this.name);
      }
      return 0;
    }
    if (!handle.$$) {
      throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
    }
    if (!handle.$$.ptr) {
      throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
    }
    var handleClass = handle.$$.ptrType.registeredClass;
    var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
    return ptr;
  }
  function genericPointerToWireType(destructors, handle) {
    var ptr;
    if (handle === null) {
      if (this.isReference) {
        throwBindingError("null is not a valid " + this.name);
      }
      if (this.isSmartPointer) {
        ptr = this.rawConstructor();
        if (destructors !== null) {
          destructors.push(this.rawDestructor, ptr);
        }
        return ptr;
      } else {
        return 0;
      }
    }
    if (!handle.$$) {
      throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
    }
    if (!handle.$$.ptr) {
      throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
    }
    if (!this.isConst && handle.$$.ptrType.isConst) {
      throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
    }
    var handleClass = handle.$$.ptrType.registeredClass;
    ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
    if (this.isSmartPointer) {
      if (void 0 === handle.$$.smartPtr) {
        throwBindingError("Passing raw pointer to smart pointer is illegal");
      }
      switch (this.sharingPolicy) {
        case 0:
          if (handle.$$.smartPtrType === this) {
            ptr = handle.$$.smartPtr;
          } else {
            throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
          }
          break;
        case 1:
          ptr = handle.$$.smartPtr;
          break;
        case 2:
          if (handle.$$.smartPtrType === this) {
            ptr = handle.$$.smartPtr;
          } else {
            var clonedHandle = handle["clone"]();
            ptr = this.rawShare(ptr, __emval_register(function() {
              clonedHandle["delete"]();
            }));
            if (destructors !== null) {
              destructors.push(this.rawDestructor, ptr);
            }
          }
          break;
        default:
          throwBindingError("Unsupporting sharing policy");
      }
    }
    return ptr;
  }
  function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
    if (handle === null) {
      if (this.isReference) {
        throwBindingError("null is not a valid " + this.name);
      }
      return 0;
    }
    if (!handle.$$) {
      throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
    }
    if (!handle.$$.ptr) {
      throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
    }
    if (handle.$$.ptrType.isConst) {
      throwBindingError("Cannot convert argument of type " + handle.$$.ptrType.name + " to parameter type " + this.name);
    }
    var handleClass = handle.$$.ptrType.registeredClass;
    var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
    return ptr;
  }
  function simpleReadValueFromPointer(pointer) {
    return this["fromWireType"](HEAPU32[pointer >> 2]);
  }
  function RegisteredPointer_getPointee(ptr) {
    if (this.rawGetPointee) {
      ptr = this.rawGetPointee(ptr);
    }
    return ptr;
  }
  function RegisteredPointer_destructor(ptr) {
    if (this.rawDestructor) {
      this.rawDestructor(ptr);
    }
  }
  function RegisteredPointer_deleteObject(handle) {
    if (handle !== null) {
      handle["delete"]();
    }
  }
  function downcastPointer(ptr, ptrClass, desiredClass) {
    if (ptrClass === desiredClass) {
      return ptr;
    }
    if (void 0 === desiredClass.baseClass) {
      return null;
    }
    var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
    if (rv === null) {
      return null;
    }
    return desiredClass.downcast(rv);
  }
  function getInheritedInstanceCount() {
    return Object.keys(registeredInstances).length;
  }
  function getLiveInheritedInstances() {
    var rv = [];
    for (var k in registeredInstances) {
      if (registeredInstances.hasOwnProperty(k)) {
        rv.push(registeredInstances[k]);
      }
    }
    return rv;
  }
  function setDelayFunction(fn) {
    delayFunction = fn;
    if (deletionQueue.length && delayFunction) {
      delayFunction(flushPendingDeletes);
    }
  }
  function init_embind() {
    Module2["getInheritedInstanceCount"] = getInheritedInstanceCount;
    Module2["getLiveInheritedInstances"] = getLiveInheritedInstances;
    Module2["flushPendingDeletes"] = flushPendingDeletes;
    Module2["setDelayFunction"] = setDelayFunction;
  }
  var registeredInstances = {};
  function getBasestPointer(class_, ptr) {
    if (ptr === void 0) {
      throwBindingError("ptr should not be undefined");
    }
    while (class_.baseClass) {
      ptr = class_.upcast(ptr);
      class_ = class_.baseClass;
    }
    return ptr;
  }
  function getInheritedInstance(class_, ptr) {
    ptr = getBasestPointer(class_, ptr);
    return registeredInstances[ptr];
  }
  function makeClassHandle(prototype, record) {
    if (!record.ptrType || !record.ptr) {
      throwInternalError("makeClassHandle requires ptr and ptrType");
    }
    var hasSmartPtrType = !!record.smartPtrType;
    var hasSmartPtr = !!record.smartPtr;
    if (hasSmartPtrType !== hasSmartPtr) {
      throwInternalError("Both smartPtrType and smartPtr must be specified");
    }
    record.count = {
      value: 1
    };
    return attachFinalizer(Object.create(prototype, {
      $$: {
        value: record
      }
    }));
  }
  function RegisteredPointer_fromWireType(ptr) {
    var rawPointer = this.getPointee(ptr);
    if (!rawPointer) {
      this.destructor(ptr);
      return null;
    }
    var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
    if (void 0 !== registeredInstance) {
      if (0 === registeredInstance.$$.count.value) {
        registeredInstance.$$.ptr = rawPointer;
        registeredInstance.$$.smartPtr = ptr;
        return registeredInstance["clone"]();
      } else {
        var rv = registeredInstance["clone"]();
        this.destructor(ptr);
        return rv;
      }
    }
    function makeDefaultHandle() {
      if (this.isSmartPointer) {
        return makeClassHandle(this.registeredClass.instancePrototype, {
          ptrType: this.pointeeType,
          ptr: rawPointer,
          smartPtrType: this,
          smartPtr: ptr
        });
      } else {
        return makeClassHandle(this.registeredClass.instancePrototype, {
          ptrType: this,
          ptr
        });
      }
    }
    var actualType = this.registeredClass.getActualType(rawPointer);
    var registeredPointerRecord = registeredPointers[actualType];
    if (!registeredPointerRecord) {
      return makeDefaultHandle.call(this);
    }
    var toType;
    if (this.isConst) {
      toType = registeredPointerRecord.constPointerType;
    } else {
      toType = registeredPointerRecord.pointerType;
    }
    var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);
    if (dp === null) {
      return makeDefaultHandle.call(this);
    }
    if (this.isSmartPointer) {
      return makeClassHandle(toType.registeredClass.instancePrototype, {
        ptrType: toType,
        ptr: dp,
        smartPtrType: this,
        smartPtr: ptr
      });
    } else {
      return makeClassHandle(toType.registeredClass.instancePrototype, {
        ptrType: toType,
        ptr: dp
      });
    }
  }
  function init_RegisteredPointer() {
    RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;
    RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;
    RegisteredPointer.prototype["argPackAdvance"] = 8;
    RegisteredPointer.prototype["readValueFromPointer"] = simpleReadValueFromPointer;
    RegisteredPointer.prototype["deleteObject"] = RegisteredPointer_deleteObject;
    RegisteredPointer.prototype["fromWireType"] = RegisteredPointer_fromWireType;
  }
  function RegisteredPointer(name12, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {
    this.name = name12;
    this.registeredClass = registeredClass;
    this.isReference = isReference;
    this.isConst = isConst;
    this.isSmartPointer = isSmartPointer;
    this.pointeeType = pointeeType;
    this.sharingPolicy = sharingPolicy;
    this.rawGetPointee = rawGetPointee;
    this.rawConstructor = rawConstructor;
    this.rawShare = rawShare;
    this.rawDestructor = rawDestructor;
    if (!isSmartPointer && registeredClass.baseClass === void 0) {
      if (isConst) {
        this["toWireType"] = constNoSmartPtrRawPointerToWireType;
        this.destructorFunction = null;
      } else {
        this["toWireType"] = nonConstNoSmartPtrRawPointerToWireType;
        this.destructorFunction = null;
      }
    } else {
      this["toWireType"] = genericPointerToWireType;
    }
  }
  function replacePublicSymbol(name12, value, numArguments) {
    if (!Module2.hasOwnProperty(name12)) {
      throwInternalError("Replacing nonexistant public symbol");
    }
    if (void 0 !== Module2[name12].overloadTable && void 0 !== numArguments) {
      Module2[name12].overloadTable[numArguments] = value;
    } else {
      Module2[name12] = value;
      Module2[name12].argCount = numArguments;
    }
  }
  function embind__requireFunction(signature, rawFunction) {
    signature = readLatin1String(signature);
    function makeDynCaller(dynCall2) {
      var args = [];
      for (var i = 1; i < signature.length; ++i) {
        args.push("a" + i);
      }
      var name12 = "dynCall_" + signature + "_" + rawFunction;
      var body = "return function " + name12 + "(" + args.join(", ") + ") {\n";
      body += "    return dynCall(rawFunction" + (args.length ? ", " : "") + args.join(", ") + ");\n";
      body += "};\n";
      return new Function("dynCall", "rawFunction", body)(dynCall2, rawFunction);
    }
    var dc = Module2["dynCall_" + signature];
    var fp = makeDynCaller(dc);
    if (typeof fp !== "function") {
      throwBindingError("unknown function pointer with signature " + signature + ": " + rawFunction);
    }
    return fp;
  }
  var UnboundTypeError = void 0;
  function getTypeName(type) {
    var ptr = ___getTypeName(type);
    var rv = readLatin1String(ptr);
    _free(ptr);
    return rv;
  }
  function throwUnboundTypeError(message, types) {
    var unboundTypes = [];
    var seen = {};
    function visit(type) {
      if (seen[type]) {
        return;
      }
      if (registeredTypes[type]) {
        return;
      }
      if (typeDependencies[type]) {
        typeDependencies[type].forEach(visit);
        return;
      }
      unboundTypes.push(type);
      seen[type] = true;
    }
    types.forEach(visit);
    throw new UnboundTypeError(message + ": " + unboundTypes.map(getTypeName).join([", "]));
  }
  function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name12, destructorSignature, rawDestructor) {
    name12 = readLatin1String(name12);
    getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
    if (upcast) {
      upcast = embind__requireFunction(upcastSignature, upcast);
    }
    if (downcast) {
      downcast = embind__requireFunction(downcastSignature, downcast);
    }
    rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
    var legalFunctionName = makeLegalFunctionName(name12);
    exposePublicSymbol(legalFunctionName, function() {
      throwUnboundTypeError("Cannot construct " + name12 + " due to unbound types", [
        baseClassRawType
      ]);
    });
    whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], function(base) {
      base = base[0];
      var baseClass;
      var basePrototype;
      if (baseClassRawType) {
        baseClass = base.registeredClass;
        basePrototype = baseClass.instancePrototype;
      } else {
        basePrototype = ClassHandle.prototype;
      }
      var constructor = createNamedFunction(legalFunctionName, function() {
        if (Object.getPrototypeOf(this) !== instancePrototype) {
          throw new BindingError("Use 'new' to construct " + name12);
        }
        if (void 0 === registeredClass.constructor_body) {
          throw new BindingError(name12 + " has no accessible constructor");
        }
        var body = registeredClass.constructor_body[arguments.length];
        if (void 0 === body) {
          throw new BindingError("Tried to invoke ctor of " + name12 + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(registeredClass.constructor_body).toString() + ") parameters instead!");
        }
        return body.apply(this, arguments);
      });
      var instancePrototype = Object.create(basePrototype, {
        constructor: {
          value: constructor
        }
      });
      constructor.prototype = instancePrototype;
      var registeredClass = new RegisteredClass(name12, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);
      var referenceConverter = new RegisteredPointer(name12, registeredClass, true, false, false);
      var pointerConverter = new RegisteredPointer(name12 + "*", registeredClass, false, false, false);
      var constPointerConverter = new RegisteredPointer(name12 + " const*", registeredClass, false, true, false);
      registeredPointers[rawType] = {
        pointerType: pointerConverter,
        constPointerType: constPointerConverter
      };
      replacePublicSymbol(legalFunctionName, constructor);
      return [referenceConverter, pointerConverter, constPointerConverter];
    });
  }
  function heap32VectorToArray(count, firstElement) {
    var array = [];
    for (var i = 0; i < count; i++) {
      array.push(HEAP32[(firstElement >> 2) + i]);
    }
    return array;
  }
  function runDestructors(destructors) {
    while (destructors.length) {
      var ptr = destructors.pop();
      var del = destructors.pop();
      del(ptr);
    }
  }
  function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {
    assert6(argCount > 0);
    var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
    invoker = embind__requireFunction(invokerSignature, invoker);
    var args = [rawConstructor];
    var destructors = [];
    whenDependentTypesAreResolved([], [rawClassType], function(classType) {
      classType = classType[0];
      var humanName = "constructor " + classType.name;
      if (void 0 === classType.registeredClass.constructor_body) {
        classType.registeredClass.constructor_body = [];
      }
      if (void 0 !== classType.registeredClass.constructor_body[argCount - 1]) {
        throw new BindingError("Cannot register multiple constructors with identical number of parameters (" + (argCount - 1) + ") for class '" + classType.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
      }
      classType.registeredClass.constructor_body[argCount - 1] = function unboundTypeHandler() {
        throwUnboundTypeError("Cannot construct " + classType.name + " due to unbound types", rawArgTypes);
      };
      whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
        classType.registeredClass.constructor_body[argCount - 1] = function constructor_body() {
          if (arguments.length !== argCount - 1) {
            throwBindingError(humanName + " called with " + arguments.length + " arguments, expected " + (argCount - 1));
          }
          destructors.length = 0;
          args.length = argCount;
          for (var i = 1; i < argCount; ++i) {
            args[i] = argTypes[i]["toWireType"](destructors, arguments[i - 1]);
          }
          var ptr = invoker.apply(null, args);
          runDestructors(destructors);
          return argTypes[0]["fromWireType"](ptr);
        };
        return [];
      });
      return [];
    });
  }
  function new_(constructor, argumentList) {
    if (!(constructor instanceof Function)) {
      throw new TypeError("new_ called with constructor type " + typeof constructor + " which is not a function");
    }
    var dummy = createNamedFunction(constructor.name || "unknownFunctionName", function() {
    });
    dummy.prototype = constructor.prototype;
    var obj = new dummy();
    var r = constructor.apply(obj, argumentList);
    return r instanceof Object ? r : obj;
  }
  function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {
    var argCount = argTypes.length;
    if (argCount < 2) {
      throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
    }
    var isClassMethodFunc = argTypes[1] !== null && classType !== null;
    var needsDestructorStack = false;
    for (var i = 1; i < argTypes.length; ++i) {
      if (argTypes[i] !== null && argTypes[i].destructorFunction === void 0) {
        needsDestructorStack = true;
        break;
      }
    }
    var returns = argTypes[0].name !== "void";
    var argsList = "";
    var argsListWired = "";
    for (var i = 0; i < argCount - 2; ++i) {
      argsList += (i !== 0 ? ", " : "") + "arg" + i;
      argsListWired += (i !== 0 ? ", " : "") + "arg" + i + "Wired";
    }
    var invokerFnBody = "return function " + makeLegalFunctionName(humanName) + "(" + argsList + ") {\nif (arguments.length !== " + (argCount - 2) + ") {\nthrowBindingError('function " + humanName + " called with ' + arguments.length + ' arguments, expected " + (argCount - 2) + " args!');\n}\n";
    if (needsDestructorStack) {
      invokerFnBody += "var destructors = [];\n";
    }
    var dtorStack = needsDestructorStack ? "destructors" : "null";
    var args1 = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"];
    var args2 = [
      throwBindingError,
      cppInvokerFunc,
      cppTargetFunc,
      runDestructors,
      argTypes[0],
      argTypes[1]
    ];
    if (isClassMethodFunc) {
      invokerFnBody += "var thisWired = classParam.toWireType(" + dtorStack + ", this);\n";
    }
    for (var i = 0; i < argCount - 2; ++i) {
      invokerFnBody += "var arg" + i + "Wired = argType" + i + ".toWireType(" + dtorStack + ", arg" + i + "); // " + argTypes[i + 2].name + "\n";
      args1.push("argType" + i);
      args2.push(argTypes[i + 2]);
    }
    if (isClassMethodFunc) {
      argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
    }
    invokerFnBody += (returns ? "var rv = " : "") + "invoker(fn" + (argsListWired.length > 0 ? ", " : "") + argsListWired + ");\n";
    if (needsDestructorStack) {
      invokerFnBody += "runDestructors(destructors);\n";
    } else {
      for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {
        var paramName = i === 1 ? "thisWired" : "arg" + (i - 2) + "Wired";
        if (argTypes[i].destructorFunction !== null) {
          invokerFnBody += paramName + "_dtor(" + paramName + "); // " + argTypes[i].name + "\n";
          args1.push(paramName + "_dtor");
          args2.push(argTypes[i].destructorFunction);
        }
      }
    }
    if (returns) {
      invokerFnBody += "var ret = retType.fromWireType(rv);\nreturn ret;\n";
    } else {
    }
    invokerFnBody += "}\n";
    args1.push(invokerFnBody);
    var invokerFunction = new_(Function, args1).apply(null, args2);
    return invokerFunction;
  }
  function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual) {
    var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
    methodName = readLatin1String(methodName);
    rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
    whenDependentTypesAreResolved([], [rawClassType], function(classType) {
      classType = classType[0];
      var humanName = classType.name + "." + methodName;
      if (isPureVirtual) {
        classType.registeredClass.pureVirtualFunctions.push(methodName);
      }
      function unboundTypesHandler() {
        throwUnboundTypeError("Cannot call " + humanName + " due to unbound types", rawArgTypes);
      }
      var proto = classType.registeredClass.instancePrototype;
      var method = proto[methodName];
      if (void 0 === method || void 0 === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {
        unboundTypesHandler.argCount = argCount - 2;
        unboundTypesHandler.className = classType.name;
        proto[methodName] = unboundTypesHandler;
      } else {
        ensureOverloadTable(proto, methodName, humanName);
        proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
      }
      whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
        var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);
        if (void 0 === proto[methodName].overloadTable) {
          memberFunction.argCount = argCount - 2;
          proto[methodName] = memberFunction;
        } else {
          proto[methodName].overloadTable[argCount - 2] = memberFunction;
        }
        return [];
      });
      return [];
    });
  }
  var emval_free_list = [];
  var emval_handle_array = [
    {},
    {
      value: void 0
    },
    {
      value: null
    },
    {
      value: true
    },
    {
      value: false
    }
  ];
  function __emval_decref(handle) {
    if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {
      emval_handle_array[handle] = void 0;
      emval_free_list.push(handle);
    }
  }
  function count_emval_handles() {
    var count = 0;
    for (var i = 5; i < emval_handle_array.length; ++i) {
      if (emval_handle_array[i] !== void 0) {
        ++count;
      }
    }
    return count;
  }
  function get_first_emval() {
    for (var i = 5; i < emval_handle_array.length; ++i) {
      if (emval_handle_array[i] !== void 0) {
        return emval_handle_array[i];
      }
    }
    return null;
  }
  function init_emval() {
    Module2["count_emval_handles"] = count_emval_handles;
    Module2["get_first_emval"] = get_first_emval;
  }
  function __emval_register(value) {
    switch (value) {
      case void 0: {
        return 1;
      }
      case null: {
        return 2;
      }
      case true: {
        return 3;
      }
      case false: {
        return 4;
      }
      default: {
        var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;
        emval_handle_array[handle] = {
          refcount: 1,
          value
        };
        return handle;
      }
    }
  }
  function __embind_register_emval(rawType, name12) {
    name12 = readLatin1String(name12);
    registerType(rawType, {
      name: name12,
      fromWireType: function(handle) {
        var rv = emval_handle_array[handle].value;
        __emval_decref(handle);
        return rv;
      },
      toWireType: function(destructors, value) {
        return __emval_register(value);
      },
      argPackAdvance: 8,
      readValueFromPointer: simpleReadValueFromPointer,
      destructorFunction: null
    });
  }
  function _embind_repr(v) {
    if (v === null) {
      return "null";
    }
    var t = typeof v;
    if (t === "object" || t === "array" || t === "function") {
      return v.toString();
    } else {
      return "" + v;
    }
  }
  function floatReadValueFromPointer(name12, shift) {
    switch (shift) {
      case 2:
        return function(pointer) {
          return this["fromWireType"](HEAPF32[pointer >> 2]);
        };
      case 3:
        return function(pointer) {
          return this["fromWireType"](HEAPF64[pointer >> 3]);
        };
      default:
        throw new TypeError("Unknown float type: " + name12);
    }
  }
  function __embind_register_float(rawType, name12, size) {
    var shift = getShiftFromSize(size);
    name12 = readLatin1String(name12);
    registerType(rawType, {
      name: name12,
      fromWireType: function(value) {
        return value;
      },
      toWireType: function(destructors, value) {
        if (typeof value !== "number" && typeof value !== "boolean") {
          throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
        }
        return value;
      },
      argPackAdvance: 8,
      readValueFromPointer: floatReadValueFromPointer(name12, shift),
      destructorFunction: null
    });
  }
  function integerReadValueFromPointer(name12, shift, signed) {
    switch (shift) {
      case 0:
        return signed ? function readS8FromPointer(pointer) {
          return HEAP8[pointer];
        } : function readU8FromPointer(pointer) {
          return HEAPU8[pointer];
        };
      case 1:
        return signed ? function readS16FromPointer(pointer) {
          return HEAP16[pointer >> 1];
        } : function readU16FromPointer(pointer) {
          return HEAPU16[pointer >> 1];
        };
      case 2:
        return signed ? function readS32FromPointer(pointer) {
          return HEAP32[pointer >> 2];
        } : function readU32FromPointer(pointer) {
          return HEAPU32[pointer >> 2];
        };
      default:
        throw new TypeError("Unknown integer type: " + name12);
    }
  }
  function __embind_register_integer(primitiveType, name12, size, minRange, maxRange) {
    name12 = readLatin1String(name12);
    if (maxRange === -1) {
      maxRange = 4294967295;
    }
    var shift = getShiftFromSize(size);
    var fromWireType = function(value) {
      return value;
    };
    if (minRange === 0) {
      var bitshift = 32 - 8 * size;
      fromWireType = function(value) {
        return value << bitshift >>> bitshift;
      };
    }
    var isUnsignedType = name12.indexOf("unsigned") != -1;
    registerType(primitiveType, {
      name: name12,
      fromWireType,
      toWireType: function(destructors, value) {
        if (typeof value !== "number" && typeof value !== "boolean") {
          throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
        }
        if (value < minRange || value > maxRange) {
          throw new TypeError('Passing a number "' + _embind_repr(value) + '" from JS side to C/C++ side to an argument of type "' + name12 + '", which is outside the valid range [' + minRange + ", " + maxRange + "]!");
        }
        return isUnsignedType ? value >>> 0 : value | 0;
      },
      argPackAdvance: 8,
      readValueFromPointer: integerReadValueFromPointer(name12, shift, minRange !== 0),
      destructorFunction: null
    });
  }
  function __embind_register_memory_view(rawType, dataTypeIndex, name12) {
    var typeMapping = [
      Int8Array,
      Uint8Array,
      Int16Array,
      Uint16Array,
      Int32Array,
      Uint32Array,
      Float32Array,
      Float64Array
    ];
    var TA = typeMapping[dataTypeIndex];
    function decodeMemoryView(handle) {
      handle = handle >> 2;
      var heap = HEAPU32;
      var size = heap[handle];
      var data2 = heap[handle + 1];
      return new TA(buffer, data2, size);
    }
    name12 = readLatin1String(name12);
    registerType(rawType, {
      name: name12,
      fromWireType: decodeMemoryView,
      argPackAdvance: 8,
      readValueFromPointer: decodeMemoryView
    }, {
      ignoreDuplicateRegistrations: true
    });
  }
  function __embind_register_std_string(rawType, name12) {
    name12 = readLatin1String(name12);
    var stdStringIsUTF8 = name12 === "std::string";
    registerType(rawType, {
      name: name12,
      fromWireType: function(value) {
        var length = HEAPU32[value >> 2];
        var str;
        if (stdStringIsUTF8) {
          var decodeStartPtr = value + 4;
          for (var i = 0; i <= length; ++i) {
            var currentBytePtr = value + 4 + i;
            if (HEAPU8[currentBytePtr] == 0 || i == length) {
              var maxRead = currentBytePtr - decodeStartPtr;
              var stringSegment = UTF8ToString(decodeStartPtr, maxRead);
              if (str === void 0) {
                str = stringSegment;
              } else {
                str += String.fromCharCode(0);
                str += stringSegment;
              }
              decodeStartPtr = currentBytePtr + 1;
            }
          }
        } else {
          var a2 = new Array(length);
          for (var i = 0; i < length; ++i) {
            a2[i] = String.fromCharCode(HEAPU8[value + 4 + i]);
          }
          str = a2.join("");
        }
        _free(value);
        return str;
      },
      toWireType: function(destructors, value) {
        if (value instanceof ArrayBuffer) {
          value = new Uint8Array(value);
        }
        var getLength;
        var valueIsOfTypeString = typeof value === "string";
        if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
          throwBindingError("Cannot pass non-string to std::string");
        }
        if (stdStringIsUTF8 && valueIsOfTypeString) {
          getLength = function() {
            return lengthBytesUTF8(value);
          };
        } else {
          getLength = function() {
            return value.length;
          };
        }
        var length = getLength();
        var ptr = _malloc(4 + length + 1);
        HEAPU32[ptr >> 2] = length;
        if (stdStringIsUTF8 && valueIsOfTypeString) {
          stringToUTF8(value, ptr + 4, length + 1);
        } else {
          if (valueIsOfTypeString) {
            for (var i = 0; i < length; ++i) {
              var charCode = value.charCodeAt(i);
              if (charCode > 255) {
                _free(ptr);
                throwBindingError("String has UTF-16 code units that do not fit in 8 bits");
              }
              HEAPU8[ptr + 4 + i] = charCode;
            }
          } else {
            for (var i = 0; i < length; ++i) {
              HEAPU8[ptr + 4 + i] = value[i];
            }
          }
        }
        if (destructors !== null) {
          destructors.push(_free, ptr);
        }
        return ptr;
      },
      argPackAdvance: 8,
      readValueFromPointer: simpleReadValueFromPointer,
      destructorFunction: function(ptr) {
        _free(ptr);
      }
    });
  }
  function __embind_register_std_wstring(rawType, charSize, name12) {
    name12 = readLatin1String(name12);
    var decodeString, encodeString, getHeap, lengthBytesUTF, shift;
    if (charSize === 2) {
      decodeString = UTF16ToString;
      encodeString = stringToUTF16;
      lengthBytesUTF = lengthBytesUTF16;
      getHeap = function() {
        return HEAPU16;
      };
      shift = 1;
    } else if (charSize === 4) {
      decodeString = UTF32ToString;
      encodeString = stringToUTF32;
      lengthBytesUTF = lengthBytesUTF32;
      getHeap = function() {
        return HEAPU32;
      };
      shift = 2;
    }
    registerType(rawType, {
      name: name12,
      fromWireType: function(value) {
        var length = HEAPU32[value >> 2];
        var HEAP = getHeap();
        var str;
        var decodeStartPtr = value + 4;
        for (var i = 0; i <= length; ++i) {
          var currentBytePtr = value + 4 + i * charSize;
          if (HEAP[currentBytePtr >> shift] == 0 || i == length) {
            var maxReadBytes = currentBytePtr - decodeStartPtr;
            var stringSegment = decodeString(decodeStartPtr, maxReadBytes);
            if (str === void 0) {
              str = stringSegment;
            } else {
              str += String.fromCharCode(0);
              str += stringSegment;
            }
            decodeStartPtr = currentBytePtr + charSize;
          }
        }
        _free(value);
        return str;
      },
      toWireType: function(destructors, value) {
        if (!(typeof value === "string")) {
          throwBindingError("Cannot pass non-string to C++ string type " + name12);
        }
        var length = lengthBytesUTF(value);
        var ptr = _malloc(4 + length + charSize);
        HEAPU32[ptr >> 2] = length >> shift;
        encodeString(value, ptr + 4, length + charSize);
        if (destructors !== null) {
          destructors.push(_free, ptr);
        }
        return ptr;
      },
      argPackAdvance: 8,
      readValueFromPointer: simpleReadValueFromPointer,
      destructorFunction: function(ptr) {
        _free(ptr);
      }
    });
  }
  function __embind_register_void(rawType, name12) {
    name12 = readLatin1String(name12);
    registerType(rawType, {
      isVoid: true,
      name: name12,
      argPackAdvance: 0,
      fromWireType: function() {
        return void 0;
      },
      toWireType: function(destructors, o) {
        return void 0;
      }
    });
  }
  function _abort() {
    abort();
  }
  function _emscripten_get_heap_size() {
    return HEAPU8.length;
  }
  function abortOnCannotGrowMemory(requestedSize) {
    abort("OOM");
  }
  function _emscripten_resize_heap(requestedSize) {
    requestedSize = requestedSize >>> 0;
    abortOnCannotGrowMemory(requestedSize);
  }
  function _llvm_trap() {
    abort("trap!");
  }
  function _emscripten_memcpy_big(dest, src, num) {
    HEAPU8.copyWithin(dest, src, src + num);
  }
  embind_init_charCodes();
  BindingError = Module2["BindingError"] = extendError(Error, "BindingError");
  InternalError = Module2["InternalError"] = extendError(Error, "InternalError");
  init_ClassHandle();
  init_RegisteredPointer();
  init_embind();
  UnboundTypeError = Module2["UnboundTypeError"] = extendError(Error, "UnboundTypeError");
  init_emval();
  var ASSERTIONS = false;
  function intArrayToString(array) {
    var ret = [];
    for (var i = 0; i < array.length; i++) {
      var chr = array[i];
      if (chr > 255) {
        if (ASSERTIONS) {
          assert6(false, "Character code " + chr + " (" + String.fromCharCode(chr) + ")  at offset " + i + " not in 0x00-0xFF.");
        }
        chr &= 255;
      }
      ret.push(String.fromCharCode(chr));
    }
    return ret.join("");
  }
  var decodeBase64 = typeof atob === "function" ? atob : function(input) {
    var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var output = "";
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i = 0;
    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
    do {
      enc1 = keyStr.indexOf(input.charAt(i++));
      enc2 = keyStr.indexOf(input.charAt(i++));
      enc3 = keyStr.indexOf(input.charAt(i++));
      enc4 = keyStr.indexOf(input.charAt(i++));
      chr1 = enc1 << 2 | enc2 >> 4;
      chr2 = (enc2 & 15) << 4 | enc3 >> 2;
      chr3 = (enc3 & 3) << 6 | enc4;
      output = output + String.fromCharCode(chr1);
      if (enc3 !== 64) {
        output = output + String.fromCharCode(chr2);
      }
      if (enc4 !== 64) {
        output = output + String.fromCharCode(chr3);
      }
    } while (i < input.length);
    return output;
  };
  function intArrayFromBase64(s) {
    if (typeof ENVIRONMENT_IS_NODE === "boolean" && ENVIRONMENT_IS_NODE) {
      var buf;
      try {
        buf = Buffer.from(s, "base64");
      } catch (_) {
        buf = new Buffer(s, "base64");
      }
      return new Uint8Array(buf["buffer"], buf["byteOffset"], buf["byteLength"]);
    }
    try {
      var decoded = decodeBase64(s);
      var bytes = new Uint8Array(decoded.length);
      for (var i = 0; i < decoded.length; ++i) {
        bytes[i] = decoded.charCodeAt(i);
      }
      return bytes;
    } catch (_) {
      throw new Error("Converting base64 string to bytes failed.");
    }
  }
  function tryParseAsDataURI(filename2) {
    if (!isDataURI(filename2)) {
      return;
    }
    return intArrayFromBase64(filename2.slice(dataURIPrefix.length));
  }
  var asmGlobalArg = {
    Math,
    Int8Array,
    Int16Array,
    Int32Array,
    Uint8Array,
    Uint16Array,
    Float32Array,
    Float64Array
  };
  var asmLibraryArg = {
    A: _emscripten_memcpy_big,
    B: _emscripten_resize_heap,
    C: _llvm_trap,
    D: tempDoublePtr,
    a: abort,
    b: setTempRet0,
    c: getTempRet0,
    d: ___cxa_allocate_exception,
    e: ___cxa_begin_catch,
    f: ___cxa_throw,
    g: ___cxa_uncaught_exceptions,
    h: ___exception_addRef,
    i: ___exception_deAdjust,
    j: ___gxx_personality_v0,
    k: __embind_register_bool,
    l: __embind_register_class,
    m: __embind_register_class_constructor,
    n: __embind_register_class_function,
    o: __embind_register_emval,
    p: __embind_register_float,
    q: __embind_register_integer,
    r: __embind_register_memory_view,
    s: __embind_register_std_string,
    t: __embind_register_std_wstring,
    u: __embind_register_void,
    v: __emval_decref,
    w: __emval_register,
    x: _abort,
    y: _embind_repr,
    z: _emscripten_get_heap_size
  };
  var asm = (
    /** @suppress {uselessCode} */
    function(global2, env, buffer2) {
      ;
      var a2 = new global2.Int8Array(buffer2), b4 = new global2.Int16Array(buffer2), c2 = new global2.Int32Array(buffer2), d = new global2.Uint8Array(buffer2), e = new global2.Uint16Array(buffer2), f = new global2.Float32Array(buffer2), g = new global2.Float64Array(buffer2), h = env.D | 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = global2.Math.imul, r = global2.Math.clz32, s = env.a, t = env.b, u = env.c, v = env.d, w = env.e, x = env.f, y = env.g, z = env.h, A = env.i, B = env.j, C = env.k, D = env.l, E = env.m, F = env.n, G = env.o, H = env.p, I = env.q, J = env.r, K = env.s, L = env.t, M = env.u, N = env.v, O = env.w, P = env.x, Q = env.y, R = env.z, S = env.A, T = env.B, U = env.C, V = 22384, W = 5265264, X = 0;
      function ia() {
        em();
        fm();
      }
      function ja() {
        ka(0);
        return;
      }
      function ka(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0, m2 = 0;
        a3 = V;
        V = V + 16 | 0;
        b5 = a3 + 8 | 0;
        d2 = a3;
        vk();
        m2 = xk() | 0;
        g2 = yk() | 0;
        f2 = Ak() | 0;
        h2 = Bk() | 0;
        i2 = Ck() | 0;
        j2 = Dk() | 0;
        k2 = Jk() | 0;
        l2 = Kk() | 0;
        e2 = Kk() | 0;
        D(f2 | 0, h2 | 0, i2 | 0, j2 | 0, k2 | 0, 9, l2 | 0, m2 | 0, e2 | 0, g2 | 0, 6204, Lk() | 0, 138);
        Nk(1);
        c2[d2 >> 2] = 5;
        c2[d2 + 4 >> 2] = 0;
        c2[b5 >> 2] = c2[d2 >> 2];
        c2[b5 + 4 >> 2] = c2[d2 + 4 >> 2];
        Uk(6211, b5);
        c2[d2 >> 2] = 3;
        c2[d2 + 4 >> 2] = 0;
        c2[b5 >> 2] = c2[d2 >> 2];
        c2[b5 + 4 >> 2] = c2[d2 + 4 >> 2];
        cl(6216, b5);
        c2[d2 >> 2] = 10;
        c2[d2 + 4 >> 2] = 0;
        c2[b5 >> 2] = c2[d2 >> 2];
        c2[b5 + 4 >> 2] = c2[d2 + 4 >> 2];
        kl(6225, b5);
        sl();
        g2 = ul() | 0;
        e2 = vl() | 0;
        m2 = xl() | 0;
        l2 = yl() | 0;
        k2 = zl() | 0;
        j2 = Dk() | 0;
        i2 = Jk() | 0;
        h2 = Kk() | 0;
        f2 = Kk() | 0;
        D(m2 | 0, l2 | 0, k2 | 0, j2 | 0, i2 | 0, 11, h2 | 0, g2 | 0, f2 | 0, e2 | 0, 6234, Lk() | 0, 139);
        Gl(2);
        c2[d2 >> 2] = 6;
        c2[d2 + 4 >> 2] = 0;
        c2[b5 >> 2] = c2[d2 >> 2];
        c2[b5 + 4 >> 2] = c2[d2 + 4 >> 2];
        Nl(6211, b5);
        c2[d2 >> 2] = 4;
        c2[d2 + 4 >> 2] = 0;
        c2[b5 >> 2] = c2[d2 >> 2];
        c2[b5 + 4 >> 2] = c2[d2 + 4 >> 2];
        Ul(6248, b5);
        c2[d2 >> 2] = 5;
        c2[d2 + 4 >> 2] = 0;
        c2[b5 >> 2] = c2[d2 >> 2];
        c2[b5 + 4 >> 2] = c2[d2 + 4 >> 2];
        Ul(6265, b5);
        c2[d2 >> 2] = 6;
        c2[d2 + 4 >> 2] = 0;
        c2[b5 >> 2] = c2[d2 >> 2];
        c2[b5 + 4 >> 2] = c2[d2 + 4 >> 2];
        Ul(6280, b5);
        c2[d2 >> 2] = 7;
        c2[d2 + 4 >> 2] = 0;
        c2[b5 >> 2] = c2[d2 >> 2];
        c2[b5 + 4 >> 2] = c2[d2 + 4 >> 2];
        _l(6216, b5);
        V = a3;
        return;
      }
      function la(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0;
        e2 = V;
        V = V + 32 | 0;
        h2 = e2 + 16 | 0;
        f2 = e2 + 8 | 0;
        i2 = e2;
        g2 = eq(20) | 0;
        ta(g2, b5, d2);
        c2[i2 >> 2] = 0;
        c2[h2 >> 2] = c2[i2 >> 2];
        va(f2, g2, h2);
        b5 = c2[f2 >> 2] | 0;
        c2[f2 >> 2] = c2[a3 >> 2];
        c2[a3 >> 2] = b5;
        b5 = f2 + 4 | 0;
        d2 = a3 + 4 | 0;
        g2 = c2[b5 >> 2] | 0;
        c2[b5 >> 2] = c2[d2 >> 2];
        c2[d2 >> 2] = g2;
        wa(f2);
        d2 = eq(352) | 0;
        ua(d2, c2[a3 >> 2] | 0);
        g2 = a3 + 8 | 0;
        c2[i2 >> 2] = 0;
        c2[h2 >> 2] = c2[i2 >> 2];
        Fa(f2, d2, h2);
        d2 = c2[f2 >> 2] | 0;
        c2[f2 >> 2] = c2[g2 >> 2];
        c2[g2 >> 2] = d2;
        g2 = f2 + 4 | 0;
        d2 = a3 + 12 | 0;
        b5 = c2[g2 >> 2] | 0;
        c2[g2 >> 2] = c2[d2 >> 2];
        c2[d2 >> 2] = b5;
        Ga(f2);
        V = e2;
        return;
      }
      function ma(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        dd(c2[a3 + 8 >> 2] | 0, b5);
        return;
      }
      function na(a3) {
        a3 = a3 | 0;
        a3 = (Qh(c2[a3 + 8 >> 2] | 0) | 0) + 107 | 0;
        return d[a3 >> 0] | d[a3 + 1 >> 0] << 8 | d[a3 + 2 >> 0] << 16 | d[a3 + 3 >> 0] << 24 | 0;
      }
      function oa(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0;
        e2 = V;
        V = V + 32 | 0;
        g2 = e2 + 16 | 0;
        f2 = e2 + 8 | 0;
        h2 = e2;
        i2 = eq(12) | 0;
        Rh(i2, b5, d2);
        c2[h2 >> 2] = 0;
        c2[g2 >> 2] = c2[h2 >> 2];
        Vh(f2, i2, g2);
        i2 = c2[f2 >> 2] | 0;
        c2[f2 >> 2] = c2[a3 >> 2];
        c2[a3 >> 2] = i2;
        i2 = f2 + 4 | 0;
        d2 = a3 + 4 | 0;
        b5 = c2[i2 >> 2] | 0;
        c2[i2 >> 2] = c2[d2 >> 2];
        c2[d2 >> 2] = b5;
        Wh(f2);
        d2 = a3 + 8 | 0;
        b5 = eq(12) | 0;
        Sh(b5, c2[a3 >> 2] | 0);
        c2[h2 >> 2] = 0;
        c2[g2 >> 2] = c2[h2 >> 2];
        ai(f2, b5, g2);
        b5 = c2[f2 >> 2] | 0;
        c2[f2 >> 2] = c2[d2 >> 2];
        c2[d2 >> 2] = b5;
        b5 = f2 + 4 | 0;
        h2 = a3 + 12 | 0;
        i2 = c2[b5 >> 2] | 0;
        c2[b5 >> 2] = c2[h2 >> 2];
        c2[h2 >> 2] = i2;
        bi(f2);
        Th(f2, c2[d2 >> 2] | 0);
        d2 = a3 + 16 | 0;
        h2 = c2[f2 >> 2] | 0;
        i2 = f2 + 4 | 0;
        b5 = c2[i2 >> 2] | 0;
        c2[f2 >> 2] = 0;
        c2[i2 >> 2] = 0;
        c2[g2 >> 2] = c2[d2 >> 2];
        c2[d2 >> 2] = h2;
        d2 = a3 + 20 | 0;
        c2[g2 + 4 >> 2] = c2[d2 >> 2];
        c2[d2 >> 2] = b5;
        Uh(g2);
        Uh(f2);
        V = e2;
        return;
      }
      function pa(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0;
        a3 = a3 + 16 | 0;
        d2 = c2[a3 >> 2] | 0;
        a:
          do
            if (d2 | 0)
              switch (b5 | 0) {
                case 4: {
                  ui(d2);
                  break a;
                }
                case 8: {
                  vi(d2);
                  vi(c2[a3 >> 2] | 0);
                  break a;
                }
                default:
                  break a;
              }
          while (0);
        return;
      }
      function qa(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0;
        d2 = a3 + 16 | 0;
        a3 = c2[d2 >> 2] | 0;
        a:
          do
            if (a3 | 0) {
              switch (b5 | 0) {
                case 1: {
                  hj(a3);
                  break a;
                }
                case 2: {
                  ij(a3);
                  break a;
                }
                case 8: {
                  ui(a3);
                  a3 = c2[d2 >> 2] | 0;
                  break;
                }
                case 4:
                  break;
                default:
                  break a;
              }
              ui(a3);
            }
          while (0);
        return;
      }
      function ra(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0;
        d2 = a3 + 16 | 0;
        a3 = c2[d2 >> 2] | 0;
        a:
          do
            if (a3 | 0) {
              switch (b5 | 0) {
                case 1: {
                  Rj(a3);
                  break a;
                }
                case 2: {
                  Sj(a3);
                  break a;
                }
                case 8: {
                  vi(a3);
                  a3 = c2[d2 >> 2] | 0;
                  break;
                }
                case 4:
                  break;
                default:
                  break a;
              }
              vi(a3);
            }
          while (0);
        return;
      }
      function sa(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        a3 = c2[a3 + 16 >> 2] | 0;
        if (a3 | 0)
          $[c2[c2[a3 >> 2] >> 2] & 63](a3, b5) | 0;
        return;
      }
      function ta(b5, d2, e2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        c2[b5 >> 2] = d2;
        c2[b5 + 4 >> 2] = e2;
        c2[b5 + 8 >> 2] = 0;
        a2[b5 + 12 >> 0] = 0;
        a2[b5 + 13 >> 0] = 0;
        c2[b5 + 16 >> 2] = 0;
        return;
      }
      function ua(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c2[a3 >> 2] = b5;
        Va(a3 + 4 | 0, b5);
        Wa(a3 + 247 | 0);
        c2[a3 + 288 >> 2] = 0;
        c2[a3 + 292 >> 2] = 0;
        c2[a3 + 296 >> 2] = 0;
        Xa(a3 + 300 | 0);
        b5 = a3 + 312 | 0;
        c2[b5 >> 2] = 0;
        c2[b5 + 4 >> 2] = 0;
        c2[b5 + 8 >> 2] = 0;
        c2[b5 + 12 >> 2] = 0;
        Ya(a3 + 328 | 0);
        Za(a3);
        return;
      }
      function va(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0;
        d2 = V;
        V = V + 16 | 0;
        e2 = d2;
        c2[a3 >> 2] = b5;
        f2 = eq(16) | 0;
        c2[f2 + 4 >> 2] = 0;
        c2[f2 + 8 >> 2] = 0;
        c2[f2 >> 2] = 4296;
        c2[f2 + 12 >> 2] = b5;
        c2[a3 + 4 >> 2] = f2;
        c2[e2 >> 2] = b5;
        c2[e2 + 4 >> 2] = b5;
        xa(a3, e2);
        V = d2;
        return;
      }
      function wa(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        a3 = c2[a3 + 4 >> 2] | 0;
        if (a3 | 0 ? (d2 = a3 + 4 | 0, b5 = c2[d2 >> 2] | 0, c2[d2 >> 2] = b5 + -1, (b5 | 0) == 0) : 0) {
          ca[c2[(c2[a3 >> 2] | 0) + 8 >> 2] & 255](a3);
          qq(a3);
        }
        return;
      }
      function xa(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return;
      }
      function ya(a3) {
        a3 = a3 | 0;
        w(a3 | 0) | 0;
        lp();
      }
      function za(a3) {
        a3 = a3 | 0;
        pq(a3);
        jp(a3);
        return;
      }
      function Aa(a3) {
        a3 = a3 | 0;
        a3 = c2[a3 + 12 >> 2] | 0;
        if (a3 | 0)
          jp(a3);
        return;
      }
      function Ba(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return ((c2[b5 + 4 >> 2] | 0) == 6407 ? a3 + 12 | 0 : 0) | 0;
      }
      function Ca(a3) {
        a3 = a3 | 0;
        Da(a3, 16);
        return;
      }
      function Da(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        Ea(a3);
        return;
      }
      function Ea(a3) {
        a3 = a3 | 0;
        jp(a3);
        return;
      }
      function Fa(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0;
        d2 = V;
        V = V + 16 | 0;
        e2 = d2;
        c2[a3 >> 2] = b5;
        f2 = eq(16) | 0;
        c2[f2 + 4 >> 2] = 0;
        c2[f2 + 8 >> 2] = 0;
        c2[f2 >> 2] = 4324;
        c2[f2 + 12 >> 2] = b5;
        c2[a3 + 4 >> 2] = f2;
        c2[e2 >> 2] = b5;
        c2[e2 + 4 >> 2] = b5;
        Ha(a3, e2);
        V = d2;
        return;
      }
      function Ga(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        a3 = c2[a3 + 4 >> 2] | 0;
        if (a3 | 0 ? (d2 = a3 + 4 | 0, b5 = c2[d2 >> 2] | 0, c2[d2 >> 2] = b5 + -1, (b5 | 0) == 0) : 0) {
          ca[c2[(c2[a3 >> 2] | 0) + 8 >> 2] & 255](a3);
          qq(a3);
        }
        return;
      }
      function Ha(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return;
      }
      function Ia(a3) {
        a3 = a3 | 0;
        pq(a3);
        jp(a3);
        return;
      }
      function Ja(a3) {
        a3 = a3 | 0;
        a3 = c2[a3 + 12 >> 2] | 0;
        if (a3 | 0) {
          Ma(a3);
          jp(a3);
        }
        return;
      }
      function Ka(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return ((c2[b5 + 4 >> 2] | 0) == 6605 ? a3 + 12 | 0 : 0) | 0;
      }
      function La(a3) {
        a3 = a3 | 0;
        Da(a3, 16);
        return;
      }
      function Ma(a3) {
        a3 = a3 | 0;
        Na(a3 + 320 | 0);
        Oa(a3 + 312 | 0);
        Pa(a3 + 300 | 0);
        Ta(a3 + 288 | 0);
        Qa(a3 + 247 | 0);
        Ra(a3 + 4 | 0);
        return;
      }
      function Na(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        a3 = c2[a3 + 4 >> 2] | 0;
        if (a3 | 0 ? (d2 = a3 + 4 | 0, b5 = c2[d2 >> 2] | 0, c2[d2 >> 2] = b5 + -1, (b5 | 0) == 0) : 0) {
          ca[c2[(c2[a3 >> 2] | 0) + 8 >> 2] & 255](a3);
          qq(a3);
        }
        return;
      }
      function Oa(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        a3 = c2[a3 + 4 >> 2] | 0;
        if (a3 | 0 ? (d2 = a3 + 4 | 0, b5 = c2[d2 >> 2] | 0, c2[d2 >> 2] = b5 + -1, (b5 | 0) == 0) : 0) {
          ca[c2[(c2[a3 >> 2] | 0) + 8 >> 2] & 255](a3);
          qq(a3);
        }
        return;
      }
      function Pa(a3) {
        a3 = a3 | 0;
        Sa(a3);
        return;
      }
      function Qa(a3) {
        a3 = a3 | 0;
        a3 = a3 + 34 | 0;
        a3 = d[a3 >> 0] | d[a3 + 1 >> 0] << 8 | d[a3 + 2 >> 0] << 16 | d[a3 + 3 >> 0] << 24;
        if (a3 | 0)
          gq(a3);
        return;
      }
      function Ra(a3) {
        a3 = a3 | 0;
        Ua(c2[a3 + 12 >> 2] | 0);
        return;
      }
      function Sa(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        b5 = c2[a3 >> 2] | 0;
        d2 = b5;
        if (b5 | 0) {
          c2[a3 + 4 >> 2] = d2;
          Da(b5, (c2[a3 + 8 >> 2] | 0) - d2 | 0);
        }
        return;
      }
      function Ta(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        b5 = c2[a3 >> 2] | 0;
        d2 = b5;
        if (b5 | 0) {
          c2[a3 + 4 >> 2] = d2;
          Da(b5, (c2[a3 + 8 >> 2] | 0) - d2 | 0);
        }
        return;
      }
      function Ua(a3) {
        a3 = a3 | 0;
        er(c2[a3 + -4 >> 2] | 0);
        return;
      }
      function Va(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c2[a3 >> 2] = b5;
        c2[a3 + 4 >> 2] = 0;
        c2[a3 + 8 >> 2] = 0;
        c2[a3 + 12 >> 2] = _a(1048576) | 0;
        return;
      }
      function Wa(b5) {
        b5 = b5 | 0;
        var c3 = 0;
        c3 = b5 + 32 | 0;
        a2[c3 >> 0] = 0;
        a2[c3 + 1 >> 0] = 0;
        b5 = b5 + 34 | 0;
        a2[b5 >> 0] = 0;
        a2[b5 + 1 >> 0] = 0;
        a2[b5 + 2 >> 0] = 0;
        a2[b5 + 3 >> 0] = 0;
        return;
      }
      function Xa(a3) {
        a3 = a3 | 0;
        c2[a3 >> 2] = 0;
        c2[a3 + 4 >> 2] = 0;
        c2[a3 + 8 >> 2] = 0;
        return;
      }
      function Ya(a3) {
        a3 = a3 | 0;
        c2[a3 >> 2] = 0;
        c2[a3 + 4 >> 2] = 0;
        c2[a3 + 8 >> 2] = 0;
        c2[a3 + 12 >> 2] = 0;
        a3 = a3 + 16 | 0;
        c2[a3 >> 2] = -1;
        c2[a3 + 4 >> 2] = -1;
        return;
      }
      function Za(b5) {
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0;
        i2 = V;
        V = V + 64 | 0;
        g2 = i2 + 32 | 0;
        e2 = i2 + 56 | 0;
        d2 = i2 + 16 | 0;
        h2 = i2;
        $a(c2[b5 >> 2] | 0, e2, 4);
        mb(g2, e2, e2 + 4 | 0);
        e2 = lb(6693) | 0;
        f2 = a2[g2 + 11 >> 0] | 0;
        if ((e2 | 0) == ((f2 << 24 >> 24 < 0 ? c2[g2 + 4 >> 2] | 0 : f2 & 255) | 0)) {
          f2 = (Hq(g2, 0, -1, 6693, e2) | 0) == 0;
          Cq(g2);
          if (f2) {
            e2 = c2[b5 >> 2] | 0;
            c2[d2 >> 2] = 0;
            c2[d2 + 4 >> 2] = 0;
            c2[d2 + 8 >> 2] = 0;
            c2[d2 + 12 >> 2] = 0;
            c2[g2 >> 2] = c2[d2 >> 2];
            c2[g2 + 4 >> 2] = c2[d2 + 4 >> 2];
            c2[g2 + 8 >> 2] = c2[d2 + 8 >> 2];
            c2[g2 + 12 >> 2] = c2[d2 + 12 >> 2];
            bb(e2, g2);
            e2 = b5 + 20 | 0;
            $a(c2[b5 >> 2] | 0, e2, 227);
            cb2(b5, e2);
            f2 = db() | 0;
            d2 = c2[f2 >> 2] | 0;
            f2 = c2[f2 + 4 >> 2] | 0;
            if ((d2 | 0) != (f2 | 0))
              do {
                eb(g2, d2);
                fb(g2, e2);
                gb(g2);
                d2 = d2 + 24 | 0;
              } while ((d2 | 0) != (f2 | 0));
            hb(b5);
            ib(b5);
            jb(c2[b5 >> 2] | 0);
            f2 = c2[b5 >> 2] | 0;
            d2 = (c2[b5 + 116 >> 2] | 0) + 8 | 0;
            e2 = h2;
            c2[e2 >> 2] = 0;
            c2[e2 + 4 >> 2] = 0;
            e2 = h2 + 8 | 0;
            c2[e2 >> 2] = d2;
            c2[e2 + 4 >> 2] = 0;
            c2[g2 >> 2] = c2[h2 >> 2];
            c2[g2 + 4 >> 2] = c2[h2 + 4 >> 2];
            c2[g2 + 8 >> 2] = c2[h2 + 8 >> 2];
            c2[g2 + 12 >> 2] = c2[h2 + 12 >> 2];
            bb(f2, g2);
            kb(b5 + 4 | 0);
            V = i2;
            return;
          }
        } else
          Cq(g2);
        i2 = v(8) | 0;
        ab2(i2);
        x(i2 | 0, 2592, 8);
      }
      function _a(a3) {
        a3 = a3 | 0;
        var b5 = 0;
        b5 = dr(a3 + 68 | 0) | 0;
        a3 = b5 + 68 & -64;
        c2[a3 + -4 >> 2] = b5;
        return a3 | 0;
      }
      function $a(b5, d2, e2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0;
        i2 = b5 + 13 | 0;
        if (!(a2[i2 >> 0] | 0)) {
          h2 = b5 + 4 | 0;
          f2 = c2[h2 >> 2] | 0;
          j2 = b5 + 8 | 0;
          g2 = c2[j2 >> 2] | 0;
          k2 = f2 - g2 | 0;
          e2 = (k2 | 0) < (e2 | 0) ? k2 : e2;
          if (e2) {
            vr(d2 | 0, (c2[b5 >> 2] | 0) + g2 | 0, e2 | 0) | 0;
            g2 = c2[j2 >> 2] | 0;
            f2 = c2[h2 >> 2] | 0;
          }
          k2 = g2 + e2 | 0;
          c2[j2 >> 2] = k2;
          c2[b5 + 16 >> 2] = e2;
          if ((k2 | 0) >= (f2 | 0))
            a2[i2 >> 0] = 1;
        } else
          a2[b5 + 12 >> 0] = 1;
        return;
      }
      function ab2(a3) {
        a3 = a3 | 0;
        xq(a3, 6791);
        c2[a3 >> 2] = 4352;
        return;
      }
      function bb(b5, d2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0, g2 = 0;
        g2 = d2 + 8 | 0;
        d2 = c2[g2 >> 2] | 0;
        g2 = c2[g2 + 4 >> 2] | 0;
        e2 = c2[b5 + 4 >> 2] | 0;
        f2 = ((e2 | 0) < 0) << 31 >> 31;
        if ((g2 | 0) < (f2 | 0) | (g2 | 0) == (f2 | 0) & d2 >>> 0 < e2 >>> 0)
          c2[b5 + 8 >> 2] = d2;
        else
          a2[b5 + 12 >> 0] = 1;
        return;
      }
      function cb2(b5, c3) {
        b5 = b5 | 0;
        c3 = c3 | 0;
        var d2 = 0, e2 = 0, f2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0, m2 = 0, n2 = 0, o2 = 0;
        n2 = c3 + 179 | 0;
        a2[h >> 0] = a2[n2 >> 0];
        a2[h + 1 >> 0] = a2[n2 + 1 >> 0];
        a2[h + 2 >> 0] = a2[n2 + 2 >> 0];
        a2[h + 3 >> 0] = a2[n2 + 3 >> 0];
        a2[h + 4 >> 0] = a2[n2 + 4 >> 0];
        a2[h + 5 >> 0] = a2[n2 + 5 >> 0];
        a2[h + 6 >> 0] = a2[n2 + 6 >> 0];
        a2[h + 7 >> 0] = a2[n2 + 7 >> 0];
        m2 = +g[h >> 3];
        j2 = c3 + 187 | 0;
        a2[h >> 0] = a2[j2 >> 0];
        a2[h + 1 >> 0] = a2[j2 + 1 >> 0];
        a2[h + 2 >> 0] = a2[j2 + 2 >> 0];
        a2[h + 3 >> 0] = a2[j2 + 3 >> 0];
        a2[h + 4 >> 0] = a2[j2 + 4 >> 0];
        a2[h + 5 >> 0] = a2[j2 + 5 >> 0];
        a2[h + 6 >> 0] = a2[j2 + 6 >> 0];
        a2[h + 7 >> 0] = a2[j2 + 7 >> 0];
        o2 = +g[h >> 3];
        b5 = c3 + 195 | 0;
        a2[h >> 0] = a2[b5 >> 0];
        a2[h + 1 >> 0] = a2[b5 + 1 >> 0];
        a2[h + 2 >> 0] = a2[b5 + 2 >> 0];
        a2[h + 3 >> 0] = a2[b5 + 3 >> 0];
        a2[h + 4 >> 0] = a2[b5 + 4 >> 0];
        a2[h + 5 >> 0] = a2[b5 + 5 >> 0];
        a2[h + 6 >> 0] = a2[b5 + 6 >> 0];
        a2[h + 7 >> 0] = a2[b5 + 7 >> 0];
        i2 = +g[h >> 3];
        l2 = c3 + 203 | 0;
        a2[h >> 0] = a2[l2 >> 0];
        a2[h + 1 >> 0] = a2[l2 + 1 >> 0];
        a2[h + 2 >> 0] = a2[l2 + 2 >> 0];
        a2[h + 3 >> 0] = a2[l2 + 3 >> 0];
        a2[h + 4 >> 0] = a2[l2 + 4 >> 0];
        a2[h + 5 >> 0] = a2[l2 + 5 >> 0];
        a2[h + 6 >> 0] = a2[l2 + 6 >> 0];
        a2[h + 7 >> 0] = a2[l2 + 7 >> 0];
        k2 = +g[h >> 3];
        f2 = c3 + 211 | 0;
        a2[h >> 0] = a2[f2 >> 0];
        a2[h + 1 >> 0] = a2[f2 + 1 >> 0];
        a2[h + 2 >> 0] = a2[f2 + 2 >> 0];
        a2[h + 3 >> 0] = a2[f2 + 3 >> 0];
        a2[h + 4 >> 0] = a2[f2 + 4 >> 0];
        a2[h + 5 >> 0] = a2[f2 + 5 >> 0];
        a2[h + 6 >> 0] = a2[f2 + 6 >> 0];
        a2[h + 7 >> 0] = a2[f2 + 7 >> 0];
        d2 = +g[h >> 3];
        c3 = c3 + 219 | 0;
        a2[h >> 0] = a2[c3 >> 0];
        a2[h + 1 >> 0] = a2[c3 + 1 >> 0];
        a2[h + 2 >> 0] = a2[c3 + 2 >> 0];
        a2[h + 3 >> 0] = a2[c3 + 3 >> 0];
        a2[h + 4 >> 0] = a2[c3 + 4 >> 0];
        a2[h + 5 >> 0] = a2[c3 + 5 >> 0];
        a2[h + 6 >> 0] = a2[c3 + 6 >> 0];
        a2[h + 7 >> 0] = a2[c3 + 7 >> 0];
        e2 = +g[h >> 3];
        g[h >> 3] = o2;
        a2[n2 >> 0] = a2[h >> 0];
        a2[n2 + 1 >> 0] = a2[h + 1 >> 0];
        a2[n2 + 2 >> 0] = a2[h + 2 >> 0];
        a2[n2 + 3 >> 0] = a2[h + 3 >> 0];
        a2[n2 + 4 >> 0] = a2[h + 4 >> 0];
        a2[n2 + 5 >> 0] = a2[h + 5 >> 0];
        a2[n2 + 6 >> 0] = a2[h + 6 >> 0];
        a2[n2 + 7 >> 0] = a2[h + 7 >> 0];
        g[h >> 3] = m2;
        a2[l2 >> 0] = a2[h >> 0];
        a2[l2 + 1 >> 0] = a2[h + 1 >> 0];
        a2[l2 + 2 >> 0] = a2[h + 2 >> 0];
        a2[l2 + 3 >> 0] = a2[h + 3 >> 0];
        a2[l2 + 4 >> 0] = a2[h + 4 >> 0];
        a2[l2 + 5 >> 0] = a2[h + 5 >> 0];
        a2[l2 + 6 >> 0] = a2[h + 6 >> 0];
        a2[l2 + 7 >> 0] = a2[h + 7 >> 0];
        g[h >> 3] = k2;
        a2[j2 >> 0] = a2[h >> 0];
        a2[j2 + 1 >> 0] = a2[h + 1 >> 0];
        a2[j2 + 2 >> 0] = a2[h + 2 >> 0];
        a2[j2 + 3 >> 0] = a2[h + 3 >> 0];
        a2[j2 + 4 >> 0] = a2[h + 4 >> 0];
        a2[j2 + 5 >> 0] = a2[h + 5 >> 0];
        a2[j2 + 6 >> 0] = a2[h + 6 >> 0];
        a2[j2 + 7 >> 0] = a2[h + 7 >> 0];
        g[h >> 3] = i2;
        a2[f2 >> 0] = a2[h >> 0];
        a2[f2 + 1 >> 0] = a2[h + 1 >> 0];
        a2[f2 + 2 >> 0] = a2[h + 2 >> 0];
        a2[f2 + 3 >> 0] = a2[h + 3 >> 0];
        a2[f2 + 4 >> 0] = a2[h + 4 >> 0];
        a2[f2 + 5 >> 0] = a2[h + 5 >> 0];
        a2[f2 + 6 >> 0] = a2[h + 6 >> 0];
        a2[f2 + 7 >> 0] = a2[h + 7 >> 0];
        g[h >> 3] = e2;
        a2[b5 >> 0] = a2[h >> 0];
        a2[b5 + 1 >> 0] = a2[h + 1 >> 0];
        a2[b5 + 2 >> 0] = a2[h + 2 >> 0];
        a2[b5 + 3 >> 0] = a2[h + 3 >> 0];
        a2[b5 + 4 >> 0] = a2[h + 4 >> 0];
        a2[b5 + 5 >> 0] = a2[h + 5 >> 0];
        a2[b5 + 6 >> 0] = a2[h + 6 >> 0];
        a2[b5 + 7 >> 0] = a2[h + 7 >> 0];
        g[h >> 3] = d2;
        a2[c3 >> 0] = a2[h >> 0];
        a2[c3 + 1 >> 0] = a2[h + 1 >> 0];
        a2[c3 + 2 >> 0] = a2[h + 2 >> 0];
        a2[c3 + 3 >> 0] = a2[h + 3 >> 0];
        a2[c3 + 4 >> 0] = a2[h + 4 >> 0];
        a2[c3 + 5 >> 0] = a2[h + 5 >> 0];
        a2[c3 + 6 >> 0] = a2[h + 6 >> 0];
        a2[c3 + 7 >> 0] = a2[h + 7 >> 0];
        return;
      }
      function db() {
        var b5 = 0, d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0;
        g2 = V;
        V = V + 48 | 0;
        e2 = g2 + 24 | 0;
        f2 = g2;
        b5 = g2 + 44 | 0;
        if ((a2[21440] | 0) == 0 ? Tp(21440) | 0 : 0) {
          c2[5374] = 0;
          c2[5375] = 0;
          c2[5376] = 0;
          $p(21440);
        }
        if ((a2[21448] | 0) == 0 ? Tp(21448) | 0 : 0)
          $p(21448);
        if ((c2[5374] | 0) == (c2[5375] | 0)) {
          rq(21508);
          if ((c2[5374] | 0) == (c2[5375] | 0)) {
            a2[e2 >> 0] = a2[b5 >> 0] | 0;
            pb(f2, e2);
            b5 = c2[5375] | 0;
            do
              if (b5 >>> 0 >= (c2[5376] | 0) >>> 0) {
                b5 = ((b5 - (c2[5374] | 0) | 0) / 24 | 0) + 1 | 0;
                d2 = xb(21496) | 0;
                if (d2 >>> 0 < b5 >>> 0)
                  cr(21496);
                else {
                  h2 = c2[5374] | 0;
                  j2 = ((c2[5376] | 0) - h2 | 0) / 24 | 0;
                  i2 = j2 << 1;
                  ub(e2, j2 >>> 0 < d2 >>> 1 >>> 0 ? i2 >>> 0 < b5 >>> 0 ? b5 : i2 : d2, ((c2[5375] | 0) - h2 | 0) / 24 | 0, 21504);
                  d2 = e2 + 8 | 0;
                  sb(c2[d2 >> 2] | 0, f2);
                  c2[d2 >> 2] = (c2[d2 >> 2] | 0) + 24;
                  vb(21496, e2);
                  wb(e2);
                  break;
                }
              } else {
                qb(e2, 21496, 1);
                j2 = e2 + 4 | 0;
                sb(c2[j2 >> 2] | 0, f2);
                c2[j2 >> 2] = (c2[j2 >> 2] | 0) + 24;
                rb(e2);
              }
            while (0);
            gb(f2);
          }
          sq(21508);
        }
        V = g2;
        return 21496;
      }
      function eb(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0;
        d2 = b5 + 16 | 0;
        e2 = c2[d2 >> 2] | 0;
        do
          if (e2)
            if ((b5 | 0) == (e2 | 0)) {
              e2 = tb(a3) | 0;
              c2[a3 + 16 >> 2] = e2;
              d2 = c2[d2 >> 2] | 0;
              da[c2[(c2[d2 >> 2] | 0) + 12 >> 2] & 15](d2, e2);
              break;
            } else {
              c2[a3 + 16 >> 2] = Z[c2[(c2[e2 >> 2] | 0) + 8 >> 2] & 15](e2) | 0;
              break;
            }
          else
            c2[a3 + 16 >> 2] = 0;
        while (0);
        return;
      }
      function fb(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        a3 = c2[a3 + 16 >> 2] | 0;
        if (!a3) {
          b5 = v(4) | 0;
          c2[b5 >> 2] = 0;
          Nb(b5);
          x(b5 | 0, 4168, 131);
        } else {
          da[c2[(c2[a3 >> 2] | 0) + 24 >> 2] & 15](a3, b5);
          return;
        }
      }
      function gb(a3) {
        a3 = a3 | 0;
        var b5 = 0;
        b5 = c2[a3 + 16 >> 2] | 0;
        if ((a3 | 0) != (b5 | 0)) {
          if (b5 | 0)
            ca[c2[(c2[b5 >> 2] | 0) + 20 >> 2] & 255](b5);
        } else
          ca[c2[(c2[b5 >> 2] | 0) + 16 >> 2] & 255](b5);
        return;
      }
      function hb(b5) {
        b5 = b5 | 0;
        var f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0, m2 = 0, n2 = 0, o2 = 0, p2 = 0, q2 = 0;
        q2 = V;
        V = V + 96 | 0;
        i2 = q2 + 16 | 0;
        o2 = q2;
        l2 = q2 + 72 | 0;
        j2 = c2[b5 >> 2] | 0;
        m2 = e[b5 + 114 >> 1] | 0;
        n2 = o2;
        c2[n2 >> 2] = 0;
        c2[n2 + 4 >> 2] = 0;
        n2 = o2 + 8 | 0;
        c2[n2 >> 2] = m2;
        c2[n2 + 4 >> 2] = 0;
        c2[i2 >> 2] = c2[o2 >> 2];
        c2[i2 + 4 >> 2] = c2[o2 + 4 >> 2];
        c2[i2 + 8 >> 2] = c2[o2 + 8 >> 2];
        c2[i2 + 12 >> 2] = c2[o2 + 12 >> 2];
        bb(j2, i2);
        j2 = b5 + 120 | 0;
        a:
          do
            if (c2[j2 >> 2] | 0) {
              k2 = i2 + 2 | 0;
              m2 = i2 + 16 | 0;
              n2 = i2 + 20 | 0;
              o2 = i2 + 18 | 0;
              g2 = 0;
              while (1) {
                if (!(Ob(c2[b5 >> 2] | 0) | 0))
                  break a;
                if (Pb(c2[b5 >> 2] | 0) | 0)
                  break a;
                $a(c2[b5 >> 2] | 0, i2, 54);
                f2 = 7277;
                h2 = k2;
                while (1) {
                  if ((a2[h2 >> 0] | 0) != (a2[f2 >> 0] | 0))
                    break;
                  h2 = h2 + 1 | 0;
                  if ((h2 | 0) == (m2 | 0)) {
                    p2 = 8;
                    break;
                  } else
                    f2 = f2 + 1 | 0;
                }
                if ((p2 | 0) == 8 ? (p2 = 0, (d[o2 >> 0] | d[o2 + 1 >> 0] << 8) << 16 >> 16 == 22204) : 0)
                  break;
                Rb(c2[b5 >> 2] | 0, (d[n2 >> 0] | d[n2 + 1 >> 0] << 8) & 65535, 0, 1);
                g2 = g2 + 1 | 0;
                if (g2 >>> 0 >= (c2[j2 >> 2] | 0) >>> 0)
                  break a;
              }
              o2 = (d[n2 >> 0] | d[n2 + 1 >> 0] << 8) & 65535;
              p2 = fq(o2) | 0;
              $a(c2[b5 >> 2] | 0, p2, o2);
              Qb(b5, p2);
              jp(p2);
              p2 = b5 + 125 | 0;
              Tb(l2, b5 + 247 | 0, (d[p2 >> 0] | d[p2 + 1 >> 0] << 8) & 65535);
              Ub(b5 + 300 | 0, l2) | 0;
              Pa(l2);
              V = q2;
              return;
            }
          while (0);
        q2 = v(8) | 0;
        Sb(q2);
        x(q2 | 0, 2672, 8);
      }
      function ib(a3) {
        a3 = a3 | 0;
        var b5 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0, m2 = 0, n2 = 0, o2 = 0;
        n2 = V;
        V = V + 176 | 0;
        g2 = n2 + 40 | 0;
        h2 = n2 + 24 | 0;
        b5 = n2 + 16 | 0;
        f2 = n2;
        k2 = n2 + 152 | 0;
        l2 = n2 + 136 | 0;
        m2 = n2 + 56 | 0;
        j2 = c2[a3 >> 2] | 0;
        i2 = a3 + 116 | 0;
        o2 = c2[i2 >> 2] | 0;
        e2 = h2;
        c2[e2 >> 2] = 0;
        c2[e2 + 4 >> 2] = 0;
        e2 = h2 + 8 | 0;
        c2[e2 >> 2] = o2;
        c2[e2 + 4 >> 2] = 0;
        c2[g2 >> 2] = c2[h2 >> 2];
        c2[g2 + 4 >> 2] = c2[h2 + 4 >> 2];
        c2[g2 + 8 >> 2] = c2[h2 + 8 >> 2];
        c2[g2 + 12 >> 2] = c2[h2 + 12 >> 2];
        bb(j2, g2);
        j2 = b5;
        c2[j2 >> 2] = 0;
        c2[j2 + 4 >> 2] = 0;
        $a(c2[a3 >> 2] | 0, b5, 8);
        if (!(Ob(c2[a3 >> 2] | 0) | 0)) {
          o2 = v(8) | 0;
          hc(o2);
          x(o2 | 0, 2704, 8);
        }
        e2 = b5;
        b5 = c2[e2 >> 2] | 0;
        e2 = c2[e2 + 4 >> 2] | 0;
        if ((b5 | 0) == -1 & (e2 | 0) == -1) {
          o2 = v(8) | 0;
          ic(o2, 7488);
          x(o2 | 0, 2720, 8);
        }
        o2 = c2[a3 >> 2] | 0;
        j2 = f2;
        c2[j2 >> 2] = 0;
        c2[j2 + 4 >> 2] = 0;
        j2 = f2 + 8 | 0;
        c2[j2 >> 2] = b5;
        c2[j2 + 4 >> 2] = e2;
        c2[g2 >> 2] = c2[f2 >> 2];
        c2[g2 + 4 >> 2] = c2[f2 + 4 >> 2];
        c2[g2 + 8 >> 2] = c2[f2 + 8 >> 2];
        c2[g2 + 12 >> 2] = c2[f2 + 12 >> 2];
        bb(o2, g2);
        if (!(Ob(c2[a3 >> 2] | 0) | 0)) {
          o2 = v(8) | 0;
          hc(o2);
          x(o2 | 0, 2704, 8);
        }
        $a(c2[a3 >> 2] | 0, g2, 8);
        if (!(Ob(c2[a3 >> 2] | 0) | 0)) {
          o2 = v(8) | 0;
          hc(o2);
          x(o2 | 0, 2704, 8);
        }
        if (c2[g2 >> 2] | 0) {
          o2 = v(8) | 0;
          jc(o2);
          x(o2 | 0, 2736, 8);
        }
        h2 = a3 + 288 | 0;
        j2 = a3 + 292 | 0;
        c2[j2 >> 2] = c2[h2 >> 2];
        o2 = a3 + 259 | 0;
        if ((d[o2 >> 0] | d[o2 + 1 >> 0] << 8 | d[o2 + 2 >> 0] << 16 | d[o2 + 3 >> 0] << 24 | 0) == -1) {
          o2 = v(8) | 0;
          ic(o2, 7606);
          x(o2 | 0, 2720, 8);
        }
        f2 = g2 + 4 | 0;
        kc(h2, (c2[f2 >> 2] | 0) + 1 | 0);
        o2 = c2[h2 >> 2] | 0;
        c2[o2 >> 2] = (c2[i2 >> 2] | 0) + 8;
        c2[o2 + 4 >> 2] = 0;
        if ((c2[f2 >> 2] | 0) >>> 0 > 1) {
          Va(k2, c2[a3 >> 2] | 0);
          lc(l2, k2);
          mc(m2, 32, 2, 8, 0);
          nc(l2);
          oc(m2);
          if (!(c2[f2 >> 2] | 0)) {
            h2 = c2[h2 >> 2] | 0;
            e2 = h2;
          } else {
            e2 = 1;
            do {
              if (e2 >>> 0 > 1)
                b5 = c2[(c2[h2 >> 2] | 0) + (e2 + -1 << 3) >> 2] | 0;
              else
                b5 = 0;
              i2 = pc(m2, l2, b5, 1) | 0;
              b5 = c2[h2 >> 2] | 0;
              o2 = b5 + (e2 << 3) | 0;
              c2[o2 >> 2] = i2;
              c2[o2 + 4 >> 2] = ((i2 | 0) < 0) << 31 >> 31;
              e2 = e2 + 1 | 0;
            } while (e2 >>> 0 <= (c2[f2 >> 2] | 0) >>> 0);
            e2 = b5;
            h2 = b5;
          }
          b5 = c2[j2 >> 2] | 0;
          if (b5 - e2 >> 3 >>> 0 > 1) {
            g2 = b5 - h2 >> 3;
            f2 = h2;
            b5 = 1;
            e2 = c2[f2 >> 2] | 0;
            f2 = c2[f2 + 4 >> 2] | 0;
            do {
              o2 = h2 + (b5 << 3) | 0;
              j2 = o2;
              e2 = lr(c2[j2 >> 2] | 0, c2[j2 + 4 >> 2] | 0, e2 | 0, f2 | 0) | 0;
              f2 = u() | 0;
              c2[o2 >> 2] = e2;
              c2[o2 + 4 >> 2] = f2;
              b5 = b5 + 1 | 0;
            } while (b5 >>> 0 < g2 >>> 0);
          }
          qc(m2);
          rc(l2);
          Ra(k2);
        }
        V = n2;
        return;
      }
      function jb(b5) {
        b5 = b5 | 0;
        a2[b5 + 12 >> 0] = 0;
        a2[b5 + 13 >> 0] = 0;
        return;
      }
      function kb(a3) {
        a3 = a3 | 0;
        c2[a3 + 8 >> 2] = 0;
        c2[a3 + 4 >> 2] = 0;
        return;
      }
      function lb(a3) {
        a3 = a3 | 0;
        return fo(a3) | 0;
      }
      function mb(b5, d2, e2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0;
        i2 = V;
        V = V + 16 | 0;
        g2 = d2;
        h2 = i2;
        f2 = e2 - g2 | 0;
        if (f2 >>> 0 > 4294967279)
          yq(b5);
        if (f2 >>> 0 < 11)
          a2[b5 + 11 >> 0] = f2;
        else {
          k2 = f2 + 16 & -16;
          j2 = eq(k2) | 0;
          c2[b5 >> 2] = j2;
          c2[b5 + 8 >> 2] = k2 | -2147483648;
          c2[b5 + 4 >> 2] = f2;
          b5 = j2;
        }
        if ((d2 | 0) != (e2 | 0)) {
          g2 = e2 - g2 | 0;
          f2 = b5;
          while (1) {
            nb(f2, d2);
            d2 = d2 + 1 | 0;
            if ((d2 | 0) == (e2 | 0))
              break;
            else
              f2 = f2 + 1 | 0;
          }
          b5 = b5 + g2 | 0;
        }
        a2[h2 >> 0] = 0;
        nb(b5, h2);
        V = i2;
        return;
      }
      function nb(b5, c3) {
        b5 = b5 | 0;
        c3 = c3 | 0;
        a2[b5 >> 0] = a2[c3 >> 0] | 0;
        return;
      }
      function ob(a3) {
        a3 = a3 | 0;
        yp(a3);
        jp(a3);
        return;
      }
      function pb(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c2[a3 >> 2] = 4372;
        c2[a3 + 16 >> 2] = a3;
        return;
      }
      function qb(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        c2[a3 >> 2] = b5;
        b5 = c2[b5 + 4 >> 2] | 0;
        c2[a3 + 4 >> 2] = b5;
        c2[a3 + 8 >> 2] = b5 + (d2 * 24 | 0);
        return;
      }
      function rb(a3) {
        a3 = a3 | 0;
        c2[(c2[a3 >> 2] | 0) + 4 >> 2] = c2[a3 + 4 >> 2];
        return;
      }
      function sb(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0;
        d2 = b5 + 16 | 0;
        e2 = c2[d2 >> 2] | 0;
        do
          if (e2)
            if ((b5 | 0) == (e2 | 0)) {
              e2 = tb(a3) | 0;
              c2[a3 + 16 >> 2] = e2;
              d2 = c2[d2 >> 2] | 0;
              da[c2[(c2[d2 >> 2] | 0) + 12 >> 2] & 15](d2, e2);
              break;
            } else {
              c2[a3 + 16 >> 2] = e2;
              c2[d2 >> 2] = 0;
              break;
            }
          else
            c2[a3 + 16 >> 2] = 0;
        while (0);
        return;
      }
      function tb(a3) {
        a3 = a3 | 0;
        return a3 | 0;
      }
      function ub(a3, b5, d2, e2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f2 = 0;
        f2 = a3 + 12 | 0;
        c2[f2 >> 2] = 0;
        c2[a3 + 16 >> 2] = e2;
        do
          if (b5)
            if (b5 >>> 0 > 178956970) {
              f2 = v(8) | 0;
              vq(f2, 6723);
              c2[f2 >> 2] = 5956;
              x(f2 | 0, 3928, 123);
            } else {
              e2 = eq(b5 * 24 | 0) | 0;
              break;
            }
          else
            e2 = 0;
        while (0);
        c2[a3 >> 2] = e2;
        d2 = e2 + (d2 * 24 | 0) | 0;
        c2[a3 + 8 >> 2] = d2;
        c2[a3 + 4 >> 2] = d2;
        c2[f2 >> 2] = e2 + (b5 * 24 | 0);
        return;
      }
      function vb(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0;
        i2 = c2[a3 >> 2] | 0;
        j2 = a3 + 4 | 0;
        d2 = c2[j2 >> 2] | 0;
        h2 = b5 + 4 | 0;
        if ((d2 | 0) == (i2 | 0)) {
          f2 = h2;
          g2 = a3;
          e2 = c2[h2 >> 2] | 0;
          d2 = i2;
        } else {
          e2 = c2[h2 >> 2] | 0;
          do {
            d2 = d2 + -24 | 0;
            sb(e2 + -24 | 0, d2);
            e2 = (c2[h2 >> 2] | 0) + -24 | 0;
            c2[h2 >> 2] = e2;
          } while ((d2 | 0) != (i2 | 0));
          f2 = h2;
          g2 = a3;
          d2 = c2[a3 >> 2] | 0;
        }
        c2[g2 >> 2] = e2;
        c2[f2 >> 2] = d2;
        i2 = b5 + 8 | 0;
        h2 = c2[j2 >> 2] | 0;
        c2[j2 >> 2] = c2[i2 >> 2];
        c2[i2 >> 2] = h2;
        i2 = a3 + 8 | 0;
        j2 = b5 + 12 | 0;
        a3 = c2[i2 >> 2] | 0;
        c2[i2 >> 2] = c2[j2 >> 2];
        c2[j2 >> 2] = a3;
        c2[b5 >> 2] = c2[f2 >> 2];
        return;
      }
      function wb(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0, f2 = 0;
        d2 = c2[a3 + 4 >> 2] | 0;
        e2 = a3 + 8 | 0;
        b5 = c2[e2 >> 2] | 0;
        if ((b5 | 0) != (d2 | 0))
          do {
            f2 = b5 + -24 | 0;
            c2[e2 >> 2] = f2;
            gb(f2);
            b5 = c2[e2 >> 2] | 0;
          } while ((b5 | 0) != (d2 | 0));
        b5 = c2[a3 >> 2] | 0;
        if (b5 | 0)
          Da(b5, (c2[a3 + 12 >> 2] | 0) - b5 | 0);
        return;
      }
      function xb(a3) {
        a3 = a3 | 0;
        return 178956970;
      }
      function yb(a3) {
        a3 = a3 | 0;
        jp(a3);
        return;
      }
      function zb(a3) {
        a3 = a3 | 0;
        a3 = eq(8) | 0;
        c2[a3 >> 2] = 4372;
        return a3 | 0;
      }
      function Ab(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c2[b5 >> 2] = 4372;
        return;
      }
      function Bb(a3) {
        a3 = a3 | 0;
        return;
      }
      function Cb(a3) {
        a3 = a3 | 0;
        Da(a3, 8);
        return;
      }
      function Db(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        Hb(a3 + 4 | 0, b5);
        return;
      }
      function Eb(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return ((c2[b5 + 4 >> 2] | 0) == 7183 ? a3 + 4 | 0 : 0) | 0;
      }
      function Fb(a3) {
        a3 = a3 | 0;
        return 2664;
      }
      function Gb(a3) {
        a3 = a3 | 0;
        return;
      }
      function Hb(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        Ib(a3, b5);
        return;
      }
      function Ib(b5, c3) {
        b5 = b5 | 0;
        c3 = c3 | 0;
        var e2 = 0, f2 = 0;
        b5 = c3 + 104 | 0;
        c3 = d[b5 >> 0] | 0;
        e2 = c3 >>> 7;
        f2 = c3 >>> 6 & 1;
        if ((e2 | 0) == 1 & (f2 | 0) != 0) {
          f2 = v(8) | 0;
          Jb(f2);
          x(f2 | 0, 2632, 8);
        }
        if ((e2 | 0) == (f2 | 0)) {
          f2 = v(8) | 0;
          Kb(f2);
          x(f2 | 0, 2648, 8);
        } else {
          a2[b5 >> 0] = c3 & 63;
          return;
        }
      }
      function Jb(a3) {
        a3 = a3 | 0;
        xq(a3, 7076);
        c2[a3 >> 2] = 4416;
        return;
      }
      function Kb(a3) {
        a3 = a3 | 0;
        xq(a3, 7144);
        c2[a3 >> 2] = 4436;
        return;
      }
      function Lb(a3) {
        a3 = a3 | 0;
        yp(a3);
        jp(a3);
        return;
      }
      function Mb(a3) {
        a3 = a3 | 0;
        yp(a3);
        jp(a3);
        return;
      }
      function Nb(a3) {
        a3 = a3 | 0;
        c2[a3 >> 2] = 6092;
        return;
      }
      function Ob(b5) {
        b5 = b5 | 0;
        var c3 = 0;
        c3 = b5 + 12 | 0;
        b5 = (a2[c3 >> 0] | 0) == 0;
        a2[c3 >> 0] = 0;
        return b5 | 0;
      }
      function Pb(b5) {
        b5 = b5 | 0;
        return (a2[b5 + 13 >> 0] | 0) != 0 | 0;
      }
      function Qb(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        a3 = a3 + 247 | 0;
        Vb(a3, b5);
        if ((d[a3 >> 0] | d[a3 + 1 >> 0] << 8) << 16 >> 16 == 2)
          return;
        else {
          b5 = v(8) | 0;
          Wb(b5);
          x(b5 | 0, 2688, 8);
        }
      }
      function Rb(b5, d2, e2, f2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        f2 = f2 | 0;
        var g2 = 0, h2 = 0;
        switch (f2 | 0) {
          case 0:
            break;
          case 2: {
            f2 = c2[b5 + 4 >> 2] | 0;
            d2 = lr(lr(d2 | 0, e2 | 0, -1, -1) | 0, u() | 0, f2 | 0, ((f2 | 0) < 0) << 31 >> 31 | 0) | 0;
            e2 = u() | 0;
            break;
          }
          case 1: {
            f2 = c2[b5 + 8 >> 2] | 0;
            d2 = lr(f2 | 0, ((f2 | 0) < 0) << 31 >> 31 | 0, d2 | 0, e2 | 0) | 0;
            e2 = u() | 0;
            break;
          }
          default: {
            e2 = 0;
            d2 = 0;
          }
        }
        g2 = c2[b5 + 4 >> 2] | 0;
        h2 = ((g2 | 0) < 0) << 31 >> 31;
        f2 = b5 + 12 | 0;
        if ((e2 | 0) < 0 | ((e2 | 0) > (h2 | 0) | (e2 | 0) == (h2 | 0) & d2 >>> 0 >= g2 >>> 0))
          a2[f2 >> 0] = 1;
        else {
          a2[f2 >> 0] = 0;
          c2[b5 + 8 >> 2] = d2;
        }
        return;
      }
      function Sb(a3) {
        a3 = a3 | 0;
        xq(a3, 7410);
        c2[a3 >> 2] = 4476;
        return;
      }
      function Tb(a3, b5, c3) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        var e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0;
        h2 = V;
        V = V + 16 | 0;
        g2 = h2;
        Xa(a3);
        f2 = b5 + 32 | 0;
        if ((d[f2 >> 0] | d[f2 + 1 >> 0] << 8) << 16 >> 16) {
          e2 = b5 + 34 | 0;
          b5 = 0;
          do {
            j2 = d[e2 >> 0] | d[e2 + 1 >> 0] << 8 | d[e2 + 2 >> 0] << 16 | d[e2 + 3 >> 0] << 24;
            k2 = j2 + (b5 * 6 | 0) | 0;
            i2 = j2 + (b5 * 6 | 0) + 2 | 0;
            j2 = j2 + (b5 * 6 | 0) + 4 | 0;
            _b(g2, (d[k2 >> 0] | d[k2 + 1 >> 0] << 8) & 65535, (d[i2 >> 0] | d[i2 + 1 >> 0] << 8) & 65535, (d[j2 >> 0] | d[j2 + 1 >> 0] << 8) & 65535);
            Zb(a3, g2);
            c3 = c3 - ((d[i2 >> 0] | d[i2 + 1 >> 0] << 8) & 65535) | 0;
            b5 = b5 + 1 | 0;
          } while (b5 >>> 0 < ((d[f2 >> 0] | d[f2 + 1 >> 0] << 8) & 65535) >>> 0);
        }
        if ((c3 | 0) < 0) {
          k2 = v(8) | 0;
          Wb(k2);
          x(k2 | 0, 2688, 8);
        }
        if (c3 | 0) {
          _b(g2, 0, c3, 2);
          Zb(a3, g2);
        }
        V = h2;
        return;
      }
      function Ub(b5, c3) {
        b5 = b5 | 0;
        c3 = c3 | 0;
        var d2 = 0, e2 = 0;
        d2 = V;
        V = V + 16 | 0;
        e2 = d2 + 1 | 0;
        a2[e2 >> 0] = a2[d2 >> 0] | 0;
        fc(b5, c3, e2);
        V = d2;
        return b5 | 0;
      }
      function Vb(b5, c3) {
        b5 = b5 | 0;
        c3 = c3 | 0;
        var e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0;
        f2 = c3 + 2 | 0;
        h2 = d[c3 >> 0] | d[c3 + 1 >> 0] << 8;
        a2[b5 >> 0] = h2;
        a2[b5 + 1 >> 0] = h2 >> 8;
        h2 = b5 + 2 | 0;
        f2 = d[f2 >> 0] | d[f2 + 1 >> 0] << 8;
        a2[h2 >> 0] = f2;
        a2[h2 + 1 >> 0] = f2 >> 8;
        a2[b5 + 4 >> 0] = a2[c3 + 4 >> 0] | 0;
        h2 = c3 + 6 | 0;
        a2[b5 + 5 >> 0] = a2[c3 + 5 >> 0] | 0;
        f2 = c3 + 8 | 0;
        e2 = b5 + 6 | 0;
        h2 = d[h2 >> 0] | d[h2 + 1 >> 0] << 8;
        a2[e2 >> 0] = h2;
        a2[e2 + 1 >> 0] = h2 >> 8;
        e2 = c3 + 12 | 0;
        h2 = b5 + 8 | 0;
        f2 = d[f2 >> 0] | d[f2 + 1 >> 0] << 8 | d[f2 + 2 >> 0] << 16 | d[f2 + 3 >> 0] << 24;
        a2[h2 >> 0] = f2;
        a2[h2 + 1 >> 0] = f2 >> 8;
        a2[h2 + 2 >> 0] = f2 >> 16;
        a2[h2 + 3 >> 0] = f2 >> 24;
        h2 = b5 + 12 | 0;
        e2 = d[e2 >> 0] | d[e2 + 1 >> 0] << 8 | d[e2 + 2 >> 0] << 16 | d[e2 + 3 >> 0] << 24;
        a2[h2 >> 0] = e2;
        a2[h2 + 1 >> 0] = e2 >> 8;
        a2[h2 + 2 >> 0] = e2 >> 16;
        a2[h2 + 3 >> 0] = e2 >> 24;
        h2 = c3 + 16 | 0;
        e2 = h2;
        e2 = d[e2 >> 0] | d[e2 + 1 >> 0] << 8 | d[e2 + 2 >> 0] << 16 | d[e2 + 3 >> 0] << 24;
        h2 = h2 + 4 | 0;
        h2 = d[h2 >> 0] | d[h2 + 1 >> 0] << 8 | d[h2 + 2 >> 0] << 16 | d[h2 + 3 >> 0] << 24;
        f2 = b5 + 16 | 0;
        i2 = f2;
        a2[i2 >> 0] = e2;
        a2[i2 + 1 >> 0] = e2 >> 8;
        a2[i2 + 2 >> 0] = e2 >> 16;
        a2[i2 + 3 >> 0] = e2 >> 24;
        f2 = f2 + 4 | 0;
        a2[f2 >> 0] = h2;
        a2[f2 + 1 >> 0] = h2 >> 8;
        a2[f2 + 2 >> 0] = h2 >> 16;
        a2[f2 + 3 >> 0] = h2 >> 24;
        f2 = c3 + 32 | 0;
        h2 = c3 + 24 | 0;
        i2 = h2;
        i2 = d[i2 >> 0] | d[i2 + 1 >> 0] << 8 | d[i2 + 2 >> 0] << 16 | d[i2 + 3 >> 0] << 24;
        h2 = h2 + 4 | 0;
        h2 = d[h2 >> 0] | d[h2 + 1 >> 0] << 8 | d[h2 + 2 >> 0] << 16 | d[h2 + 3 >> 0] << 24;
        e2 = b5 + 24 | 0;
        g2 = e2;
        a2[g2 >> 0] = i2;
        a2[g2 + 1 >> 0] = i2 >> 8;
        a2[g2 + 2 >> 0] = i2 >> 16;
        a2[g2 + 3 >> 0] = i2 >> 24;
        e2 = e2 + 4 | 0;
        a2[e2 >> 0] = h2;
        a2[e2 + 1 >> 0] = h2 >> 8;
        a2[e2 + 2 >> 0] = h2 >> 16;
        a2[e2 + 3 >> 0] = h2 >> 24;
        e2 = c3 + 34 | 0;
        h2 = b5 + 32 | 0;
        f2 = d[f2 >> 0] | d[f2 + 1 >> 0] << 8;
        a2[h2 >> 0] = f2;
        a2[h2 + 1 >> 0] = f2 >> 8;
        g2 = b5 + 34 | 0;
        b5 = d[g2 >> 0] | d[g2 + 1 >> 0] << 8 | d[g2 + 2 >> 0] << 16 | d[g2 + 3 >> 0] << 24;
        if (!b5)
          b5 = f2;
        else {
          gq(b5);
          b5 = d[h2 >> 0] | d[h2 + 1 >> 0] << 8;
        }
        f2 = fq((b5 & 65535) * 6 | 0) | 0;
        a2[g2 >> 0] = f2;
        a2[g2 + 1 >> 0] = f2 >> 8;
        a2[g2 + 2 >> 0] = f2 >> 16;
        a2[g2 + 3 >> 0] = f2 >> 24;
        if (b5 << 16 >> 16 ? (b5 = c3 + 36 | 0, i2 = d[e2 >> 0] | d[e2 + 1 >> 0] << 8, a2[f2 >> 0] = i2, a2[f2 + 1 >> 0] = i2 >> 8, c3 = c3 + 38 | 0, i2 = f2 + 2 | 0, b5 = d[b5 >> 0] | d[b5 + 1 >> 0] << 8, a2[i2 >> 0] = b5, a2[i2 + 1 >> 0] = b5 >> 8, i2 = f2 + 4 | 0, c3 = d[c3 >> 0] | d[c3 + 1 >> 0] << 8, a2[i2 >> 0] = c3, a2[i2 + 1 >> 0] = c3 >> 8, ((d[h2 >> 0] | d[h2 + 1 >> 0] << 8) & 65535) > 1) : 0) {
          b5 = 1;
          do {
            c3 = e2;
            e2 = e2 + 6 | 0;
            i2 = d[g2 >> 0] | d[g2 + 1 >> 0] << 8 | d[g2 + 2 >> 0] << 16 | d[g2 + 3 >> 0] << 24;
            j2 = c3 + 8 | 0;
            f2 = i2 + (b5 * 6 | 0) | 0;
            k2 = d[e2 >> 0] | d[e2 + 1 >> 0] << 8;
            a2[f2 >> 0] = k2;
            a2[f2 + 1 >> 0] = k2 >> 8;
            c3 = c3 + 10 | 0;
            f2 = i2 + (b5 * 6 | 0) + 2 | 0;
            j2 = d[j2 >> 0] | d[j2 + 1 >> 0] << 8;
            a2[f2 >> 0] = j2;
            a2[f2 + 1 >> 0] = j2 >> 8;
            i2 = i2 + (b5 * 6 | 0) + 4 | 0;
            c3 = d[c3 >> 0] | d[c3 + 1 >> 0] << 8;
            a2[i2 >> 0] = c3;
            a2[i2 + 1 >> 0] = c3 >> 8;
            b5 = b5 + 1 | 0;
          } while (b5 >>> 0 < ((d[h2 >> 0] | d[h2 + 1 >> 0] << 8) & 65535) >>> 0);
        }
        return;
      }
      function Wb(a3) {
        a3 = a3 | 0;
        xq(a3, 7354);
        c2[a3 >> 2] = 4456;
        return;
      }
      function Xb(a3) {
        a3 = a3 | 0;
        yp(a3);
        jp(a3);
        return;
      }
      function Yb(a3) {
        a3 = a3 | 0;
        yp(a3);
        jp(a3);
        return;
      }
      function Zb(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0;
        i2 = V;
        V = V + 32 | 0;
        f2 = i2;
        g2 = a3 + 4 | 0;
        d2 = c2[g2 >> 2] | 0;
        h2 = a3 + 8 | 0;
        do
          if ((d2 | 0) == (c2[h2 >> 2] | 0)) {
            d2 = ((d2 - (c2[a3 >> 2] | 0) | 0) / 12 | 0) + 1 | 0;
            e2 = ec(a3) | 0;
            if (e2 >>> 0 < d2 >>> 0)
              cr(a3);
            else {
              j2 = c2[a3 >> 2] | 0;
              k2 = ((c2[h2 >> 2] | 0) - j2 | 0) / 12 | 0;
              h2 = k2 << 1;
              bc(f2, k2 >>> 0 < e2 >>> 1 >>> 0 ? h2 >>> 0 < d2 >>> 0 ? d2 : h2 : e2, ((c2[g2 >> 2] | 0) - j2 | 0) / 12 | 0, a3 + 8 | 0);
              h2 = f2 + 8 | 0;
              g2 = c2[h2 >> 2] | 0;
              c2[g2 >> 2] = c2[b5 >> 2];
              c2[g2 + 4 >> 2] = c2[b5 + 4 >> 2];
              c2[g2 + 8 >> 2] = c2[b5 + 8 >> 2];
              c2[h2 >> 2] = (c2[h2 >> 2] | 0) + 12;
              cc(a3, f2);
              dc(f2);
              break;
            }
          } else {
            $b(f2, a3, 1);
            k2 = f2 + 4 | 0;
            j2 = c2[k2 >> 2] | 0;
            c2[j2 >> 2] = c2[b5 >> 2];
            c2[j2 + 4 >> 2] = c2[b5 + 4 >> 2];
            c2[j2 + 8 >> 2] = c2[b5 + 8 >> 2];
            c2[k2 >> 2] = (c2[k2 >> 2] | 0) + 12;
            ac(f2);
          }
        while (0);
        V = i2;
        return;
      }
      function _b(a3, b5, d2, e2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        c2[a3 >> 2] = b5;
        c2[a3 + 4 >> 2] = d2;
        c2[a3 + 8 >> 2] = e2;
        return;
      }
      function $b(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        c2[a3 >> 2] = b5;
        b5 = c2[b5 + 4 >> 2] | 0;
        c2[a3 + 4 >> 2] = b5;
        c2[a3 + 8 >> 2] = b5 + (d2 * 12 | 0);
        return;
      }
      function ac(a3) {
        a3 = a3 | 0;
        c2[(c2[a3 >> 2] | 0) + 4 >> 2] = c2[a3 + 4 >> 2];
        return;
      }
      function bc(a3, b5, d2, e2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f2 = 0;
        f2 = a3 + 12 | 0;
        c2[f2 >> 2] = 0;
        c2[a3 + 16 >> 2] = e2;
        do
          if (b5)
            if (b5 >>> 0 > 357913941) {
              f2 = v(8) | 0;
              vq(f2, 6723);
              c2[f2 >> 2] = 5956;
              x(f2 | 0, 3928, 123);
            } else {
              e2 = eq(b5 * 12 | 0) | 0;
              break;
            }
          else
            e2 = 0;
        while (0);
        c2[a3 >> 2] = e2;
        d2 = e2 + (d2 * 12 | 0) | 0;
        c2[a3 + 8 >> 2] = d2;
        c2[a3 + 4 >> 2] = d2;
        c2[f2 >> 2] = e2 + (b5 * 12 | 0);
        return;
      }
      function cc(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0;
        e2 = c2[a3 >> 2] | 0;
        h2 = a3 + 4 | 0;
        g2 = b5 + 4 | 0;
        f2 = (c2[h2 >> 2] | 0) - e2 | 0;
        d2 = (c2[g2 >> 2] | 0) + (((f2 | 0) / -12 | 0) * 12 | 0) | 0;
        c2[g2 >> 2] = d2;
        if ((f2 | 0) > 0) {
          ur(d2 | 0, e2 | 0, f2 | 0) | 0;
          e2 = g2;
          d2 = c2[g2 >> 2] | 0;
        } else
          e2 = g2;
        g2 = c2[a3 >> 2] | 0;
        c2[a3 >> 2] = d2;
        c2[e2 >> 2] = g2;
        g2 = b5 + 8 | 0;
        f2 = c2[h2 >> 2] | 0;
        c2[h2 >> 2] = c2[g2 >> 2];
        c2[g2 >> 2] = f2;
        g2 = a3 + 8 | 0;
        h2 = b5 + 12 | 0;
        a3 = c2[g2 >> 2] | 0;
        c2[g2 >> 2] = c2[h2 >> 2];
        c2[h2 >> 2] = a3;
        c2[b5 >> 2] = c2[e2 >> 2];
        return;
      }
      function dc(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0;
        b5 = c2[a3 + 4 >> 2] | 0;
        d2 = a3 + 8 | 0;
        e2 = c2[d2 >> 2] | 0;
        if ((e2 | 0) != (b5 | 0))
          c2[d2 >> 2] = e2 + (~(((e2 + -12 - b5 | 0) >>> 0) / 12 | 0) * 12 | 0);
        b5 = c2[a3 >> 2] | 0;
        if (b5 | 0)
          Da(b5, (c2[a3 + 12 >> 2] | 0) - b5 | 0);
        return;
      }
      function ec(a3) {
        a3 = a3 | 0;
        return 357913941;
      }
      function fc(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0;
        gc(a3);
        c2[a3 >> 2] = c2[b5 >> 2];
        d2 = b5 + 4 | 0;
        c2[a3 + 4 >> 2] = c2[d2 >> 2];
        e2 = b5 + 8 | 0;
        c2[a3 + 8 >> 2] = c2[e2 >> 2];
        c2[e2 >> 2] = 0;
        c2[d2 >> 2] = 0;
        c2[b5 >> 2] = 0;
        return;
      }
      function gc(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0, f2 = 0;
        b5 = c2[a3 >> 2] | 0;
        d2 = b5;
        if (b5 | 0) {
          e2 = a3 + 4 | 0;
          c2[e2 >> 2] = d2;
          f2 = a3 + 8 | 0;
          Da(b5, (c2[f2 >> 2] | 0) - d2 | 0);
          c2[f2 >> 2] = 0;
          c2[e2 >> 2] = 0;
          c2[a3 >> 2] = 0;
        }
        return;
      }
      function hc(a3) {
        a3 = a3 | 0;
        xq(a3, 7660);
        c2[a3 >> 2] = 4496;
        return;
      }
      function ic(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        xq(a3, b5);
        c2[a3 >> 2] = 4516;
        return;
      }
      function jc(a3) {
        a3 = a3 | 0;
        xq(a3, 7704);
        c2[a3 >> 2] = 4536;
        return;
      }
      function kc(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0;
        d2 = a3 + 4 | 0;
        f2 = c2[a3 >> 2] | 0;
        e2 = (c2[d2 >> 2] | 0) - f2 >> 3;
        if (e2 >>> 0 >= b5 >>> 0) {
          if (e2 >>> 0 > b5 >>> 0)
            c2[d2 >> 2] = f2 + (b5 << 3);
        } else
          vc(a3, b5 - e2 | 0);
        return;
      }
      function lc(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c2[a3 >> 2] = b5;
        c2[a3 + 4 >> 2] = 0;
        c2[a3 + 8 >> 2] = -1;
        return;
      }
      function mc(a3, b5, d2, e2, f2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        f2 = f2 | 0;
        var g2 = 0;
        c2[a3 + 4 >> 2] = b5;
        c2[a3 + 8 >> 2] = d2;
        c2[a3 + 12 >> 2] = e2;
        c2[a3 + 16 >> 2] = f2;
        c2[a3 + 36 >> 2] = 0;
        c2[a3 + 40 >> 2] = 0;
        c2[a3 + 44 >> 2] = 0;
        Gc(a3 + 48 | 0);
        c2[a3 + 68 >> 2] = 0;
        c2[a3 + 72 >> 2] = 0;
        c2[a3 + 76 >> 2] = 0;
        do
          if (!f2) {
            d2 = a3 + 20 | 0;
            if ((b5 + -1 | 0) >>> 0 < 31) {
              c2[d2 >> 2] = b5;
              f2 = 1 << b5;
              c2[a3 + 24 >> 2] = f2;
              d2 = f2 >>> 1;
              c2[a3 + 28 >> 2] = 0 - d2;
              d2 = f2 + -1 - d2 | 0;
              break;
            } else {
              c2[d2 >> 2] = 32;
              c2[a3 + 24 >> 2] = 0;
              c2[a3 + 28 >> 2] = -2147483648;
              d2 = 2147483647;
              break;
            }
          } else {
            e2 = a3 + 20 | 0;
            c2[e2 >> 2] = 0;
            c2[a3 + 24 >> 2] = f2;
            d2 = f2;
            g2 = 0;
            while (1) {
              d2 = d2 >>> 1;
              b5 = g2 + 1 | 0;
              if (!d2)
                break;
              else
                g2 = b5;
            }
            c2[e2 >> 2] = (1 << g2 | 0) == (f2 | 0) ? g2 : b5;
            d2 = f2 >>> 1;
            c2[a3 + 28 >> 2] = 0 - d2;
            d2 = f2 + -1 - d2 | 0;
          }
        while (0);
        c2[a3 + 32 >> 2] = d2;
        c2[a3 >> 2] = 0;
        return;
      }
      function nc(a3) {
        a3 = a3 | 0;
        var b5 = 0;
        b5 = ((Jc(c2[a3 >> 2] | 0) | 0) & 255) << 24;
        b5 = ((Jc(c2[a3 >> 2] | 0) | 0) & 255) << 16 | b5;
        b5 = b5 | ((Jc(c2[a3 >> 2] | 0) | 0) & 255) << 8;
        c2[a3 + 4 >> 2] = b5 | (Jc(c2[a3 >> 2] | 0) | 0) & 255;
        return;
      }
      function oc(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0, m2 = 0, n2 = 0, o2 = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0;
        q2 = V;
        V = V + 64 | 0;
        o2 = q2 + 44 | 0;
        p2 = q2;
        k2 = a3 + 36 | 0;
        l2 = a3 + 40 | 0;
        a:
          do
            if ((c2[k2 >> 2] | 0) == (c2[l2 >> 2] | 0)) {
              m2 = a3 + 8 | 0;
              b:
                do
                  if (!(c2[m2 >> 2] | 0))
                    n2 = a3 + 20 | 0;
                  else {
                    f2 = a3 + 20 | 0;
                    g2 = a3 + 44 | 0;
                    h2 = o2 + 4 | 0;
                    i2 = a3 + 44 | 0;
                    j2 = o2 + 8 | 0;
                    e2 = 0;
                    while (1) {
                      Oc(p2, (c2[f2 >> 2] | 0) + 1 | 0, 0, 0);
                      b5 = c2[l2 >> 2] | 0;
                      if (b5 >>> 0 < (c2[g2 >> 2] | 0) >>> 0) {
                        Pc(o2, k2, 1);
                        Rc(c2[h2 >> 2] | 0, p2);
                        c2[h2 >> 2] = (c2[h2 >> 2] | 0) + 44;
                        Qc(o2);
                      } else {
                        b5 = ((b5 - (c2[k2 >> 2] | 0) | 0) / 44 | 0) + 1 | 0;
                        d2 = Vc(k2) | 0;
                        if (d2 >>> 0 < b5 >>> 0)
                          break;
                        r2 = c2[k2 >> 2] | 0;
                        t2 = ((c2[g2 >> 2] | 0) - r2 | 0) / 44 | 0;
                        s2 = t2 << 1;
                        Sc(o2, t2 >>> 0 < d2 >>> 1 >>> 0 ? s2 >>> 0 < b5 >>> 0 ? b5 : s2 : d2, ((c2[l2 >> 2] | 0) - r2 | 0) / 44 | 0, i2);
                        Rc(c2[j2 >> 2] | 0, p2);
                        c2[j2 >> 2] = (c2[j2 >> 2] | 0) + 44;
                        Tc(k2, o2);
                        Uc(o2);
                      }
                      Ic(p2);
                      e2 = e2 + 1 | 0;
                      if (e2 >>> 0 >= (c2[m2 >> 2] | 0) >>> 0) {
                        n2 = f2;
                        break b;
                      }
                    }
                    cr(k2);
                  }
                while (0);
              if (c2[n2 >> 2] | 0) {
                h2 = a3 + 12 | 0;
                i2 = a3 + 68 | 0;
                j2 = a3 + 72 | 0;
                k2 = a3 + 76 | 0;
                l2 = o2 + 4 | 0;
                f2 = a3 + 76 | 0;
                g2 = o2 + 8 | 0;
                e2 = 1;
                while (1) {
                  b5 = c2[h2 >> 2] | 0;
                  Oc(p2, 1 << (e2 >>> 0 > b5 >>> 0 ? b5 : e2), 0, 0);
                  b5 = c2[j2 >> 2] | 0;
                  if (b5 >>> 0 < (c2[k2 >> 2] | 0) >>> 0) {
                    Pc(o2, i2, 1);
                    Rc(c2[l2 >> 2] | 0, p2);
                    c2[l2 >> 2] = (c2[l2 >> 2] | 0) + 44;
                    Qc(o2);
                  } else {
                    b5 = ((b5 - (c2[i2 >> 2] | 0) | 0) / 44 | 0) + 1 | 0;
                    d2 = Vc(i2) | 0;
                    if (d2 >>> 0 < b5 >>> 0)
                      break;
                    t2 = c2[i2 >> 2] | 0;
                    r2 = ((c2[k2 >> 2] | 0) - t2 | 0) / 44 | 0;
                    s2 = r2 << 1;
                    Sc(o2, r2 >>> 0 < d2 >>> 1 >>> 0 ? s2 >>> 0 < b5 >>> 0 ? b5 : s2 : d2, ((c2[j2 >> 2] | 0) - t2 | 0) / 44 | 0, f2);
                    Rc(c2[g2 >> 2] | 0, p2);
                    c2[g2 >> 2] = (c2[g2 >> 2] | 0) + 44;
                    Tc(i2, o2);
                    Uc(o2);
                  }
                  Ic(p2);
                  e2 = e2 + 1 | 0;
                  if (e2 >>> 0 > (c2[n2 >> 2] | 0) >>> 0)
                    break a;
                }
                cr(i2);
              }
            }
          while (0);
        V = q2;
        return;
      }
      function pc(a3, b5, d2, e2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        d2 = (Yc(a3, b5, (c2[a3 + 36 >> 2] | 0) + (e2 * 44 | 0) | 0) | 0) + d2 | 0;
        b5 = c2[a3 + 24 >> 2] | 0;
        if ((d2 | 0) < 0)
          return d2 + b5 | 0;
        else
          return d2 - (d2 >>> 0 < b5 >>> 0 ? 0 : b5) | 0;
        return 0;
      }
      function qc(a3) {
        a3 = a3 | 0;
        Hc(a3 + 68 | 0);
        Hc(a3 + 36 | 0);
        return;
      }
      function rc(a3) {
        a3 = a3 | 0;
        return;
      }
      function sc(a3) {
        a3 = a3 | 0;
        yp(a3);
        jp(a3);
        return;
      }
      function tc(a3) {
        a3 = a3 | 0;
        yp(a3);
        jp(a3);
        return;
      }
      function uc(a3) {
        a3 = a3 | 0;
        yp(a3);
        jp(a3);
        return;
      }
      function vc(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0;
        i2 = V;
        V = V + 32 | 0;
        f2 = i2;
        g2 = a3 + 8 | 0;
        h2 = a3 + 4 | 0;
        d2 = c2[h2 >> 2] | 0;
        do
          if ((c2[g2 >> 2] | 0) - d2 >> 3 >>> 0 < b5 >>> 0) {
            d2 = (d2 - (c2[a3 >> 2] | 0) >> 3) + b5 | 0;
            e2 = Dc(a3) | 0;
            if (e2 >>> 0 < d2 >>> 0)
              cr(a3);
            else {
              j2 = c2[a3 >> 2] | 0;
              k2 = (c2[g2 >> 2] | 0) - j2 | 0;
              g2 = k2 >> 2;
              xc(f2, k2 >> 3 >>> 0 < e2 >>> 1 >>> 0 ? g2 >>> 0 < d2 >>> 0 ? d2 : g2 : e2, (c2[h2 >> 2] | 0) - j2 >> 3, a3 + 8 | 0);
              yc(f2, b5);
              zc(a3, f2);
              Ac(f2);
              break;
            }
          } else
            wc(a3, b5);
        while (0);
        V = i2;
        return;
      }
      function wc(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0;
        f2 = V;
        V = V + 16 | 0;
        e2 = f2;
        Bc(e2, a3, b5);
        a3 = e2 + 4 | 0;
        b5 = c2[a3 >> 2] | 0;
        d2 = c2[e2 + 8 >> 2] | 0;
        if ((b5 | 0) != (d2 | 0)) {
          d2 = d2 + -8 - b5 | 0;
          wr(b5 | 0, 0, d2 + 8 & -8 | 0) | 0;
          c2[a3 >> 2] = b5 + ((d2 >>> 3) + 1 << 3);
        }
        Cc(e2);
        V = f2;
        return;
      }
      function xc(a3, b5, d2, e2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f2 = 0;
        f2 = a3 + 12 | 0;
        c2[f2 >> 2] = 0;
        c2[a3 + 16 >> 2] = e2;
        do
          if (b5)
            if (b5 >>> 0 > 536870911) {
              f2 = v(8) | 0;
              vq(f2, 6723);
              c2[f2 >> 2] = 5956;
              x(f2 | 0, 3928, 123);
            } else {
              e2 = eq(b5 << 3) | 0;
              break;
            }
          else
            e2 = 0;
        while (0);
        c2[a3 >> 2] = e2;
        d2 = e2 + (d2 << 3) | 0;
        c2[a3 + 8 >> 2] = d2;
        c2[a3 + 4 >> 2] = d2;
        c2[f2 >> 2] = e2 + (b5 << 3);
        return;
      }
      function yc(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0;
        e2 = V;
        V = V + 16 | 0;
        d2 = e2;
        Ec(d2, a3 + 8 | 0, b5);
        a3 = c2[d2 >> 2] | 0;
        b5 = c2[d2 + 4 >> 2] | 0;
        if ((a3 | 0) != (b5 | 0)) {
          b5 = b5 + -8 - a3 | 0;
          wr(a3 | 0, 0, b5 + 8 & -8 | 0) | 0;
          c2[d2 >> 2] = a3 + ((b5 >>> 3) + 1 << 3);
        }
        Fc(d2);
        V = e2;
        return;
      }
      function zc(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0;
        e2 = c2[a3 >> 2] | 0;
        h2 = a3 + 4 | 0;
        g2 = b5 + 4 | 0;
        f2 = (c2[h2 >> 2] | 0) - e2 | 0;
        d2 = (c2[g2 >> 2] | 0) + (0 - (f2 >> 3) << 3) | 0;
        c2[g2 >> 2] = d2;
        if ((f2 | 0) > 0) {
          ur(d2 | 0, e2 | 0, f2 | 0) | 0;
          e2 = g2;
          d2 = c2[g2 >> 2] | 0;
        } else
          e2 = g2;
        g2 = c2[a3 >> 2] | 0;
        c2[a3 >> 2] = d2;
        c2[e2 >> 2] = g2;
        g2 = b5 + 8 | 0;
        f2 = c2[h2 >> 2] | 0;
        c2[h2 >> 2] = c2[g2 >> 2];
        c2[g2 >> 2] = f2;
        g2 = a3 + 8 | 0;
        h2 = b5 + 12 | 0;
        a3 = c2[g2 >> 2] | 0;
        c2[g2 >> 2] = c2[h2 >> 2];
        c2[h2 >> 2] = a3;
        c2[b5 >> 2] = c2[e2 >> 2];
        return;
      }
      function Ac(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0;
        b5 = c2[a3 + 4 >> 2] | 0;
        d2 = a3 + 8 | 0;
        e2 = c2[d2 >> 2] | 0;
        if ((e2 | 0) != (b5 | 0))
          c2[d2 >> 2] = e2 + (~((e2 + -8 - b5 | 0) >>> 3) << 3);
        b5 = c2[a3 >> 2] | 0;
        if (b5 | 0)
          Da(b5, (c2[a3 + 12 >> 2] | 0) - b5 | 0);
        return;
      }
      function Bc(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        c2[a3 >> 2] = b5;
        b5 = c2[b5 + 4 >> 2] | 0;
        c2[a3 + 4 >> 2] = b5;
        c2[a3 + 8 >> 2] = b5 + (d2 << 3);
        return;
      }
      function Cc(a3) {
        a3 = a3 | 0;
        c2[(c2[a3 >> 2] | 0) + 4 >> 2] = c2[a3 + 4 >> 2];
        return;
      }
      function Dc(a3) {
        a3 = a3 | 0;
        return 536870911;
      }
      function Ec(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        c2[a3 >> 2] = c2[b5 >> 2];
        c2[a3 + 4 >> 2] = (c2[b5 >> 2] | 0) + (d2 << 3);
        c2[a3 + 8 >> 2] = b5;
        return;
      }
      function Fc(a3) {
        a3 = a3 | 0;
        c2[c2[a3 + 8 >> 2] >> 2] = c2[a3 >> 2];
        return;
      }
      function Gc(a3) {
        a3 = a3 | 0;
        c2[a3 + 12 >> 2] = 1;
        c2[a3 + 16 >> 2] = 2;
        c2[a3 + 8 >> 2] = 4096;
        c2[a3 + 4 >> 2] = 4;
        c2[a3 >> 2] = 4;
        return;
      }
      function Hc(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0;
        d2 = c2[a3 >> 2] | 0;
        if (d2 | 0) {
          e2 = a3 + 4 | 0;
          b5 = c2[e2 >> 2] | 0;
          if ((b5 | 0) == (d2 | 0))
            b5 = d2;
          else {
            do {
              b5 = b5 + -44 | 0;
              Ic(b5);
            } while ((b5 | 0) != (d2 | 0));
            b5 = c2[a3 >> 2] | 0;
          }
          c2[e2 >> 2] = d2;
          Da(b5, (c2[a3 + 8 >> 2] | 0) - b5 | 0);
        }
        return;
      }
      function Ic(a3) {
        a3 = a3 | 0;
        var b5 = 0;
        b5 = c2[a3 + 8 >> 2] | 0;
        if (b5 | 0)
          Ua(b5);
        b5 = c2[a3 + 12 >> 2] | 0;
        if (b5 | 0)
          Ua(b5);
        b5 = c2[a3 + 16 >> 2] | 0;
        if (b5 | 0)
          Ua(b5);
        return;
      }
      function Jc(b5) {
        b5 = b5 | 0;
        var d2 = 0, e2 = 0;
        e2 = b5 + 4 | 0;
        d2 = c2[e2 >> 2] | 0;
        if ((d2 | 0) >= (c2[b5 + 8 >> 2] | 0)) {
          Kc(b5);
          d2 = c2[e2 >> 2] | 0;
        }
        b5 = c2[b5 + 12 >> 2] | 0;
        c2[e2 >> 2] = d2 + 1;
        return a2[b5 + d2 >> 0] | 0;
      }
      function Kc(a3) {
        a3 = a3 | 0;
        var b5 = 0;
        c2[a3 + 4 >> 2] = 0;
        $a(c2[a3 >> 2] | 0, c2[a3 + 12 >> 2] | 0, 1048576);
        b5 = Lc(c2[a3 >> 2] | 0) | 0;
        c2[a3 + 8 >> 2] = b5;
        if (!b5) {
          b5 = v(8) | 0;
          Mc(b5);
          x(b5 | 0, 2752, 8);
        } else
          return;
      }
      function Lc(a3) {
        a3 = a3 | 0;
        return c2[a3 + 16 >> 2] | 0;
      }
      function Mc(a3) {
        a3 = a3 | 0;
        xq(a3, 7769);
        c2[a3 >> 2] = 4556;
        return;
      }
      function Nc(a3) {
        a3 = a3 | 0;
        yp(a3);
        jp(a3);
        return;
      }
      function Oc(b5, d2, e2, f2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        f2 = f2 | 0;
        var g2 = 0, h2 = 0, i2 = 0;
        c2[b5 >> 2] = d2;
        a2[b5 + 4 >> 0] = e2 & 1;
        h2 = b5 + 8 | 0;
        c2[h2 >> 2] = 0;
        i2 = b5 + 12 | 0;
        c2[i2 >> 2] = 0;
        g2 = b5 + 16 | 0;
        c2[g2 >> 2] = 0;
        if ((d2 + -2 | 0) >>> 0 > 2046) {
          b5 = v(8) | 0;
          xq(b5, 7789);
          x(b5 | 0, 3912, 8);
        }
        c2[b5 + 32 >> 2] = d2 + -1;
        if (d2 >>> 0 > 16 & (e2 ^ 1)) {
          e2 = 3;
          while (1)
            if (1 << e2 + 2 >>> 0 < d2 >>> 0)
              e2 = e2 + 1 | 0;
            else
              break;
          d2 = 1 << e2;
          c2[b5 + 36 >> 2] = d2;
          c2[b5 + 40 >> 2] = 15 - e2;
          c2[g2 >> 2] = _a((d2 << 2) + 8 | 0) | 0;
          d2 = c2[b5 >> 2] | 0;
        } else {
          c2[g2 >> 2] = 0;
          c2[b5 + 40 >> 2] = 0;
          c2[b5 + 36 >> 2] = 0;
        }
        c2[h2 >> 2] = _a(d2 << 2) | 0;
        g2 = _a(c2[b5 >> 2] << 2) | 0;
        c2[i2 >> 2] = g2;
        c2[b5 + 20 >> 2] = 0;
        d2 = c2[b5 >> 2] | 0;
        e2 = b5 + 24 | 0;
        c2[e2 >> 2] = d2;
        d2 = (d2 | 0) != 0;
        if (!f2) {
          if (d2) {
            d2 = 0;
            do {
              c2[g2 + (d2 << 2) >> 2] = 1;
              d2 = d2 + 1 | 0;
            } while (d2 >>> 0 < (c2[b5 >> 2] | 0) >>> 0);
          }
        } else if (d2) {
          d2 = 0;
          do {
            c2[g2 + (d2 << 2) >> 2] = c2[f2 + (d2 << 2) >> 2];
            d2 = d2 + 1 | 0;
          } while (d2 >>> 0 < (c2[b5 >> 2] | 0) >>> 0);
        }
        Xc(b5);
        f2 = ((c2[b5 >> 2] | 0) + 6 | 0) >>> 1;
        c2[e2 >> 2] = f2;
        c2[b5 + 28 >> 2] = f2;
        return;
      }
      function Pc(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        c2[a3 >> 2] = b5;
        b5 = c2[b5 + 4 >> 2] | 0;
        c2[a3 + 4 >> 2] = b5;
        c2[a3 + 8 >> 2] = b5 + (d2 * 44 | 0);
        return;
      }
      function Qc(a3) {
        a3 = a3 | 0;
        c2[(c2[a3 >> 2] | 0) + 4 >> 2] = c2[a3 + 4 >> 2];
        return;
      }
      function Rc(b5, d2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0;
        c2[b5 >> 2] = c2[d2 >> 2];
        a2[b5 + 4 >> 0] = a2[d2 + 4 >> 0] | 0;
        e2 = d2 + 8 | 0;
        c2[b5 + 8 >> 2] = c2[e2 >> 2];
        c2[b5 + 12 >> 2] = c2[d2 + 12 >> 2];
        c2[b5 + 16 >> 2] = c2[d2 + 16 >> 2];
        c2[b5 + 20 >> 2] = c2[d2 + 20 >> 2];
        c2[b5 + 24 >> 2] = c2[d2 + 24 >> 2];
        c2[b5 + 28 >> 2] = c2[d2 + 28 >> 2];
        c2[b5 + 32 >> 2] = c2[d2 + 32 >> 2];
        c2[b5 + 36 >> 2] = c2[d2 + 36 >> 2];
        c2[b5 + 40 >> 2] = c2[d2 + 40 >> 2];
        c2[e2 >> 2] = 0;
        c2[e2 + 4 >> 2] = 0;
        c2[e2 + 8 >> 2] = 0;
        return;
      }
      function Sc(a3, b5, d2, e2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f2 = 0;
        f2 = a3 + 12 | 0;
        c2[f2 >> 2] = 0;
        c2[a3 + 16 >> 2] = e2;
        do
          if (b5)
            if (b5 >>> 0 > 97612893) {
              f2 = v(8) | 0;
              vq(f2, 6723);
              c2[f2 >> 2] = 5956;
              x(f2 | 0, 3928, 123);
            } else {
              e2 = eq(b5 * 44 | 0) | 0;
              break;
            }
          else
            e2 = 0;
        while (0);
        c2[a3 >> 2] = e2;
        d2 = e2 + (d2 * 44 | 0) | 0;
        c2[a3 + 8 >> 2] = d2;
        c2[a3 + 4 >> 2] = d2;
        c2[f2 >> 2] = e2 + (b5 * 44 | 0);
        return;
      }
      function Tc(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0;
        i2 = c2[a3 >> 2] | 0;
        j2 = a3 + 4 | 0;
        d2 = c2[j2 >> 2] | 0;
        h2 = b5 + 4 | 0;
        if ((d2 | 0) == (i2 | 0)) {
          f2 = h2;
          g2 = a3;
          e2 = c2[h2 >> 2] | 0;
          d2 = i2;
        } else {
          e2 = c2[h2 >> 2] | 0;
          do {
            d2 = d2 + -44 | 0;
            Wc(e2 + -44 | 0, d2);
            e2 = (c2[h2 >> 2] | 0) + -44 | 0;
            c2[h2 >> 2] = e2;
          } while ((d2 | 0) != (i2 | 0));
          f2 = h2;
          g2 = a3;
          d2 = c2[a3 >> 2] | 0;
        }
        c2[g2 >> 2] = e2;
        c2[f2 >> 2] = d2;
        i2 = b5 + 8 | 0;
        h2 = c2[j2 >> 2] | 0;
        c2[j2 >> 2] = c2[i2 >> 2];
        c2[i2 >> 2] = h2;
        i2 = a3 + 8 | 0;
        j2 = b5 + 12 | 0;
        a3 = c2[i2 >> 2] | 0;
        c2[i2 >> 2] = c2[j2 >> 2];
        c2[j2 >> 2] = a3;
        c2[b5 >> 2] = c2[f2 >> 2];
        return;
      }
      function Uc(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0, f2 = 0;
        d2 = c2[a3 + 4 >> 2] | 0;
        e2 = a3 + 8 | 0;
        b5 = c2[e2 >> 2] | 0;
        if ((b5 | 0) != (d2 | 0))
          do {
            f2 = b5 + -44 | 0;
            c2[e2 >> 2] = f2;
            Ic(f2);
            b5 = c2[e2 >> 2] | 0;
          } while ((b5 | 0) != (d2 | 0));
        b5 = c2[a3 >> 2] | 0;
        if (b5 | 0)
          Da(b5, (c2[a3 + 12 >> 2] | 0) - b5 | 0);
        return;
      }
      function Vc(a3) {
        a3 = a3 | 0;
        return 97612893;
      }
      function Wc(b5, d2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0, g2 = 0, h2 = 0;
        e2 = c2[d2 >> 2] | 0;
        c2[b5 >> 2] = e2;
        a2[b5 + 4 >> 0] = a2[d2 + 4 >> 0] | 0;
        c2[b5 + 20 >> 2] = c2[d2 + 20 >> 2];
        c2[b5 + 24 >> 2] = c2[d2 + 24 >> 2];
        c2[b5 + 28 >> 2] = c2[d2 + 28 >> 2];
        c2[b5 + 32 >> 2] = c2[d2 + 32 >> 2];
        h2 = b5 + 36 | 0;
        c2[h2 >> 2] = c2[d2 + 36 >> 2];
        c2[b5 + 40 >> 2] = c2[d2 + 40 >> 2];
        e2 = e2 << 2;
        f2 = _a(e2) | 0;
        c2[b5 + 8 >> 2] = f2;
        g2 = c2[b5 >> 2] | 0;
        if (g2 | 0)
          vr(f2 | 0, c2[d2 + 8 >> 2] | 0, g2 << 2 | 0) | 0;
        e2 = _a(e2) | 0;
        c2[b5 + 12 >> 2] = e2;
        f2 = c2[b5 >> 2] | 0;
        if (f2 | 0)
          vr(e2 | 0, c2[d2 + 12 >> 2] | 0, f2 << 2 | 0) | 0;
        e2 = c2[h2 >> 2] | 0;
        if (e2) {
          f2 = _a((e2 << 2) + 8 | 0) | 0;
          c2[b5 + 16 >> 2] = f2;
          e2 = (c2[h2 >> 2] << 2) + 8 | 0;
          if (e2 | 0)
            vr(f2 | 0, c2[d2 + 16 >> 2] | 0, e2 | 0) | 0;
        } else
          c2[b5 + 16 >> 2] = 0;
        return;
      }
      function Xc(b5) {
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0, m2 = 0, n2 = 0, o2 = 0, p2 = 0, r2 = 0;
        r2 = b5 + 24 | 0;
        g2 = b5 + 20 | 0;
        d2 = (c2[g2 >> 2] | 0) + (c2[r2 >> 2] | 0) | 0;
        c2[g2 >> 2] = d2;
        if (d2 >>> 0 > 32768) {
          c2[g2 >> 2] = 0;
          if (!(c2[b5 >> 2] | 0))
            d2 = 0;
          else {
            f2 = c2[b5 + 12 >> 2] | 0;
            e2 = 0;
            do {
              n2 = f2 + (e2 << 2) | 0;
              d2 = ((c2[n2 >> 2] | 0) + 1 | 0) >>> 1;
              c2[n2 >> 2] = d2;
              d2 = (c2[g2 >> 2] | 0) + d2 | 0;
              c2[g2 >> 2] = d2;
              e2 = e2 + 1 | 0;
            } while (e2 >>> 0 < (c2[b5 >> 2] | 0) >>> 0);
          }
        }
        n2 = 2147483648 / (d2 >>> 0) | 0;
        do
          if ((a2[b5 + 4 >> 0] | 0) == 0 ? (o2 = b5 + 36 | 0, (c2[o2 >> 2] | 0) != 0) : 0) {
            if (c2[b5 >> 2] | 0) {
              j2 = c2[b5 + 8 >> 2] | 0;
              k2 = c2[b5 + 12 >> 2] | 0;
              l2 = b5 + 40 | 0;
              m2 = b5 + 16 | 0;
              d2 = 0;
              h2 = 0;
              i2 = 0;
              do {
                e2 = (q(h2, n2) | 0) >>> 16;
                c2[j2 + (i2 << 2) >> 2] = e2;
                h2 = (c2[k2 + (i2 << 2) >> 2] | 0) + h2 | 0;
                e2 = e2 >>> (c2[l2 >> 2] | 0);
                if (d2 >>> 0 < e2 >>> 0) {
                  f2 = i2 + -1 | 0;
                  g2 = c2[m2 >> 2] | 0;
                  do {
                    d2 = d2 + 1 | 0;
                    c2[g2 + (d2 << 2) >> 2] = f2;
                  } while ((d2 | 0) != (e2 | 0));
                  d2 = e2;
                }
                i2 = i2 + 1 | 0;
              } while (i2 >>> 0 < (c2[b5 >> 2] | 0) >>> 0);
              e2 = c2[m2 >> 2] | 0;
              c2[e2 >> 2] = 0;
              if (d2 >>> 0 > (c2[o2 >> 2] | 0) >>> 0) {
                d2 = b5;
                break;
              }
            } else {
              e2 = c2[b5 + 16 >> 2] | 0;
              c2[e2 >> 2] = 0;
              d2 = 0;
            }
            do {
              d2 = d2 + 1 | 0;
              c2[e2 + (d2 << 2) >> 2] = (c2[b5 >> 2] | 0) + -1;
            } while (d2 >>> 0 <= (c2[o2 >> 2] | 0) >>> 0);
            d2 = b5;
          } else
            p2 = 7;
        while (0);
        if ((p2 | 0) == 7)
          if (!(c2[b5 >> 2] | 0))
            d2 = b5;
          else {
            f2 = c2[b5 + 8 >> 2] | 0;
            g2 = c2[b5 + 12 >> 2] | 0;
            d2 = 0;
            e2 = 0;
            do {
              c2[f2 + (d2 << 2) >> 2] = (q(e2, n2) | 0) >>> 16;
              e2 = (c2[g2 + (d2 << 2) >> 2] | 0) + e2 | 0;
              d2 = d2 + 1 | 0;
            } while (d2 >>> 0 < (c2[b5 >> 2] | 0) >>> 0);
            d2 = b5;
          }
        p2 = ((c2[r2 >> 2] | 0) * 5 | 0) >>> 2;
        o2 = (c2[d2 >> 2] << 3) + 48 | 0;
        p2 = p2 >>> 0 > o2 >>> 0 ? o2 : p2;
        c2[r2 >> 2] = p2;
        c2[b5 + 28 >> 2] = p2;
        return;
      }
      function Yc(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0;
        d2 = Zc(b5, d2) | 0;
        c2[a3 >> 2] = d2;
        do
          if (d2) {
            if (d2 >>> 0 >= 32) {
              d2 = c2[a3 + 28 >> 2] | 0;
              break;
            }
            e2 = c2[a3 + 12 >> 2] | 0;
            if (d2 >>> 0 > e2 >>> 0) {
              e2 = d2 - e2 | 0;
              d2 = Zc(b5, (c2[a3 + 68 >> 2] | 0) + ((d2 + -1 | 0) * 44 | 0) | 0) | 0;
              e2 = d2 << e2 | (_c(b5, e2) | 0);
            } else
              e2 = Zc(b5, (c2[a3 + 68 >> 2] | 0) + ((d2 + -1 | 0) * 44 | 0) | 0) | 0;
            d2 = c2[a3 >> 2] | 0;
            if ((e2 | 0) < (1 << d2 + -1 | 0)) {
              d2 = e2 + 1 + (-1 << d2) | 0;
              break;
            } else {
              d2 = e2 + 1 | 0;
              break;
            }
          } else
            d2 = $c(b5, a3 + 48 | 0) | 0;
        while (0);
        return d2 | 0;
      }
      function Zc(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0, m2 = 0, n2 = 0, o2 = 0;
        n2 = a3 + 8 | 0;
        m2 = c2[n2 >> 2] | 0;
        f2 = c2[b5 + 16 >> 2] | 0;
        if (f2) {
          e2 = a3 + 4 | 0;
          d2 = c2[e2 >> 2] | 0;
          l2 = m2 >>> 15;
          c2[n2 >> 2] = l2;
          j2 = (d2 >>> 0) / (l2 >>> 0) | 0;
          i2 = j2 >>> (c2[b5 + 40 >> 2] | 0);
          g2 = c2[f2 + (i2 << 2) >> 2] | 0;
          i2 = (c2[f2 + (i2 + 1 << 2) >> 2] | 0) + 1 | 0;
          h2 = g2 + 1 | 0;
          k2 = c2[b5 + 8 >> 2] | 0;
          if (i2 >>> 0 > h2 >>> 0) {
            f2 = g2;
            g2 = i2;
            do {
              h2 = (g2 + f2 | 0) >>> 1;
              i2 = (c2[k2 + (h2 << 2) >> 2] | 0) >>> 0 > j2 >>> 0;
              f2 = i2 ? f2 : h2;
              g2 = i2 ? h2 : g2;
              h2 = f2 + 1 | 0;
            } while (g2 >>> 0 > h2 >>> 0);
            g2 = f2;
          }
          f2 = q(c2[k2 + (g2 << 2) >> 2] | 0, l2) | 0;
          if ((g2 | 0) == (c2[b5 + 32 >> 2] | 0))
            h2 = m2;
          else
            h2 = q(c2[k2 + (h2 << 2) >> 2] | 0, l2) | 0;
        } else {
          k2 = m2 >>> 15;
          c2[n2 >> 2] = k2;
          i2 = c2[b5 >> 2] | 0;
          l2 = c2[b5 + 8 >> 2] | 0;
          e2 = a3 + 4 | 0;
          d2 = c2[e2 >> 2] | 0;
          j2 = i2 >>> 1;
          f2 = 0;
          h2 = m2;
          g2 = 0;
          do {
            o2 = q(c2[l2 + (j2 << 2) >> 2] | 0, k2) | 0;
            m2 = o2 >>> 0 > d2 >>> 0;
            h2 = m2 ? o2 : h2;
            f2 = m2 ? f2 : o2;
            g2 = m2 ? g2 : j2;
            i2 = m2 ? j2 : i2;
            j2 = (g2 + i2 | 0) >>> 1;
          } while ((j2 | 0) != (g2 | 0));
        }
        c2[e2 >> 2] = d2 - f2;
        o2 = h2 - f2 | 0;
        c2[n2 >> 2] = o2;
        if (o2 >>> 0 < 16777216)
          ad(a3);
        n2 = (c2[b5 + 12 >> 2] | 0) + (g2 << 2) | 0;
        c2[n2 >> 2] = (c2[n2 >> 2] | 0) + 1;
        n2 = b5 + 28 | 0;
        o2 = (c2[n2 >> 2] | 0) + -1 | 0;
        c2[n2 >> 2] = o2;
        if (!o2)
          Xc(b5);
        return g2 | 0;
      }
      function _c(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0;
        if (b5 >>> 0 > 19) {
          d2 = (bd(a3) | 0) & 65535;
          return (_c(a3, b5 + -16 | 0) | 0) << 16 | d2 | 0;
        }
        e2 = a3 + 4 | 0;
        f2 = c2[e2 >> 2] | 0;
        g2 = a3 + 8 | 0;
        d2 = (c2[g2 >> 2] | 0) >>> b5;
        c2[g2 >> 2] = d2;
        b5 = (f2 >>> 0) / (d2 >>> 0) | 0;
        c2[e2 >> 2] = f2 - (q(b5, d2) | 0);
        if (d2 >>> 0 < 16777216)
          ad(a3);
        return b5 | 0;
      }
      function $c(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0;
        e2 = a3 + 8 | 0;
        f2 = c2[e2 >> 2] | 0;
        d2 = q(f2 >>> 13, c2[b5 + 8 >> 2] | 0) | 0;
        g2 = a3 + 4 | 0;
        h2 = c2[g2 >> 2] | 0;
        i2 = h2 >>> 0 >= d2 >>> 0;
        if (i2) {
          c2[g2 >> 2] = h2 - d2;
          d2 = f2 - d2 | 0;
          c2[e2 >> 2] = d2;
        } else {
          c2[e2 >> 2] = d2;
          h2 = b5 + 12 | 0;
          c2[h2 >> 2] = (c2[h2 >> 2] | 0) + 1;
        }
        if (d2 >>> 0 < 16777216)
          ad(a3);
        h2 = b5 + 4 | 0;
        a3 = (c2[h2 >> 2] | 0) + -1 | 0;
        c2[h2 >> 2] = a3;
        if (!a3)
          cd(b5);
        return i2 & 1 | 0;
      }
      function ad(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0, f2 = 0;
        b5 = a3 + 4 | 0;
        d2 = a3 + 8 | 0;
        e2 = c2[b5 >> 2] | 0;
        do {
          e2 = e2 << 8 | (Jc(c2[a3 >> 2] | 0) | 0) & 255;
          c2[b5 >> 2] = e2;
          f2 = c2[d2 >> 2] << 8;
          c2[d2 >> 2] = f2;
        } while (f2 >>> 0 < 16777216);
        return;
      }
      function bd(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0, f2 = 0;
        d2 = a3 + 4 | 0;
        f2 = c2[d2 >> 2] | 0;
        b5 = a3 + 8 | 0;
        e2 = (c2[b5 >> 2] | 0) >>> 16;
        c2[b5 >> 2] = e2;
        b5 = (f2 >>> 0) / (e2 >>> 0) | 0;
        c2[d2 >> 2] = f2 - (q(b5, e2) | 0);
        ad(a3);
        return b5 & 65535 | 0;
      }
      function cd(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0, f2 = 0, g2 = 0;
        f2 = c2[a3 >> 2] | 0;
        d2 = a3 + 16 | 0;
        b5 = (c2[d2 >> 2] | 0) + f2 | 0;
        c2[d2 >> 2] = b5;
        if (b5 >>> 0 > 8192) {
          e2 = (b5 + 1 | 0) >>> 1;
          c2[d2 >> 2] = e2;
          g2 = a3 + 12 | 0;
          b5 = ((c2[g2 >> 2] | 0) + 1 | 0) >>> 1;
          c2[g2 >> 2] = b5;
          if ((b5 | 0) == (e2 | 0)) {
            b5 = e2 + 1 | 0;
            c2[d2 >> 2] = b5;
            d2 = b5;
            b5 = e2;
          } else
            d2 = e2;
        } else {
          d2 = b5;
          b5 = c2[a3 + 12 >> 2] | 0;
        }
        c2[a3 + 8 >> 2] = (q(b5, 2147483648 / (d2 >>> 0) | 0) | 0) >>> 18;
        g2 = f2 * 5 | 0;
        g2 = g2 >>> 0 > 259 ? 64 : g2 >>> 2;
        c2[a3 >> 2] = g2;
        c2[a3 + 4 >> 2] = g2;
        return;
      }
      function dd(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0, m2 = 0, n2 = 0, o2 = 0;
        m2 = V;
        V = V + 32 | 0;
        h2 = m2 + 16 | 0;
        i2 = m2 + 8 | 0;
        j2 = m2;
        k2 = a3 + 336 | 0;
        f2 = k2;
        g2 = a3 + 259 | 0;
        if (!((c2[f2 + 4 >> 2] | 0) == 0 ? (c2[f2 >> 2] | 0) == (d[g2 >> 0] | d[g2 + 1 >> 0] << 8 | d[g2 + 2 >> 0] << 16 | d[g2 + 3 >> 0] << 24 | 0) : 0)) {
          f2 = a3 + 320 | 0;
          e2 = c2[f2 >> 2] | 0;
          g2 = e2;
          if (!((e2 | 0) != 0 ? (c2[a3 + 312 >> 2] | 0) != 0 : 0)) {
            e2 = g2;
            l2 = 5;
          }
        } else {
          f2 = a3 + 320 | 0;
          e2 = c2[a3 + 320 >> 2] | 0;
          l2 = 5;
        }
        if ((l2 | 0) == 5) {
          l2 = a3 + 320 | 0;
          c2[h2 >> 2] = e2;
          c2[l2 >> 2] = 0;
          e2 = a3 + 324 | 0;
          c2[h2 + 4 >> 2] = c2[e2 >> 2];
          c2[e2 >> 2] = 0;
          Na(h2);
          g2 = a3 + 312 | 0;
          c2[h2 >> 2] = c2[g2 >> 2];
          c2[g2 >> 2] = 0;
          n2 = a3 + 316 | 0;
          c2[h2 + 4 >> 2] = c2[n2 >> 2];
          c2[n2 >> 2] = 0;
          Oa(h2);
          o2 = eq(12) | 0;
          lc(o2, a3 + 4 | 0);
          c2[j2 >> 2] = 0;
          c2[h2 >> 2] = c2[j2 >> 2];
          fd(i2, o2, h2);
          o2 = c2[i2 >> 2] | 0;
          c2[i2 >> 2] = c2[g2 >> 2];
          c2[g2 >> 2] = o2;
          o2 = i2 + 4 | 0;
          j2 = c2[o2 >> 2] | 0;
          c2[o2 >> 2] = c2[n2 >> 2];
          c2[n2 >> 2] = j2;
          Oa(i2);
          ed(i2, c2[g2 >> 2] | 0, a3 + 300 | 0);
          g2 = c2[i2 >> 2] | 0;
          n2 = i2 + 4 | 0;
          j2 = c2[n2 >> 2] | 0;
          c2[i2 >> 2] = 0;
          c2[n2 >> 2] = 0;
          c2[h2 >> 2] = c2[l2 >> 2];
          c2[l2 >> 2] = g2;
          c2[h2 + 4 >> 2] = c2[e2 >> 2];
          c2[e2 >> 2] = j2;
          Na(h2);
          Na(i2);
          e2 = a3 + 328 | 0;
          j2 = e2;
          j2 = lr(c2[j2 >> 2] | 0, c2[j2 + 4 >> 2] | 0, 1, 0) | 0;
          l2 = u() | 0;
          c2[e2 >> 2] = j2;
          c2[e2 + 4 >> 2] = l2;
          e2 = k2;
          c2[e2 >> 2] = 0;
          c2[e2 + 4 >> 2] = 0;
          e2 = c2[f2 >> 2] | 0;
        }
        $[c2[c2[e2 >> 2] >> 2] & 63](e2, b5) | 0;
        l2 = k2;
        l2 = lr(c2[l2 >> 2] | 0, c2[l2 + 4 >> 2] | 0, 1, 0) | 0;
        n2 = u() | 0;
        o2 = k2;
        c2[o2 >> 2] = l2;
        c2[o2 + 4 >> 2] = n2;
        V = m2;
        return;
      }
      function ed(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0, g2 = 0, h2 = 0;
        h2 = V;
        V = V + 64 | 0;
        e2 = h2 + 56 | 0;
        f2 = h2;
        g2 = ld(d2) | 0;
        if ((g2 | 0) == -1) {
          h2 = v(8) | 0;
          md(h2);
          x(h2 | 0, 2784, 8);
        }
        d2 = nd(d2) | 0;
        a:
          do
            if (!d2)
              switch (g2 | 0) {
                case 0: {
                  g2 = eq(4788) | 0;
                  xd(g2);
                  wd(a3, b5, g2);
                  break a;
                }
                case 1: {
                  g2 = eq(5116) | 0;
                  zd(g2);
                  yd(a3, b5, g2);
                  break a;
                }
                case 2: {
                  g2 = eq(5104) | 0;
                  Bd(g2);
                  Ad(a3, b5, g2);
                  break a;
                }
                case 3: {
                  g2 = eq(5432) | 0;
                  Dd(g2);
                  Cd(a3, b5, g2);
                  break a;
                }
                default: {
                  c2[a3 >> 2] = 0;
                  c2[a3 + 4 >> 2] = 0;
                  break a;
                }
              }
            else {
              od(e2, b5);
              pd(c2[e2 >> 2] | 0);
              if ((g2 | 2 | 0) == 3)
                qd(c2[e2 >> 2] | 0);
              if ((g2 | 1 | 0) == 3)
                rd(c2[e2 >> 2] | 0);
              g2 = c2[e2 >> 2] | 0;
              td(f2, d2);
              sd(g2, f2);
              ud(f2);
              c2[a3 >> 2] = c2[e2 >> 2];
              g2 = e2 + 4 | 0;
              c2[a3 + 4 >> 2] = c2[g2 >> 2];
              c2[e2 >> 2] = 0;
              c2[g2 >> 2] = 0;
              vd(e2);
            }
          while (0);
        V = h2;
        return;
      }
      function fd(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0;
        d2 = V;
        V = V + 16 | 0;
        e2 = d2;
        c2[a3 >> 2] = b5;
        f2 = eq(16) | 0;
        c2[f2 + 4 >> 2] = 0;
        c2[f2 + 8 >> 2] = 0;
        c2[f2 >> 2] = 4576;
        c2[f2 + 12 >> 2] = b5;
        c2[a3 + 4 >> 2] = f2;
        c2[e2 >> 2] = b5;
        c2[e2 + 4 >> 2] = b5;
        gd(a3, e2);
        V = d2;
        return;
      }
      function gd(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return;
      }
      function hd(a3) {
        a3 = a3 | 0;
        pq(a3);
        jp(a3);
        return;
      }
      function id(a3) {
        a3 = a3 | 0;
        a3 = c2[a3 + 12 >> 2] | 0;
        if (a3 | 0) {
          rc(a3);
          jp(a3);
        }
        return;
      }
      function jd(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return ((c2[b5 + 4 >> 2] | 0) == 7983 ? a3 + 12 | 0 : 0) | 0;
      }
      function kd(a3) {
        a3 = a3 | 0;
        Da(a3, 16);
        return;
      }
      function ld(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        b5 = (c2[a3 + 4 >> 2] | 0) - (c2[a3 >> 2] | 0) | 0;
        a:
          do
            if (((b5 | 0) != 0 ? (d2 = ((b5 | 0) / 12 | 0) + (((nd(a3) | 0) != 0) << 31 >> 31) | 0, (d2 | 0) != 0) : 0) ? (b5 = c2[a3 >> 2] | 0, !(Ed(b5, Fd() | 0) | 0)) : 0) {
              switch (d2 | 0) {
                case 1: {
                  a3 = 0;
                  break a;
                }
                case 2: {
                  if (Gd((c2[a3 >> 2] | 0) + 12 | 0, Hd() | 0) | 0) {
                    a3 = 1;
                    break a;
                  }
                  if (Gd((c2[a3 >> 2] | 0) + 12 | 0, Id() | 0) | 0) {
                    a3 = 2;
                    break a;
                  }
                  break;
                }
                case 3: {
                  if (Gd((c2[a3 >> 2] | 0) + 12 | 0, Hd() | 0) | 0 ? (d2 = (c2[a3 >> 2] | 0) + 24 | 0, Gd(d2, Id() | 0) | 0) : 0) {
                    a3 = 3;
                    break a;
                  }
                  break;
                }
                default: {
                }
              }
              a3 = -1;
            } else
              a3 = -1;
          while (0);
        return a3 | 0;
      }
      function md(a3) {
        a3 = a3 | 0;
        xq(a3, 8131);
        c2[a3 >> 2] = 4604;
        return;
      }
      function nd(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        b5 = c2[a3 + 4 >> 2] | 0;
        if (((b5 | 0) != (c2[a3 >> 2] | 0) ? (d2 = b5, (c2[d2 + -12 >> 2] | 0) == 0) : 0) ? (c2[d2 + -4 >> 2] | 0) == 2 : 0)
          a3 = c2[d2 + -8 >> 2] | 0;
        else
          a3 = 0;
        return a3 | 0;
      }
      function od(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0;
        d2 = V;
        V = V + 16 | 0;
        e2 = d2 + 4 | 0;
        g2 = d2;
        f2 = eq(24) | 0;
        Kd(f2, b5);
        c2[g2 >> 2] = 0;
        c2[e2 >> 2] = c2[g2 >> 2];
        Ld(a3, f2, e2);
        V = d2;
        return;
      }
      function pd(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0;
        j2 = V;
        V = V + 32 | 0;
        e2 = j2 + 12 | 0;
        f2 = j2;
        b5 = j2 + 8 | 0;
        h2 = eq(4792) | 0;
        Zd(h2, c2[a3 + 4 >> 2] | 0);
        g2 = a3 + 8 | 0;
        c2[b5 >> 2] = 0;
        c2[e2 >> 2] = c2[b5 >> 2];
        _d(f2, h2, e2);
        h2 = a3 + 12 | 0;
        b5 = c2[h2 >> 2] | 0;
        i2 = a3 + 16 | 0;
        do
          if (b5 >>> 0 >= (c2[i2 >> 2] | 0) >>> 0) {
            b5 = (b5 - (c2[g2 >> 2] | 0) >> 3) + 1 | 0;
            d2 = ee(g2) | 0;
            if (d2 >>> 0 < b5 >>> 0)
              cr(g2);
            else {
              k2 = c2[g2 >> 2] | 0;
              l2 = (c2[i2 >> 2] | 0) - k2 | 0;
              i2 = l2 >> 2;
              be(e2, l2 >> 3 >>> 0 < d2 >>> 1 >>> 0 ? i2 >>> 0 < b5 >>> 0 ? b5 : i2 : d2, (c2[h2 >> 2] | 0) - k2 >> 3, a3 + 16 | 0);
              i2 = e2 + 8 | 0;
              h2 = c2[i2 >> 2] | 0;
              c2[h2 >> 2] = c2[f2 >> 2];
              a3 = f2 + 4 | 0;
              c2[h2 + 4 >> 2] = c2[a3 >> 2];
              c2[f2 >> 2] = 0;
              c2[a3 >> 2] = 0;
              c2[i2 >> 2] = h2 + 8;
              ce(g2, e2);
              de(e2);
              break;
            }
          } else {
            $d(e2, g2, 1);
            l2 = e2 + 4 | 0;
            k2 = c2[l2 >> 2] | 0;
            c2[k2 >> 2] = c2[f2 >> 2];
            i2 = f2 + 4 | 0;
            c2[k2 + 4 >> 2] = c2[i2 >> 2];
            c2[f2 >> 2] = 0;
            c2[i2 >> 2] = 0;
            c2[l2 >> 2] = k2 + 8;
            ae(e2);
          }
        while (0);
        Sd(f2);
        V = j2;
        return;
      }
      function qd(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0;
        j2 = V;
        V = V + 32 | 0;
        e2 = j2 + 12 | 0;
        f2 = j2;
        b5 = j2 + 8 | 0;
        h2 = eq(336) | 0;
        af(h2, c2[a3 + 4 >> 2] | 0);
        g2 = a3 + 8 | 0;
        c2[b5 >> 2] = 0;
        c2[e2 >> 2] = c2[b5 >> 2];
        bf(f2, h2, e2);
        h2 = a3 + 12 | 0;
        b5 = c2[h2 >> 2] | 0;
        i2 = a3 + 16 | 0;
        do
          if (b5 >>> 0 >= (c2[i2 >> 2] | 0) >>> 0) {
            b5 = (b5 - (c2[g2 >> 2] | 0) >> 3) + 1 | 0;
            d2 = ee(g2) | 0;
            if (d2 >>> 0 < b5 >>> 0)
              cr(g2);
            else {
              k2 = c2[g2 >> 2] | 0;
              l2 = (c2[i2 >> 2] | 0) - k2 | 0;
              i2 = l2 >> 2;
              be(e2, l2 >> 3 >>> 0 < d2 >>> 1 >>> 0 ? i2 >>> 0 < b5 >>> 0 ? b5 : i2 : d2, (c2[h2 >> 2] | 0) - k2 >> 3, a3 + 16 | 0);
              i2 = e2 + 8 | 0;
              h2 = c2[i2 >> 2] | 0;
              c2[h2 >> 2] = c2[f2 >> 2];
              a3 = f2 + 4 | 0;
              c2[h2 + 4 >> 2] = c2[a3 >> 2];
              c2[f2 >> 2] = 0;
              c2[a3 >> 2] = 0;
              c2[i2 >> 2] = h2 + 8;
              ce(g2, e2);
              de(e2);
              break;
            }
          } else {
            $d(e2, g2, 1);
            l2 = e2 + 4 | 0;
            k2 = c2[l2 >> 2] | 0;
            c2[k2 >> 2] = c2[f2 >> 2];
            i2 = f2 + 4 | 0;
            c2[k2 + 4 >> 2] = c2[i2 >> 2];
            c2[f2 >> 2] = 0;
            c2[i2 >> 2] = 0;
            c2[l2 >> 2] = k2 + 8;
            ae(e2);
          }
        while (0);
        Sd(f2);
        V = j2;
        return;
      }
      function rd(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0;
        j2 = V;
        V = V + 32 | 0;
        e2 = j2 + 12 | 0;
        f2 = j2;
        b5 = j2 + 8 | 0;
        h2 = eq(324) | 0;
        Af(h2, c2[a3 + 4 >> 2] | 0);
        g2 = a3 + 8 | 0;
        c2[b5 >> 2] = 0;
        c2[e2 >> 2] = c2[b5 >> 2];
        Bf(f2, h2, e2);
        h2 = a3 + 12 | 0;
        b5 = c2[h2 >> 2] | 0;
        i2 = a3 + 16 | 0;
        do
          if (b5 >>> 0 >= (c2[i2 >> 2] | 0) >>> 0) {
            b5 = (b5 - (c2[g2 >> 2] | 0) >> 3) + 1 | 0;
            d2 = ee(g2) | 0;
            if (d2 >>> 0 < b5 >>> 0)
              cr(g2);
            else {
              k2 = c2[g2 >> 2] | 0;
              l2 = (c2[i2 >> 2] | 0) - k2 | 0;
              i2 = l2 >> 2;
              be(e2, l2 >> 3 >>> 0 < d2 >>> 1 >>> 0 ? i2 >>> 0 < b5 >>> 0 ? b5 : i2 : d2, (c2[h2 >> 2] | 0) - k2 >> 3, a3 + 16 | 0);
              i2 = e2 + 8 | 0;
              h2 = c2[i2 >> 2] | 0;
              c2[h2 >> 2] = c2[f2 >> 2];
              a3 = f2 + 4 | 0;
              c2[h2 + 4 >> 2] = c2[a3 >> 2];
              c2[f2 >> 2] = 0;
              c2[a3 >> 2] = 0;
              c2[i2 >> 2] = h2 + 8;
              ce(g2, e2);
              de(e2);
              break;
            }
          } else {
            $d(e2, g2, 1);
            l2 = e2 + 4 | 0;
            k2 = c2[l2 >> 2] | 0;
            c2[k2 >> 2] = c2[f2 >> 2];
            i2 = f2 + 4 | 0;
            c2[k2 + 4 >> 2] = c2[i2 >> 2];
            c2[f2 >> 2] = 0;
            c2[i2 >> 2] = 0;
            c2[l2 >> 2] = k2 + 8;
            ae(e2);
          }
        while (0);
        Sd(f2);
        V = j2;
        return;
      }
      function sd(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0;
        j2 = V;
        V = V + 32 | 0;
        h2 = j2 + 12 | 0;
        i2 = j2;
        e2 = j2 + 8 | 0;
        g2 = eq(64) | 0;
        Qf(g2, c2[a3 + 4 >> 2] | 0, b5);
        f2 = a3 + 8 | 0;
        c2[e2 >> 2] = 0;
        c2[h2 >> 2] = c2[e2 >> 2];
        Rf(i2, g2, h2);
        g2 = a3 + 12 | 0;
        b5 = c2[g2 >> 2] | 0;
        e2 = a3 + 16 | 0;
        do
          if (b5 >>> 0 >= (c2[e2 >> 2] | 0) >>> 0) {
            b5 = (b5 - (c2[f2 >> 2] | 0) >> 3) + 1 | 0;
            d2 = ee(f2) | 0;
            if (d2 >>> 0 < b5 >>> 0)
              cr(f2);
            else {
              k2 = c2[f2 >> 2] | 0;
              l2 = (c2[e2 >> 2] | 0) - k2 | 0;
              e2 = l2 >> 2;
              be(h2, l2 >> 3 >>> 0 < d2 >>> 1 >>> 0 ? e2 >>> 0 < b5 >>> 0 ? b5 : e2 : d2, (c2[g2 >> 2] | 0) - k2 >> 3, a3 + 16 | 0);
              a3 = h2 + 8 | 0;
              g2 = c2[a3 >> 2] | 0;
              c2[g2 >> 2] = c2[i2 >> 2];
              e2 = i2 + 4 | 0;
              c2[g2 + 4 >> 2] = c2[e2 >> 2];
              c2[i2 >> 2] = 0;
              c2[e2 >> 2] = 0;
              c2[a3 >> 2] = g2 + 8;
              ce(f2, h2);
              de(h2);
              break;
            }
          } else {
            $d(h2, f2, 1);
            l2 = h2 + 4 | 0;
            k2 = c2[l2 >> 2] | 0;
            c2[k2 >> 2] = c2[i2 >> 2];
            a3 = i2 + 4 | 0;
            c2[k2 + 4 >> 2] = c2[a3 >> 2];
            c2[i2 >> 2] = 0;
            c2[a3 >> 2] = 0;
            c2[l2 >> 2] = k2 + 8;
            ae(h2);
          }
        while (0);
        Sd(i2);
        V = j2;
        return;
      }
      function td(b5, d2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0;
        e2 = V;
        V = V + 48 | 0;
        f2 = e2;
        c2[b5 >> 2] = d2;
        a2[b5 + 4 >> 0] = 0;
        Jg(b5 + 8 | 0, d2);
        Jg(b5 + 20 | 0, d2);
        Oc(f2, 256, 0, 0);
        Kg(b5 + 32 | 0, d2, f2);
        Ic(f2);
        V = e2;
        return;
      }
      function ud(a3) {
        a3 = a3 | 0;
        Ng(a3 + 32 | 0);
        _f(a3 + 20 | 0);
        _f(a3 + 8 | 0);
        return;
      }
      function vd(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        a3 = c2[a3 + 4 >> 2] | 0;
        if (a3 | 0 ? (d2 = a3 + 4 | 0, b5 = c2[d2 >> 2] | 0, c2[d2 >> 2] = b5 + -1, (b5 | 0) == 0) : 0) {
          ca[c2[(c2[a3 >> 2] | 0) + 8 >> 2] & 255](a3);
          qq(a3);
        }
        return;
      }
      function wd(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0, g2 = 0, h2 = 0;
        e2 = V;
        V = V + 16 | 0;
        f2 = e2 + 4 | 0;
        h2 = e2;
        g2 = eq(12) | 0;
        Og(g2, b5, d2);
        c2[h2 >> 2] = 0;
        c2[f2 >> 2] = c2[h2 >> 2];
        Pg(a3, g2, f2);
        V = e2;
        return;
      }
      function xd(a3) {
        a3 = a3 | 0;
        ge(a3);
        $g(a3 + 4784 | 0);
        return;
      }
      function yd(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0, g2 = 0, h2 = 0;
        e2 = V;
        V = V + 16 | 0;
        f2 = e2 + 4 | 0;
        h2 = e2;
        g2 = eq(12) | 0;
        ah(g2, b5, d2);
        c2[h2 >> 2] = 0;
        c2[f2 >> 2] = c2[h2 >> 2];
        bh(a3, g2, f2);
        V = e2;
        return;
      }
      function zd(a3) {
        a3 = a3 | 0;
        ge(a3);
        nh(a3 + 4784 | 0);
        return;
      }
      function Ad(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0, g2 = 0, h2 = 0;
        e2 = V;
        V = V + 16 | 0;
        f2 = e2 + 4 | 0;
        h2 = e2;
        g2 = eq(12) | 0;
        oh(g2, b5, d2);
        c2[h2 >> 2] = 0;
        c2[f2 >> 2] = c2[h2 >> 2];
        ph(a3, g2, f2);
        V = e2;
        return;
      }
      function Bd(a3) {
        a3 = a3 | 0;
        ge(a3);
        Bh(a3 + 4784 | 0);
        return;
      }
      function Cd(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0, g2 = 0, h2 = 0;
        e2 = V;
        V = V + 16 | 0;
        f2 = e2 + 4 | 0;
        h2 = e2;
        g2 = eq(12) | 0;
        Ch(g2, b5, d2);
        c2[h2 >> 2] = 0;
        c2[f2 >> 2] = c2[h2 >> 2];
        Dh(a3, g2, f2);
        V = e2;
        return;
      }
      function Dd(a3) {
        a3 = a3 | 0;
        ge(a3);
        Ph(a3 + 4784 | 0);
        return;
      }
      function Ed(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return (Gd(a3, b5) | 0) ^ 1 | 0;
      }
      function Fd() {
        if ((a2[21456] | 0) == 0 ? Tp(21456) | 0 : 0) {
          _b(21536, 6, 20, 2);
          $p(21456);
        }
        return 21536;
      }
      function Gd(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        if ((c2[a3 >> 2] | 0) == (c2[b5 >> 2] | 0) ? (c2[a3 + 8 >> 2] | 0) == (c2[b5 + 8 >> 2] | 0) : 0)
          a3 = (c2[a3 + 4 >> 2] | 0) == (c2[b5 + 4 >> 2] | 0);
        else
          a3 = 0;
        return a3 | 0;
      }
      function Hd() {
        if ((a2[21464] | 0) == 0 ? Tp(21464) | 0 : 0) {
          _b(21548, 7, 8, 2);
          $p(21464);
        }
        return 21548;
      }
      function Id() {
        if ((a2[21472] | 0) == 0 ? Tp(21472) | 0 : 0) {
          _b(21560, 8, 6, 2);
          $p(21472);
        }
        return 21560;
      }
      function Jd(a3) {
        a3 = a3 | 0;
        yp(a3);
        jp(a3);
        return;
      }
      function Kd(b5, d2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        Md(b5);
        c2[b5 >> 2] = 4624;
        c2[b5 + 4 >> 2] = d2;
        c2[b5 + 8 >> 2] = 0;
        c2[b5 + 12 >> 2] = 0;
        c2[b5 + 16 >> 2] = 0;
        a2[b5 + 20 >> 0] = 1;
        return;
      }
      function Ld(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0;
        d2 = V;
        V = V + 16 | 0;
        e2 = d2;
        c2[a3 >> 2] = b5;
        f2 = eq(16) | 0;
        c2[f2 + 4 >> 2] = 0;
        c2[f2 + 8 >> 2] = 0;
        c2[f2 >> 2] = 4664;
        c2[f2 + 12 >> 2] = b5;
        c2[a3 + 4 >> 2] = f2;
        c2[e2 >> 2] = b5;
        c2[e2 + 4 >> 2] = b5;
        Ud(a3, e2);
        V = d2;
        return;
      }
      function Md(a3) {
        a3 = a3 | 0;
        c2[a3 >> 2] = 4644;
        return;
      }
      function Nd(b5, d2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0;
        k2 = V;
        V = V + 16 | 0;
        h2 = k2;
        e2 = c2[b5 + 8 >> 2] | 0;
        i2 = c2[b5 + 12 >> 2] | 0;
        if ((e2 | 0) != (i2 | 0)) {
          j2 = h2 + 4 | 0;
          do {
            f2 = c2[e2 >> 2] | 0;
            c2[h2 >> 2] = f2;
            g2 = c2[e2 + 4 >> 2] | 0;
            c2[j2 >> 2] = g2;
            if (g2 | 0) {
              g2 = g2 + 4 | 0;
              c2[g2 >> 2] = (c2[g2 >> 2] | 0) + 1;
            }
            d2 = $[c2[(c2[f2 >> 2] | 0) + 12 >> 2] & 63](f2, d2) | 0;
            Sd(h2);
            e2 = e2 + 8 | 0;
          } while ((e2 | 0) != (i2 | 0));
        }
        e2 = b5 + 20 | 0;
        if (a2[e2 >> 0] | 0) {
          a2[e2 >> 0] = 0;
          nc(c2[b5 + 4 >> 2] | 0);
        }
        V = k2;
        return d2 | 0;
      }
      function Od(a3) {
        a3 = a3 | 0;
        c2[a3 >> 2] = 4624;
        Td(a3 + 8 | 0);
        Qd(a3);
        return;
      }
      function Pd(a3) {
        a3 = a3 | 0;
        Od(a3);
        jp(a3);
        return;
      }
      function Qd(a3) {
        a3 = a3 | 0;
        return;
      }
      function Rd(a3) {
        a3 = a3 | 0;
        U();
      }
      function Sd(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        a3 = c2[a3 + 4 >> 2] | 0;
        if (a3 | 0 ? (d2 = a3 + 4 | 0, b5 = c2[d2 >> 2] | 0, c2[d2 >> 2] = b5 + -1, (b5 | 0) == 0) : 0) {
          ca[c2[(c2[a3 >> 2] | 0) + 8 >> 2] & 255](a3);
          qq(a3);
        }
        return;
      }
      function Td(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0;
        d2 = c2[a3 >> 2] | 0;
        if (d2 | 0) {
          e2 = a3 + 4 | 0;
          b5 = c2[e2 >> 2] | 0;
          if ((b5 | 0) == (d2 | 0))
            b5 = d2;
          else {
            do {
              b5 = b5 + -8 | 0;
              Sd(b5);
            } while ((b5 | 0) != (d2 | 0));
            b5 = c2[a3 >> 2] | 0;
          }
          c2[e2 >> 2] = d2;
          Da(b5, (c2[a3 + 8 >> 2] | 0) - b5 | 0);
        }
        return;
      }
      function Ud(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return;
      }
      function Vd(a3) {
        a3 = a3 | 0;
        pq(a3);
        jp(a3);
        return;
      }
      function Wd(a3) {
        a3 = a3 | 0;
        a3 = c2[a3 + 12 >> 2] | 0;
        if (a3 | 0)
          ca[c2[(c2[a3 >> 2] | 0) + 8 >> 2] & 255](a3);
        return;
      }
      function Xd(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return ((c2[b5 + 4 >> 2] | 0) == 8546 ? a3 + 12 | 0 : 0) | 0;
      }
      function Yd(a3) {
        a3 = a3 | 0;
        Da(a3, 16);
        return;
      }
      function Zd(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        fe(a3);
        c2[a3 >> 2] = 4692;
        c2[a3 + 4 >> 2] = b5;
        ge(a3 + 8 | 0);
        return;
      }
      function _d(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0;
        d2 = V;
        V = V + 16 | 0;
        e2 = d2;
        c2[a3 >> 2] = b5;
        f2 = eq(16) | 0;
        c2[f2 + 4 >> 2] = 0;
        c2[f2 + 8 >> 2] = 0;
        c2[f2 >> 2] = 4740;
        c2[f2 + 12 >> 2] = b5;
        c2[a3 + 4 >> 2] = f2;
        c2[e2 >> 2] = b5;
        c2[e2 + 4 >> 2] = b5;
        Xe(a3, e2);
        V = d2;
        return;
      }
      function $d(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        c2[a3 >> 2] = b5;
        b5 = c2[b5 + 4 >> 2] | 0;
        c2[a3 + 4 >> 2] = b5;
        c2[a3 + 8 >> 2] = b5 + (d2 << 3);
        return;
      }
      function ae(a3) {
        a3 = a3 | 0;
        c2[(c2[a3 >> 2] | 0) + 4 >> 2] = c2[a3 + 4 >> 2];
        return;
      }
      function be(a3, b5, d2, e2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f2 = 0;
        f2 = a3 + 12 | 0;
        c2[f2 >> 2] = 0;
        c2[a3 + 16 >> 2] = e2;
        do
          if (b5)
            if (b5 >>> 0 > 536870911) {
              f2 = v(8) | 0;
              vq(f2, 6723);
              c2[f2 >> 2] = 5956;
              x(f2 | 0, 3928, 123);
            } else {
              e2 = eq(b5 << 3) | 0;
              break;
            }
          else
            e2 = 0;
        while (0);
        c2[a3 >> 2] = e2;
        d2 = e2 + (d2 << 3) | 0;
        c2[a3 + 8 >> 2] = d2;
        c2[a3 + 4 >> 2] = d2;
        c2[f2 >> 2] = e2 + (b5 << 3);
        return;
      }
      function ce(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0;
        i2 = c2[a3 >> 2] | 0;
        j2 = a3 + 4 | 0;
        d2 = c2[j2 >> 2] | 0;
        h2 = b5 + 4 | 0;
        if ((d2 | 0) == (i2 | 0)) {
          f2 = h2;
          g2 = a3;
          e2 = c2[h2 >> 2] | 0;
          d2 = i2;
        } else {
          e2 = c2[h2 >> 2] | 0;
          do {
            g2 = d2;
            d2 = d2 + -8 | 0;
            c2[e2 + -8 >> 2] = c2[d2 >> 2];
            g2 = g2 + -4 | 0;
            c2[e2 + -4 >> 2] = c2[g2 >> 2];
            c2[d2 >> 2] = 0;
            c2[g2 >> 2] = 0;
            e2 = (c2[h2 >> 2] | 0) + -8 | 0;
            c2[h2 >> 2] = e2;
          } while ((d2 | 0) != (i2 | 0));
          f2 = h2;
          g2 = a3;
          d2 = c2[a3 >> 2] | 0;
        }
        c2[g2 >> 2] = e2;
        c2[f2 >> 2] = d2;
        i2 = b5 + 8 | 0;
        h2 = c2[j2 >> 2] | 0;
        c2[j2 >> 2] = c2[i2 >> 2];
        c2[i2 >> 2] = h2;
        i2 = a3 + 8 | 0;
        j2 = b5 + 12 | 0;
        a3 = c2[i2 >> 2] | 0;
        c2[i2 >> 2] = c2[j2 >> 2];
        c2[j2 >> 2] = a3;
        c2[b5 >> 2] = c2[f2 >> 2];
        return;
      }
      function de(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0, f2 = 0;
        d2 = c2[a3 + 4 >> 2] | 0;
        e2 = a3 + 8 | 0;
        b5 = c2[e2 >> 2] | 0;
        if ((b5 | 0) != (d2 | 0))
          do {
            f2 = b5 + -8 | 0;
            c2[e2 >> 2] = f2;
            Sd(f2);
            b5 = c2[e2 >> 2] | 0;
          } while ((b5 | 0) != (d2 | 0));
        b5 = c2[a3 >> 2] | 0;
        if (b5 | 0)
          Da(b5, (c2[a3 + 12 >> 2] | 0) - b5 | 0);
        return;
      }
      function ee(a3) {
        a3 = a3 | 0;
        return 536870911;
      }
      function fe(a3) {
        a3 = a3 | 0;
        c2[a3 >> 2] = 4716;
        return;
      }
      function ge(b5) {
        b5 = b5 | 0;
        oe(b5);
        pe(b5 + 3980 | 0);
        qe(b5 + 4380 | 0);
        a2[b5 + 4780 >> 0] = 0;
        a2[b5 + 4781 >> 0] = 0;
        return;
      }
      function he(a3) {
        a3 = a3 | 0;
        c2[a3 >> 2] = 4692;
        ze(a3 + 8 | 0);
        le(a3);
        return;
      }
      function ie(a3) {
        a3 = a3 | 0;
        he(a3);
        jp(a3);
        return;
      }
      function je(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return b5 | 0;
      }
      function ke(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return Be(a3 + 8 | 0, c2[a3 + 4 >> 2] | 0, b5) | 0;
      }
      function le(a3) {
        a3 = a3 | 0;
        return;
      }
      function me(a3) {
        a3 = a3 | 0;
        le(a3);
        jp(a3);
        return;
      }
      function ne(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return b5 | 0;
      }
      function oe(d2) {
        d2 = d2 | 0;
        var e2 = 0, f2 = 0;
        te(d2);
        ue(d2 + 52 | 0);
        ue(d2 + 436 | 0);
        Oc(d2 + 852 | 0, 64, 0, 0);
        a2[d2 + 3976 >> 0] = 0;
        e2 = d2 + 20 | 0;
        f2 = e2 + 32 | 0;
        do {
          b4[e2 >> 1] = 0;
          e2 = e2 + 2 | 0;
        } while ((e2 | 0) < (f2 | 0));
        e2 = eq(44) | 0;
        Oc(e2, 256, 0, 0);
        c2[d2 + 896 >> 2] = e2;
        e2 = eq(44) | 0;
        Oc(e2, 256, 0, 0);
        c2[d2 + 900 >> 2] = e2;
        e2 = d2 + 820 | 0;
        c2[e2 >> 2] = 0;
        c2[e2 + 4 >> 2] = 0;
        c2[e2 + 8 >> 2] = 0;
        c2[e2 + 12 >> 2] = 0;
        c2[e2 + 16 >> 2] = 0;
        c2[e2 + 20 >> 2] = 0;
        c2[e2 + 24 >> 2] = 0;
        c2[e2 + 28 >> 2] = 0;
        e2 = 0;
        do {
          f2 = eq(44) | 0;
          Oc(f2, 256, 0, 0);
          c2[d2 + 904 + (e2 << 2) >> 2] = f2;
          f2 = eq(44) | 0;
          Oc(f2, 256, 0, 0);
          c2[d2 + 1928 + (e2 << 2) >> 2] = f2;
          f2 = eq(44) | 0;
          Oc(f2, 256, 0, 0);
          c2[d2 + 2952 + (e2 << 2) >> 2] = f2;
          e2 = e2 + 1 | 0;
        } while (e2 >>> 0 < 256);
        return;
      }
      function pe(a3) {
        a3 = a3 | 0;
        xe(a3, 16, 4, 8, 0);
        xe(a3 + 80 | 0, 16, 1, 8, 0);
        xe(a3 + 160 | 0, 32, 2, 8, 0);
        xe(a3 + 240 | 0, 32, 22, 8, 0);
        xe(a3 + 320 | 0, 32, 20, 8, 0);
        return;
      }
      function qe(a3) {
        a3 = a3 | 0;
        mc(a3, 16, 4, 8, 0);
        mc(a3 + 80 | 0, 16, 1, 8, 0);
        mc(a3 + 160 | 0, 32, 2, 8, 0);
        mc(a3 + 240 | 0, 32, 22, 8, 0);
        mc(a3 + 320 | 0, 32, 20, 8, 0);
        return;
      }
      function re(a3) {
        a3 = a3 | 0;
        ye(a3 + 320 | 0);
        ye(a3 + 240 | 0);
        ye(a3 + 160 | 0);
        ye(a3 + 80 | 0);
        ye(a3);
        return;
      }
      function se(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        b5 = c2[a3 + 896 >> 2] | 0;
        if (b5 | 0) {
          Ic(b5);
          jp(b5);
        }
        b5 = c2[a3 + 900 >> 2] | 0;
        if (b5 | 0) {
          Ic(b5);
          jp(b5);
        }
        d2 = 0;
        do {
          b5 = c2[a3 + 904 + (d2 << 2) >> 2] | 0;
          if (b5 | 0) {
            Ic(b5);
            jp(b5);
          }
          b5 = c2[a3 + 1928 + (d2 << 2) >> 2] | 0;
          if (b5 | 0) {
            Ic(b5);
            jp(b5);
          }
          b5 = c2[a3 + 2952 + (d2 << 2) >> 2] | 0;
          if (b5 | 0) {
            Ic(b5);
            jp(b5);
          }
          d2 = d2 + 1 | 0;
        } while ((d2 | 0) != 256);
        Ic(a3 + 852 | 0);
        return;
      }
      function te(b5) {
        b5 = b5 | 0;
        var c3 = 0;
        a2[b5 >> 0] = 0;
        a2[b5 + 1 >> 0] = 0;
        a2[b5 + 2 >> 0] = 0;
        a2[b5 + 3 >> 0] = 0;
        c3 = b5 + 4 | 0;
        a2[c3 >> 0] = 0;
        a2[c3 + 1 >> 0] = 0;
        a2[c3 + 2 >> 0] = 0;
        a2[c3 + 3 >> 0] = 0;
        b5 = b5 + 12 | 0;
        c3 = b5;
        a2[c3 >> 0] = 0;
        a2[c3 + 1 >> 0] = 0;
        a2[c3 + 2 >> 0] = 0;
        a2[c3 + 3 >> 0] = 0;
        b5 = b5 + 4 | 0;
        a2[b5 >> 0] = 0;
        a2[b5 + 1 >> 0] = 0;
        a2[b5 + 2 >> 0] = 0;
        a2[b5 + 3 >> 0] = 0;
        return;
      }
      function ue(a3) {
        a3 = a3 | 0;
        var b5 = 0;
        b5 = a3 + 384 | 0;
        do {
          ve(a3);
          a3 = a3 + 24 | 0;
        } while ((a3 | 0) != (b5 | 0));
        return;
      }
      function ve(a3) {
        a3 = a3 | 0;
        we(a3);
        return;
      }
      function we(b5) {
        b5 = b5 | 0;
        c2[b5 >> 2] = 0;
        c2[b5 + 4 >> 2] = 0;
        c2[b5 + 8 >> 2] = 0;
        c2[b5 + 12 >> 2] = 0;
        c2[b5 + 16 >> 2] = 0;
        a2[b5 + 20 >> 0] = 1;
        return;
      }
      function xe(a3, b5, d2, e2, f2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        f2 = f2 | 0;
        var g2 = 0;
        c2[a3 + 4 >> 2] = b5;
        c2[a3 + 8 >> 2] = d2;
        c2[a3 + 12 >> 2] = e2;
        c2[a3 + 16 >> 2] = f2;
        c2[a3 + 36 >> 2] = 0;
        c2[a3 + 40 >> 2] = 0;
        c2[a3 + 44 >> 2] = 0;
        Gc(a3 + 48 | 0);
        c2[a3 + 68 >> 2] = 0;
        c2[a3 + 72 >> 2] = 0;
        c2[a3 + 76 >> 2] = 0;
        do
          if (!f2) {
            d2 = a3 + 20 | 0;
            if ((b5 + -1 | 0) >>> 0 < 31) {
              c2[d2 >> 2] = b5;
              f2 = 1 << b5;
              c2[a3 + 24 >> 2] = f2;
              d2 = f2 >>> 1;
              c2[a3 + 28 >> 2] = 0 - d2;
              d2 = f2 + -1 - d2 | 0;
              break;
            } else {
              c2[d2 >> 2] = 32;
              c2[a3 + 24 >> 2] = 0;
              c2[a3 + 28 >> 2] = -2147483648;
              d2 = 2147483647;
              break;
            }
          } else {
            e2 = a3 + 20 | 0;
            c2[e2 >> 2] = 0;
            c2[a3 + 24 >> 2] = f2;
            d2 = f2;
            g2 = 0;
            while (1) {
              d2 = d2 >>> 1;
              b5 = g2 + 1 | 0;
              if (!d2)
                break;
              else
                g2 = b5;
            }
            c2[e2 >> 2] = (1 << g2 | 0) == (f2 | 0) ? g2 : b5;
            d2 = f2 >>> 1;
            c2[a3 + 28 >> 2] = 0 - d2;
            d2 = f2 + -1 - d2 | 0;
          }
        while (0);
        c2[a3 + 32 >> 2] = d2;
        c2[a3 >> 2] = 0;
        return;
      }
      function ye(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0, f2 = 0, g2 = 0;
        g2 = a3 + 36 | 0;
        d2 = c2[g2 >> 2] | 0;
        e2 = a3 + 40 | 0;
        b5 = c2[e2 >> 2] | 0;
        if ((b5 | 0) != (d2 | 0))
          do {
            b5 = b5 + -44 | 0;
            Ic(b5);
          } while ((b5 | 0) != (d2 | 0));
        c2[e2 >> 2] = d2;
        e2 = a3 + 68 | 0;
        f2 = c2[e2 >> 2] | 0;
        d2 = a3 + 72 | 0;
        b5 = c2[d2 >> 2] | 0;
        if ((b5 | 0) != (f2 | 0))
          do {
            b5 = b5 + -44 | 0;
            Ic(b5);
          } while ((b5 | 0) != (f2 | 0));
        c2[d2 >> 2] = f2;
        Hc(e2);
        Hc(g2);
        return;
      }
      function ze(a3) {
        a3 = a3 | 0;
        Ae(a3 + 4380 | 0);
        re(a3 + 3980 | 0);
        se(a3);
        return;
      }
      function Ae(a3) {
        a3 = a3 | 0;
        qc(a3 + 320 | 0);
        qc(a3 + 240 | 0);
        qc(a3 + 160 | 0);
        qc(a3 + 80 | 0);
        qc(a3);
        return;
      }
      function Be(f2, g2, h2) {
        f2 = f2 | 0;
        g2 = g2 | 0;
        h2 = h2 | 0;
        var i2 = 0, j2 = 0, k2 = 0, l2 = 0, m2 = 0, n2 = 0, o2 = 0, p2 = 0, q2 = 0;
        p2 = V;
        V = V + 32 | 0;
        o2 = p2;
        i2 = f2 + 4781 | 0;
        if (!(a2[i2 >> 0] | 0)) {
          Ce(f2 + 4380 | 0);
          a2[i2 >> 0] = 1;
        }
        i2 = f2 + 3976 | 0;
        if (!(a2[i2 >> 0] | 0)) {
          a2[i2 >> 0] = 1;
          Ee(De(g2) | 0, h2, 20);
          Fe(o2, h2);
          k2 = f2;
          i2 = o2;
          j2 = k2 + 20 | 0;
          do {
            a2[k2 >> 0] = a2[i2 >> 0] | 0;
            k2 = k2 + 1 | 0;
            i2 = i2 + 1 | 0;
          } while ((k2 | 0) < (j2 | 0));
          b4[f2 + 12 >> 1] = 0;
        } else {
          m2 = Zc(g2, f2 + 852 | 0) | 0;
          if (m2) {
            if (m2 & 32 | 0)
              He((Zc(g2, c2[f2 + 904 + (((Ge(f2) | 0) & 255) << 2) >> 2] | 0) | 0) & 255, f2);
            n2 = f2 + 14 | 0;
            k2 = a2[n2 >> 0] | 0;
            i2 = k2 & 7;
            k2 = (k2 & 255) >>> 3 & 7;
            j2 = d[16 + (k2 << 3) + i2 >> 0] | 0;
            i2 = d[80 + (k2 << 3) + i2 >> 0] | 0;
            if (!(m2 & 16))
              l2 = b4[f2 + 20 + (j2 << 1) >> 1] | 0;
            else {
              q2 = f2 + 20 + (j2 << 1) | 0;
              l2 = (pc(f2 + 4380 | 0, g2, e[q2 >> 1] | 0, j2 >>> 0 < 3 ? j2 : 3) | 0) & 65535;
              b4[q2 >> 1] = l2;
            }
            b4[f2 + 12 >> 1] = l2;
            if (m2 & 8 | 0) {
              q2 = f2 + 15 | 0;
              a2[q2 >> 0] = Zc(g2, c2[f2 + 1928 + (d[q2 >> 0] << 2) >> 2] | 0) | 0;
            }
            if (m2 & 4 | 0) {
              n2 = Zc(g2, c2[f2 + 896 + (((d[n2 >> 0] | 0) >>> 6 & 1) << 2) >> 2] | 0) | 0;
              q2 = f2 + 16 | 0;
              a2[q2 >> 0] = Ie(n2 + (a2[q2 >> 0] | 0) | 0) | 0;
            }
            if (m2 & 2 | 0) {
              q2 = f2 + 17 | 0;
              a2[q2 >> 0] = Zc(g2, c2[f2 + 2952 + (d[q2 >> 0] << 2) >> 2] | 0) | 0;
            }
            if (m2 & 1) {
              q2 = f2 + 18 | 0;
              b4[q2 >> 1] = pc(f2 + 4460 | 0, g2, e[q2 >> 1] | 0, 0) | 0;
            }
          } else {
            q2 = a2[f2 + 14 >> 0] | 0;
            i2 = q2 & 7;
            q2 = (q2 & 255) >>> 3 & 7;
            k2 = q2;
            j2 = d[16 + (q2 << 3) + i2 >> 0] | 0;
            i2 = d[80 + (q2 << 3) + i2 >> 0] | 0;
          }
          l2 = f2 + 52 + (j2 * 24 | 0) | 0;
          m2 = f2 + 4540 | 0;
          n2 = (k2 | 0) == 1 & 1;
          k2 = pc(m2, g2, Je(l2) | 0, n2) | 0;
          c2[o2 >> 2] = k2;
          c2[f2 >> 2] = (c2[f2 >> 2] | 0) + k2;
          Ke(l2, o2);
          l2 = f2 + 436 + (j2 * 24 | 0) | 0;
          k2 = Je(l2) | 0;
          j2 = Le(m2) | 0;
          q2 = f2 + 4620 | 0;
          j2 = pc(q2, g2, k2, (j2 >>> 0 < 20 ? j2 & -2 : 20) | n2) | 0;
          c2[o2 >> 2] = j2;
          k2 = f2 + 4 | 0;
          c2[k2 >> 2] = (c2[k2 >> 2] | 0) + j2;
          Ke(l2, o2);
          o2 = Le(m2) | 0;
          o2 = (Le(q2) | 0) + o2 | 0;
          q2 = f2 + 820 + (i2 << 2) | 0;
          o2 = pc(f2 + 4700 | 0, g2, c2[q2 >> 2] | 0, (o2 >>> 0 < 36 ? o2 >>> 1 & 2147483646 : 18) | n2) | 0;
          c2[f2 + 8 >> 2] = o2;
          c2[q2 >> 2] = o2;
          Me(f2, h2);
        }
        V = p2;
        return h2 + 20 | 0;
      }
      function Ce(a3) {
        a3 = a3 | 0;
        oc(a3);
        oc(a3 + 80 | 0);
        oc(a3 + 160 | 0);
        oc(a3 + 240 | 0);
        oc(a3 + 320 | 0);
        return;
      }
      function De(a3) {
        a3 = a3 | 0;
        return c2[a3 >> 2] | 0;
      }
      function Ee(b5, d2, e2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0;
        k2 = b5 + 4 | 0;
        f2 = c2[k2 >> 2] | 0;
        j2 = (c2[b5 + 8 >> 2] | 0) - f2 | 0;
        j2 = j2 >>> 0 > e2 >>> 0 ? e2 : j2;
        i2 = b5 + 12 | 0;
        g2 = (c2[i2 >> 2] | 0) + f2 | 0;
        h2 = g2 + j2 | 0;
        if (j2) {
          f2 = g2;
          g2 = d2;
          while (1) {
            a2[g2 >> 0] = a2[f2 >> 0] | 0;
            f2 = f2 + 1 | 0;
            if ((f2 | 0) == (h2 | 0))
              break;
            else
              g2 = g2 + 1 | 0;
          }
          f2 = c2[k2 >> 2] | 0;
        }
        c2[k2 >> 2] = f2 + j2;
        e2 = e2 - j2 | 0;
        if (e2 | 0) {
          Kc(b5);
          g2 = (c2[i2 >> 2] | 0) + (c2[k2 >> 2] | 0) | 0;
          h2 = g2 + e2 | 0;
          f2 = d2 + j2 | 0;
          while (1) {
            a2[f2 >> 0] = a2[g2 >> 0] | 0;
            g2 = g2 + 1 | 0;
            if ((g2 | 0) == (h2 | 0))
              break;
            else
              f2 = f2 + 1 | 0;
          }
          c2[k2 >> 2] = (c2[k2 >> 2] | 0) + e2;
        }
        return;
      }
      function Fe(d2, e2) {
        d2 = d2 | 0;
        e2 = e2 | 0;
        te(d2);
        c2[d2 >> 2] = Ne(e2) | 0;
        c2[d2 + 4 >> 2] = Ne(e2 + 4 | 0) | 0;
        c2[d2 + 8 >> 2] = Ne(e2 + 8 | 0) | 0;
        b4[d2 + 12 >> 1] = Oe(e2 + 12 | 0) | 0;
        He(Pe(e2 + 14 | 0) | 0, d2);
        a2[d2 + 15 >> 0] = Pe(e2 + 15 | 0) | 0;
        a2[d2 + 16 >> 0] = Qe(e2 + 16 | 0) | 0;
        a2[d2 + 17 >> 0] = Qe(e2 + 17 | 0) | 0;
        b4[d2 + 18 >> 1] = Oe(e2 + 18 | 0) | 0;
        return;
      }
      function Ge(b5) {
        b5 = b5 | 0;
        return a2[b5 + 14 >> 0] | 0;
      }
      function He(b5, c3) {
        b5 = b5 | 0;
        c3 = c3 | 0;
        a2[c3 + 14 >> 0] = b5;
        return;
      }
      function Ie(a3) {
        a3 = a3 | 0;
        return a3 & 255 | 0;
      }
      function Je(a3) {
        a3 = a3 | 0;
        return c2[a3 + 8 >> 2] | 0;
      }
      function Ke(b5, d2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0;
        k2 = b5 + 20 | 0;
        do
          if (!(a2[k2 >> 0] | 0)) {
            j2 = b5 + 8 | 0;
            e2 = c2[j2 >> 2] | 0;
            f2 = c2[d2 >> 2] | 0;
            g2 = b5 + 4 | 0;
            h2 = c2[g2 >> 2] | 0;
            if ((e2 | 0) >= (f2 | 0)) {
              if ((h2 | 0) < (f2 | 0)) {
                c2[b5 >> 2] = h2;
                c2[g2 >> 2] = c2[d2 >> 2];
              } else
                c2[b5 >> 2] = f2;
              a2[k2 >> 0] = 1;
              break;
            }
            c2[b5 >> 2] = h2;
            c2[g2 >> 2] = e2;
            g2 = b5 + 16 | 0;
            h2 = c2[g2 >> 2] | 0;
            i2 = c2[d2 >> 2] | 0;
            e2 = b5 + 12 | 0;
            f2 = c2[e2 >> 2] | 0;
            if ((h2 | 0) < (i2 | 0)) {
              c2[j2 >> 2] = f2;
              c2[e2 >> 2] = h2;
              c2[g2 >> 2] = c2[d2 >> 2];
              break;
            }
            if ((f2 | 0) < (i2 | 0)) {
              c2[j2 >> 2] = f2;
              c2[e2 >> 2] = c2[d2 >> 2];
              break;
            } else {
              c2[j2 >> 2] = i2;
              break;
            }
          } else {
            g2 = c2[d2 >> 2] | 0;
            i2 = b5 + 8 | 0;
            e2 = c2[i2 >> 2] | 0;
            h2 = b5 + 12 | 0;
            f2 = c2[h2 >> 2] | 0;
            if ((g2 | 0) >= (e2 | 0)) {
              e2 = b5 + 16 | 0;
              if ((g2 | 0) < (f2 | 0)) {
                c2[e2 >> 2] = f2;
                c2[h2 >> 2] = c2[d2 >> 2];
              } else
                c2[e2 >> 2] = g2;
              a2[k2 >> 0] = 0;
              break;
            }
            c2[b5 + 16 >> 2] = f2;
            c2[h2 >> 2] = e2;
            e2 = c2[d2 >> 2] | 0;
            f2 = c2[b5 >> 2] | 0;
            g2 = b5 + 4 | 0;
            h2 = c2[g2 >> 2] | 0;
            if ((e2 | 0) < (f2 | 0)) {
              c2[i2 >> 2] = h2;
              c2[g2 >> 2] = f2;
              c2[b5 >> 2] = c2[d2 >> 2];
              break;
            }
            if ((e2 | 0) < (h2 | 0)) {
              c2[i2 >> 2] = h2;
              c2[g2 >> 2] = c2[d2 >> 2];
              break;
            } else {
              c2[i2 >> 2] = e2;
              break;
            }
          }
        while (0);
        return;
      }
      function Le(a3) {
        a3 = a3 | 0;
        return c2[a3 >> 2] | 0;
      }
      function Me(b5, c3) {
        b5 = b5 | 0;
        c3 = c3 | 0;
        var e2 = 0;
        Se(d[b5 >> 0] | d[b5 + 1 >> 0] << 8 | d[b5 + 2 >> 0] << 16 | d[b5 + 3 >> 0] << 24, c3);
        e2 = b5 + 4 | 0;
        Se(d[e2 >> 0] | d[e2 + 1 >> 0] << 8 | d[e2 + 2 >> 0] << 16 | d[e2 + 3 >> 0] << 24, c3 + 4 | 0);
        e2 = b5 + 8 | 0;
        Se(d[e2 >> 0] | d[e2 + 1 >> 0] << 8 | d[e2 + 2 >> 0] << 16 | d[e2 + 3 >> 0] << 24, c3 + 8 | 0);
        e2 = b5 + 12 | 0;
        Te(d[e2 >> 0] | d[e2 + 1 >> 0] << 8, c3 + 12 | 0);
        Ue(Ge(b5) | 0, c3 + 14 | 0);
        Ue(a2[b5 + 15 >> 0] | 0, c3 + 15 | 0);
        Ve(a2[b5 + 16 >> 0] | 0, c3 + 16 | 0);
        Ve(a2[b5 + 17 >> 0] | 0, c3 + 17 | 0);
        b5 = b5 + 18 | 0;
        Te(d[b5 >> 0] | d[b5 + 1 >> 0] << 8, c3 + 18 | 0);
        return;
      }
      function Ne(a3) {
        a3 = a3 | 0;
        return Re(a3) | 0;
      }
      function Oe(b5) {
        b5 = b5 | 0;
        return (a2[b5 + 1 >> 0] << 8 | d[b5 >> 0]) & 65535 | 0;
      }
      function Pe(b5) {
        b5 = b5 | 0;
        return a2[b5 >> 0] | 0;
      }
      function Qe(b5) {
        b5 = b5 | 0;
        return a2[b5 >> 0] | 0;
      }
      function Re(a3) {
        a3 = a3 | 0;
        return (d[a3 + 1 >> 0] | 0) << 8 | (d[a3 >> 0] | 0) | (d[a3 + 2 >> 0] | 0) << 16 | (d[a3 + 3 >> 0] | 0) << 24 | 0;
      }
      function Se(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        We(a3, b5);
        return;
      }
      function Te(b5, c3) {
        b5 = b5 | 0;
        c3 = c3 | 0;
        a2[c3 + 1 >> 0] = (b5 & 65535) >>> 8;
        a2[c3 >> 0] = b5;
        return;
      }
      function Ue(b5, c3) {
        b5 = b5 | 0;
        c3 = c3 | 0;
        a2[c3 >> 0] = b5;
        return;
      }
      function Ve(b5, c3) {
        b5 = b5 | 0;
        c3 = c3 | 0;
        a2[c3 >> 0] = b5;
        return;
      }
      function We(b5, c3) {
        b5 = b5 | 0;
        c3 = c3 | 0;
        a2[c3 + 3 >> 0] = b5 >>> 24;
        a2[c3 + 2 >> 0] = b5 >>> 16;
        a2[c3 + 1 >> 0] = b5 >>> 8;
        a2[c3 >> 0] = b5;
        return;
      }
      function Xe(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return;
      }
      function Ye(a3) {
        a3 = a3 | 0;
        pq(a3);
        jp(a3);
        return;
      }
      function Ze(a3) {
        a3 = a3 | 0;
        a3 = c2[a3 + 12 >> 2] | 0;
        if (a3 | 0)
          ca[c2[(c2[a3 >> 2] | 0) + 4 >> 2] & 255](a3);
        return;
      }
      function _e(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return ((c2[b5 + 4 >> 2] | 0) == 9202 ? a3 + 12 | 0 : 0) | 0;
      }
      function $e(a3) {
        a3 = a3 | 0;
        Da(a3, 16);
        return;
      }
      function af(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        fe(a3);
        c2[a3 >> 2] = 4768;
        c2[a3 + 4 >> 2] = b5;
        cf(a3 + 8 | 0);
        return;
      }
      function bf(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0;
        d2 = V;
        V = V + 16 | 0;
        e2 = d2;
        c2[a3 >> 2] = b5;
        f2 = eq(16) | 0;
        c2[f2 + 4 >> 2] = 0;
        c2[f2 + 8 >> 2] = 0;
        c2[f2 >> 2] = 4792;
        c2[f2 + 12 >> 2] = b5;
        c2[a3 + 4 >> 2] = f2;
        c2[e2 >> 2] = b5;
        c2[e2 + 4 >> 2] = b5;
        Xe(a3, e2);
        V = d2;
        return;
      }
      function cf(b5) {
        b5 = b5 | 0;
        gf(b5);
        hf(b5 + 164 | 0);
        jf(b5 + 244 | 0);
        a2[b5 + 324 >> 0] = 0;
        a2[b5 + 325 >> 0] = 0;
        return;
      }
      function df(a3) {
        a3 = a3 | 0;
        c2[a3 >> 2] = 4768;
        of(a3 + 8 | 0);
        le(a3);
        return;
      }
      function ef(a3) {
        a3 = a3 | 0;
        df(a3);
        jp(a3);
        return;
      }
      function ff(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return qf(a3 + 8 | 0, c2[a3 + 4 >> 2] | 0, b5) | 0;
      }
      function gf(b5) {
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0;
        h2 = V;
        V = V + 16 | 0;
        f2 = h2;
        a2[b5 >> 0] = 0;
        Oc(b5 + 4 | 0, 516, 0, 0);
        Oc(b5 + 48 | 0, 6, 0, 0);
        c2[b5 + 92 >> 2] = 0;
        c2[b5 + 96 >> 2] = 0;
        e2 = b5 + 100 | 0;
        mf(e2);
        nf(f2);
        g2 = c2[f2 >> 2] | 0;
        f2 = c2[f2 + 4 >> 2] | 0;
        d2 = 4;
        while (1) {
          i2 = e2;
          j2 = i2;
          a2[j2 >> 0] = g2;
          a2[j2 + 1 >> 0] = g2 >> 8;
          a2[j2 + 2 >> 0] = g2 >> 16;
          a2[j2 + 3 >> 0] = g2 >> 24;
          i2 = i2 + 4 | 0;
          a2[i2 >> 0] = f2;
          a2[i2 + 1 >> 0] = f2 >> 8;
          a2[i2 + 2 >> 0] = f2 >> 16;
          a2[i2 + 3 >> 0] = f2 >> 24;
          d2 = d2 + -1 | 0;
          if (!d2)
            break;
          else
            e2 = e2 + 8 | 0;
        }
        j2 = b5 + 132 | 0;
        c2[j2 >> 2] = 0;
        c2[j2 + 4 >> 2] = 0;
        c2[j2 + 8 >> 2] = 0;
        c2[j2 + 12 >> 2] = 0;
        c2[j2 + 16 >> 2] = 0;
        c2[j2 + 20 >> 2] = 0;
        c2[j2 + 24 >> 2] = 0;
        c2[j2 + 28 >> 2] = 0;
        V = h2;
        return;
      }
      function hf(a3) {
        a3 = a3 | 0;
        xe(a3, 32, 9, 8, 0);
        return;
      }
      function jf(a3) {
        a3 = a3 | 0;
        mc(a3, 32, 9, 8, 0);
        return;
      }
      function kf(a3) {
        a3 = a3 | 0;
        ye(a3);
        return;
      }
      function lf(a3) {
        a3 = a3 | 0;
        Ic(a3 + 48 | 0);
        Ic(a3 + 4 | 0);
        return;
      }
      function mf(a3) {
        a3 = a3 | 0;
        var b5 = 0;
        b5 = a3 + 32 | 0;
        do {
          nf(a3);
          a3 = a3 + 8 | 0;
        } while ((a3 | 0) != (b5 | 0));
        return;
      }
      function nf(b5) {
        b5 = b5 | 0;
        var c3 = 0;
        c3 = b5;
        a2[c3 >> 0] = 0;
        a2[c3 + 1 >> 0] = 0;
        a2[c3 + 2 >> 0] = 0;
        a2[c3 + 3 >> 0] = 0;
        b5 = b5 + 4 | 0;
        a2[b5 >> 0] = 0;
        a2[b5 + 1 >> 0] = 0;
        a2[b5 + 2 >> 0] = 0;
        a2[b5 + 3 >> 0] = 0;
        return;
      }
      function of(a3) {
        a3 = a3 | 0;
        pf(a3 + 244 | 0);
        kf(a3 + 164 | 0);
        lf(a3);
        return;
      }
      function pf(a3) {
        a3 = a3 | 0;
        qc(a3);
        return;
      }
      function qf(b5, e2, f2) {
        b5 = b5 | 0;
        e2 = e2 | 0;
        f2 = f2 | 0;
        var g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0;
        g2 = b5 + 325 | 0;
        if (!(a2[g2 >> 0] | 0)) {
          rf(b5 + 244 | 0);
          a2[g2 >> 0] = 1;
        }
        if (!(a2[b5 >> 0] | 0)) {
          a2[b5 >> 0] = 1;
          Ee(De(e2) | 0, f2, 8);
          i2 = sf(f2) | 0;
          j2 = u() | 0;
          b5 = b5 + 100 | 0;
          e2 = b5;
          a2[e2 >> 0] = i2;
          a2[e2 + 1 >> 0] = i2 >> 8;
          a2[e2 + 2 >> 0] = i2 >> 16;
          a2[e2 + 3 >> 0] = i2 >> 24;
          b5 = b5 + 4 | 0;
          a2[b5 >> 0] = j2;
          a2[b5 + 1 >> 0] = j2 >> 8;
          a2[b5 + 2 >> 0] = j2 >> 16;
          a2[b5 + 3 >> 0] = j2 >> 24;
        } else {
          j2 = b5 + 92 | 0;
          a:
            do
              if (!(c2[b5 + 132 + (c2[j2 >> 2] << 2) >> 2] | 0)) {
                g2 = Zc(e2, b5 + 48 | 0) | 0;
                switch (g2 | 0) {
                  case 1: {
                    e2 = pc(b5 + 244 | 0, e2, 0, 0) | 0;
                    c2[b5 + 132 + (c2[j2 >> 2] << 2) >> 2] = e2;
                    e2 = c2[j2 >> 2] | 0;
                    k2 = c2[b5 + 132 + (e2 << 2) >> 2] | 0;
                    i2 = b5 + 100 + (e2 << 3) | 0;
                    h2 = i2;
                    g2 = h2;
                    h2 = h2 + 4 | 0;
                    k2 = lr(d[g2 >> 0] | d[g2 + 1 >> 0] << 8 | d[g2 + 2 >> 0] << 16 | d[g2 + 3 >> 0] << 24 | 0, d[h2 >> 0] | d[h2 + 1 >> 0] << 8 | d[h2 + 2 >> 0] << 16 | d[h2 + 3 >> 0] << 24 | 0, k2 | 0, ((k2 | 0) < 0) << 31 >> 31 | 0) | 0;
                    h2 = u() | 0;
                    g2 = i2;
                    a2[g2 >> 0] = k2;
                    a2[g2 + 1 >> 0] = k2 >> 8;
                    a2[g2 + 2 >> 0] = k2 >> 16;
                    a2[g2 + 3 >> 0] = k2 >> 24;
                    i2 = i2 + 4 | 0;
                    a2[i2 >> 0] = h2;
                    a2[i2 + 1 >> 0] = h2 >> 8;
                    a2[i2 + 2 >> 0] = h2 >> 16;
                    a2[i2 + 3 >> 0] = h2 >> 24;
                    c2[b5 + 148 + (e2 << 2) >> 2] = 0;
                    break a;
                  }
                  case 2: {
                    k2 = b5 + 96 | 0;
                    c2[k2 >> 2] = (c2[k2 >> 2] | 0) + 1 & 3;
                    i2 = b5 + 100 + (c2[j2 >> 2] << 3) + 4 | 0;
                    i2 = pc(b5 + 244 | 0, e2, d[i2 >> 0] | d[i2 + 1 >> 0] << 8 | d[i2 + 2 >> 0] << 16 | d[i2 + 3 >> 0] << 24, 8) | 0;
                    g2 = b5 + 100 + (c2[k2 >> 2] << 3) | 0;
                    h2 = g2;
                    a2[h2 >> 0] = 0;
                    a2[h2 + 1 >> 0] = 0;
                    a2[h2 + 2 >> 0] = 0;
                    a2[h2 + 3 >> 0] = 0;
                    g2 = g2 + 4 | 0;
                    a2[g2 >> 0] = i2;
                    a2[g2 + 1 >> 0] = i2 >> 8;
                    a2[g2 + 2 >> 0] = i2 >> 16;
                    a2[g2 + 3 >> 0] = i2 >> 24;
                    g2 = tf(e2) | 0;
                    k2 = c2[k2 >> 2] | 0;
                    e2 = b5 + 100 + (k2 << 3) | 0;
                    i2 = e2;
                    h2 = i2;
                    i2 = i2 + 4 | 0;
                    i2 = d[i2 >> 0] | d[i2 + 1 >> 0] << 8 | d[i2 + 2 >> 0] << 16 | d[i2 + 3 >> 0] << 24;
                    g2 = d[h2 >> 0] | d[h2 + 1 >> 0] << 8 | d[h2 + 2 >> 0] << 16 | d[h2 + 3 >> 0] << 24 | g2;
                    h2 = e2;
                    a2[h2 >> 0] = g2;
                    a2[h2 + 1 >> 0] = g2 >> 8;
                    a2[h2 + 2 >> 0] = g2 >> 16;
                    a2[h2 + 3 >> 0] = g2 >> 24;
                    e2 = e2 + 4 | 0;
                    a2[e2 >> 0] = i2;
                    a2[e2 + 1 >> 0] = i2 >> 8;
                    a2[e2 + 2 >> 0] = i2 >> 16;
                    a2[e2 + 3 >> 0] = i2 >> 24;
                    c2[j2 >> 2] = k2;
                    c2[b5 + 132 + (k2 << 2) >> 2] = 0;
                    c2[b5 + 148 + (c2[j2 >> 2] << 2) >> 2] = 0;
                    break a;
                  }
                  default: {
                    if ((g2 | 0) <= 2)
                      break a;
                    c2[j2 >> 2] = g2 + 2 + (c2[j2 >> 2] | 0) & 3;
                    qf(b5, e2, f2) | 0;
                    break a;
                  }
                }
              } else {
                i2 = Zc(e2, b5 + 4 | 0) | 0;
                if ((i2 | 0) == 1) {
                  g2 = pc(b5 + 244 | 0, e2, c2[b5 + 132 + (c2[j2 >> 2] << 2) >> 2] | 0, 1) | 0;
                  k2 = c2[j2 >> 2] | 0;
                  e2 = b5 + 100 + (k2 << 3) | 0;
                  i2 = e2;
                  h2 = i2;
                  i2 = i2 + 4 | 0;
                  g2 = lr(d[h2 >> 0] | d[h2 + 1 >> 0] << 8 | d[h2 + 2 >> 0] << 16 | d[h2 + 3 >> 0] << 24 | 0, d[i2 >> 0] | d[i2 + 1 >> 0] << 8 | d[i2 + 2 >> 0] << 16 | d[i2 + 3 >> 0] << 24 | 0, g2 | 0, ((g2 | 0) < 0) << 31 >> 31 | 0) | 0;
                  i2 = u() | 0;
                  h2 = e2;
                  a2[h2 >> 0] = g2;
                  a2[h2 + 1 >> 0] = g2 >> 8;
                  a2[h2 + 2 >> 0] = g2 >> 16;
                  a2[h2 + 3 >> 0] = g2 >> 24;
                  e2 = e2 + 4 | 0;
                  a2[e2 >> 0] = i2;
                  a2[e2 + 1 >> 0] = i2 >> 8;
                  a2[e2 + 2 >> 0] = i2 >> 16;
                  a2[e2 + 3 >> 0] = i2 >> 24;
                  c2[b5 + 148 + (k2 << 2) >> 2] = 0;
                  break;
                }
                if ((i2 | 0) >= 511) {
                  if ((i2 | 0) == 512) {
                    k2 = b5 + 96 | 0;
                    c2[k2 >> 2] = (c2[k2 >> 2] | 0) + 1 & 3;
                    i2 = b5 + 100 + (c2[j2 >> 2] << 3) + 4 | 0;
                    i2 = pc(b5 + 244 | 0, e2, d[i2 >> 0] | d[i2 + 1 >> 0] << 8 | d[i2 + 2 >> 0] << 16 | d[i2 + 3 >> 0] << 24, 8) | 0;
                    g2 = b5 + 100 + (c2[k2 >> 2] << 3) | 0;
                    h2 = g2;
                    a2[h2 >> 0] = 0;
                    a2[h2 + 1 >> 0] = 0;
                    a2[h2 + 2 >> 0] = 0;
                    a2[h2 + 3 >> 0] = 0;
                    g2 = g2 + 4 | 0;
                    a2[g2 >> 0] = i2;
                    a2[g2 + 1 >> 0] = i2 >> 8;
                    a2[g2 + 2 >> 0] = i2 >> 16;
                    a2[g2 + 3 >> 0] = i2 >> 24;
                    g2 = tf(e2) | 0;
                    k2 = c2[k2 >> 2] | 0;
                    e2 = b5 + 100 + (k2 << 3) | 0;
                    i2 = e2;
                    h2 = i2;
                    i2 = i2 + 4 | 0;
                    i2 = d[i2 >> 0] | d[i2 + 1 >> 0] << 8 | d[i2 + 2 >> 0] << 16 | d[i2 + 3 >> 0] << 24;
                    g2 = d[h2 >> 0] | d[h2 + 1 >> 0] << 8 | d[h2 + 2 >> 0] << 16 | d[h2 + 3 >> 0] << 24 | g2;
                    h2 = e2;
                    a2[h2 >> 0] = g2;
                    a2[h2 + 1 >> 0] = g2 >> 8;
                    a2[h2 + 2 >> 0] = g2 >> 16;
                    a2[h2 + 3 >> 0] = g2 >> 24;
                    e2 = e2 + 4 | 0;
                    a2[e2 >> 0] = i2;
                    a2[e2 + 1 >> 0] = i2 >> 8;
                    a2[e2 + 2 >> 0] = i2 >> 16;
                    a2[e2 + 3 >> 0] = i2 >> 24;
                    c2[j2 >> 2] = k2;
                    c2[b5 + 132 + (k2 << 2) >> 2] = 0;
                    c2[b5 + 148 + (c2[j2 >> 2] << 2) >> 2] = 0;
                    break;
                  }
                  if ((i2 | 0) <= 511)
                    break;
                  c2[j2 >> 2] = (c2[j2 >> 2] | 0) + i2 & 3;
                  qf(b5, e2, f2) | 0;
                  break;
                }
                do
                  if (!i2) {
                    g2 = pc(b5 + 244 | 0, e2, 0, 7) | 0;
                    h2 = b5 + 148 + (c2[j2 >> 2] << 2) | 0;
                    c2[h2 >> 2] = (c2[h2 >> 2] | 0) + 1;
                    h2 = c2[j2 >> 2] | 0;
                    if ((c2[b5 + 148 + (h2 << 2) >> 2] | 0) > 3) {
                      c2[b5 + 132 + (h2 << 2) >> 2] = g2;
                      c2[b5 + 148 + (c2[j2 >> 2] << 2) >> 2] = 0;
                    }
                  } else {
                    if ((i2 | 0) < 500) {
                      g2 = b5 + 244 | 0;
                      h2 = q(c2[b5 + 132 + (c2[j2 >> 2] << 2) >> 2] | 0, i2) | 0;
                      if ((i2 | 0) < 10) {
                        g2 = pc(g2, e2, h2, 2) | 0;
                        break;
                      } else {
                        g2 = pc(g2, e2, h2, 3) | 0;
                        break;
                      }
                    }
                    if ((i2 | 0) == 500) {
                      g2 = pc(b5 + 244 | 0, e2, (c2[b5 + 132 + (c2[j2 >> 2] << 2) >> 2] | 0) * 500 | 0, 4) | 0;
                      h2 = b5 + 148 + (c2[j2 >> 2] << 2) | 0;
                      c2[h2 >> 2] = (c2[h2 >> 2] | 0) + 1;
                      h2 = c2[j2 >> 2] | 0;
                      if ((c2[b5 + 148 + (h2 << 2) >> 2] | 0) <= 3)
                        break;
                      c2[b5 + 132 + (h2 << 2) >> 2] = g2;
                      c2[b5 + 148 + (c2[j2 >> 2] << 2) >> 2] = 0;
                      break;
                    }
                    g2 = 500 - i2 | 0;
                    h2 = b5 + 244 | 0;
                    i2 = c2[b5 + 132 + (c2[j2 >> 2] << 2) >> 2] | 0;
                    if ((g2 | 0) > -10) {
                      g2 = pc(h2, e2, q(i2, g2) | 0, 5) | 0;
                      break;
                    }
                    g2 = pc(h2, e2, q(i2, -10) | 0, 6) | 0;
                    h2 = b5 + 148 + (c2[j2 >> 2] << 2) | 0;
                    c2[h2 >> 2] = (c2[h2 >> 2] | 0) + 1;
                    h2 = c2[j2 >> 2] | 0;
                    if ((c2[b5 + 148 + (h2 << 2) >> 2] | 0) > 3) {
                      c2[b5 + 132 + (h2 << 2) >> 2] = g2;
                      c2[b5 + 148 + (c2[j2 >> 2] << 2) >> 2] = 0;
                    }
                  }
                while (0);
                k2 = b5 + 100 + (c2[j2 >> 2] << 3) | 0;
                h2 = k2;
                e2 = h2;
                h2 = h2 + 4 | 0;
                h2 = lr(d[e2 >> 0] | d[e2 + 1 >> 0] << 8 | d[e2 + 2 >> 0] << 16 | d[e2 + 3 >> 0] << 24 | 0, d[h2 >> 0] | d[h2 + 1 >> 0] << 8 | d[h2 + 2 >> 0] << 16 | d[h2 + 3 >> 0] << 24 | 0, g2 | 0, ((g2 | 0) < 0) << 31 >> 31 | 0) | 0;
                e2 = u() | 0;
                i2 = k2;
                a2[i2 >> 0] = h2;
                a2[i2 + 1 >> 0] = h2 >> 8;
                a2[i2 + 2 >> 0] = h2 >> 16;
                a2[i2 + 3 >> 0] = h2 >> 24;
                k2 = k2 + 4 | 0;
                a2[k2 >> 0] = e2;
                a2[k2 + 1 >> 0] = e2 >> 8;
                a2[k2 + 2 >> 0] = e2 >> 16;
                a2[k2 + 3 >> 0] = e2 >> 24;
              }
            while (0);
          uf(b5 + 100 + (c2[j2 >> 2] << 3) | 0, f2);
        }
        return f2 + 8 | 0;
      }
      function rf(a3) {
        a3 = a3 | 0;
        oc(a3);
        return;
      }
      function sf(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0;
        b5 = V;
        V = V + 16 | 0;
        d2 = b5;
        e2 = Re(a3) | 0;
        vf(d2, e2, Re(a3 + 4 | 0) | 0);
        a3 = c2[d2 >> 2] | 0;
        t(c2[d2 + 4 >> 2] | 0);
        V = b5;
        return a3 | 0;
      }
      function tf(a3) {
        a3 = a3 | 0;
        var b5 = 0;
        b5 = (bd(a3) | 0) & 65535;
        return ((bd(a3) | 0) & 65535) << 16 | b5 | 0;
      }
      function uf(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var c3 = 0;
        c3 = a3;
        We(d[c3 >> 0] | d[c3 + 1 >> 0] << 8 | d[c3 + 2 >> 0] << 16 | d[c3 + 3 >> 0] << 24, b5);
        a3 = a3 + 4 | 0;
        We(d[a3 >> 0] | d[a3 + 1 >> 0] << 8 | d[a3 + 2 >> 0] << 16 | d[a3 + 3 >> 0] << 24, b5 + 4 | 0);
        return;
      }
      function vf(b5, c3, d2) {
        b5 = b5 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var e2 = 0;
        e2 = b5;
        a2[e2 >> 0] = c3;
        a2[e2 + 1 >> 0] = c3 >> 8;
        a2[e2 + 2 >> 0] = c3 >> 16;
        a2[e2 + 3 >> 0] = c3 >> 24;
        c3 = b5 + 4 | 0;
        a2[c3 >> 0] = d2;
        a2[c3 + 1 >> 0] = d2 >> 8;
        a2[c3 + 2 >> 0] = d2 >> 16;
        a2[c3 + 3 >> 0] = d2 >> 24;
        return;
      }
      function wf(a3) {
        a3 = a3 | 0;
        pq(a3);
        jp(a3);
        return;
      }
      function xf(a3) {
        a3 = a3 | 0;
        a3 = c2[a3 + 12 >> 2] | 0;
        if (a3 | 0)
          ca[c2[(c2[a3 >> 2] | 0) + 4 >> 2] & 255](a3);
        return;
      }
      function yf(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return ((c2[b5 + 4 >> 2] | 0) == 9890 ? a3 + 12 | 0 : 0) | 0;
      }
      function zf(a3) {
        a3 = a3 | 0;
        Da(a3, 16);
        return;
      }
      function Af(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        fe(a3);
        c2[a3 >> 2] = 4820;
        c2[a3 + 4 >> 2] = b5;
        Cf(a3 + 8 | 0);
        return;
      }
      function Bf(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0;
        d2 = V;
        V = V + 16 | 0;
        e2 = d2;
        c2[a3 >> 2] = b5;
        f2 = eq(16) | 0;
        c2[f2 + 4 >> 2] = 0;
        c2[f2 + 8 >> 2] = 0;
        c2[f2 >> 2] = 4844;
        c2[f2 + 12 >> 2] = b5;
        c2[a3 + 4 >> 2] = f2;
        c2[e2 >> 2] = b5;
        c2[e2 + 4 >> 2] = b5;
        Xe(a3, e2);
        V = d2;
        return;
      }
      function Cf(b5) {
        b5 = b5 | 0;
        a2[b5 >> 0] = 0;
        Gf(b5 + 1 | 0);
        Oc(b5 + 8 | 0, 128, 0, 0);
        Oc(b5 + 52 | 0, 256, 0, 0);
        Oc(b5 + 96 | 0, 256, 0, 0);
        Oc(b5 + 140 | 0, 256, 0, 0);
        Oc(b5 + 184 | 0, 256, 0, 0);
        Oc(b5 + 228 | 0, 256, 0, 0);
        Oc(b5 + 272 | 0, 256, 0, 0);
        return;
      }
      function Df(a3) {
        a3 = a3 | 0;
        c2[a3 >> 2] = 4820;
        Hf(a3 + 8 | 0);
        le(a3);
        return;
      }
      function Ef(a3) {
        a3 = a3 | 0;
        Df(a3);
        jp(a3);
        return;
      }
      function Ff(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return If(a3 + 8 | 0, c2[a3 + 4 >> 2] | 0, b5) | 0;
      }
      function Gf(b5) {
        b5 = b5 | 0;
        var c3 = 0;
        a2[b5 >> 0] = 0;
        a2[b5 + 1 >> 0] = 0;
        c3 = b5 + 2 | 0;
        a2[c3 >> 0] = 0;
        a2[c3 + 1 >> 0] = 0;
        b5 = b5 + 4 | 0;
        a2[b5 >> 0] = 0;
        a2[b5 + 1 >> 0] = 0;
        return;
      }
      function Hf(a3) {
        a3 = a3 | 0;
        Ic(a3 + 272 | 0);
        Ic(a3 + 228 | 0);
        Ic(a3 + 184 | 0);
        Ic(a3 + 140 | 0);
        Ic(a3 + 96 | 0);
        Ic(a3 + 52 | 0);
        Ic(a3 + 8 | 0);
        return;
      }
      function If(c3, f2, g2) {
        c3 = c3 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        var h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0, m2 = 0, n2 = 0, o2 = 0, p2 = 0;
        o2 = V;
        V = V + 16 | 0;
        m2 = o2;
        if (!(a2[c3 >> 0] | 0)) {
          a2[c3 >> 0] = 1;
          Ee(De(f2) | 0, g2, 6);
          Jf(m2, g2);
          n2 = c3 + 1 | 0;
          a2[n2 >> 0] = a2[m2 >> 0] | 0;
          a2[n2 + 1 >> 0] = a2[m2 + 1 >> 0] | 0;
          a2[n2 + 2 >> 0] = a2[m2 + 2 >> 0] | 0;
          a2[n2 + 3 >> 0] = a2[m2 + 3 >> 0] | 0;
          a2[n2 + 4 >> 0] = a2[m2 + 4 >> 0] | 0;
          a2[n2 + 5 >> 0] = a2[m2 + 5 >> 0] | 0;
        } else {
          n2 = Zc(f2, c3 + 8 | 0) | 0;
          Gf(m2);
          if (!(n2 & 1)) {
            h2 = c3 + 1 | 0;
            h2 = (d[h2 >> 0] | d[h2 + 1 >> 0] << 8) & 255;
          } else {
            l2 = (Zc(f2, c3 + 52 | 0) | 0) & 255;
            h2 = c3 + 1 | 0;
            h2 = (Ie(l2 + ((d[h2 >> 0] | d[h2 + 1 >> 0] << 8) & 255) | 0) | 0) & 255;
          }
          b4[m2 >> 1] = h2;
          if (!(n2 & 2)) {
            l2 = c3 + 1 | 0;
            h2 = h2 | (d[l2 >> 0] | d[l2 + 1 >> 0] << 8) & -256;
          } else {
            h2 = (Zc(f2, c3 + 96 | 0) | 0) & 255;
            l2 = c3 + 1 | 0;
            h2 = ((Ie((((d[l2 >> 0] | d[l2 + 1 >> 0] << 8) & 65535) >>> 8) + h2 | 0) | 0) & 255) << 8;
            h2 = (h2 | e[m2 >> 1]) & 65535;
          }
          b4[m2 >> 1] = h2;
          do
            if (n2 & 64) {
              k2 = c3 + 1 | 0;
              i2 = (h2 & 255) - ((d[k2 >> 0] | d[k2 + 1 >> 0] << 8) & 255) | 0;
              if (!(n2 & 4)) {
                h2 = c3 + 3 | 0;
                h2 = (d[h2 >> 0] | d[h2 + 1 >> 0] << 8) & 255;
              } else {
                h2 = (Zc(f2, c3 + 140 | 0) | 0) & 255;
                l2 = c3 + 3 | 0;
                l2 = i2 + ((d[l2 >> 0] | d[l2 + 1 >> 0] << 8) & 255) | 0;
                h2 = (Ie(((l2 | 0) < 1 ? 0 : (l2 | 0) > 254 ? 255 : l2 & 255) + h2 | 0) | 0) & 255;
              }
              l2 = m2 + 2 | 0;
              b4[l2 >> 1] = h2;
              if (!(n2 & 16)) {
                h2 = c3 + 5 | 0;
                h2 = (d[h2 >> 0] | d[h2 + 1 >> 0] << 8) & 255;
              } else {
                h2 = Zc(f2, c3 + 228 | 0) | 0;
                p2 = c3 + 3 | 0;
                j2 = c3 + 5 | 0;
                j2 = ((i2 + (b4[l2 >> 1] & 255) - ((d[p2 >> 0] | d[p2 + 1 >> 0] << 8) & 255) | 0) / 2 | 0) + ((d[j2 >> 0] | d[j2 + 1 >> 0] << 8) & 255) | 0;
                h2 = (Ie(((j2 | 0) < 1 ? 0 : (j2 | 0) > 254 ? 255 : j2 & 255) + (h2 & 255) | 0) | 0) & 255;
              }
              j2 = m2 + 4 | 0;
              b4[j2 >> 1] = h2;
              h2 = ((e[m2 >> 1] | 0) >>> 8) - (((d[k2 >> 0] | d[k2 + 1 >> 0] << 8) & 65535) >>> 8) | 0;
              if (!(n2 & 8)) {
                i2 = c3 + 3 | 0;
                i2 = b4[l2 >> 1] | (d[i2 >> 0] | d[i2 + 1 >> 0] << 8) & -256;
              } else {
                i2 = (Zc(f2, c3 + 184 | 0) | 0) & 255;
                p2 = c3 + 3 | 0;
                p2 = (((d[p2 >> 0] | d[p2 + 1 >> 0] << 8) & 65535) >>> 8) + h2 | 0;
                i2 = ((Ie(((p2 | 0) < 1 ? 0 : (p2 | 0) > 254 ? 255 : p2 & 255) + i2 | 0) | 0) & 255) << 8;
                i2 = (i2 | e[l2 >> 1]) & 65535;
              }
              b4[l2 >> 1] = i2;
              if (!(n2 & 32)) {
                p2 = c3 + 5 | 0;
                b4[j2 >> 1] = b4[j2 >> 1] | (d[p2 >> 0] | d[p2 + 1 >> 0] << 8) & -256;
                break;
              } else {
                p2 = Zc(f2, c3 + 272 | 0) | 0;
                f2 = c3 + 3 | 0;
                n2 = c3 + 5 | 0;
                n2 = ((((e[l2 >> 1] | 0) >>> 8) + h2 - (((d[f2 >> 0] | d[f2 + 1 >> 0] << 8) & 65535) >>> 8) | 0) / 2 | 0) + (((d[n2 >> 0] | d[n2 + 1 >> 0] << 8) & 65535) >>> 8) | 0;
                p2 = ((Ie(((n2 | 0) < 1 ? 0 : (n2 | 0) > 254 ? 255 : n2 & 255) + (p2 & 255) | 0) | 0) & 255) << 8;
                b4[j2 >> 1] = p2 | e[j2 >> 1];
                break;
              }
            } else {
              b4[m2 + 2 >> 1] = h2;
              b4[m2 + 4 >> 1] = h2;
            }
          while (0);
          p2 = c3 + 1 | 0;
          a2[p2 >> 0] = a2[m2 >> 0] | 0;
          a2[p2 + 1 >> 0] = a2[m2 + 1 >> 0] | 0;
          a2[p2 + 2 >> 0] = a2[m2 + 2 >> 0] | 0;
          a2[p2 + 3 >> 0] = a2[m2 + 3 >> 0] | 0;
          a2[p2 + 4 >> 0] = a2[m2 + 4 >> 0] | 0;
          a2[p2 + 5 >> 0] = a2[m2 + 5 >> 0] | 0;
          Kf(p2, g2);
        }
        V = o2;
        return g2 + 6 | 0;
      }
      function Jf(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var c3 = 0, d2 = 0;
        d2 = Oe(b5) | 0;
        c3 = Oe(b5 + 2 | 0) | 0;
        Lf(a3, d2, c3, Oe(b5 + 4 | 0) | 0);
        return;
      }
      function Kf(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var c3 = 0;
        Te(d[a3 >> 0] | d[a3 + 1 >> 0] << 8, b5);
        c3 = a3 + 2 | 0;
        Te(d[c3 >> 0] | d[c3 + 1 >> 0] << 8, b5 + 2 | 0);
        a3 = a3 + 4 | 0;
        Te(d[a3 >> 0] | d[a3 + 1 >> 0] << 8, b5 + 4 | 0);
        return;
      }
      function Lf(b5, c3, d2, e2) {
        b5 = b5 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        a2[b5 >> 0] = c3;
        a2[b5 + 1 >> 0] = c3 >> 8;
        c3 = b5 + 2 | 0;
        a2[c3 >> 0] = d2;
        a2[c3 + 1 >> 0] = d2 >> 8;
        d2 = b5 + 4 | 0;
        a2[d2 >> 0] = e2;
        a2[d2 + 1 >> 0] = e2 >> 8;
        return;
      }
      function Mf(a3) {
        a3 = a3 | 0;
        pq(a3);
        jp(a3);
        return;
      }
      function Nf(a3) {
        a3 = a3 | 0;
        a3 = c2[a3 + 12 >> 2] | 0;
        if (a3 | 0)
          ca[c2[(c2[a3 >> 2] | 0) + 4 >> 2] & 255](a3);
        return;
      }
      function Of(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return ((c2[b5 + 4 >> 2] | 0) == 10570 ? a3 + 12 | 0 : 0) | 0;
      }
      function Pf(a3) {
        a3 = a3 | 0;
        Da(a3, 16);
        return;
      }
      function Qf(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        fe(a3);
        c2[a3 >> 2] = 4872;
        c2[a3 + 4 >> 2] = b5;
        Sf(a3 + 8 | 0, d2);
        return;
      }
      function Rf(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0;
        d2 = V;
        V = V + 16 | 0;
        e2 = d2;
        c2[a3 >> 2] = b5;
        f2 = eq(16) | 0;
        c2[f2 + 4 >> 2] = 0;
        c2[f2 + 8 >> 2] = 0;
        c2[f2 >> 2] = 4896;
        c2[f2 + 12 >> 2] = b5;
        c2[a3 + 4 >> 2] = f2;
        c2[e2 >> 2] = b5;
        c2[e2 + 4 >> 2] = b5;
        Xe(a3, e2);
        V = d2;
        return;
      }
      function Sf(b5, d2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        c2[b5 >> 2] = c2[d2 >> 2];
        a2[b5 + 4 >> 0] = a2[d2 + 4 >> 0] | 0;
        Wf(b5 + 8 | 0, d2 + 8 | 0);
        Wf(b5 + 20 | 0, d2 + 20 | 0);
        Xf(b5 + 32 | 0, d2 + 32 | 0);
        return;
      }
      function Tf(a3) {
        a3 = a3 | 0;
        c2[a3 >> 2] = 4872;
        ud(a3 + 8 | 0);
        le(a3);
        return;
      }
      function Uf(a3) {
        a3 = a3 | 0;
        Tf(a3);
        jp(a3);
        return;
      }
      function Vf(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return Dg(a3 + 8 | 0, c2[a3 + 4 >> 2] | 0, b5) | 0;
      }
      function Wf(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0;
        c2[a3 >> 2] = 0;
        c2[a3 + 4 >> 2] = 0;
        c2[a3 + 8 >> 2] = 0;
        d2 = b5 + 4 | 0;
        e2 = (c2[d2 >> 2] | 0) - (c2[b5 >> 2] | 0) | 0;
        if (e2 | 0) {
          Yf(a3, e2);
          Zf(a3, c2[b5 >> 2] | 0, c2[d2 >> 2] | 0, e2);
        }
        return;
      }
      function Xf(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0;
        d2 = V;
        V = V + 32 | 0;
        e2 = d2 + 24 | 0;
        f2 = d2 + 16 | 0;
        h2 = d2 + 8 | 0;
        g2 = d2;
        c2[a3 >> 2] = 0;
        c2[a3 + 4 >> 2] = 0;
        c2[a3 + 8 >> 2] = 0;
        c2[a3 + 12 >> 2] = 0;
        c2[a3 + 16 >> 2] = 0;
        c2[a3 + 20 >> 2] = 0;
        zg(h2, b5);
        Ag(g2, b5);
        c2[f2 >> 2] = c2[h2 >> 2];
        c2[f2 + 4 >> 2] = c2[h2 + 4 >> 2];
        c2[e2 >> 2] = c2[g2 >> 2];
        c2[e2 + 4 >> 2] = c2[g2 + 4 >> 2];
        cg(a3, f2, e2, 0);
        V = d2;
        return;
      }
      function Yf(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0;
        if (($f(a3) | 0) >>> 0 < b5 >>> 0)
          cr(a3);
        else {
          d2 = eq(b5) | 0;
          c2[a3 + 4 >> 2] = d2;
          c2[a3 >> 2] = d2;
          c2[a3 + 8 >> 2] = d2 + b5;
          return;
        }
      }
      function Zf(a3, b5, d2, e2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f2 = 0, g2 = 0;
        g2 = V;
        V = V + 16 | 0;
        f2 = g2;
        ag(f2, a3, e2);
        e2 = f2 + 4 | 0;
        a3 = d2 - b5 | 0;
        if ((a3 | 0) > 0) {
          ur(c2[e2 >> 2] | 0, b5 | 0, a3 | 0) | 0;
          c2[e2 >> 2] = (c2[e2 >> 2] | 0) + a3;
        }
        bg(f2);
        V = g2;
        return;
      }
      function _f(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        b5 = c2[a3 >> 2] | 0;
        d2 = b5;
        if (b5 | 0) {
          c2[a3 + 4 >> 2] = d2;
          Da(b5, (c2[a3 + 8 >> 2] | 0) - d2 | 0);
        }
        return;
      }
      function $f(a3) {
        a3 = a3 | 0;
        return 2147483647;
      }
      function ag(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        c2[a3 >> 2] = b5;
        b5 = c2[b5 + 4 >> 2] | 0;
        c2[a3 + 4 >> 2] = b5;
        c2[a3 + 8 >> 2] = b5 + d2;
        return;
      }
      function bg(a3) {
        a3 = a3 | 0;
        c2[(c2[a3 >> 2] | 0) + 4 >> 2] = c2[a3 + 4 >> 2];
        return;
      }
      function cg(a3, b5, d2, e2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0, m2 = 0, n2 = 0, o2 = 0, p2 = 0, q2 = 0;
        q2 = V;
        V = V + 96 | 0;
        p2 = q2 + 80 | 0;
        m2 = q2 + 64 | 0;
        j2 = q2 + 48 | 0;
        k2 = q2 + 40 | 0;
        l2 = q2 + 8 | 0;
        i2 = q2;
        n2 = q2 + 32 | 0;
        o2 = q2 + 16 | 0;
        h2 = b5;
        g2 = c2[h2 >> 2] | 0;
        h2 = c2[h2 + 4 >> 2] | 0;
        f2 = d2;
        d2 = c2[f2 >> 2] | 0;
        f2 = c2[f2 + 4 >> 2] | 0;
        e2 = g2;
        if ((f2 | 0) == (h2 | 0))
          h2 = 0;
        else
          h2 = ((f2 - (c2[d2 >> 2] | 0) | 0) / 44 | 0) + ((d2 - g2 >> 2) * 93 | 0) + ((h2 - (c2[g2 >> 2] | 0) | 0) / -44 | 0) | 0;
        d2 = (c2[a3 + 8 >> 2] | 0) - (c2[a3 + 4 >> 2] | 0) | 0;
        d2 = ((d2 | 0) == 0 ? 0 : ((d2 >> 2) * 93 | 0) + -1 | 0) - ((c2[a3 + 20 >> 2] | 0) + (c2[a3 + 16 >> 2] | 0)) | 0;
        if (h2 >>> 0 > d2 >>> 0)
          eg(a3, h2 - d2 | 0);
        fg(k2, a3);
        fg(i2, a3);
        f2 = i2;
        d2 = c2[f2 >> 2] | 0;
        f2 = c2[f2 + 4 >> 2] | 0;
        g2 = l2;
        c2[g2 >> 2] = d2;
        c2[g2 + 4 >> 2] = f2;
        g2 = d2;
        if (h2 | 0) {
          d2 = ((f2 - (c2[d2 >> 2] | 0) | 0) / 44 | 0) + h2 | 0;
          if ((d2 | 0) > 0) {
            i2 = (d2 >>> 0) / 93 | 0;
            h2 = g2 + (i2 << 2) | 0;
            c2[l2 >> 2] = h2;
            d2 = (c2[h2 >> 2] | 0) + ((d2 - (i2 * 93 | 0) | 0) * 44 | 0) | 0;
          } else {
            d2 = 92 - d2 | 0;
            i2 = g2 + (((d2 | 0) / -93 | 0) << 2) | 0;
            c2[l2 >> 2] = i2;
            d2 = (c2[i2 >> 2] | 0) + ((92 - ((d2 | 0) % 93 | 0) | 0) * 44 | 0) | 0;
          }
          c2[l2 + 4 >> 2] = d2;
        }
        c2[m2 >> 2] = c2[k2 >> 2];
        c2[m2 + 4 >> 2] = c2[k2 + 4 >> 2];
        c2[p2 >> 2] = c2[l2 >> 2];
        c2[p2 + 4 >> 2] = c2[l2 + 4 >> 2];
        gg(j2, m2, p2);
        hg(p2, j2);
        ig(m2, j2);
        if (jg(p2, m2) | 0) {
          g2 = o2 + 4 | 0;
          h2 = b5 + 4 | 0;
          do {
            kg(n2, p2);
            lg(o2, a3, n2);
            d2 = c2[o2 >> 2] | 0;
            if ((d2 | 0) != (c2[g2 >> 2] | 0)) {
              f2 = c2[h2 >> 2] | 0;
              do {
                Wc(d2, f2);
                d2 = (c2[o2 >> 2] | 0) + 44 | 0;
                c2[o2 >> 2] = d2;
                f2 = f2 + 44 | 0;
                c2[h2 >> 2] = f2;
                if ((f2 - (c2[e2 >> 2] | 0) | 0) == 4092) {
                  e2 = e2 + 4 | 0;
                  c2[b5 >> 2] = e2;
                  f2 = c2[e2 >> 2] | 0;
                  c2[h2 >> 2] = f2;
                }
              } while ((d2 | 0) != (c2[g2 >> 2] | 0));
            }
            mg(o2);
            ng(p2) | 0;
          } while (jg(p2, m2) | 0);
        }
        V = q2;
        return;
      }
      function dg(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0;
        b5 = c2[a3 + 4 >> 2] | 0;
        d2 = a3 + 8 | 0;
        e2 = c2[d2 >> 2] | 0;
        if ((e2 | 0) != (b5 | 0))
          c2[d2 >> 2] = e2 + (~((e2 + -4 - b5 | 0) >>> 2) << 2);
        b5 = c2[a3 >> 2] | 0;
        if (b5 | 0)
          Da(b5, (c2[a3 + 12 >> 2] | 0) - b5 | 0);
        return;
      }
      function eg(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0, m2 = 0, n2 = 0, o2 = 0, p2 = 0, r2 = 0, s2 = 0, t2 = 0, u2 = 0, v2 = 0, w2 = 0, x2 = 0, y2 = 0, z2 = 0, A2 = 0, B2 = 0, C2 = 0;
        B2 = V;
        V = V + 64 | 0;
        v2 = B2 + 52 | 0;
        u2 = B2 + 48 | 0;
        w2 = B2 + 28 | 0;
        x2 = B2 + 24 | 0;
        y2 = B2 + 20 | 0;
        p2 = B2;
        z2 = a3 + 8 | 0;
        d2 = c2[z2 >> 2] | 0;
        A2 = a3 + 4 | 0;
        j2 = c2[A2 >> 2] | 0;
        s2 = ((d2 | 0) == (j2 | 0) & 1) + b5 | 0;
        h2 = (s2 >>> 0) / 93 | 0;
        h2 = h2 + ((s2 - (h2 * 93 | 0) | 0) != 0 & 1) | 0;
        s2 = a3 + 16 | 0;
        e2 = c2[s2 >> 2] | 0;
        i2 = (e2 >>> 0) / 93 | 0;
        r2 = h2 >>> 0 < i2 >>> 0 ? h2 : i2;
        b5 = h2 - r2 | 0;
        g2 = d2;
        a:
          do
            if (!b5) {
              c2[s2 >> 2] = (q(r2, -93) | 0) + e2;
              if (r2 | 0) {
                i2 = a3 + 12 | 0;
                k2 = a3 + 12 | 0;
                l2 = w2 + 4 | 0;
                m2 = w2 + 8 | 0;
                n2 = w2 + 12 | 0;
                b5 = r2;
                e2 = j2;
                while (1) {
                  h2 = c2[e2 >> 2] | 0;
                  g2 = e2 + 4 | 0;
                  c2[A2 >> 2] = g2;
                  t2 = c2[i2 >> 2] | 0;
                  e2 = t2;
                  do
                    if ((d2 | 0) == (t2 | 0)) {
                      t2 = c2[a3 >> 2] | 0;
                      d2 = t2;
                      if (g2 >>> 0 <= t2 >>> 0) {
                        d2 = e2 - d2 | 0;
                        d2 = (d2 | 0) == 0 ? 1 : d2 >> 1;
                        qg(w2, d2, d2 >>> 2, k2);
                        c2[x2 >> 2] = c2[A2 >> 2];
                        c2[y2 >> 2] = c2[z2 >> 2];
                        c2[u2 >> 2] = c2[x2 >> 2];
                        c2[v2 >> 2] = c2[y2 >> 2];
                        ug(w2, u2, v2);
                        d2 = c2[a3 >> 2] | 0;
                        c2[a3 >> 2] = c2[w2 >> 2];
                        c2[w2 >> 2] = d2;
                        d2 = c2[A2 >> 2] | 0;
                        c2[A2 >> 2] = c2[l2 >> 2];
                        c2[l2 >> 2] = d2;
                        d2 = c2[z2 >> 2] | 0;
                        c2[z2 >> 2] = c2[m2 >> 2];
                        c2[m2 >> 2] = d2;
                        d2 = c2[i2 >> 2] | 0;
                        c2[i2 >> 2] = c2[n2 >> 2];
                        c2[n2 >> 2] = d2;
                        tg(w2);
                        d2 = c2[z2 >> 2] | 0;
                        break;
                      }
                      t2 = g2;
                      d2 = ((t2 - d2 >> 2) + 1 | 0) / -2 | 0;
                      f2 = g2 + (d2 << 2) | 0;
                      e2 = e2 - t2 | 0;
                      if (!e2)
                        d2 = f2;
                      else {
                        vr(f2 | 0, g2 | 0, e2 | 0) | 0;
                        d2 = (c2[A2 >> 2] | 0) + (d2 << 2) | 0;
                      }
                      t2 = f2 + (e2 >> 2 << 2) | 0;
                      c2[z2 >> 2] = t2;
                      c2[A2 >> 2] = d2;
                      d2 = t2;
                    }
                  while (0);
                  c2[d2 >> 2] = h2;
                  d2 = (c2[z2 >> 2] | 0) + 4 | 0;
                  c2[z2 >> 2] = d2;
                  b5 = b5 + -1 | 0;
                  if (!b5)
                    break a;
                  e2 = c2[A2 >> 2] | 0;
                }
              }
            } else {
              t2 = a3 + 12 | 0;
              e2 = c2[t2 >> 2] | 0;
              f2 = e2 - (c2[a3 >> 2] | 0) | 0;
              d2 = g2 - j2 >> 2;
              if (b5 >>> 0 > ((f2 >> 2) - d2 | 0) >>> 0) {
                o2 = f2 >> 1;
                n2 = d2 + b5 | 0;
                qg(p2, o2 >>> 0 < n2 >>> 0 ? n2 : o2, d2 - r2 | 0, a3 + 12 | 0);
                do {
                  c2[v2 >> 2] = eq(4092) | 0;
                  rg(p2, v2);
                  b5 = b5 + -1 | 0;
                } while ((b5 | 0) != 0);
                if (!r2)
                  d2 = c2[A2 >> 2] | 0;
                else {
                  i2 = p2 + 8 | 0;
                  j2 = p2 + 12 | 0;
                  k2 = p2 + 4 | 0;
                  l2 = p2 + 16 | 0;
                  m2 = w2 + 4 | 0;
                  n2 = w2 + 8 | 0;
                  o2 = w2 + 12 | 0;
                  h2 = r2;
                  b5 = c2[i2 >> 2] | 0;
                  d2 = c2[A2 >> 2] | 0;
                  do {
                    g2 = c2[j2 >> 2] | 0;
                    e2 = g2;
                    do
                      if ((b5 | 0) == (g2 | 0)) {
                        f2 = c2[k2 >> 2] | 0;
                        g2 = c2[p2 >> 2] | 0;
                        b5 = g2;
                        if (f2 >>> 0 <= g2 >>> 0) {
                          b5 = e2 - b5 | 0;
                          b5 = (b5 | 0) == 0 ? 1 : b5 >> 1;
                          qg(w2, b5, b5 >>> 2, c2[l2 >> 2] | 0);
                          c2[x2 >> 2] = c2[k2 >> 2];
                          c2[y2 >> 2] = c2[i2 >> 2];
                          c2[u2 >> 2] = c2[x2 >> 2];
                          c2[v2 >> 2] = c2[y2 >> 2];
                          ug(w2, u2, v2);
                          b5 = c2[p2 >> 2] | 0;
                          c2[p2 >> 2] = c2[w2 >> 2];
                          c2[w2 >> 2] = b5;
                          b5 = c2[k2 >> 2] | 0;
                          c2[k2 >> 2] = c2[m2 >> 2];
                          c2[m2 >> 2] = b5;
                          b5 = c2[i2 >> 2] | 0;
                          c2[i2 >> 2] = c2[n2 >> 2];
                          c2[n2 >> 2] = b5;
                          b5 = c2[j2 >> 2] | 0;
                          c2[j2 >> 2] = c2[o2 >> 2];
                          c2[o2 >> 2] = b5;
                          tg(w2);
                          b5 = c2[i2 >> 2] | 0;
                          break;
                        }
                        C2 = f2;
                        b5 = ((C2 - b5 >> 2) + 1 | 0) / -2 | 0;
                        g2 = f2 + (b5 << 2) | 0;
                        e2 = e2 - C2 | 0;
                        if (!e2)
                          b5 = g2;
                        else {
                          vr(g2 | 0, f2 | 0, e2 | 0) | 0;
                          b5 = (c2[k2 >> 2] | 0) + (b5 << 2) | 0;
                        }
                        C2 = g2 + (e2 >> 2 << 2) | 0;
                        c2[i2 >> 2] = C2;
                        c2[k2 >> 2] = b5;
                        b5 = C2;
                      }
                    while (0);
                    c2[b5 >> 2] = c2[d2 >> 2];
                    b5 = (c2[i2 >> 2] | 0) + 4 | 0;
                    c2[i2 >> 2] = b5;
                    d2 = (c2[A2 >> 2] | 0) + 4 | 0;
                    c2[A2 >> 2] = d2;
                    h2 = h2 + -1 | 0;
                  } while ((h2 | 0) != 0);
                }
                b5 = c2[z2 >> 2] | 0;
                if ((b5 | 0) != (d2 | 0)) {
                  do {
                    b5 = b5 + -4 | 0;
                    sg(p2, b5);
                    d2 = c2[A2 >> 2] | 0;
                  } while ((b5 | 0) != (d2 | 0));
                  b5 = c2[z2 >> 2] | 0;
                }
                C2 = c2[a3 >> 2] | 0;
                c2[a3 >> 2] = c2[p2 >> 2];
                c2[p2 >> 2] = C2;
                C2 = p2 + 4 | 0;
                c2[A2 >> 2] = c2[C2 >> 2];
                c2[C2 >> 2] = d2;
                C2 = p2 + 8 | 0;
                c2[z2 >> 2] = c2[C2 >> 2];
                c2[C2 >> 2] = b5;
                C2 = p2 + 12 | 0;
                A2 = c2[t2 >> 2] | 0;
                c2[t2 >> 2] = c2[C2 >> 2];
                c2[C2 >> 2] = A2;
                c2[s2 >> 2] = (c2[s2 >> 2] | 0) + (q(r2, -93) | 0);
                tg(p2);
                break;
              } else {
                b:
                  do
                    if ((e2 | 0) == (g2 | 0))
                      k2 = 18;
                    else {
                      while (1) {
                        c2[v2 >> 2] = eq(4092) | 0;
                        og(a3, v2);
                        b5 = b5 + -1 | 0;
                        if (!b5)
                          break;
                        if ((c2[t2 >> 2] | 0) == (c2[z2 >> 2] | 0)) {
                          k2 = 18;
                          break b;
                        }
                      }
                      d2 = r2;
                      b5 = c2[s2 >> 2] | 0;
                    }
                  while (0);
                if ((k2 | 0) == 18) {
                  e2 = ~(h2 >>> 0 > i2 >>> 0 ? i2 : h2);
                  d2 = b5;
                  do {
                    c2[v2 >> 2] = eq(4092) | 0;
                    pg(a3, v2);
                    d2 = d2 + -1 | 0;
                    f2 = (((c2[z2 >> 2] | 0) - (c2[A2 >> 2] | 0) | 0) == 4 ? 92 : 93) + (c2[s2 >> 2] | 0) | 0;
                    c2[s2 >> 2] = f2;
                  } while ((d2 | 0) != 0);
                  d2 = b5 + -1 - e2 | 0;
                  b5 = f2;
                }
                c2[s2 >> 2] = b5 + (q(d2, -93) | 0);
                if (!d2)
                  break;
                i2 = a3 + 12 | 0;
                j2 = w2 + 4 | 0;
                k2 = w2 + 8 | 0;
                l2 = w2 + 12 | 0;
                b5 = c2[z2 >> 2] | 0;
                do {
                  g2 = c2[A2 >> 2] | 0;
                  h2 = c2[g2 >> 2] | 0;
                  g2 = g2 + 4 | 0;
                  c2[A2 >> 2] = g2;
                  C2 = c2[t2 >> 2] | 0;
                  e2 = C2;
                  do
                    if ((b5 | 0) == (C2 | 0)) {
                      C2 = c2[a3 >> 2] | 0;
                      b5 = C2;
                      if (g2 >>> 0 <= C2 >>> 0) {
                        b5 = e2 - b5 | 0;
                        b5 = (b5 | 0) == 0 ? 1 : b5 >> 1;
                        qg(w2, b5, b5 >>> 2, i2);
                        c2[x2 >> 2] = c2[A2 >> 2];
                        c2[y2 >> 2] = c2[z2 >> 2];
                        c2[u2 >> 2] = c2[x2 >> 2];
                        c2[v2 >> 2] = c2[y2 >> 2];
                        ug(w2, u2, v2);
                        b5 = c2[a3 >> 2] | 0;
                        c2[a3 >> 2] = c2[w2 >> 2];
                        c2[w2 >> 2] = b5;
                        b5 = c2[A2 >> 2] | 0;
                        c2[A2 >> 2] = c2[j2 >> 2];
                        c2[j2 >> 2] = b5;
                        b5 = c2[z2 >> 2] | 0;
                        c2[z2 >> 2] = c2[k2 >> 2];
                        c2[k2 >> 2] = b5;
                        b5 = c2[t2 >> 2] | 0;
                        c2[t2 >> 2] = c2[l2 >> 2];
                        c2[l2 >> 2] = b5;
                        tg(w2);
                        b5 = c2[z2 >> 2] | 0;
                        break;
                      }
                      C2 = g2;
                      b5 = ((C2 - b5 >> 2) + 1 | 0) / -2 | 0;
                      f2 = g2 + (b5 << 2) | 0;
                      e2 = e2 - C2 | 0;
                      if (!e2)
                        b5 = f2;
                      else {
                        vr(f2 | 0, g2 | 0, e2 | 0) | 0;
                        b5 = (c2[A2 >> 2] | 0) + (b5 << 2) | 0;
                      }
                      C2 = f2 + (e2 >> 2 << 2) | 0;
                      c2[z2 >> 2] = C2;
                      c2[A2 >> 2] = b5;
                      b5 = C2;
                    }
                  while (0);
                  c2[b5 >> 2] = h2;
                  b5 = (c2[z2 >> 2] | 0) + 4 | 0;
                  c2[z2 >> 2] = b5;
                  d2 = d2 + -1 | 0;
                } while ((d2 | 0) != 0);
              }
            }
          while (0);
        V = B2;
        return;
      }
      function fg(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0;
        d2 = (c2[b5 + 16 >> 2] | 0) + (c2[b5 + 20 >> 2] | 0) | 0;
        g2 = c2[b5 + 4 >> 2] | 0;
        e2 = (d2 >>> 0) / 93 | 0;
        f2 = g2 + (e2 << 2) | 0;
        if ((c2[b5 + 8 >> 2] | 0) == (g2 | 0))
          b5 = 0;
        else
          b5 = (c2[f2 >> 2] | 0) + ((d2 - (e2 * 93 | 0) | 0) * 44 | 0) | 0;
        c2[a3 >> 2] = f2;
        c2[a3 + 4 >> 2] = b5;
        return;
      }
      function gg(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0;
        f2 = b5;
        b5 = c2[f2 + 4 >> 2] | 0;
        e2 = a3;
        c2[e2 >> 2] = c2[f2 >> 2];
        c2[e2 + 4 >> 2] = b5;
        e2 = d2;
        b5 = c2[e2 + 4 >> 2] | 0;
        d2 = a3 + 8 | 0;
        c2[d2 >> 2] = c2[e2 >> 2];
        c2[d2 + 4 >> 2] = b5;
        return;
      }
      function hg(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c2[a3 >> 2] = c2[b5 >> 2];
        c2[a3 + 4 >> 2] = c2[b5 + 4 >> 2];
        c2[a3 + 8 >> 2] = c2[b5 + 8 >> 2];
        c2[a3 + 12 >> 2] = c2[b5 + 12 >> 2];
        return;
      }
      function ig(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0;
        d2 = V;
        V = V + 32 | 0;
        e2 = d2 + 24 | 0;
        f2 = d2 + 16 | 0;
        h2 = d2 + 8 | 0;
        g2 = d2;
        i2 = b5 + 8 | 0;
        j2 = c2[i2 >> 2] | 0;
        i2 = c2[i2 + 4 >> 2] | 0;
        b5 = h2;
        c2[b5 >> 2] = j2;
        c2[b5 + 4 >> 2] = i2;
        b5 = g2;
        c2[b5 >> 2] = j2;
        c2[b5 + 4 >> 2] = i2;
        c2[f2 >> 2] = c2[h2 >> 2];
        c2[f2 + 4 >> 2] = c2[h2 + 4 >> 2];
        c2[e2 >> 2] = c2[g2 >> 2];
        c2[e2 + 4 >> 2] = c2[g2 + 4 >> 2];
        gg(a3, f2, e2);
        V = d2;
        return;
      }
      function jg(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return (xg(a3, b5) | 0) ^ 1 | 0;
      }
      function kg(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0;
        d2 = c2[b5 >> 2] | 0;
        e2 = c2[b5 + 4 >> 2] | 0;
        if ((d2 | 0) == (c2[b5 + 8 >> 2] | 0))
          yg(a3, e2, c2[b5 + 12 >> 2] | 0);
        else
          yg(a3, e2, (c2[d2 >> 2] | 0) + 4092 | 0);
        return;
      }
      function lg(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0;
        e2 = c2[d2 >> 2] | 0;
        c2[a3 >> 2] = e2;
        c2[a3 + 4 >> 2] = c2[d2 + 4 >> 2];
        c2[a3 + 8 >> 2] = e2;
        c2[a3 + 12 >> 2] = b5;
        return;
      }
      function mg(a3) {
        a3 = a3 | 0;
        var b5 = 0;
        b5 = (c2[a3 + 12 >> 2] | 0) + 20 | 0;
        c2[b5 >> 2] = (c2[b5 >> 2] | 0) + (((c2[a3 >> 2] | 0) - (c2[a3 + 8 >> 2] | 0) | 0) / 44 | 0);
        return;
      }
      function ng(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0;
        b5 = c2[a3 >> 2] | 0;
        d2 = a3 + 8 | 0;
        if ((b5 | 0) == (c2[d2 >> 2] | 0)) {
          e2 = d2;
          b5 = c2[e2 + 4 >> 2] | 0;
          d2 = a3;
          c2[d2 >> 2] = c2[e2 >> 2];
          c2[d2 + 4 >> 2] = b5;
        } else {
          e2 = b5 + 4 | 0;
          c2[a3 >> 2] = e2;
          c2[a3 + 4 >> 2] = c2[e2 >> 2];
        }
        return a3 | 0;
      }
      function og(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0, m2 = 0, n2 = 0, o2 = 0, p2 = 0, q2 = 0;
        p2 = V;
        V = V + 48 | 0;
        f2 = p2 + 32 | 0;
        e2 = p2 + 28 | 0;
        i2 = p2 + 8 | 0;
        j2 = p2 + 4 | 0;
        k2 = p2;
        o2 = a3 + 8 | 0;
        d2 = c2[o2 >> 2] | 0;
        l2 = a3 + 12 | 0;
        n2 = c2[l2 >> 2] | 0;
        g2 = n2;
        do
          if ((d2 | 0) == (n2 | 0)) {
            n2 = a3 + 4 | 0;
            m2 = c2[n2 >> 2] | 0;
            q2 = c2[a3 >> 2] | 0;
            h2 = q2;
            if (m2 >>> 0 <= q2 >>> 0) {
              d2 = g2 - h2 | 0;
              d2 = (d2 | 0) == 0 ? 1 : d2 >> 1;
              qg(i2, d2, d2 >>> 2, a3 + 12 | 0);
              c2[j2 >> 2] = c2[n2 >> 2];
              c2[k2 >> 2] = c2[o2 >> 2];
              c2[e2 >> 2] = c2[j2 >> 2];
              c2[f2 >> 2] = c2[k2 >> 2];
              ug(i2, e2, f2);
              d2 = c2[a3 >> 2] | 0;
              c2[a3 >> 2] = c2[i2 >> 2];
              c2[i2 >> 2] = d2;
              d2 = i2 + 4 | 0;
              q2 = c2[n2 >> 2] | 0;
              c2[n2 >> 2] = c2[d2 >> 2];
              c2[d2 >> 2] = q2;
              d2 = i2 + 8 | 0;
              q2 = c2[o2 >> 2] | 0;
              c2[o2 >> 2] = c2[d2 >> 2];
              c2[d2 >> 2] = q2;
              d2 = i2 + 12 | 0;
              q2 = c2[l2 >> 2] | 0;
              c2[l2 >> 2] = c2[d2 >> 2];
              c2[d2 >> 2] = q2;
              tg(i2);
              d2 = c2[o2 >> 2] | 0;
              break;
            }
            f2 = m2;
            e2 = ((f2 - h2 >> 2) + 1 | 0) / -2 | 0;
            a3 = m2 + (e2 << 2) | 0;
            f2 = d2 - f2 | 0;
            if (!f2)
              d2 = a3;
            else {
              vr(a3 | 0, m2 | 0, f2 | 0) | 0;
              d2 = (c2[n2 >> 2] | 0) + (e2 << 2) | 0;
            }
            q2 = a3 + (f2 >> 2 << 2) | 0;
            c2[o2 >> 2] = q2;
            c2[n2 >> 2] = d2;
            d2 = q2;
          }
        while (0);
        c2[d2 >> 2] = c2[b5 >> 2];
        c2[o2 >> 2] = (c2[o2 >> 2] | 0) + 4;
        V = p2;
        return;
      }
      function pg(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0, m2 = 0, n2 = 0, o2 = 0, p2 = 0, q2 = 0;
        p2 = V;
        V = V + 48 | 0;
        e2 = p2 + 32 | 0;
        d2 = p2 + 28 | 0;
        h2 = p2 + 8 | 0;
        i2 = p2 + 4 | 0;
        j2 = p2;
        o2 = a3 + 4 | 0;
        m2 = c2[o2 >> 2] | 0;
        n2 = c2[a3 >> 2] | 0;
        k2 = n2;
        do
          if ((m2 | 0) == (n2 | 0)) {
            n2 = a3 + 8 | 0;
            l2 = c2[n2 >> 2] | 0;
            g2 = a3 + 12 | 0;
            q2 = c2[g2 >> 2] | 0;
            f2 = q2;
            if (l2 >>> 0 >= q2 >>> 0) {
              q2 = f2 - k2 | 0;
              q2 = (q2 | 0) == 0 ? 1 : q2 >> 1;
              qg(h2, q2, (q2 + 3 | 0) >>> 2, a3 + 12 | 0);
              c2[i2 >> 2] = c2[o2 >> 2];
              c2[j2 >> 2] = c2[n2 >> 2];
              c2[d2 >> 2] = c2[i2 >> 2];
              c2[e2 >> 2] = c2[j2 >> 2];
              ug(h2, d2, e2);
              d2 = c2[a3 >> 2] | 0;
              c2[a3 >> 2] = c2[h2 >> 2];
              c2[h2 >> 2] = d2;
              d2 = h2 + 4 | 0;
              q2 = c2[o2 >> 2] | 0;
              c2[o2 >> 2] = c2[d2 >> 2];
              c2[d2 >> 2] = q2;
              d2 = h2 + 8 | 0;
              q2 = c2[n2 >> 2] | 0;
              c2[n2 >> 2] = c2[d2 >> 2];
              c2[d2 >> 2] = q2;
              d2 = h2 + 12 | 0;
              q2 = c2[g2 >> 2] | 0;
              c2[g2 >> 2] = c2[d2 >> 2];
              c2[d2 >> 2] = q2;
              tg(h2);
              d2 = c2[o2 >> 2] | 0;
              break;
            }
            e2 = l2;
            a3 = ((f2 - e2 >> 2) + 1 | 0) / 2 | 0;
            f2 = l2 + (a3 << 2) | 0;
            e2 = e2 - m2 | 0;
            d2 = f2 + (0 - (e2 >> 2) << 2) | 0;
            if (!e2) {
              d2 = f2;
              e2 = f2;
            } else {
              vr(d2 | 0, m2 | 0, e2 | 0) | 0;
              e2 = (c2[n2 >> 2] | 0) + (a3 << 2) | 0;
            }
            c2[o2 >> 2] = d2;
            c2[n2 >> 2] = e2;
          } else
            d2 = m2;
        while (0);
        c2[d2 + -4 >> 2] = c2[b5 >> 2];
        c2[o2 >> 2] = (c2[o2 >> 2] | 0) + -4;
        V = p2;
        return;
      }
      function qg(a3, b5, d2, e2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f2 = 0;
        f2 = a3 + 12 | 0;
        c2[f2 >> 2] = 0;
        c2[a3 + 16 >> 2] = e2;
        do
          if (b5)
            if (b5 >>> 0 > 1073741823) {
              f2 = v(8) | 0;
              vq(f2, 6723);
              c2[f2 >> 2] = 5956;
              x(f2 | 0, 3928, 123);
            } else {
              e2 = eq(b5 << 2) | 0;
              break;
            }
          else
            e2 = 0;
        while (0);
        c2[a3 >> 2] = e2;
        d2 = e2 + (d2 << 2) | 0;
        c2[a3 + 8 >> 2] = d2;
        c2[a3 + 4 >> 2] = d2;
        c2[f2 >> 2] = e2 + (b5 << 2);
        return;
      }
      function rg(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0, m2 = 0, n2 = 0, o2 = 0, p2 = 0, q2 = 0;
        p2 = V;
        V = V + 48 | 0;
        f2 = p2 + 32 | 0;
        e2 = p2 + 28 | 0;
        i2 = p2 + 8 | 0;
        j2 = p2 + 4 | 0;
        k2 = p2;
        o2 = a3 + 8 | 0;
        d2 = c2[o2 >> 2] | 0;
        l2 = a3 + 12 | 0;
        n2 = c2[l2 >> 2] | 0;
        g2 = n2;
        do
          if ((d2 | 0) == (n2 | 0)) {
            n2 = a3 + 4 | 0;
            m2 = c2[n2 >> 2] | 0;
            q2 = c2[a3 >> 2] | 0;
            h2 = q2;
            if (m2 >>> 0 <= q2 >>> 0) {
              d2 = g2 - h2 | 0;
              d2 = (d2 | 0) == 0 ? 1 : d2 >> 1;
              qg(i2, d2, d2 >>> 2, c2[a3 + 16 >> 2] | 0);
              c2[j2 >> 2] = c2[n2 >> 2];
              c2[k2 >> 2] = c2[o2 >> 2];
              c2[e2 >> 2] = c2[j2 >> 2];
              c2[f2 >> 2] = c2[k2 >> 2];
              ug(i2, e2, f2);
              d2 = c2[a3 >> 2] | 0;
              c2[a3 >> 2] = c2[i2 >> 2];
              c2[i2 >> 2] = d2;
              d2 = i2 + 4 | 0;
              q2 = c2[n2 >> 2] | 0;
              c2[n2 >> 2] = c2[d2 >> 2];
              c2[d2 >> 2] = q2;
              d2 = i2 + 8 | 0;
              q2 = c2[o2 >> 2] | 0;
              c2[o2 >> 2] = c2[d2 >> 2];
              c2[d2 >> 2] = q2;
              d2 = i2 + 12 | 0;
              q2 = c2[l2 >> 2] | 0;
              c2[l2 >> 2] = c2[d2 >> 2];
              c2[d2 >> 2] = q2;
              tg(i2);
              d2 = c2[o2 >> 2] | 0;
              break;
            }
            f2 = m2;
            e2 = ((f2 - h2 >> 2) + 1 | 0) / -2 | 0;
            a3 = m2 + (e2 << 2) | 0;
            f2 = d2 - f2 | 0;
            if (!f2)
              d2 = a3;
            else {
              vr(a3 | 0, m2 | 0, f2 | 0) | 0;
              d2 = (c2[n2 >> 2] | 0) + (e2 << 2) | 0;
            }
            q2 = a3 + (f2 >> 2 << 2) | 0;
            c2[o2 >> 2] = q2;
            c2[n2 >> 2] = d2;
            d2 = q2;
          }
        while (0);
        c2[d2 >> 2] = c2[b5 >> 2];
        c2[o2 >> 2] = (c2[o2 >> 2] | 0) + 4;
        V = p2;
        return;
      }
      function sg(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0, m2 = 0, n2 = 0, o2 = 0, p2 = 0, q2 = 0;
        p2 = V;
        V = V + 48 | 0;
        e2 = p2 + 32 | 0;
        d2 = p2 + 28 | 0;
        h2 = p2 + 8 | 0;
        i2 = p2 + 4 | 0;
        j2 = p2;
        o2 = a3 + 4 | 0;
        m2 = c2[o2 >> 2] | 0;
        n2 = c2[a3 >> 2] | 0;
        k2 = n2;
        do
          if ((m2 | 0) == (n2 | 0)) {
            n2 = a3 + 8 | 0;
            l2 = c2[n2 >> 2] | 0;
            g2 = a3 + 12 | 0;
            q2 = c2[g2 >> 2] | 0;
            f2 = q2;
            if (l2 >>> 0 >= q2 >>> 0) {
              q2 = f2 - k2 | 0;
              q2 = (q2 | 0) == 0 ? 1 : q2 >> 1;
              qg(h2, q2, (q2 + 3 | 0) >>> 2, c2[a3 + 16 >> 2] | 0);
              c2[i2 >> 2] = c2[o2 >> 2];
              c2[j2 >> 2] = c2[n2 >> 2];
              c2[d2 >> 2] = c2[i2 >> 2];
              c2[e2 >> 2] = c2[j2 >> 2];
              ug(h2, d2, e2);
              d2 = c2[a3 >> 2] | 0;
              c2[a3 >> 2] = c2[h2 >> 2];
              c2[h2 >> 2] = d2;
              d2 = h2 + 4 | 0;
              q2 = c2[o2 >> 2] | 0;
              c2[o2 >> 2] = c2[d2 >> 2];
              c2[d2 >> 2] = q2;
              d2 = h2 + 8 | 0;
              q2 = c2[n2 >> 2] | 0;
              c2[n2 >> 2] = c2[d2 >> 2];
              c2[d2 >> 2] = q2;
              d2 = h2 + 12 | 0;
              q2 = c2[g2 >> 2] | 0;
              c2[g2 >> 2] = c2[d2 >> 2];
              c2[d2 >> 2] = q2;
              tg(h2);
              d2 = c2[o2 >> 2] | 0;
              break;
            }
            e2 = l2;
            a3 = ((f2 - e2 >> 2) + 1 | 0) / 2 | 0;
            f2 = l2 + (a3 << 2) | 0;
            e2 = e2 - m2 | 0;
            d2 = f2 + (0 - (e2 >> 2) << 2) | 0;
            if (!e2) {
              d2 = f2;
              e2 = f2;
            } else {
              vr(d2 | 0, m2 | 0, e2 | 0) | 0;
              e2 = (c2[n2 >> 2] | 0) + (a3 << 2) | 0;
            }
            c2[o2 >> 2] = d2;
            c2[n2 >> 2] = e2;
          } else
            d2 = m2;
        while (0);
        c2[d2 + -4 >> 2] = c2[b5 >> 2];
        c2[o2 >> 2] = (c2[o2 >> 2] | 0) + -4;
        V = p2;
        return;
      }
      function tg(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0;
        b5 = c2[a3 + 4 >> 2] | 0;
        d2 = a3 + 8 | 0;
        e2 = c2[d2 >> 2] | 0;
        if ((e2 | 0) != (b5 | 0))
          c2[d2 >> 2] = e2 + (~((e2 + -4 - b5 | 0) >>> 2) << 2);
        b5 = c2[a3 >> 2] | 0;
        if (b5 | 0)
          Da(b5, (c2[a3 + 12 >> 2] | 0) - b5 | 0);
        return;
      }
      function ug(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0, g2 = 0, h2 = 0;
        h2 = V;
        V = V + 16 | 0;
        g2 = h2;
        f2 = c2[b5 >> 2] | 0;
        vg(g2, a3 + 8 | 0, (c2[d2 >> 2] | 0) - f2 >> 2);
        a3 = c2[g2 >> 2] | 0;
        e2 = g2 + 4 | 0;
        if ((a3 | 0) != (c2[e2 >> 2] | 0)) {
          d2 = f2;
          do {
            c2[a3 >> 2] = c2[d2 >> 2];
            a3 = (c2[g2 >> 2] | 0) + 4 | 0;
            c2[g2 >> 2] = a3;
            d2 = d2 + 4 | 0;
          } while ((a3 | 0) != (c2[e2 >> 2] | 0));
          c2[b5 >> 2] = d2;
        }
        wg(g2);
        V = h2;
        return;
      }
      function vg(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        c2[a3 >> 2] = c2[b5 >> 2];
        c2[a3 + 4 >> 2] = (c2[b5 >> 2] | 0) + (d2 << 2);
        c2[a3 + 8 >> 2] = b5;
        return;
      }
      function wg(a3) {
        a3 = a3 | 0;
        c2[c2[a3 + 8 >> 2] >> 2] = c2[a3 >> 2];
        return;
      }
      function xg(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return (c2[a3 + 4 >> 2] | 0) == (c2[b5 + 4 >> 2] | 0) | 0;
      }
      function yg(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        c2[a3 >> 2] = b5;
        c2[a3 + 4 >> 2] = d2;
        return;
      }
      function zg(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0;
        g2 = c2[b5 + 4 >> 2] | 0;
        d2 = c2[b5 + 16 >> 2] | 0;
        e2 = (d2 >>> 0) / 93 | 0;
        f2 = g2 + (e2 << 2) | 0;
        if ((c2[b5 + 8 >> 2] | 0) == (g2 | 0))
          b5 = 0;
        else
          b5 = (c2[f2 >> 2] | 0) + ((d2 - (e2 * 93 | 0) | 0) * 44 | 0) | 0;
        c2[a3 >> 2] = f2;
        c2[a3 + 4 >> 2] = b5;
        return;
      }
      function Ag(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0;
        d2 = (c2[b5 + 16 >> 2] | 0) + (c2[b5 + 20 >> 2] | 0) | 0;
        g2 = c2[b5 + 4 >> 2] | 0;
        e2 = (d2 >>> 0) / 93 | 0;
        f2 = g2 + (e2 << 2) | 0;
        if ((c2[b5 + 8 >> 2] | 0) == (g2 | 0))
          b5 = 0;
        else
          b5 = (c2[f2 >> 2] | 0) + ((d2 - (e2 * 93 | 0) | 0) * 44 | 0) | 0;
        c2[a3 >> 2] = f2;
        c2[a3 + 4 >> 2] = b5;
        return;
      }
      function Bg(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0;
        i2 = V;
        V = V + 16 | 0;
        e2 = i2 + 8 | 0;
        g2 = i2;
        Cg(e2, a3);
        fg(g2, a3);
        f2 = e2 + 4 | 0;
        b5 = c2[f2 >> 2] | 0;
        g2 = g2 + 4 | 0;
        if ((b5 | 0) != (c2[g2 >> 2] | 0))
          do {
            Ic(b5);
            b5 = (c2[f2 >> 2] | 0) + 44 | 0;
            c2[f2 >> 2] = b5;
            d2 = c2[e2 >> 2] | 0;
            if ((b5 - (c2[d2 >> 2] | 0) | 0) == 4092) {
              b5 = d2 + 4 | 0;
              c2[e2 >> 2] = b5;
              b5 = c2[b5 >> 2] | 0;
              c2[f2 >> 2] = b5;
            }
          } while ((b5 | 0) != (c2[g2 >> 2] | 0));
        c2[a3 + 20 >> 2] = 0;
        f2 = a3 + 8 | 0;
        e2 = a3 + 4 | 0;
        d2 = c2[e2 >> 2] | 0;
        b5 = (c2[f2 >> 2] | 0) - d2 >> 2;
        if (b5 >>> 0 > 2)
          do {
            Da(c2[d2 >> 2] | 0, 4092);
            d2 = (c2[e2 >> 2] | 0) + 4 | 0;
            c2[e2 >> 2] = d2;
            b5 = (c2[f2 >> 2] | 0) - d2 >> 2;
          } while (b5 >>> 0 > 2);
        switch (b5 | 0) {
          case 1: {
            b5 = 46;
            h2 = 11;
            break;
          }
          case 2: {
            b5 = 93;
            h2 = 11;
            break;
          }
          default: {
          }
        }
        if ((h2 | 0) == 11)
          c2[a3 + 16 >> 2] = b5;
        V = i2;
        return;
      }
      function Cg(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0;
        g2 = c2[b5 + 4 >> 2] | 0;
        d2 = c2[b5 + 16 >> 2] | 0;
        e2 = (d2 >>> 0) / 93 | 0;
        f2 = g2 + (e2 << 2) | 0;
        if ((c2[b5 + 8 >> 2] | 0) == (g2 | 0))
          b5 = 0;
        else
          b5 = (c2[f2 >> 2] | 0) + ((d2 - (e2 * 93 | 0) | 0) * 44 | 0) | 0;
        c2[a3 >> 2] = f2;
        c2[a3 + 4 >> 2] = b5;
        return;
      }
      function Dg(b5, e2, f2) {
        b5 = b5 | 0;
        e2 = e2 | 0;
        f2 = f2 | 0;
        var g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0, m2 = 0;
        m2 = V;
        V = V + 16 | 0;
        l2 = m2;
        j2 = b5 + 4 | 0;
        if (!(a2[j2 >> 0] | 0)) {
          l2 = De(e2) | 0;
          Ee(l2, f2, c2[b5 >> 2] | 0);
          l2 = c2[b5 >> 2] | 0;
          i2 = f2 + l2 | 0;
          if (!l2)
            g2 = 0;
          else {
            g2 = f2;
            h2 = c2[b5 + 8 >> 2] | 0;
            while (1) {
              a2[h2 >> 0] = a2[g2 >> 0] | 0;
              g2 = g2 + 1 | 0;
              if ((g2 | 0) == (i2 | 0))
                break;
              else
                h2 = h2 + 1 | 0;
            }
            g2 = c2[b5 >> 2] | 0;
          }
          a2[j2 >> 0] = 1;
          f2 = f2 + g2 | 0;
        } else {
          h2 = c2[b5 + 20 >> 2] | 0;
          g2 = c2[b5 + 8 >> 2] | 0;
          Cg(l2, b5 + 32 | 0);
          b5 = b5 + 12 | 0;
          if ((g2 | 0) != (c2[b5 >> 2] | 0)) {
            k2 = l2 + 4 | 0;
            j2 = g2;
            i2 = h2;
            g2 = c2[k2 >> 2] | 0;
            while (1) {
              h2 = d[j2 >> 0] | 0;
              h2 = Eg((Zc(e2, g2) | 0) + h2 | 0) | 0;
              a2[i2 >> 0] = h2;
              a2[f2 >> 0] = h2;
              a2[j2 >> 0] = h2;
              j2 = j2 + 1 | 0;
              f2 = f2 + 1 | 0;
              h2 = c2[l2 >> 2] | 0;
              g2 = (c2[k2 >> 2] | 0) + 44 | 0;
              c2[k2 >> 2] = g2;
              if ((g2 - (c2[h2 >> 2] | 0) | 0) == 4092) {
                g2 = h2 + 4 | 0;
                c2[l2 >> 2] = g2;
                g2 = c2[g2 >> 2] | 0;
                c2[k2 >> 2] = g2;
              }
              if ((j2 | 0) == (c2[b5 >> 2] | 0))
                break;
              else
                i2 = i2 + 1 | 0;
            }
          }
        }
        V = m2;
        return f2 | 0;
      }
      function Eg(a3) {
        a3 = a3 | 0;
        return a3 & 255 | 0;
      }
      function Fg(a3) {
        a3 = a3 | 0;
        pq(a3);
        jp(a3);
        return;
      }
      function Gg(a3) {
        a3 = a3 | 0;
        a3 = c2[a3 + 12 >> 2] | 0;
        if (a3 | 0)
          ca[c2[(c2[a3 >> 2] | 0) + 4 >> 2] & 255](a3);
        return;
      }
      function Hg(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return ((c2[b5 + 4 >> 2] | 0) == 11262 ? a3 + 12 | 0 : 0) | 0;
      }
      function Ig(a3) {
        a3 = a3 | 0;
        Da(a3, 16);
        return;
      }
      function Jg(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c2[a3 >> 2] = 0;
        c2[a3 + 4 >> 2] = 0;
        c2[a3 + 8 >> 2] = 0;
        if (b5 | 0) {
          Yf(a3, b5);
          Lg(a3, b5);
        }
        return;
      }
      function Kg(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        c2[a3 >> 2] = 0;
        c2[a3 + 4 >> 2] = 0;
        c2[a3 + 8 >> 2] = 0;
        c2[a3 + 12 >> 2] = 0;
        c2[a3 + 16 >> 2] = 0;
        c2[a3 + 20 >> 2] = 0;
        if (b5 | 0)
          Mg(a3, b5, d2);
        return;
      }
      function Lg(b5, d2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0, g2 = 0;
        g2 = V;
        V = V + 16 | 0;
        f2 = g2;
        ag(f2, b5, d2);
        d2 = f2 + 4 | 0;
        b5 = c2[d2 >> 2] | 0;
        e2 = f2 + 8 | 0;
        if ((b5 | 0) != (c2[e2 >> 2] | 0))
          do {
            a2[b5 >> 0] = 0;
            b5 = (c2[d2 >> 2] | 0) + 1 | 0;
            c2[d2 >> 2] = b5;
          } while ((b5 | 0) != (c2[e2 >> 2] | 0));
        bg(f2);
        V = g2;
        return;
      }
      function Mg(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0, m2 = 0, n2 = 0, o2 = 0;
        o2 = V;
        V = V + 96 | 0;
        n2 = o2 + 80 | 0;
        k2 = o2 + 64 | 0;
        h2 = o2 + 48 | 0;
        i2 = o2 + 40 | 0;
        j2 = o2 + 8 | 0;
        f2 = o2;
        l2 = o2 + 32 | 0;
        m2 = o2 + 16 | 0;
        e2 = (c2[a3 + 8 >> 2] | 0) - (c2[a3 + 4 >> 2] | 0) | 0;
        e2 = ((e2 | 0) == 0 ? 0 : ((e2 >> 2) * 93 | 0) + -1 | 0) - ((c2[a3 + 20 >> 2] | 0) + (c2[a3 + 16 >> 2] | 0)) | 0;
        if (e2 >>> 0 < b5 >>> 0)
          eg(a3, b5 - e2 | 0);
        fg(i2, a3);
        fg(f2, a3);
        e2 = c2[f2 >> 2] | 0;
        f2 = c2[f2 + 4 >> 2] | 0;
        g2 = j2;
        c2[g2 >> 2] = e2;
        c2[g2 + 4 >> 2] = f2;
        g2 = e2;
        if (b5 | 0) {
          e2 = ((f2 - (c2[e2 >> 2] | 0) | 0) / 44 | 0) + b5 | 0;
          if ((e2 | 0) > 0) {
            b5 = (e2 >>> 0) / 93 | 0;
            g2 = g2 + (b5 << 2) | 0;
            c2[j2 >> 2] = g2;
            e2 = (c2[g2 >> 2] | 0) + ((e2 - (b5 * 93 | 0) | 0) * 44 | 0) | 0;
          } else {
            e2 = 92 - e2 | 0;
            b5 = g2 + (((e2 | 0) / -93 | 0) << 2) | 0;
            c2[j2 >> 2] = b5;
            e2 = (c2[b5 >> 2] | 0) + ((92 - ((e2 | 0) % 93 | 0) | 0) * 44 | 0) | 0;
          }
          c2[j2 + 4 >> 2] = e2;
        }
        c2[k2 >> 2] = c2[i2 >> 2];
        c2[k2 + 4 >> 2] = c2[i2 + 4 >> 2];
        c2[n2 >> 2] = c2[j2 >> 2];
        c2[n2 + 4 >> 2] = c2[j2 + 4 >> 2];
        gg(h2, k2, n2);
        hg(n2, h2);
        ig(k2, h2);
        if (jg(n2, k2) | 0) {
          f2 = m2 + 4 | 0;
          do {
            kg(l2, n2);
            lg(m2, a3, l2);
            e2 = c2[m2 >> 2] | 0;
            if ((e2 | 0) != (c2[f2 >> 2] | 0))
              do {
                Wc(e2, d2);
                e2 = (c2[m2 >> 2] | 0) + 44 | 0;
                c2[m2 >> 2] = e2;
              } while ((e2 | 0) != (c2[f2 >> 2] | 0));
            mg(m2);
            ng(n2) | 0;
          } while (jg(n2, k2) | 0);
        }
        V = o2;
        return;
      }
      function Ng(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        Bg(a3);
        b5 = c2[a3 + 4 >> 2] | 0;
        d2 = c2[a3 + 8 >> 2] | 0;
        if ((b5 | 0) != (d2 | 0))
          do {
            Da(c2[b5 >> 2] | 0, 4092);
            b5 = b5 + 4 | 0;
          } while ((b5 | 0) != (d2 | 0));
        dg(a3);
        return;
      }
      function Og(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        Md(a3);
        c2[a3 >> 2] = 4924;
        c2[a3 + 4 >> 2] = b5;
        c2[a3 + 8 >> 2] = d2;
        return;
      }
      function Pg(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0;
        d2 = V;
        V = V + 16 | 0;
        e2 = d2;
        c2[a3 >> 2] = b5;
        f2 = eq(16) | 0;
        c2[f2 + 4 >> 2] = 0;
        c2[f2 + 8 >> 2] = 0;
        c2[f2 >> 2] = 4944;
        c2[f2 + 12 >> 2] = b5;
        c2[a3 + 4 >> 2] = f2;
        c2[e2 >> 2] = b5;
        c2[e2 + 4 >> 2] = b5;
        Wg(a3, e2);
        V = d2;
        return;
      }
      function Qg(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return Tg(c2[a3 + 8 >> 2] | 0, c2[a3 + 4 >> 2] | 0, b5) | 0;
      }
      function Rg(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        c2[a3 >> 2] = 4924;
        d2 = a3 + 8 | 0;
        b5 = c2[d2 >> 2] | 0;
        c2[d2 >> 2] = 0;
        if (b5 | 0) {
          Vg(b5);
          jp(b5);
        }
        Qd(a3);
        return;
      }
      function Sg(a3) {
        a3 = a3 | 0;
        Rg(a3);
        jp(a3);
        return;
      }
      function Tg(a3, b5, c3) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        return Ug(a3 + 4784 | 0, b5, Be(a3, b5, c3) | 0) | 0;
      }
      function Ug(b5, c3, d2) {
        b5 = b5 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        if (a2[b5 >> 0] | 0) {
          nc(c3);
          a2[b5 >> 0] = 0;
        }
        return d2 | 0;
      }
      function Vg(a3) {
        a3 = a3 | 0;
        ze(a3);
        return;
      }
      function Wg(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return;
      }
      function Xg(a3) {
        a3 = a3 | 0;
        pq(a3);
        jp(a3);
        return;
      }
      function Yg(a3) {
        a3 = a3 | 0;
        a3 = c2[a3 + 12 >> 2] | 0;
        if (a3 | 0)
          ca[c2[(c2[a3 >> 2] | 0) + 8 >> 2] & 255](a3);
        return;
      }
      function Zg(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return ((c2[b5 + 4 >> 2] | 0) == 12004 ? a3 + 12 | 0 : 0) | 0;
      }
      function _g(a3) {
        a3 = a3 | 0;
        Da(a3, 16);
        return;
      }
      function $g(b5) {
        b5 = b5 | 0;
        a2[b5 >> 0] = 1;
        return;
      }
      function ah(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        Md(a3);
        c2[a3 >> 2] = 4972;
        c2[a3 + 4 >> 2] = b5;
        c2[a3 + 8 >> 2] = d2;
        return;
      }
      function bh(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0;
        d2 = V;
        V = V + 16 | 0;
        e2 = d2;
        c2[a3 >> 2] = b5;
        f2 = eq(16) | 0;
        c2[f2 + 4 >> 2] = 0;
        c2[f2 + 8 >> 2] = 0;
        c2[f2 >> 2] = 4992;
        c2[f2 + 12 >> 2] = b5;
        c2[a3 + 4 >> 2] = f2;
        c2[e2 >> 2] = b5;
        c2[e2 + 4 >> 2] = b5;
        Wg(a3, e2);
        V = d2;
        return;
      }
      function ch(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return fh(c2[a3 + 8 >> 2] | 0, c2[a3 + 4 >> 2] | 0, b5) | 0;
      }
      function dh(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        c2[a3 >> 2] = 4972;
        d2 = a3 + 8 | 0;
        b5 = c2[d2 >> 2] | 0;
        c2[d2 >> 2] = 0;
        if (b5 | 0) {
          hh(b5);
          jp(b5);
        }
        Qd(a3);
        return;
      }
      function eh(a3) {
        a3 = a3 | 0;
        dh(a3);
        jp(a3);
        return;
      }
      function fh(a3, b5, c3) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        return gh(a3 + 4784 | 0, b5, Be(a3, b5, c3) | 0) | 0;
      }
      function gh(a3, b5, c3) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        return Ug(a3 + 328 | 0, b5, qf(a3, b5, c3) | 0) | 0;
      }
      function hh(a3) {
        a3 = a3 | 0;
        ih(a3 + 4784 | 0);
        ze(a3);
        return;
      }
      function ih(a3) {
        a3 = a3 | 0;
        of(a3);
        return;
      }
      function jh(a3) {
        a3 = a3 | 0;
        pq(a3);
        jp(a3);
        return;
      }
      function kh(a3) {
        a3 = a3 | 0;
        a3 = c2[a3 + 12 >> 2] | 0;
        if (a3 | 0)
          ca[c2[(c2[a3 >> 2] | 0) + 8 >> 2] & 255](a3);
        return;
      }
      function lh(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return ((c2[b5 + 4 >> 2] | 0) == 12827 ? a3 + 12 | 0 : 0) | 0;
      }
      function mh(a3) {
        a3 = a3 | 0;
        Da(a3, 16);
        return;
      }
      function nh(a3) {
        a3 = a3 | 0;
        cf(a3);
        $g(a3 + 328 | 0);
        return;
      }
      function oh(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        Md(a3);
        c2[a3 >> 2] = 5020;
        c2[a3 + 4 >> 2] = b5;
        c2[a3 + 8 >> 2] = d2;
        return;
      }
      function ph(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0;
        d2 = V;
        V = V + 16 | 0;
        e2 = d2;
        c2[a3 >> 2] = b5;
        f2 = eq(16) | 0;
        c2[f2 + 4 >> 2] = 0;
        c2[f2 + 8 >> 2] = 0;
        c2[f2 >> 2] = 5040;
        c2[f2 + 12 >> 2] = b5;
        c2[a3 + 4 >> 2] = f2;
        c2[e2 >> 2] = b5;
        c2[e2 + 4 >> 2] = b5;
        Wg(a3, e2);
        V = d2;
        return;
      }
      function qh(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return th(c2[a3 + 8 >> 2] | 0, c2[a3 + 4 >> 2] | 0, b5) | 0;
      }
      function rh(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        c2[a3 >> 2] = 5020;
        d2 = a3 + 8 | 0;
        b5 = c2[d2 >> 2] | 0;
        c2[d2 >> 2] = 0;
        if (b5 | 0) {
          vh(b5);
          jp(b5);
        }
        Qd(a3);
        return;
      }
      function sh(a3) {
        a3 = a3 | 0;
        rh(a3);
        jp(a3);
        return;
      }
      function th(a3, b5, c3) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        return uh(a3 + 4784 | 0, b5, Be(a3, b5, c3) | 0) | 0;
      }
      function uh(a3, b5, c3) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        return Ug(a3 + 316 | 0, b5, If(a3, b5, c3) | 0) | 0;
      }
      function vh(a3) {
        a3 = a3 | 0;
        wh(a3 + 4784 | 0);
        ze(a3);
        return;
      }
      function wh(a3) {
        a3 = a3 | 0;
        Hf(a3);
        return;
      }
      function xh(a3) {
        a3 = a3 | 0;
        pq(a3);
        jp(a3);
        return;
      }
      function yh(a3) {
        a3 = a3 | 0;
        a3 = c2[a3 + 12 >> 2] | 0;
        if (a3 | 0)
          ca[c2[(c2[a3 >> 2] | 0) + 8 >> 2] & 255](a3);
        return;
      }
      function zh(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return ((c2[b5 + 4 >> 2] | 0) == 13672 ? a3 + 12 | 0 : 0) | 0;
      }
      function Ah(a3) {
        a3 = a3 | 0;
        Da(a3, 16);
        return;
      }
      function Bh(a3) {
        a3 = a3 | 0;
        Cf(a3);
        $g(a3 + 316 | 0);
        return;
      }
      function Ch(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        Md(a3);
        c2[a3 >> 2] = 5068;
        c2[a3 + 4 >> 2] = b5;
        c2[a3 + 8 >> 2] = d2;
        return;
      }
      function Dh(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0;
        d2 = V;
        V = V + 16 | 0;
        e2 = d2;
        c2[a3 >> 2] = b5;
        f2 = eq(16) | 0;
        c2[f2 + 4 >> 2] = 0;
        c2[f2 + 8 >> 2] = 0;
        c2[f2 >> 2] = 5088;
        c2[f2 + 12 >> 2] = b5;
        c2[a3 + 4 >> 2] = f2;
        c2[e2 >> 2] = b5;
        c2[e2 + 4 >> 2] = b5;
        Wg(a3, e2);
        V = d2;
        return;
      }
      function Eh(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return Hh(c2[a3 + 8 >> 2] | 0, c2[a3 + 4 >> 2] | 0, b5) | 0;
      }
      function Fh(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        c2[a3 >> 2] = 5068;
        d2 = a3 + 8 | 0;
        b5 = c2[d2 >> 2] | 0;
        c2[d2 >> 2] = 0;
        if (b5 | 0) {
          Jh(b5);
          jp(b5);
        }
        Qd(a3);
        return;
      }
      function Gh(a3) {
        a3 = a3 | 0;
        Fh(a3);
        jp(a3);
        return;
      }
      function Hh(a3, b5, c3) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        return Ih(a3 + 4784 | 0, b5, Be(a3, b5, c3) | 0) | 0;
      }
      function Ih(a3, b5, c3) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        return uh(a3 + 328 | 0, b5, qf(a3, b5, c3) | 0) | 0;
      }
      function Jh(a3) {
        a3 = a3 | 0;
        Kh(a3 + 4784 | 0);
        ze(a3);
        return;
      }
      function Kh(a3) {
        a3 = a3 | 0;
        wh(a3 + 328 | 0);
        of(a3);
        return;
      }
      function Lh(a3) {
        a3 = a3 | 0;
        pq(a3);
        jp(a3);
        return;
      }
      function Mh(a3) {
        a3 = a3 | 0;
        a3 = c2[a3 + 12 >> 2] | 0;
        if (a3 | 0)
          ca[c2[(c2[a3 >> 2] | 0) + 8 >> 2] & 255](a3);
        return;
      }
      function Nh(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return ((c2[b5 + 4 >> 2] | 0) == 14573 ? a3 + 12 | 0 : 0) | 0;
      }
      function Oh(a3) {
        a3 = a3 | 0;
        Da(a3, 16);
        return;
      }
      function Ph(a3) {
        a3 = a3 | 0;
        cf(a3);
        Bh(a3 + 328 | 0);
        return;
      }
      function Qh(a3) {
        a3 = a3 | 0;
        return a3 + 20 | 0;
      }
      function Rh(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        c2[a3 >> 2] = b5;
        c2[a3 + 4 >> 2] = d2;
        c2[a3 + 8 >> 2] = 0;
        return;
      }
      function Sh(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c2[a3 >> 2] = b5;
        c2[a3 + 4 >> 2] = 0;
        c2[a3 + 8 >> 2] = -1;
        return;
      }
      function Th(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0;
        d2 = V;
        V = V + 16 | 0;
        e2 = d2 + 4 | 0;
        g2 = d2;
        f2 = eq(24) | 0;
        ii(f2, b5);
        c2[g2 >> 2] = 0;
        c2[e2 >> 2] = c2[g2 >> 2];
        ji(a3, f2, e2);
        V = d2;
        return;
      }
      function Uh(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        a3 = c2[a3 + 4 >> 2] | 0;
        if (a3 | 0 ? (d2 = a3 + 4 | 0, b5 = c2[d2 >> 2] | 0, c2[d2 >> 2] = b5 + -1, (b5 | 0) == 0) : 0) {
          ca[c2[(c2[a3 >> 2] | 0) + 8 >> 2] & 255](a3);
          qq(a3);
        }
        return;
      }
      function Vh(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0;
        d2 = V;
        V = V + 16 | 0;
        e2 = d2;
        c2[a3 >> 2] = b5;
        f2 = eq(16) | 0;
        c2[f2 + 4 >> 2] = 0;
        c2[f2 + 8 >> 2] = 0;
        c2[f2 >> 2] = 5116;
        c2[f2 + 12 >> 2] = b5;
        c2[a3 + 4 >> 2] = f2;
        c2[e2 >> 2] = b5;
        c2[e2 + 4 >> 2] = b5;
        Xh(a3, e2);
        V = d2;
        return;
      }
      function Wh(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        a3 = c2[a3 + 4 >> 2] | 0;
        if (a3 | 0 ? (d2 = a3 + 4 | 0, b5 = c2[d2 >> 2] | 0, c2[d2 >> 2] = b5 + -1, (b5 | 0) == 0) : 0) {
          ca[c2[(c2[a3 >> 2] | 0) + 8 >> 2] & 255](a3);
          qq(a3);
        }
        return;
      }
      function Xh(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return;
      }
      function Yh(a3) {
        a3 = a3 | 0;
        pq(a3);
        jp(a3);
        return;
      }
      function Zh(a3) {
        a3 = a3 | 0;
        a3 = c2[a3 + 12 >> 2] | 0;
        if (a3 | 0)
          jp(a3);
        return;
      }
      function _h(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return ((c2[b5 + 4 >> 2] | 0) == 14966 ? a3 + 12 | 0 : 0) | 0;
      }
      function $h(a3) {
        a3 = a3 | 0;
        Da(a3, 16);
        return;
      }
      function ai(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0;
        d2 = V;
        V = V + 16 | 0;
        e2 = d2;
        c2[a3 >> 2] = b5;
        f2 = eq(16) | 0;
        c2[f2 + 4 >> 2] = 0;
        c2[f2 + 8 >> 2] = 0;
        c2[f2 >> 2] = 5144;
        c2[f2 + 12 >> 2] = b5;
        c2[a3 + 4 >> 2] = f2;
        c2[e2 >> 2] = b5;
        c2[e2 + 4 >> 2] = b5;
        ci(a3, e2);
        V = d2;
        return;
      }
      function bi(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        a3 = c2[a3 + 4 >> 2] | 0;
        if (a3 | 0 ? (d2 = a3 + 4 | 0, b5 = c2[d2 >> 2] | 0, c2[d2 >> 2] = b5 + -1, (b5 | 0) == 0) : 0) {
          ca[c2[(c2[a3 >> 2] | 0) + 8 >> 2] & 255](a3);
          qq(a3);
        }
        return;
      }
      function ci(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return;
      }
      function di(a3) {
        a3 = a3 | 0;
        pq(a3);
        jp(a3);
        return;
      }
      function ei(a3) {
        a3 = a3 | 0;
        a3 = c2[a3 + 12 >> 2] | 0;
        if (a3 | 0) {
          hi(a3);
          jp(a3);
        }
        return;
      }
      function fi(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return ((c2[b5 + 4 >> 2] | 0) == 15127 ? a3 + 12 | 0 : 0) | 0;
      }
      function gi(a3) {
        a3 = a3 | 0;
        Da(a3, 16);
        return;
      }
      function hi(a3) {
        a3 = a3 | 0;
        return;
      }
      function ii(b5, d2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        Md(b5);
        c2[b5 >> 2] = 5172;
        c2[b5 + 4 >> 2] = d2;
        c2[b5 + 8 >> 2] = 0;
        c2[b5 + 12 >> 2] = 0;
        c2[b5 + 16 >> 2] = 0;
        a2[b5 + 20 >> 0] = 1;
        return;
      }
      function ji(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0;
        d2 = V;
        V = V + 16 | 0;
        e2 = d2;
        c2[a3 >> 2] = b5;
        f2 = eq(16) | 0;
        c2[f2 + 4 >> 2] = 0;
        c2[f2 + 8 >> 2] = 0;
        c2[f2 >> 2] = 5192;
        c2[f2 + 12 >> 2] = b5;
        c2[a3 + 4 >> 2] = f2;
        c2[e2 >> 2] = b5;
        c2[e2 + 4 >> 2] = b5;
        pi(a3, e2);
        V = d2;
        return;
      }
      function ki(b5, d2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0;
        k2 = V;
        V = V + 16 | 0;
        h2 = k2;
        e2 = c2[b5 + 8 >> 2] | 0;
        i2 = c2[b5 + 12 >> 2] | 0;
        if ((e2 | 0) != (i2 | 0)) {
          j2 = h2 + 4 | 0;
          do {
            f2 = c2[e2 >> 2] | 0;
            c2[h2 >> 2] = f2;
            g2 = c2[e2 + 4 >> 2] | 0;
            c2[j2 >> 2] = g2;
            if (g2 | 0) {
              g2 = g2 + 4 | 0;
              c2[g2 >> 2] = (c2[g2 >> 2] | 0) + 1;
            }
            d2 = $[c2[(c2[f2 >> 2] | 0) + 12 >> 2] & 63](f2, d2) | 0;
            Sd(h2);
            e2 = e2 + 8 | 0;
          } while ((e2 | 0) != (i2 | 0));
        }
        e2 = b5 + 20 | 0;
        if (a2[e2 >> 0] | 0) {
          a2[e2 >> 0] = 0;
          ni(c2[b5 + 4 >> 2] | 0);
        }
        V = k2;
        return d2 | 0;
      }
      function li(a3) {
        a3 = a3 | 0;
        c2[a3 >> 2] = 5172;
        Td(a3 + 8 | 0);
        Qd(a3);
        return;
      }
      function mi(a3) {
        a3 = a3 | 0;
        li(a3);
        jp(a3);
        return;
      }
      function ni(a3) {
        a3 = a3 | 0;
        var b5 = 0;
        b5 = ((oi(c2[a3 >> 2] | 0) | 0) & 255) << 24;
        b5 = ((oi(c2[a3 >> 2] | 0) | 0) & 255) << 16 | b5;
        b5 = b5 | ((oi(c2[a3 >> 2] | 0) | 0) & 255) << 8;
        c2[a3 + 4 >> 2] = b5 | (oi(c2[a3 >> 2] | 0) | 0) & 255;
        return;
      }
      function oi(b5) {
        b5 = b5 | 0;
        var d2 = 0, e2 = 0;
        d2 = c2[b5 >> 2] | 0;
        e2 = b5 + 8 | 0;
        b5 = c2[e2 >> 2] | 0;
        c2[e2 >> 2] = b5 + 1;
        return a2[d2 + b5 >> 0] | 0;
      }
      function pi(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return;
      }
      function qi(a3) {
        a3 = a3 | 0;
        pq(a3);
        jp(a3);
        return;
      }
      function ri(a3) {
        a3 = a3 | 0;
        a3 = c2[a3 + 12 >> 2] | 0;
        if (a3 | 0)
          ca[c2[(c2[a3 >> 2] | 0) + 8 >> 2] & 255](a3);
        return;
      }
      function si(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return ((c2[b5 + 4 >> 2] | 0) == 15450 ? a3 + 12 | 0 : 0) | 0;
      }
      function ti(a3) {
        a3 = a3 | 0;
        Da(a3, 16);
        return;
      }
      function ui(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0;
        j2 = V;
        V = V + 32 | 0;
        e2 = j2 + 12 | 0;
        f2 = j2;
        b5 = j2 + 8 | 0;
        h2 = eq(180) | 0;
        wi(h2, c2[a3 + 4 >> 2] | 0);
        g2 = a3 + 8 | 0;
        c2[b5 >> 2] = 0;
        c2[e2 >> 2] = c2[b5 >> 2];
        xi(f2, h2, e2);
        h2 = a3 + 12 | 0;
        b5 = c2[h2 >> 2] | 0;
        i2 = a3 + 16 | 0;
        do
          if (b5 >>> 0 >= (c2[i2 >> 2] | 0) >>> 0) {
            b5 = (b5 - (c2[g2 >> 2] | 0) >> 3) + 1 | 0;
            d2 = ee(g2) | 0;
            if (d2 >>> 0 < b5 >>> 0)
              cr(g2);
            else {
              k2 = c2[g2 >> 2] | 0;
              l2 = (c2[i2 >> 2] | 0) - k2 | 0;
              i2 = l2 >> 2;
              be(e2, l2 >> 3 >>> 0 < d2 >>> 1 >>> 0 ? i2 >>> 0 < b5 >>> 0 ? b5 : i2 : d2, (c2[h2 >> 2] | 0) - k2 >> 3, a3 + 16 | 0);
              i2 = e2 + 8 | 0;
              h2 = c2[i2 >> 2] | 0;
              c2[h2 >> 2] = c2[f2 >> 2];
              a3 = f2 + 4 | 0;
              c2[h2 + 4 >> 2] = c2[a3 >> 2];
              c2[f2 >> 2] = 0;
              c2[a3 >> 2] = 0;
              c2[i2 >> 2] = h2 + 8;
              ce(g2, e2);
              de(e2);
              break;
            }
          } else {
            $d(e2, g2, 1);
            l2 = e2 + 4 | 0;
            k2 = c2[l2 >> 2] | 0;
            c2[k2 >> 2] = c2[f2 >> 2];
            i2 = f2 + 4 | 0;
            c2[k2 + 4 >> 2] = c2[i2 >> 2];
            c2[f2 >> 2] = 0;
            c2[i2 >> 2] = 0;
            c2[l2 >> 2] = k2 + 8;
            ae(e2);
          }
        while (0);
        Sd(f2);
        V = j2;
        return;
      }
      function vi(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0;
        j2 = V;
        V = V + 32 | 0;
        e2 = j2 + 12 | 0;
        f2 = j2;
        b5 = j2 + 8 | 0;
        h2 = eq(180) | 0;
        Ui(h2, c2[a3 + 4 >> 2] | 0);
        g2 = a3 + 8 | 0;
        c2[b5 >> 2] = 0;
        c2[e2 >> 2] = c2[b5 >> 2];
        Vi(f2, h2, e2);
        h2 = a3 + 12 | 0;
        b5 = c2[h2 >> 2] | 0;
        i2 = a3 + 16 | 0;
        do
          if (b5 >>> 0 >= (c2[i2 >> 2] | 0) >>> 0) {
            b5 = (b5 - (c2[g2 >> 2] | 0) >> 3) + 1 | 0;
            d2 = ee(g2) | 0;
            if (d2 >>> 0 < b5 >>> 0)
              cr(g2);
            else {
              k2 = c2[g2 >> 2] | 0;
              l2 = (c2[i2 >> 2] | 0) - k2 | 0;
              i2 = l2 >> 2;
              be(e2, l2 >> 3 >>> 0 < d2 >>> 1 >>> 0 ? i2 >>> 0 < b5 >>> 0 ? b5 : i2 : d2, (c2[h2 >> 2] | 0) - k2 >> 3, a3 + 16 | 0);
              i2 = e2 + 8 | 0;
              h2 = c2[i2 >> 2] | 0;
              c2[h2 >> 2] = c2[f2 >> 2];
              a3 = f2 + 4 | 0;
              c2[h2 + 4 >> 2] = c2[a3 >> 2];
              c2[f2 >> 2] = 0;
              c2[a3 >> 2] = 0;
              c2[i2 >> 2] = h2 + 8;
              ce(g2, e2);
              de(e2);
              break;
            }
          } else {
            $d(e2, g2, 1);
            l2 = e2 + 4 | 0;
            k2 = c2[l2 >> 2] | 0;
            c2[k2 >> 2] = c2[f2 >> 2];
            i2 = f2 + 4 | 0;
            c2[k2 + 4 >> 2] = c2[i2 >> 2];
            c2[f2 >> 2] = 0;
            c2[i2 >> 2] = 0;
            c2[l2 >> 2] = k2 + 8;
            ae(e2);
          }
        while (0);
        Sd(f2);
        V = j2;
        return;
      }
      function wi(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        fe(a3);
        c2[a3 >> 2] = 5220;
        c2[a3 + 4 >> 2] = b5;
        yi(a3 + 8 | 0);
        return;
      }
      function xi(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0;
        d2 = V;
        V = V + 16 | 0;
        e2 = d2;
        c2[a3 >> 2] = b5;
        f2 = eq(16) | 0;
        c2[f2 + 4 >> 2] = 0;
        c2[f2 + 8 >> 2] = 0;
        c2[f2 >> 2] = 5244;
        c2[f2 + 12 >> 2] = b5;
        c2[a3 + 4 >> 2] = f2;
        c2[e2 >> 2] = b5;
        c2[e2 + 4 >> 2] = b5;
        Xe(a3, e2);
        V = d2;
        return;
      }
      function yi(b5) {
        b5 = b5 | 0;
        xe(b5, 32, 1, 8, 0);
        mc(b5 + 80 | 0, 32, 1, 8, 0);
        a2[b5 + 160 >> 0] = 0;
        a2[b5 + 161 >> 0] = 0;
        Ci(b5 + 164 | 0);
        return;
      }
      function zi(a3) {
        a3 = a3 | 0;
        c2[a3 >> 2] = 5220;
        Di(a3 + 8 | 0);
        le(a3);
        return;
      }
      function Ai(a3) {
        a3 = a3 | 0;
        zi(a3);
        jp(a3);
        return;
      }
      function Bi(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return Ei(a3 + 8 | 0, c2[a3 + 4 >> 2] | 0, b5) | 0;
      }
      function Ci(b5) {
        b5 = b5 | 0;
        a2[b5 + 4 >> 0] = 0;
        return;
      }
      function Di(a3) {
        a3 = a3 | 0;
        qc(a3 + 80 | 0);
        ye(a3);
        return;
      }
      function Ei(b5, d2, e2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f2 = 0, g2 = 0, h2 = 0;
        h2 = V;
        V = V + 16 | 0;
        f2 = h2;
        if (!(a2[b5 + 161 >> 0] | 0))
          oc(b5 + 80 | 0);
        g2 = b5 + 164 | 0;
        if (Fi(g2) | 0) {
          d2 = Gi(b5 + 80 | 0, d2, c2[g2 >> 2] | 0, 0) | 0;
          c2[f2 >> 2] = d2;
          Se(d2, e2);
        } else {
          Ii(Hi(d2) | 0, e2, 4);
          c2[f2 >> 2] = Ne(e2) | 0;
        }
        Ji(g2, f2);
        V = h2;
        return e2 + 4 | 0;
      }
      function Fi(b5) {
        b5 = b5 | 0;
        return (a2[b5 + 4 >> 0] | 0) != 0 | 0;
      }
      function Gi(a3, b5, d2, e2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        d2 = (Ki(a3, b5, (c2[a3 + 36 >> 2] | 0) + (e2 * 44 | 0) | 0) | 0) + d2 | 0;
        b5 = c2[a3 + 24 >> 2] | 0;
        if ((d2 | 0) < 0)
          return d2 + b5 | 0;
        else
          return d2 - (d2 >>> 0 < b5 >>> 0 ? 0 : b5) | 0;
        return 0;
      }
      function Hi(a3) {
        a3 = a3 | 0;
        return c2[a3 >> 2] | 0;
      }
      function Ii(b5, c3, d2) {
        b5 = b5 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var e2 = 0;
        if ((d2 | 0) > 0) {
          e2 = 0;
          do {
            a2[c3 + e2 >> 0] = oi(b5) | 0;
            e2 = e2 + 1 | 0;
          } while ((e2 | 0) != (d2 | 0));
        }
        return;
      }
      function Ji(b5, d2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0;
        e2 = b5 + 4 | 0;
        if (!(a2[e2 >> 0] | 0))
          a2[e2 >> 0] = 1;
        c2[b5 >> 2] = c2[d2 >> 2];
        return;
      }
      function Ki(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0;
        d2 = Li(b5, d2) | 0;
        c2[a3 >> 2] = d2;
        do
          if (d2) {
            if (d2 >>> 0 >= 32) {
              d2 = c2[a3 + 28 >> 2] | 0;
              break;
            }
            e2 = c2[a3 + 12 >> 2] | 0;
            if (d2 >>> 0 > e2 >>> 0) {
              e2 = d2 - e2 | 0;
              d2 = Li(b5, (c2[a3 + 68 >> 2] | 0) + ((d2 + -1 | 0) * 44 | 0) | 0) | 0;
              e2 = d2 << e2 | (Mi(b5, e2) | 0);
            } else
              e2 = Li(b5, (c2[a3 + 68 >> 2] | 0) + ((d2 + -1 | 0) * 44 | 0) | 0) | 0;
            d2 = c2[a3 >> 2] | 0;
            if ((e2 | 0) < (1 << d2 + -1 | 0)) {
              d2 = e2 + 1 + (-1 << d2) | 0;
              break;
            } else {
              d2 = e2 + 1 | 0;
              break;
            }
          } else
            d2 = Ni(b5, a3 + 48 | 0) | 0;
        while (0);
        return d2 | 0;
      }
      function Li(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0, m2 = 0, n2 = 0, o2 = 0;
        n2 = a3 + 8 | 0;
        m2 = c2[n2 >> 2] | 0;
        f2 = c2[b5 + 16 >> 2] | 0;
        if (f2) {
          e2 = a3 + 4 | 0;
          d2 = c2[e2 >> 2] | 0;
          l2 = m2 >>> 15;
          c2[n2 >> 2] = l2;
          j2 = (d2 >>> 0) / (l2 >>> 0) | 0;
          i2 = j2 >>> (c2[b5 + 40 >> 2] | 0);
          g2 = c2[f2 + (i2 << 2) >> 2] | 0;
          i2 = (c2[f2 + (i2 + 1 << 2) >> 2] | 0) + 1 | 0;
          h2 = g2 + 1 | 0;
          k2 = c2[b5 + 8 >> 2] | 0;
          if (i2 >>> 0 > h2 >>> 0) {
            f2 = g2;
            g2 = i2;
            do {
              h2 = (g2 + f2 | 0) >>> 1;
              i2 = (c2[k2 + (h2 << 2) >> 2] | 0) >>> 0 > j2 >>> 0;
              f2 = i2 ? f2 : h2;
              g2 = i2 ? h2 : g2;
              h2 = f2 + 1 | 0;
            } while (g2 >>> 0 > h2 >>> 0);
            g2 = f2;
          }
          f2 = q(c2[k2 + (g2 << 2) >> 2] | 0, l2) | 0;
          if ((g2 | 0) == (c2[b5 + 32 >> 2] | 0))
            h2 = m2;
          else
            h2 = q(c2[k2 + (h2 << 2) >> 2] | 0, l2) | 0;
        } else {
          k2 = m2 >>> 15;
          c2[n2 >> 2] = k2;
          i2 = c2[b5 >> 2] | 0;
          l2 = c2[b5 + 8 >> 2] | 0;
          e2 = a3 + 4 | 0;
          d2 = c2[e2 >> 2] | 0;
          j2 = i2 >>> 1;
          f2 = 0;
          h2 = m2;
          g2 = 0;
          do {
            o2 = q(c2[l2 + (j2 << 2) >> 2] | 0, k2) | 0;
            m2 = o2 >>> 0 > d2 >>> 0;
            h2 = m2 ? o2 : h2;
            f2 = m2 ? f2 : o2;
            g2 = m2 ? g2 : j2;
            i2 = m2 ? j2 : i2;
            j2 = (g2 + i2 | 0) >>> 1;
          } while ((j2 | 0) != (g2 | 0));
        }
        c2[e2 >> 2] = d2 - f2;
        o2 = h2 - f2 | 0;
        c2[n2 >> 2] = o2;
        if (o2 >>> 0 < 16777216)
          Oi(a3);
        n2 = (c2[b5 + 12 >> 2] | 0) + (g2 << 2) | 0;
        c2[n2 >> 2] = (c2[n2 >> 2] | 0) + 1;
        n2 = b5 + 28 | 0;
        o2 = (c2[n2 >> 2] | 0) + -1 | 0;
        c2[n2 >> 2] = o2;
        if (!o2)
          Xc(b5);
        return g2 | 0;
      }
      function Mi(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0;
        if (b5 >>> 0 > 19) {
          d2 = (Pi(a3) | 0) & 65535;
          return (Mi(a3, b5 + -16 | 0) | 0) << 16 | d2 | 0;
        }
        e2 = a3 + 4 | 0;
        f2 = c2[e2 >> 2] | 0;
        g2 = a3 + 8 | 0;
        d2 = (c2[g2 >> 2] | 0) >>> b5;
        c2[g2 >> 2] = d2;
        b5 = (f2 >>> 0) / (d2 >>> 0) | 0;
        c2[e2 >> 2] = f2 - (q(b5, d2) | 0);
        if (d2 >>> 0 < 16777216)
          Oi(a3);
        return b5 | 0;
      }
      function Ni(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0;
        e2 = a3 + 8 | 0;
        f2 = c2[e2 >> 2] | 0;
        d2 = q(f2 >>> 13, c2[b5 + 8 >> 2] | 0) | 0;
        g2 = a3 + 4 | 0;
        h2 = c2[g2 >> 2] | 0;
        i2 = h2 >>> 0 >= d2 >>> 0;
        if (i2) {
          c2[g2 >> 2] = h2 - d2;
          d2 = f2 - d2 | 0;
          c2[e2 >> 2] = d2;
        } else {
          c2[e2 >> 2] = d2;
          h2 = b5 + 12 | 0;
          c2[h2 >> 2] = (c2[h2 >> 2] | 0) + 1;
        }
        if (d2 >>> 0 < 16777216)
          Oi(a3);
        h2 = b5 + 4 | 0;
        a3 = (c2[h2 >> 2] | 0) + -1 | 0;
        c2[h2 >> 2] = a3;
        if (!a3)
          cd(b5);
        return i2 & 1 | 0;
      }
      function Oi(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0, f2 = 0;
        b5 = a3 + 4 | 0;
        d2 = a3 + 8 | 0;
        e2 = c2[b5 >> 2] | 0;
        do {
          e2 = e2 << 8 | (oi(c2[a3 >> 2] | 0) | 0) & 255;
          c2[b5 >> 2] = e2;
          f2 = c2[d2 >> 2] << 8;
          c2[d2 >> 2] = f2;
        } while (f2 >>> 0 < 16777216);
        return;
      }
      function Pi(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0, f2 = 0;
        d2 = a3 + 4 | 0;
        f2 = c2[d2 >> 2] | 0;
        b5 = a3 + 8 | 0;
        e2 = (c2[b5 >> 2] | 0) >>> 16;
        c2[b5 >> 2] = e2;
        b5 = (f2 >>> 0) / (e2 >>> 0) | 0;
        c2[d2 >> 2] = f2 - (q(b5, e2) | 0);
        Oi(a3);
        return b5 & 65535 | 0;
      }
      function Qi(a3) {
        a3 = a3 | 0;
        pq(a3);
        jp(a3);
        return;
      }
      function Ri(a3) {
        a3 = a3 | 0;
        a3 = c2[a3 + 12 >> 2] | 0;
        if (a3 | 0)
          ca[c2[(c2[a3 >> 2] | 0) + 4 >> 2] & 255](a3);
        return;
      }
      function Si(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return ((c2[b5 + 4 >> 2] | 0) == 15904 ? a3 + 12 | 0 : 0) | 0;
      }
      function Ti(a3) {
        a3 = a3 | 0;
        Da(a3, 16);
        return;
      }
      function Ui(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        fe(a3);
        c2[a3 >> 2] = 5272;
        c2[a3 + 4 >> 2] = b5;
        Wi(a3 + 8 | 0);
        return;
      }
      function Vi(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0;
        d2 = V;
        V = V + 16 | 0;
        e2 = d2;
        c2[a3 >> 2] = b5;
        f2 = eq(16) | 0;
        c2[f2 + 4 >> 2] = 0;
        c2[f2 + 8 >> 2] = 0;
        c2[f2 >> 2] = 5296;
        c2[f2 + 12 >> 2] = b5;
        c2[a3 + 4 >> 2] = f2;
        c2[e2 >> 2] = b5;
        c2[e2 + 4 >> 2] = b5;
        Xe(a3, e2);
        V = d2;
        return;
      }
      function Wi(b5) {
        b5 = b5 | 0;
        xe(b5, 32, 1, 8, 0);
        mc(b5 + 80 | 0, 32, 1, 8, 0);
        a2[b5 + 160 >> 0] = 0;
        a2[b5 + 161 >> 0] = 0;
        _i(b5 + 164 | 0);
        return;
      }
      function Xi(a3) {
        a3 = a3 | 0;
        c2[a3 >> 2] = 5272;
        $i(a3 + 8 | 0);
        le(a3);
        return;
      }
      function Yi(a3) {
        a3 = a3 | 0;
        Xi(a3);
        jp(a3);
        return;
      }
      function Zi(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return aj(a3 + 8 | 0, c2[a3 + 4 >> 2] | 0, b5) | 0;
      }
      function _i(b5) {
        b5 = b5 | 0;
        a2[b5 + 4 >> 0] = 0;
        return;
      }
      function $i(a3) {
        a3 = a3 | 0;
        qc(a3 + 80 | 0);
        ye(a3);
        return;
      }
      function aj(b5, d2, e2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f2 = 0, g2 = 0, h2 = 0;
        h2 = V;
        V = V + 16 | 0;
        f2 = h2;
        if (!(a2[b5 + 161 >> 0] | 0))
          oc(b5 + 80 | 0);
        g2 = b5 + 164 | 0;
        if (bj(g2) | 0) {
          d2 = Gi(b5 + 80 | 0, d2, c2[g2 >> 2] | 0, 0) | 0;
          c2[f2 >> 2] = d2;
          We(d2, e2);
        } else {
          Ii(Hi(d2) | 0, e2, 4);
          c2[f2 >> 2] = Re(e2) | 0;
        }
        cj(g2, f2);
        V = h2;
        return e2 + 4 | 0;
      }
      function bj(b5) {
        b5 = b5 | 0;
        return (a2[b5 + 4 >> 0] | 0) != 0 | 0;
      }
      function cj(b5, d2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0;
        e2 = b5 + 4 | 0;
        if (!(a2[e2 >> 0] | 0))
          a2[e2 >> 0] = 1;
        c2[b5 >> 2] = c2[d2 >> 2];
        return;
      }
      function dj(a3) {
        a3 = a3 | 0;
        pq(a3);
        jp(a3);
        return;
      }
      function ej(a3) {
        a3 = a3 | 0;
        a3 = c2[a3 + 12 >> 2] | 0;
        if (a3 | 0)
          ca[c2[(c2[a3 >> 2] | 0) + 4 >> 2] & 255](a3);
        return;
      }
      function fj(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return ((c2[b5 + 4 >> 2] | 0) == 16402 ? a3 + 12 | 0 : 0) | 0;
      }
      function gj(a3) {
        a3 = a3 | 0;
        Da(a3, 16);
        return;
      }
      function hj(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0;
        j2 = V;
        V = V + 32 | 0;
        e2 = j2 + 12 | 0;
        f2 = j2;
        b5 = j2 + 8 | 0;
        h2 = eq(172) | 0;
        jj(h2, c2[a3 + 4 >> 2] | 0);
        g2 = a3 + 8 | 0;
        c2[b5 >> 2] = 0;
        c2[e2 >> 2] = c2[b5 >> 2];
        kj(f2, h2, e2);
        h2 = a3 + 12 | 0;
        b5 = c2[h2 >> 2] | 0;
        i2 = a3 + 16 | 0;
        do
          if (b5 >>> 0 >= (c2[i2 >> 2] | 0) >>> 0) {
            b5 = (b5 - (c2[g2 >> 2] | 0) >> 3) + 1 | 0;
            d2 = ee(g2) | 0;
            if (d2 >>> 0 < b5 >>> 0)
              cr(g2);
            else {
              k2 = c2[g2 >> 2] | 0;
              l2 = (c2[i2 >> 2] | 0) - k2 | 0;
              i2 = l2 >> 2;
              be(e2, l2 >> 3 >>> 0 < d2 >>> 1 >>> 0 ? i2 >>> 0 < b5 >>> 0 ? b5 : i2 : d2, (c2[h2 >> 2] | 0) - k2 >> 3, a3 + 16 | 0);
              i2 = e2 + 8 | 0;
              h2 = c2[i2 >> 2] | 0;
              c2[h2 >> 2] = c2[f2 >> 2];
              a3 = f2 + 4 | 0;
              c2[h2 + 4 >> 2] = c2[a3 >> 2];
              c2[f2 >> 2] = 0;
              c2[a3 >> 2] = 0;
              c2[i2 >> 2] = h2 + 8;
              ce(g2, e2);
              de(e2);
              break;
            }
          } else {
            $d(e2, g2, 1);
            l2 = e2 + 4 | 0;
            k2 = c2[l2 >> 2] | 0;
            c2[k2 >> 2] = c2[f2 >> 2];
            i2 = f2 + 4 | 0;
            c2[k2 + 4 >> 2] = c2[i2 >> 2];
            c2[f2 >> 2] = 0;
            c2[i2 >> 2] = 0;
            c2[l2 >> 2] = k2 + 8;
            ae(e2);
          }
        while (0);
        Sd(f2);
        V = j2;
        return;
      }
      function ij(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0;
        j2 = V;
        V = V + 32 | 0;
        e2 = j2 + 12 | 0;
        f2 = j2;
        b5 = j2 + 8 | 0;
        h2 = eq(176) | 0;
        Aj(h2, c2[a3 + 4 >> 2] | 0);
        g2 = a3 + 8 | 0;
        c2[b5 >> 2] = 0;
        c2[e2 >> 2] = c2[b5 >> 2];
        Bj(f2, h2, e2);
        h2 = a3 + 12 | 0;
        b5 = c2[h2 >> 2] | 0;
        i2 = a3 + 16 | 0;
        do
          if (b5 >>> 0 >= (c2[i2 >> 2] | 0) >>> 0) {
            b5 = (b5 - (c2[g2 >> 2] | 0) >> 3) + 1 | 0;
            d2 = ee(g2) | 0;
            if (d2 >>> 0 < b5 >>> 0)
              cr(g2);
            else {
              k2 = c2[g2 >> 2] | 0;
              l2 = (c2[i2 >> 2] | 0) - k2 | 0;
              i2 = l2 >> 2;
              be(e2, l2 >> 3 >>> 0 < d2 >>> 1 >>> 0 ? i2 >>> 0 < b5 >>> 0 ? b5 : i2 : d2, (c2[h2 >> 2] | 0) - k2 >> 3, a3 + 16 | 0);
              i2 = e2 + 8 | 0;
              h2 = c2[i2 >> 2] | 0;
              c2[h2 >> 2] = c2[f2 >> 2];
              a3 = f2 + 4 | 0;
              c2[h2 + 4 >> 2] = c2[a3 >> 2];
              c2[f2 >> 2] = 0;
              c2[a3 >> 2] = 0;
              c2[i2 >> 2] = h2 + 8;
              ce(g2, e2);
              de(e2);
              break;
            }
          } else {
            $d(e2, g2, 1);
            l2 = e2 + 4 | 0;
            k2 = c2[l2 >> 2] | 0;
            c2[k2 >> 2] = c2[f2 >> 2];
            i2 = f2 + 4 | 0;
            c2[k2 + 4 >> 2] = c2[i2 >> 2];
            c2[f2 >> 2] = 0;
            c2[i2 >> 2] = 0;
            c2[l2 >> 2] = k2 + 8;
            ae(e2);
          }
        while (0);
        Sd(f2);
        V = j2;
        return;
      }
      function jj(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        fe(a3);
        c2[a3 >> 2] = 5324;
        c2[a3 + 4 >> 2] = b5;
        lj(a3 + 8 | 0);
        return;
      }
      function kj(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0;
        d2 = V;
        V = V + 16 | 0;
        e2 = d2;
        c2[a3 >> 2] = b5;
        f2 = eq(16) | 0;
        c2[f2 + 4 >> 2] = 0;
        c2[f2 + 8 >> 2] = 0;
        c2[f2 >> 2] = 5348;
        c2[f2 + 12 >> 2] = b5;
        c2[a3 + 4 >> 2] = f2;
        c2[e2 >> 2] = b5;
        c2[e2 + 4 >> 2] = b5;
        Xe(a3, e2);
        V = d2;
        return;
      }
      function lj(b5) {
        b5 = b5 | 0;
        xe(b5, 8, 1, 8, 0);
        mc(b5 + 80 | 0, 8, 1, 8, 0);
        a2[b5 + 160 >> 0] = 0;
        a2[b5 + 161 >> 0] = 0;
        pj(b5 + 162 | 0);
        return;
      }
      function mj(a3) {
        a3 = a3 | 0;
        c2[a3 >> 2] = 5324;
        qj(a3 + 8 | 0);
        le(a3);
        return;
      }
      function nj(a3) {
        a3 = a3 | 0;
        mj(a3);
        jp(a3);
        return;
      }
      function oj(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return rj(a3 + 8 | 0, c2[a3 + 4 >> 2] | 0, b5) | 0;
      }
      function pj(b5) {
        b5 = b5 | 0;
        a2[b5 + 1 >> 0] = 0;
        return;
      }
      function qj(a3) {
        a3 = a3 | 0;
        qc(a3 + 80 | 0);
        ye(a3);
        return;
      }
      function rj(b5, c3, d2) {
        b5 = b5 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0, g2 = 0;
        g2 = V;
        V = V + 16 | 0;
        e2 = g2;
        if (!(a2[b5 + 161 >> 0] | 0))
          oc(b5 + 80 | 0);
        f2 = b5 + 162 | 0;
        if (sj(f2) | 0) {
          c3 = (Gi(b5 + 80 | 0, c3, a2[f2 >> 0] | 0, 0) | 0) & 255;
          a2[e2 >> 0] = c3;
          tj(c3, d2);
        } else {
          Ii(Hi(c3) | 0, d2, 1);
          a2[e2 >> 0] = uj(d2) | 0;
        }
        vj(f2, e2);
        V = g2;
        return d2 + 1 | 0;
      }
      function sj(b5) {
        b5 = b5 | 0;
        return (a2[b5 + 1 >> 0] | 0) != 0 | 0;
      }
      function tj(b5, c3) {
        b5 = b5 | 0;
        c3 = c3 | 0;
        a2[c3 >> 0] = b5;
        return;
      }
      function uj(b5) {
        b5 = b5 | 0;
        return a2[b5 >> 0] | 0;
      }
      function vj(b5, c3) {
        b5 = b5 | 0;
        c3 = c3 | 0;
        var d2 = 0;
        d2 = b5 + 1 | 0;
        if (!(a2[d2 >> 0] | 0))
          a2[d2 >> 0] = 1;
        a2[b5 >> 0] = a2[c3 >> 0] | 0;
        return;
      }
      function wj(a3) {
        a3 = a3 | 0;
        pq(a3);
        jp(a3);
        return;
      }
      function xj(a3) {
        a3 = a3 | 0;
        a3 = c2[a3 + 12 >> 2] | 0;
        if (a3 | 0)
          ca[c2[(c2[a3 >> 2] | 0) + 4 >> 2] & 255](a3);
        return;
      }
      function yj(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return ((c2[b5 + 4 >> 2] | 0) == 16900 ? a3 + 12 | 0 : 0) | 0;
      }
      function zj(a3) {
        a3 = a3 | 0;
        Da(a3, 16);
        return;
      }
      function Aj(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        fe(a3);
        c2[a3 >> 2] = 5376;
        c2[a3 + 4 >> 2] = b5;
        Cj(a3 + 8 | 0);
        return;
      }
      function Bj(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0;
        d2 = V;
        V = V + 16 | 0;
        e2 = d2;
        c2[a3 >> 2] = b5;
        f2 = eq(16) | 0;
        c2[f2 + 4 >> 2] = 0;
        c2[f2 + 8 >> 2] = 0;
        c2[f2 >> 2] = 5400;
        c2[f2 + 12 >> 2] = b5;
        c2[a3 + 4 >> 2] = f2;
        c2[e2 >> 2] = b5;
        c2[e2 + 4 >> 2] = b5;
        Xe(a3, e2);
        V = d2;
        return;
      }
      function Cj(b5) {
        b5 = b5 | 0;
        xe(b5, 16, 1, 8, 0);
        mc(b5 + 80 | 0, 16, 1, 8, 0);
        a2[b5 + 160 >> 0] = 0;
        a2[b5 + 161 >> 0] = 0;
        Gj(b5 + 162 | 0);
        return;
      }
      function Dj(a3) {
        a3 = a3 | 0;
        c2[a3 >> 2] = 5376;
        Hj(a3 + 8 | 0);
        le(a3);
        return;
      }
      function Ej(a3) {
        a3 = a3 | 0;
        Dj(a3);
        jp(a3);
        return;
      }
      function Fj(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return Ij(a3 + 8 | 0, c2[a3 + 4 >> 2] | 0, b5) | 0;
      }
      function Gj(b5) {
        b5 = b5 | 0;
        a2[b5 + 2 >> 0] = 0;
        return;
      }
      function Hj(a3) {
        a3 = a3 | 0;
        qc(a3 + 80 | 0);
        ye(a3);
        return;
      }
      function Ij(c3, d2, e2) {
        c3 = c3 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f2 = 0, g2 = 0, h2 = 0;
        h2 = V;
        V = V + 16 | 0;
        f2 = h2;
        if (!(a2[c3 + 161 >> 0] | 0))
          oc(c3 + 80 | 0);
        g2 = c3 + 162 | 0;
        if (Jj(g2) | 0) {
          d2 = (Gi(c3 + 80 | 0, d2, b4[g2 >> 1] | 0, 0) | 0) & 65535;
          b4[f2 >> 1] = d2;
          Kj(d2, e2);
        } else {
          Ii(Hi(d2) | 0, e2, 2);
          b4[f2 >> 1] = Lj(e2) | 0;
        }
        Mj(g2, f2);
        V = h2;
        return e2 + 2 | 0;
      }
      function Jj(b5) {
        b5 = b5 | 0;
        return (a2[b5 + 2 >> 0] | 0) != 0 | 0;
      }
      function Kj(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        Te(a3, b5);
        return;
      }
      function Lj(a3) {
        a3 = a3 | 0;
        return Oe(a3) | 0;
      }
      function Mj(c3, d2) {
        c3 = c3 | 0;
        d2 = d2 | 0;
        var e2 = 0;
        e2 = c3 + 2 | 0;
        if (!(a2[e2 >> 0] | 0))
          a2[e2 >> 0] = 1;
        b4[c3 >> 1] = b4[d2 >> 1] | 0;
        return;
      }
      function Nj(a3) {
        a3 = a3 | 0;
        pq(a3);
        jp(a3);
        return;
      }
      function Oj(a3) {
        a3 = a3 | 0;
        a3 = c2[a3 + 12 >> 2] | 0;
        if (a3 | 0)
          ca[c2[(c2[a3 >> 2] | 0) + 4 >> 2] & 255](a3);
        return;
      }
      function Pj(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return ((c2[b5 + 4 >> 2] | 0) == 17398 ? a3 + 12 | 0 : 0) | 0;
      }
      function Qj(a3) {
        a3 = a3 | 0;
        Da(a3, 16);
        return;
      }
      function Rj(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0;
        j2 = V;
        V = V + 32 | 0;
        e2 = j2 + 12 | 0;
        f2 = j2;
        b5 = j2 + 8 | 0;
        h2 = eq(172) | 0;
        Tj(h2, c2[a3 + 4 >> 2] | 0);
        g2 = a3 + 8 | 0;
        c2[b5 >> 2] = 0;
        c2[e2 >> 2] = c2[b5 >> 2];
        Uj(f2, h2, e2);
        h2 = a3 + 12 | 0;
        b5 = c2[h2 >> 2] | 0;
        i2 = a3 + 16 | 0;
        do
          if (b5 >>> 0 >= (c2[i2 >> 2] | 0) >>> 0) {
            b5 = (b5 - (c2[g2 >> 2] | 0) >> 3) + 1 | 0;
            d2 = ee(g2) | 0;
            if (d2 >>> 0 < b5 >>> 0)
              cr(g2);
            else {
              k2 = c2[g2 >> 2] | 0;
              l2 = (c2[i2 >> 2] | 0) - k2 | 0;
              i2 = l2 >> 2;
              be(e2, l2 >> 3 >>> 0 < d2 >>> 1 >>> 0 ? i2 >>> 0 < b5 >>> 0 ? b5 : i2 : d2, (c2[h2 >> 2] | 0) - k2 >> 3, a3 + 16 | 0);
              i2 = e2 + 8 | 0;
              h2 = c2[i2 >> 2] | 0;
              c2[h2 >> 2] = c2[f2 >> 2];
              a3 = f2 + 4 | 0;
              c2[h2 + 4 >> 2] = c2[a3 >> 2];
              c2[f2 >> 2] = 0;
              c2[a3 >> 2] = 0;
              c2[i2 >> 2] = h2 + 8;
              ce(g2, e2);
              de(e2);
              break;
            }
          } else {
            $d(e2, g2, 1);
            l2 = e2 + 4 | 0;
            k2 = c2[l2 >> 2] | 0;
            c2[k2 >> 2] = c2[f2 >> 2];
            i2 = f2 + 4 | 0;
            c2[k2 + 4 >> 2] = c2[i2 >> 2];
            c2[f2 >> 2] = 0;
            c2[i2 >> 2] = 0;
            c2[l2 >> 2] = k2 + 8;
            ae(e2);
          }
        while (0);
        Sd(f2);
        V = j2;
        return;
      }
      function Sj(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0;
        j2 = V;
        V = V + 32 | 0;
        e2 = j2 + 12 | 0;
        f2 = j2;
        b5 = j2 + 8 | 0;
        h2 = eq(176) | 0;
        gk(h2, c2[a3 + 4 >> 2] | 0);
        g2 = a3 + 8 | 0;
        c2[b5 >> 2] = 0;
        c2[e2 >> 2] = c2[b5 >> 2];
        hk(f2, h2, e2);
        h2 = a3 + 12 | 0;
        b5 = c2[h2 >> 2] | 0;
        i2 = a3 + 16 | 0;
        do
          if (b5 >>> 0 >= (c2[i2 >> 2] | 0) >>> 0) {
            b5 = (b5 - (c2[g2 >> 2] | 0) >> 3) + 1 | 0;
            d2 = ee(g2) | 0;
            if (d2 >>> 0 < b5 >>> 0)
              cr(g2);
            else {
              k2 = c2[g2 >> 2] | 0;
              l2 = (c2[i2 >> 2] | 0) - k2 | 0;
              i2 = l2 >> 2;
              be(e2, l2 >> 3 >>> 0 < d2 >>> 1 >>> 0 ? i2 >>> 0 < b5 >>> 0 ? b5 : i2 : d2, (c2[h2 >> 2] | 0) - k2 >> 3, a3 + 16 | 0);
              i2 = e2 + 8 | 0;
              h2 = c2[i2 >> 2] | 0;
              c2[h2 >> 2] = c2[f2 >> 2];
              a3 = f2 + 4 | 0;
              c2[h2 + 4 >> 2] = c2[a3 >> 2];
              c2[f2 >> 2] = 0;
              c2[a3 >> 2] = 0;
              c2[i2 >> 2] = h2 + 8;
              ce(g2, e2);
              de(e2);
              break;
            }
          } else {
            $d(e2, g2, 1);
            l2 = e2 + 4 | 0;
            k2 = c2[l2 >> 2] | 0;
            c2[k2 >> 2] = c2[f2 >> 2];
            i2 = f2 + 4 | 0;
            c2[k2 + 4 >> 2] = c2[i2 >> 2];
            c2[f2 >> 2] = 0;
            c2[i2 >> 2] = 0;
            c2[l2 >> 2] = k2 + 8;
            ae(e2);
          }
        while (0);
        Sd(f2);
        V = j2;
        return;
      }
      function Tj(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        fe(a3);
        c2[a3 >> 2] = 5428;
        c2[a3 + 4 >> 2] = b5;
        Vj(a3 + 8 | 0);
        return;
      }
      function Uj(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0;
        d2 = V;
        V = V + 16 | 0;
        e2 = d2;
        c2[a3 >> 2] = b5;
        f2 = eq(16) | 0;
        c2[f2 + 4 >> 2] = 0;
        c2[f2 + 8 >> 2] = 0;
        c2[f2 >> 2] = 5452;
        c2[f2 + 12 >> 2] = b5;
        c2[a3 + 4 >> 2] = f2;
        c2[e2 >> 2] = b5;
        c2[e2 + 4 >> 2] = b5;
        Xe(a3, e2);
        V = d2;
        return;
      }
      function Vj(b5) {
        b5 = b5 | 0;
        xe(b5, 8, 1, 8, 0);
        mc(b5 + 80 | 0, 8, 1, 8, 0);
        a2[b5 + 160 >> 0] = 0;
        a2[b5 + 161 >> 0] = 0;
        Zj(b5 + 162 | 0);
        return;
      }
      function Wj(a3) {
        a3 = a3 | 0;
        c2[a3 >> 2] = 5428;
        _j(a3 + 8 | 0);
        le(a3);
        return;
      }
      function Xj(a3) {
        a3 = a3 | 0;
        Wj(a3);
        jp(a3);
        return;
      }
      function Yj(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return $j(a3 + 8 | 0, c2[a3 + 4 >> 2] | 0, b5) | 0;
      }
      function Zj(b5) {
        b5 = b5 | 0;
        a2[b5 + 1 >> 0] = 0;
        return;
      }
      function _j(a3) {
        a3 = a3 | 0;
        qc(a3 + 80 | 0);
        ye(a3);
        return;
      }
      function $j(b5, c3, e2) {
        b5 = b5 | 0;
        c3 = c3 | 0;
        e2 = e2 | 0;
        var f2 = 0, g2 = 0, h2 = 0;
        h2 = V;
        V = V + 16 | 0;
        f2 = h2;
        if (!(a2[b5 + 161 >> 0] | 0))
          oc(b5 + 80 | 0);
        g2 = b5 + 162 | 0;
        if (ak(g2) | 0) {
          c3 = (Gi(b5 + 80 | 0, c3, d[g2 >> 0] | 0, 0) | 0) & 255;
          a2[f2 >> 0] = c3;
          Ue(c3, e2);
        } else {
          Ii(Hi(c3) | 0, e2, 1);
          a2[f2 >> 0] = Pe(e2) | 0;
        }
        bk(g2, f2);
        V = h2;
        return e2 + 1 | 0;
      }
      function ak(b5) {
        b5 = b5 | 0;
        return (a2[b5 + 1 >> 0] | 0) != 0 | 0;
      }
      function bk(b5, c3) {
        b5 = b5 | 0;
        c3 = c3 | 0;
        var d2 = 0;
        d2 = b5 + 1 | 0;
        if (!(a2[d2 >> 0] | 0))
          a2[d2 >> 0] = 1;
        a2[b5 >> 0] = a2[c3 >> 0] | 0;
        return;
      }
      function ck(a3) {
        a3 = a3 | 0;
        pq(a3);
        jp(a3);
        return;
      }
      function dk(a3) {
        a3 = a3 | 0;
        a3 = c2[a3 + 12 >> 2] | 0;
        if (a3 | 0)
          ca[c2[(c2[a3 >> 2] | 0) + 4 >> 2] & 255](a3);
        return;
      }
      function ek(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return ((c2[b5 + 4 >> 2] | 0) == 17896 ? a3 + 12 | 0 : 0) | 0;
      }
      function fk(a3) {
        a3 = a3 | 0;
        Da(a3, 16);
        return;
      }
      function gk(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        fe(a3);
        c2[a3 >> 2] = 5480;
        c2[a3 + 4 >> 2] = b5;
        ik(a3 + 8 | 0);
        return;
      }
      function hk(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0;
        d2 = V;
        V = V + 16 | 0;
        e2 = d2;
        c2[a3 >> 2] = b5;
        f2 = eq(16) | 0;
        c2[f2 + 4 >> 2] = 0;
        c2[f2 + 8 >> 2] = 0;
        c2[f2 >> 2] = 5504;
        c2[f2 + 12 >> 2] = b5;
        c2[a3 + 4 >> 2] = f2;
        c2[e2 >> 2] = b5;
        c2[e2 + 4 >> 2] = b5;
        Xe(a3, e2);
        V = d2;
        return;
      }
      function ik(b5) {
        b5 = b5 | 0;
        xe(b5, 16, 1, 8, 0);
        mc(b5 + 80 | 0, 16, 1, 8, 0);
        a2[b5 + 160 >> 0] = 0;
        a2[b5 + 161 >> 0] = 0;
        mk(b5 + 162 | 0);
        return;
      }
      function jk(a3) {
        a3 = a3 | 0;
        c2[a3 >> 2] = 5480;
        nk(a3 + 8 | 0);
        le(a3);
        return;
      }
      function kk(a3) {
        a3 = a3 | 0;
        jk(a3);
        jp(a3);
        return;
      }
      function lk(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return ok(a3 + 8 | 0, c2[a3 + 4 >> 2] | 0, b5) | 0;
      }
      function mk(b5) {
        b5 = b5 | 0;
        a2[b5 + 2 >> 0] = 0;
        return;
      }
      function nk(a3) {
        a3 = a3 | 0;
        qc(a3 + 80 | 0);
        ye(a3);
        return;
      }
      function ok(c3, d2, f2) {
        c3 = c3 | 0;
        d2 = d2 | 0;
        f2 = f2 | 0;
        var g2 = 0, h2 = 0, i2 = 0;
        i2 = V;
        V = V + 16 | 0;
        g2 = i2;
        if (!(a2[c3 + 161 >> 0] | 0))
          oc(c3 + 80 | 0);
        h2 = c3 + 162 | 0;
        if (pk(h2) | 0) {
          d2 = (Gi(c3 + 80 | 0, d2, e[h2 >> 1] | 0, 0) | 0) & 65535;
          b4[g2 >> 1] = d2;
          Te(d2, f2);
        } else {
          Ii(Hi(d2) | 0, f2, 2);
          b4[g2 >> 1] = Oe(f2) | 0;
        }
        qk(h2, g2);
        V = i2;
        return f2 + 2 | 0;
      }
      function pk(b5) {
        b5 = b5 | 0;
        return (a2[b5 + 2 >> 0] | 0) != 0 | 0;
      }
      function qk(c3, d2) {
        c3 = c3 | 0;
        d2 = d2 | 0;
        var e2 = 0;
        e2 = c3 + 2 | 0;
        if (!(a2[e2 >> 0] | 0))
          a2[e2 >> 0] = 1;
        b4[c3 >> 1] = b4[d2 >> 1] | 0;
        return;
      }
      function rk(a3) {
        a3 = a3 | 0;
        pq(a3);
        jp(a3);
        return;
      }
      function sk(a3) {
        a3 = a3 | 0;
        a3 = c2[a3 + 12 >> 2] | 0;
        if (a3 | 0)
          ca[c2[(c2[a3 >> 2] | 0) + 4 >> 2] & 255](a3);
        return;
      }
      function tk(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return ((c2[b5 + 4 >> 2] | 0) == 18394 ? a3 + 12 | 0 : 0) | 0;
      }
      function uk(a3) {
        a3 = a3 | 0;
        Da(a3, 16);
        return;
      }
      function vk() {
        return;
      }
      function wk(a3) {
        a3 = a3 | 0;
        return Ek(a3) | 0;
      }
      function xk() {
        return 0;
      }
      function yk() {
        return 0;
      }
      function zk(a3) {
        a3 = a3 | 0;
        if (a3 | 0) {
          Fk(a3);
          jp(a3);
        }
        return;
      }
      function Ak() {
        return Gk() | 0;
      }
      function Bk() {
        return Hk() | 0;
      }
      function Ck() {
        return Ik() | 0;
      }
      function Dk() {
        return 0;
      }
      function Ek(a3) {
        a3 = a3 | 0;
        return 3360;
      }
      function Fk(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0, f2 = 0;
        b5 = V;
        V = V + 16 | 0;
        e2 = b5;
        c2[e2 >> 2] = c2[a3 >> 2];
        c2[a3 >> 2] = 0;
        d2 = a3 + 4 | 0;
        c2[e2 + 4 >> 2] = c2[d2 >> 2];
        c2[d2 >> 2] = 0;
        wa(e2);
        d2 = a3 + 8 | 0;
        c2[e2 >> 2] = c2[d2 >> 2];
        c2[d2 >> 2] = 0;
        f2 = a3 + 12 | 0;
        c2[e2 + 4 >> 2] = c2[f2 >> 2];
        c2[f2 >> 2] = 0;
        Ga(e2);
        Ga(d2);
        wa(a3);
        V = b5;
        return;
      }
      function Gk() {
        return 3360;
      }
      function Hk() {
        return 3368;
      }
      function Ik() {
        return 3384;
      }
      function Jk() {
        return 18579;
      }
      function Kk() {
        return 18582;
      }
      function Lk() {
        return 18584;
      }
      function Mk() {
        var a3 = 0;
        a3 = eq(16) | 0;
        Tk(a3);
        return a3 | 0;
      }
      function Nk(a3) {
        a3 = a3 | 0;
        var b5 = 0, c3 = 0, d2 = 0, e2 = 0;
        b5 = V;
        V = V + 16 | 0;
        c3 = b5;
        e2 = Ak() | 0;
        d2 = Pk(c3) | 0;
        c3 = Qk(c3) | 0;
        E(e2 | 0, d2 | 0, c3 | 0, Jk() | 0, 12, a3 | 0);
        V = b5;
        return;
      }
      function Ok(a3) {
        a3 = a3 | 0;
        return Rk(Y[a3 & 3]() | 0) | 0;
      }
      function Pk(a3) {
        a3 = a3 | 0;
        return 1;
      }
      function Qk(a3) {
        a3 = a3 | 0;
        return Sk() | 0;
      }
      function Rk(a3) {
        a3 = a3 | 0;
        return a3 | 0;
      }
      function Sk() {
        return 5524;
      }
      function Tk(a3) {
        a3 = a3 | 0;
        c2[a3 >> 2] = 0;
        c2[a3 + 4 >> 2] = 0;
        c2[a3 + 8 >> 2] = 0;
        c2[a3 + 12 >> 2] = 0;
        return;
      }
      function Uk(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0;
        d2 = V;
        V = V + 16 | 0;
        e2 = d2;
        f2 = d2 + 8 | 0;
        h2 = c2[b5 + 4 >> 2] | 0;
        c2[e2 >> 2] = c2[b5 >> 2];
        c2[e2 + 4 >> 2] = h2;
        h2 = Ak() | 0;
        g2 = Wk(f2) | 0;
        f2 = Xk(f2) | 0;
        b5 = bl() | 0;
        F(h2 | 0, a3 | 0, g2 | 0, f2 | 0, b5 | 0, 4, Yk(e2) | 0, 0);
        V = d2;
        return;
      }
      function Vk(a3, b5, d2, e2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f2 = 0, g2 = 0;
        g2 = Zk(b5) | 0;
        b5 = c2[a3 >> 2] | 0;
        f2 = c2[a3 + 4 >> 2] | 0;
        a3 = g2 + (f2 >> 1) | 0;
        if (f2 & 1)
          b5 = c2[(c2[a3 >> 2] | 0) + b5 >> 2] | 0;
        f2 = _k(d2) | 0;
        g2 = $k(e2) | 0;
        ea[b5 & 15](a3, f2, g2);
        return;
      }
      function Wk(a3) {
        a3 = a3 | 0;
        return 4;
      }
      function Xk(a3) {
        a3 = a3 | 0;
        return al() | 0;
      }
      function Yk(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        b5 = eq(8) | 0;
        d2 = c2[a3 + 4 >> 2] | 0;
        c2[b5 >> 2] = c2[a3 >> 2];
        c2[b5 + 4 >> 2] = d2;
        return b5 | 0;
      }
      function Zk(a3) {
        a3 = a3 | 0;
        return a3 | 0;
      }
      function _k(a3) {
        a3 = a3 | 0;
        return a3 | 0;
      }
      function $k(a3) {
        a3 = a3 | 0;
        return a3 | 0;
      }
      function al() {
        return 144;
      }
      function bl() {
        return 18587;
      }
      function cl(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0;
        d2 = V;
        V = V + 16 | 0;
        e2 = d2;
        f2 = d2 + 8 | 0;
        h2 = c2[b5 + 4 >> 2] | 0;
        c2[e2 >> 2] = c2[b5 >> 2];
        c2[e2 + 4 >> 2] = h2;
        h2 = Ak() | 0;
        g2 = el(f2) | 0;
        f2 = fl(f2) | 0;
        b5 = jl() | 0;
        F(h2 | 0, a3 | 0, g2 | 0, f2 | 0, b5 | 0, 7, gl(e2) | 0, 0);
        V = d2;
        return;
      }
      function dl(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0;
        f2 = Zk(b5) | 0;
        b5 = c2[a3 >> 2] | 0;
        e2 = c2[a3 + 4 >> 2] | 0;
        a3 = f2 + (e2 >> 1) | 0;
        if (e2 & 1)
          b5 = c2[(c2[a3 >> 2] | 0) + b5 >> 2] | 0;
        f2 = hl(d2) | 0;
        da[b5 & 15](a3, f2);
        return;
      }
      function el(a3) {
        a3 = a3 | 0;
        return 3;
      }
      function fl(a3) {
        a3 = a3 | 0;
        return il() | 0;
      }
      function gl(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        b5 = eq(8) | 0;
        d2 = c2[a3 + 4 >> 2] | 0;
        c2[b5 >> 2] = c2[a3 >> 2];
        c2[b5 + 4 >> 2] = d2;
        return b5 | 0;
      }
      function hl(a3) {
        a3 = a3 | 0;
        return a3 | 0;
      }
      function il() {
        return 5528;
      }
      function jl() {
        return 18593;
      }
      function kl(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0;
        d2 = V;
        V = V + 16 | 0;
        e2 = d2;
        f2 = d2 + 8 | 0;
        h2 = c2[b5 + 4 >> 2] | 0;
        c2[e2 >> 2] = c2[b5 >> 2];
        c2[e2 + 4 >> 2] = h2;
        h2 = Ak() | 0;
        g2 = ml(f2) | 0;
        f2 = nl(f2) | 0;
        b5 = rl() | 0;
        F(h2 | 0, a3 | 0, g2 | 0, f2 | 0, b5 | 0, 41, ol(e2) | 0, 0);
        V = d2;
        return;
      }
      function ll(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0;
        e2 = V;
        V = V + 16 | 0;
        d2 = e2;
        g2 = Zk(b5) | 0;
        b5 = c2[a3 >> 2] | 0;
        f2 = c2[a3 + 4 >> 2] | 0;
        a3 = g2 + (f2 >> 1) | 0;
        if (f2 & 1)
          b5 = c2[(c2[a3 >> 2] | 0) + b5 >> 2] | 0;
        c2[d2 >> 2] = Z[b5 & 15](a3) | 0;
        g2 = pl(d2) | 0;
        V = e2;
        return g2 | 0;
      }
      function ml(a3) {
        a3 = a3 | 0;
        return 2;
      }
      function nl(a3) {
        a3 = a3 | 0;
        return ql() | 0;
      }
      function ol(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        b5 = eq(8) | 0;
        d2 = c2[a3 + 4 >> 2] | 0;
        c2[b5 >> 2] = c2[a3 >> 2];
        c2[b5 + 4 >> 2] = d2;
        return b5 | 0;
      }
      function pl(a3) {
        a3 = a3 | 0;
        return c2[a3 >> 2] | 0;
      }
      function ql() {
        return 5540;
      }
      function rl() {
        return 18598;
      }
      function sl() {
        return;
      }
      function tl(a3) {
        a3 = a3 | 0;
        return Al(a3) | 0;
      }
      function ul() {
        return 0;
      }
      function vl() {
        return 0;
      }
      function wl(a3) {
        a3 = a3 | 0;
        if (a3 | 0) {
          Bl(a3);
          jp(a3);
        }
        return;
      }
      function xl() {
        return Cl() | 0;
      }
      function yl() {
        return Dl() | 0;
      }
      function zl() {
        return El() | 0;
      }
      function Al(a3) {
        a3 = a3 | 0;
        return 3400;
      }
      function Bl(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0, f2 = 0;
        b5 = V;
        V = V + 16 | 0;
        e2 = b5;
        c2[e2 >> 2] = c2[a3 >> 2];
        c2[a3 >> 2] = 0;
        d2 = a3 + 4 | 0;
        c2[e2 + 4 >> 2] = c2[d2 >> 2];
        c2[d2 >> 2] = 0;
        Wh(e2);
        d2 = a3 + 16 | 0;
        c2[e2 >> 2] = c2[d2 >> 2];
        c2[d2 >> 2] = 0;
        f2 = a3 + 20 | 0;
        c2[e2 + 4 >> 2] = c2[f2 >> 2];
        c2[f2 >> 2] = 0;
        Uh(e2);
        c2[e2 >> 2] = c2[d2 >> 2];
        c2[d2 >> 2] = 0;
        c2[e2 + 4 >> 2] = c2[f2 >> 2];
        c2[f2 >> 2] = 0;
        Uh(e2);
        Uh(d2);
        bi(a3 + 8 | 0);
        Wh(a3);
        V = b5;
        return;
      }
      function Cl() {
        return 3400;
      }
      function Dl() {
        return 3408;
      }
      function El() {
        return 3424;
      }
      function Fl() {
        var a3 = 0;
        a3 = eq(24) | 0;
        Ml(a3);
        return a3 | 0;
      }
      function Gl(a3) {
        a3 = a3 | 0;
        var b5 = 0, c3 = 0, d2 = 0, e2 = 0;
        b5 = V;
        V = V + 16 | 0;
        c3 = b5;
        e2 = xl() | 0;
        d2 = Il(c3) | 0;
        c3 = Jl(c3) | 0;
        E(e2 | 0, d2 | 0, c3 | 0, Jk() | 0, 13, a3 | 0);
        V = b5;
        return;
      }
      function Hl(a3) {
        a3 = a3 | 0;
        return Kl(Y[a3 & 3]() | 0) | 0;
      }
      function Il(a3) {
        a3 = a3 | 0;
        return 1;
      }
      function Jl(a3) {
        a3 = a3 | 0;
        return Ll() | 0;
      }
      function Kl(a3) {
        a3 = a3 | 0;
        return a3 | 0;
      }
      function Ll() {
        return 5548;
      }
      function Ml(a3) {
        a3 = a3 | 0;
        c2[a3 >> 2] = 0;
        c2[a3 + 4 >> 2] = 0;
        c2[a3 + 8 >> 2] = 0;
        c2[a3 + 12 >> 2] = 0;
        c2[a3 + 16 >> 2] = 0;
        c2[a3 + 20 >> 2] = 0;
        return;
      }
      function Nl(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0;
        d2 = V;
        V = V + 16 | 0;
        e2 = d2;
        f2 = d2 + 8 | 0;
        h2 = c2[b5 + 4 >> 2] | 0;
        c2[e2 >> 2] = c2[b5 >> 2];
        c2[e2 + 4 >> 2] = h2;
        h2 = xl() | 0;
        g2 = Pl(f2) | 0;
        f2 = Ql(f2) | 0;
        b5 = bl() | 0;
        F(h2 | 0, a3 | 0, g2 | 0, f2 | 0, b5 | 0, 5, Rl(e2) | 0, 0);
        V = d2;
        return;
      }
      function Ol(a3, b5, d2, e2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f2 = 0, g2 = 0;
        g2 = Sl(b5) | 0;
        b5 = c2[a3 >> 2] | 0;
        f2 = c2[a3 + 4 >> 2] | 0;
        a3 = g2 + (f2 >> 1) | 0;
        if (f2 & 1)
          b5 = c2[(c2[a3 >> 2] | 0) + b5 >> 2] | 0;
        f2 = _k(d2) | 0;
        g2 = $k(e2) | 0;
        ea[b5 & 15](a3, f2, g2);
        return;
      }
      function Pl(a3) {
        a3 = a3 | 0;
        return 4;
      }
      function Ql(a3) {
        a3 = a3 | 0;
        return Tl() | 0;
      }
      function Rl(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        b5 = eq(8) | 0;
        d2 = c2[a3 + 4 >> 2] | 0;
        c2[b5 >> 2] = c2[a3 >> 2];
        c2[b5 + 4 >> 2] = d2;
        return b5 | 0;
      }
      function Sl(a3) {
        a3 = a3 | 0;
        return a3 | 0;
      }
      function Tl() {
        return 160;
      }
      function Ul(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0;
        d2 = V;
        V = V + 16 | 0;
        e2 = d2;
        f2 = d2 + 8 | 0;
        h2 = c2[b5 + 4 >> 2] | 0;
        c2[e2 >> 2] = c2[b5 >> 2];
        c2[e2 + 4 >> 2] = h2;
        h2 = xl() | 0;
        g2 = Wl(f2) | 0;
        f2 = Xl(f2) | 0;
        b5 = jl() | 0;
        F(h2 | 0, a3 | 0, g2 | 0, f2 | 0, b5 | 0, 8, Yl(e2) | 0, 0);
        V = d2;
        return;
      }
      function Vl(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0;
        f2 = Sl(b5) | 0;
        b5 = c2[a3 >> 2] | 0;
        e2 = c2[a3 + 4 >> 2] | 0;
        a3 = f2 + (e2 >> 1) | 0;
        if (e2 & 1)
          b5 = c2[(c2[a3 >> 2] | 0) + b5 >> 2] | 0;
        f2 = $k(d2) | 0;
        da[b5 & 15](a3, f2);
        return;
      }
      function Wl(a3) {
        a3 = a3 | 0;
        return 3;
      }
      function Xl(a3) {
        a3 = a3 | 0;
        return Zl() | 0;
      }
      function Yl(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        b5 = eq(8) | 0;
        d2 = c2[a3 + 4 >> 2] | 0;
        c2[b5 >> 2] = c2[a3 >> 2];
        c2[b5 + 4 >> 2] = d2;
        return b5 | 0;
      }
      function Zl() {
        return 5552;
      }
      function _l(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0;
        d2 = V;
        V = V + 16 | 0;
        e2 = d2;
        f2 = d2 + 8 | 0;
        h2 = c2[b5 + 4 >> 2] | 0;
        c2[e2 >> 2] = c2[b5 >> 2];
        c2[e2 + 4 >> 2] = h2;
        h2 = xl() | 0;
        g2 = am(f2) | 0;
        f2 = bm(f2) | 0;
        b5 = jl() | 0;
        F(h2 | 0, a3 | 0, g2 | 0, f2 | 0, b5 | 0, 9, cm(e2) | 0, 0);
        V = d2;
        return;
      }
      function $l(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0;
        f2 = Sl(b5) | 0;
        b5 = c2[a3 >> 2] | 0;
        e2 = c2[a3 + 4 >> 2] | 0;
        a3 = f2 + (e2 >> 1) | 0;
        if (e2 & 1)
          b5 = c2[(c2[a3 >> 2] | 0) + b5 >> 2] | 0;
        f2 = hl(d2) | 0;
        da[b5 & 15](a3, f2);
        return;
      }
      function am(a3) {
        a3 = a3 | 0;
        return 3;
      }
      function bm(a3) {
        a3 = a3 | 0;
        return dm() | 0;
      }
      function cm(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        b5 = eq(8) | 0;
        d2 = c2[a3 + 4 >> 2] | 0;
        c2[b5 >> 2] = c2[a3 >> 2];
        c2[b5 + 4 >> 2] = d2;
        return b5 | 0;
      }
      function dm() {
        return 5564;
      }
      function em() {
        ja();
        return;
      }
      function fm() {
        gm();
        return;
      }
      function gm() {
        hm(22144);
        return;
      }
      function hm(a3) {
        a3 = a3 | 0;
        var b5 = 0;
        b5 = V;
        V = V + 16 | 0;
        c2[b5 >> 2] = a3;
        im();
        V = b5;
        return;
      }
      function im() {
        M(jm() | 0, 18653);
        C(km() | 0, 18658, 1, 1, 0);
        lm(18663);
        mm(18668);
        nm(18680);
        om(18694);
        pm(18700);
        qm(18715);
        rm(18719);
        sm(18732);
        tm(18737);
        um(18751);
        vm(18757);
        K(wm() | 0, 18764);
        K(xm() | 0, 18776);
        L(ym() | 0, 4, 18809);
        L(zm() | 0, 2, 18822);
        L(Am() | 0, 4, 18837);
        G(Bm() | 0, 18852);
        Cm(18868);
        Dm(18898);
        Em(18935);
        Fm(18974);
        Gm(19005);
        Hm(19045);
        Im(19074);
        Jm(19112);
        Km(19142);
        Dm(19181);
        Em(19213);
        Fm(19246);
        Gm(19279);
        Hm(19313);
        Im(19346);
        Lm(19380);
        Mm(19411);
        Nm(19443);
        return;
      }
      function jm() {
        return _n() | 0;
      }
      function km() {
        return Zn() | 0;
      }
      function lm(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        b5 = V;
        V = V + 16 | 0;
        d2 = b5;
        c2[d2 >> 2] = a3;
        a3 = Xn() | 0;
        I(a3 | 0, c2[d2 >> 2] | 0, 1, -128 << 24 >> 24 | 0, 127 << 24 >> 24 | 0);
        V = b5;
        return;
      }
      function mm(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        b5 = V;
        V = V + 16 | 0;
        d2 = b5;
        c2[d2 >> 2] = a3;
        a3 = Vn() | 0;
        I(a3 | 0, c2[d2 >> 2] | 0, 1, -128 << 24 >> 24 | 0, 127 << 24 >> 24 | 0);
        V = b5;
        return;
      }
      function nm(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        b5 = V;
        V = V + 16 | 0;
        d2 = b5;
        c2[d2 >> 2] = a3;
        a3 = Tn() | 0;
        I(a3 | 0, c2[d2 >> 2] | 0, 1, 0, 255);
        V = b5;
        return;
      }
      function om(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        b5 = V;
        V = V + 16 | 0;
        d2 = b5;
        c2[d2 >> 2] = a3;
        a3 = Rn() | 0;
        I(a3 | 0, c2[d2 >> 2] | 0, 2, -32768 << 16 >> 16 | 0, 32767 << 16 >> 16 | 0);
        V = b5;
        return;
      }
      function pm(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        b5 = V;
        V = V + 16 | 0;
        d2 = b5;
        c2[d2 >> 2] = a3;
        a3 = Pn() | 0;
        I(a3 | 0, c2[d2 >> 2] | 0, 2, 0, 65535);
        V = b5;
        return;
      }
      function qm(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        b5 = V;
        V = V + 16 | 0;
        d2 = b5;
        c2[d2 >> 2] = a3;
        a3 = Nn() | 0;
        I(a3 | 0, c2[d2 >> 2] | 0, 4, -2147483648, 2147483647);
        V = b5;
        return;
      }
      function rm(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        b5 = V;
        V = V + 16 | 0;
        d2 = b5;
        c2[d2 >> 2] = a3;
        a3 = Ln() | 0;
        I(a3 | 0, c2[d2 >> 2] | 0, 4, 0, -1);
        V = b5;
        return;
      }
      function sm(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        b5 = V;
        V = V + 16 | 0;
        d2 = b5;
        c2[d2 >> 2] = a3;
        a3 = Jn() | 0;
        I(a3 | 0, c2[d2 >> 2] | 0, 4, -2147483648, 2147483647);
        V = b5;
        return;
      }
      function tm(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        b5 = V;
        V = V + 16 | 0;
        d2 = b5;
        c2[d2 >> 2] = a3;
        a3 = Hn() | 0;
        I(a3 | 0, c2[d2 >> 2] | 0, 4, 0, -1);
        V = b5;
        return;
      }
      function um(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        b5 = V;
        V = V + 16 | 0;
        d2 = b5;
        c2[d2 >> 2] = a3;
        a3 = Fn() | 0;
        H(a3 | 0, c2[d2 >> 2] | 0, 4);
        V = b5;
        return;
      }
      function vm(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        b5 = V;
        V = V + 16 | 0;
        d2 = b5;
        c2[d2 >> 2] = a3;
        a3 = Dn() | 0;
        H(a3 | 0, c2[d2 >> 2] | 0, 8);
        V = b5;
        return;
      }
      function wm() {
        return Cn() | 0;
      }
      function xm() {
        return Bn() | 0;
      }
      function ym() {
        return An() | 0;
      }
      function zm() {
        return zn() | 0;
      }
      function Am() {
        return yn() | 0;
      }
      function Bm() {
        return xn() | 0;
      }
      function Cm(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0;
        b5 = V;
        V = V + 16 | 0;
        d2 = b5;
        c2[d2 >> 2] = a3;
        e2 = un() | 0;
        a3 = vn() | 0;
        J(e2 | 0, a3 | 0, c2[d2 >> 2] | 0);
        V = b5;
        return;
      }
      function Dm(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0;
        b5 = V;
        V = V + 16 | 0;
        d2 = b5;
        c2[d2 >> 2] = a3;
        e2 = rn() | 0;
        a3 = sn() | 0;
        J(e2 | 0, a3 | 0, c2[d2 >> 2] | 0);
        V = b5;
        return;
      }
      function Em(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0;
        b5 = V;
        V = V + 16 | 0;
        d2 = b5;
        c2[d2 >> 2] = a3;
        e2 = on() | 0;
        a3 = pn() | 0;
        J(e2 | 0, a3 | 0, c2[d2 >> 2] | 0);
        V = b5;
        return;
      }
      function Fm(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0;
        b5 = V;
        V = V + 16 | 0;
        d2 = b5;
        c2[d2 >> 2] = a3;
        e2 = ln() | 0;
        a3 = mn() | 0;
        J(e2 | 0, a3 | 0, c2[d2 >> 2] | 0);
        V = b5;
        return;
      }
      function Gm(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0;
        b5 = V;
        V = V + 16 | 0;
        d2 = b5;
        c2[d2 >> 2] = a3;
        e2 = hn() | 0;
        a3 = jn() | 0;
        J(e2 | 0, a3 | 0, c2[d2 >> 2] | 0);
        V = b5;
        return;
      }
      function Hm(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0;
        b5 = V;
        V = V + 16 | 0;
        d2 = b5;
        c2[d2 >> 2] = a3;
        e2 = en() | 0;
        a3 = fn() | 0;
        J(e2 | 0, a3 | 0, c2[d2 >> 2] | 0);
        V = b5;
        return;
      }
      function Im(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0;
        b5 = V;
        V = V + 16 | 0;
        d2 = b5;
        c2[d2 >> 2] = a3;
        e2 = bn() | 0;
        a3 = cn() | 0;
        J(e2 | 0, a3 | 0, c2[d2 >> 2] | 0);
        V = b5;
        return;
      }
      function Jm(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0;
        b5 = V;
        V = V + 16 | 0;
        d2 = b5;
        c2[d2 >> 2] = a3;
        e2 = _m() | 0;
        a3 = $m() | 0;
        J(e2 | 0, a3 | 0, c2[d2 >> 2] | 0);
        V = b5;
        return;
      }
      function Km(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0;
        b5 = V;
        V = V + 16 | 0;
        d2 = b5;
        c2[d2 >> 2] = a3;
        e2 = Xm() | 0;
        a3 = Ym() | 0;
        J(e2 | 0, a3 | 0, c2[d2 >> 2] | 0);
        V = b5;
        return;
      }
      function Lm(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0;
        b5 = V;
        V = V + 16 | 0;
        d2 = b5;
        c2[d2 >> 2] = a3;
        e2 = Um() | 0;
        a3 = Vm() | 0;
        J(e2 | 0, a3 | 0, c2[d2 >> 2] | 0);
        V = b5;
        return;
      }
      function Mm(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0;
        b5 = V;
        V = V + 16 | 0;
        d2 = b5;
        c2[d2 >> 2] = a3;
        e2 = Rm() | 0;
        a3 = Sm() | 0;
        J(e2 | 0, a3 | 0, c2[d2 >> 2] | 0);
        V = b5;
        return;
      }
      function Nm(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0;
        b5 = V;
        V = V + 16 | 0;
        d2 = b5;
        c2[d2 >> 2] = a3;
        e2 = Om() | 0;
        a3 = Pm() | 0;
        J(e2 | 0, a3 | 0, c2[d2 >> 2] | 0);
        V = b5;
        return;
      }
      function Om() {
        return Qm() | 0;
      }
      function Pm() {
        return 7;
      }
      function Qm() {
        return 3440;
      }
      function Rm() {
        return Tm() | 0;
      }
      function Sm() {
        return 7;
      }
      function Tm() {
        return 3448;
      }
      function Um() {
        return Wm() | 0;
      }
      function Vm() {
        return 6;
      }
      function Wm() {
        return 3456;
      }
      function Xm() {
        return Zm() | 0;
      }
      function Ym() {
        return 5;
      }
      function Zm() {
        return 3464;
      }
      function _m() {
        return an() | 0;
      }
      function $m() {
        return 4;
      }
      function an() {
        return 3472;
      }
      function bn() {
        return dn() | 0;
      }
      function cn() {
        return 5;
      }
      function dn() {
        return 3480;
      }
      function en() {
        return gn() | 0;
      }
      function fn() {
        return 4;
      }
      function gn() {
        return 3488;
      }
      function hn() {
        return kn() | 0;
      }
      function jn() {
        return 3;
      }
      function kn() {
        return 3496;
      }
      function ln() {
        return nn() | 0;
      }
      function mn() {
        return 2;
      }
      function nn() {
        return 3504;
      }
      function on() {
        return qn() | 0;
      }
      function pn() {
        return 1;
      }
      function qn() {
        return 3512;
      }
      function rn() {
        return tn() | 0;
      }
      function sn() {
        return 0;
      }
      function tn() {
        return 3520;
      }
      function un() {
        return wn() | 0;
      }
      function vn() {
        return 0;
      }
      function wn() {
        return 3528;
      }
      function xn() {
        return 3536;
      }
      function yn() {
        return 3544;
      }
      function zn() {
        return 3576;
      }
      function An() {
        return 3600;
      }
      function Bn() {
        return 3624;
      }
      function Cn() {
        return 3648;
      }
      function Dn() {
        return En() | 0;
      }
      function En() {
        return 4144;
      }
      function Fn() {
        return Gn() | 0;
      }
      function Gn() {
        return 4136;
      }
      function Hn() {
        return In() | 0;
      }
      function In() {
        return 4128;
      }
      function Jn() {
        return Kn() | 0;
      }
      function Kn() {
        return 4120;
      }
      function Ln() {
        return Mn() | 0;
      }
      function Mn() {
        return 4112;
      }
      function Nn() {
        return On() | 0;
      }
      function On() {
        return 4104;
      }
      function Pn() {
        return Qn() | 0;
      }
      function Qn() {
        return 4096;
      }
      function Rn() {
        return Sn() | 0;
      }
      function Sn() {
        return 4088;
      }
      function Tn() {
        return Un() | 0;
      }
      function Un() {
        return 4072;
      }
      function Vn() {
        return Wn() | 0;
      }
      function Wn() {
        return 4080;
      }
      function Xn() {
        return Yn() | 0;
      }
      function Yn() {
        return 4064;
      }
      function Zn() {
        return 4056;
      }
      function _n() {
        return 4040;
      }
      function $n(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0, f2 = 0;
        b5 = V;
        V = V + 16 | 0;
        d2 = b5 + 8 | 0;
        e2 = b5 + 4 | 0;
        f2 = b5;
        c2[f2 >> 2] = a3;
        c2[e2 >> 2] = c2[f2 >> 2];
        c2[d2 >> 2] = c2[(c2[e2 >> 2] | 0) + 4 >> 2];
        a3 = Jo(c2[d2 >> 2] | 0) | 0;
        V = b5;
        return a3 | 0;
      }
      function ao() {
        return 21636;
      }
      function bo(a3) {
        a3 = a3 | 0;
        return (a3 + -48 | 0) >>> 0 < 10 | 0;
      }
      function co() {
        return 5576;
      }
      function eo(b5, c3) {
        b5 = b5 | 0;
        c3 = c3 | 0;
        var d2 = 0, e2 = 0;
        d2 = a2[b5 >> 0] | 0;
        e2 = a2[c3 >> 0] | 0;
        if (d2 << 24 >> 24 == 0 ? 1 : d2 << 24 >> 24 != e2 << 24 >> 24)
          b5 = e2;
        else {
          do {
            b5 = b5 + 1 | 0;
            c3 = c3 + 1 | 0;
            d2 = a2[b5 >> 0] | 0;
            e2 = a2[c3 >> 0] | 0;
          } while (!(d2 << 24 >> 24 == 0 ? 1 : d2 << 24 >> 24 != e2 << 24 >> 24));
          b5 = e2;
        }
        return (d2 & 255) - (b5 & 255) | 0;
      }
      function fo(b5) {
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0;
        f2 = b5;
        a:
          do
            if (!(f2 & 3))
              e2 = 5;
            else {
              d2 = f2;
              while (1) {
                if (!(a2[b5 >> 0] | 0)) {
                  b5 = d2;
                  break a;
                }
                b5 = b5 + 1 | 0;
                d2 = b5;
                if (!(d2 & 3)) {
                  e2 = 5;
                  break;
                }
              }
            }
          while (0);
        if ((e2 | 0) == 5) {
          while (1) {
            d2 = c2[b5 >> 2] | 0;
            if (!((d2 & -2139062144 ^ -2139062144) & d2 + -16843009))
              b5 = b5 + 4 | 0;
            else
              break;
          }
          if ((d2 & 255) << 24 >> 24)
            do
              b5 = b5 + 1 | 0;
            while ((a2[b5 >> 0] | 0) != 0);
        }
        return b5 - f2 | 0;
      }
      function go(a3) {
        a3 = a3 | 0;
        return;
      }
      function ho(a3) {
        a3 = a3 | 0;
        return 1;
      }
      function io(b5) {
        b5 = b5 | 0;
        var d2 = 0, e2 = 0;
        d2 = b5 + 74 | 0;
        e2 = a2[d2 >> 0] | 0;
        a2[d2 >> 0] = e2 + 255 | e2;
        d2 = c2[b5 >> 2] | 0;
        if (!(d2 & 8)) {
          c2[b5 + 8 >> 2] = 0;
          c2[b5 + 4 >> 2] = 0;
          e2 = c2[b5 + 44 >> 2] | 0;
          c2[b5 + 28 >> 2] = e2;
          c2[b5 + 20 >> 2] = e2;
          c2[b5 + 16 >> 2] = e2 + (c2[b5 + 48 >> 2] | 0);
          b5 = 0;
        } else {
          c2[b5 >> 2] = d2 | 32;
          b5 = -1;
        }
        return b5 | 0;
      }
      function jo(b5, d2, e2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0;
        f2 = e2 + 16 | 0;
        g2 = c2[f2 >> 2] | 0;
        if (!g2)
          if (!(io(e2) | 0)) {
            g2 = c2[f2 >> 2] | 0;
            h2 = 5;
          } else
            f2 = 0;
        else
          h2 = 5;
        a:
          do
            if ((h2 | 0) == 5) {
              j2 = e2 + 20 | 0;
              i2 = c2[j2 >> 2] | 0;
              f2 = i2;
              if ((g2 - i2 | 0) >>> 0 < d2 >>> 0) {
                f2 = aa[c2[e2 + 36 >> 2] & 7](e2, b5, d2) | 0;
                break;
              }
              b:
                do
                  if ((a2[e2 + 75 >> 0] | 0) < 0 | (d2 | 0) == 0) {
                    h2 = 0;
                    g2 = b5;
                  } else {
                    i2 = d2;
                    while (1) {
                      g2 = i2 + -1 | 0;
                      if ((a2[b5 + g2 >> 0] | 0) == 10)
                        break;
                      if (!g2) {
                        h2 = 0;
                        g2 = b5;
                        break b;
                      } else
                        i2 = g2;
                    }
                    f2 = aa[c2[e2 + 36 >> 2] & 7](e2, b5, i2) | 0;
                    if (f2 >>> 0 < i2 >>> 0)
                      break a;
                    h2 = i2;
                    g2 = b5 + i2 | 0;
                    d2 = d2 - i2 | 0;
                    f2 = c2[j2 >> 2] | 0;
                  }
                while (0);
              ur(f2 | 0, g2 | 0, d2 | 0) | 0;
              c2[j2 >> 2] = (c2[j2 >> 2] | 0) + d2;
              f2 = h2 + d2 | 0;
            }
          while (0);
        return f2 | 0;
      }
      function ko(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        if (!b5)
          b5 = 0;
        else
          b5 = lo(c2[b5 >> 2] | 0, c2[b5 + 4 >> 2] | 0, a3) | 0;
        return ((b5 | 0) == 0 ? a3 : b5) | 0;
      }
      function lo(b5, d2, e2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0, m2 = 0, n2 = 0, o2 = 0;
        o2 = (c2[b5 >> 2] | 0) + 1794895138 | 0;
        h2 = mo(c2[b5 + 8 >> 2] | 0, o2) | 0;
        f2 = mo(c2[b5 + 12 >> 2] | 0, o2) | 0;
        g2 = mo(c2[b5 + 16 >> 2] | 0, o2) | 0;
        a:
          do
            if ((h2 >>> 0 < d2 >>> 2 >>> 0 ? (n2 = d2 - (h2 << 2) | 0, f2 >>> 0 < n2 >>> 0 & g2 >>> 0 < n2 >>> 0) : 0) ? ((g2 | f2) & 3 | 0) == 0 : 0) {
              n2 = f2 >>> 2;
              m2 = g2 >>> 2;
              l2 = 0;
              while (1) {
                j2 = h2 >>> 1;
                k2 = l2 + j2 | 0;
                i2 = k2 << 1;
                g2 = i2 + n2 | 0;
                f2 = mo(c2[b5 + (g2 << 2) >> 2] | 0, o2) | 0;
                g2 = mo(c2[b5 + (g2 + 1 << 2) >> 2] | 0, o2) | 0;
                if (!(g2 >>> 0 < d2 >>> 0 & f2 >>> 0 < (d2 - g2 | 0) >>> 0)) {
                  f2 = 0;
                  break a;
                }
                if (a2[b5 + (g2 + f2) >> 0] | 0) {
                  f2 = 0;
                  break a;
                }
                f2 = eo(e2, b5 + g2 | 0) | 0;
                if (!f2)
                  break;
                f2 = (f2 | 0) < 0;
                if ((h2 | 0) == 1) {
                  f2 = 0;
                  break a;
                }
                l2 = f2 ? l2 : k2;
                h2 = f2 ? j2 : h2 - j2 | 0;
              }
              f2 = i2 + m2 | 0;
              g2 = mo(c2[b5 + (f2 << 2) >> 2] | 0, o2) | 0;
              f2 = mo(c2[b5 + (f2 + 1 << 2) >> 2] | 0, o2) | 0;
              if (f2 >>> 0 < d2 >>> 0 & g2 >>> 0 < (d2 - f2 | 0) >>> 0)
                f2 = (a2[b5 + (f2 + g2) >> 0] | 0) == 0 ? b5 + f2 | 0 : 0;
              else
                f2 = 0;
            } else
              f2 = 0;
          while (0);
        return f2 | 0;
      }
      function mo(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var c3 = 0;
        c3 = tr(a3 | 0) | 0;
        return ((b5 | 0) == 0 ? a3 : c3) | 0;
      }
      function no(b5, d2, e2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f2 = 0, g2 = 0, h2 = 0;
        h2 = d2 & 255;
        f2 = (e2 | 0) != 0;
        a:
          do
            if (f2 & (b5 & 3 | 0) != 0) {
              g2 = d2 & 255;
              while (1) {
                if ((a2[b5 >> 0] | 0) == g2 << 24 >> 24) {
                  g2 = 6;
                  break a;
                }
                b5 = b5 + 1 | 0;
                e2 = e2 + -1 | 0;
                f2 = (e2 | 0) != 0;
                if (!(f2 & (b5 & 3 | 0) != 0)) {
                  g2 = 5;
                  break;
                }
              }
            } else
              g2 = 5;
          while (0);
        if ((g2 | 0) == 5)
          if (f2)
            g2 = 6;
          else
            b5 = 0;
        b:
          do
            if ((g2 | 0) == 6) {
              if ((a2[b5 >> 0] | 0) != (d2 & 255) << 24 >> 24) {
                f2 = q(h2, 16843009) | 0;
                c:
                  do
                    if (e2 >>> 0 > 3)
                      do {
                        h2 = c2[b5 >> 2] ^ f2;
                        if ((h2 & -2139062144 ^ -2139062144) & h2 + -16843009 | 0)
                          break c;
                        b5 = b5 + 4 | 0;
                        e2 = e2 + -4 | 0;
                      } while (e2 >>> 0 > 3);
                  while (0);
              }
              if (!e2)
                b5 = 0;
              else {
                f2 = d2 & 255;
                while (1) {
                  if ((a2[b5 >> 0] | 0) == f2 << 24 >> 24)
                    break b;
                  e2 = e2 + -1 | 0;
                  if (!e2) {
                    b5 = 0;
                    break;
                  } else
                    b5 = b5 + 1 | 0;
                }
              }
            }
          while (0);
        return b5 | 0;
      }
      function oo(a3, b5, c3) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        return ro(a3, b5, c3, 1, 8) | 0;
      }
      function po(b5, e2, f2, g2, h2, i2) {
        b5 = b5 | 0;
        e2 = +e2;
        f2 = f2 | 0;
        g2 = g2 | 0;
        h2 = h2 | 0;
        i2 = i2 | 0;
        var j2 = 0, k2 = 0, l2 = 0, m2 = 0, n2 = 0, o2 = 0, p2 = 0, r2 = 0, s2 = 0, t2 = 0, v2 = 0, w2 = 0, x2 = 0, y2 = 0, z2 = 0, A2 = 0, B2 = 0, C2 = 0, D2 = 0, E2 = 0, F2 = 0, G2 = 0, H2 = 0;
        H2 = V;
        V = V + 560 | 0;
        l2 = H2 + 32 | 0;
        w2 = H2 + 536 | 0;
        G2 = H2;
        F2 = G2;
        m2 = H2 + 540 | 0;
        c2[w2 >> 2] = 0;
        E2 = m2 + 12 | 0;
        Do(e2) | 0;
        j2 = u() | 0;
        if ((j2 | 0) < 0) {
          e2 = -e2;
          Do(e2) | 0;
          D2 = 1;
          C2 = 20247;
          j2 = u() | 0;
        } else {
          D2 = (h2 & 2049 | 0) != 0 & 1;
          C2 = (h2 & 2048 | 0) == 0 ? (h2 & 1 | 0) == 0 ? 20248 : 20253 : 20250;
        }
        do
          if (true & (j2 & 2146435072 | 0) == 2146435072) {
            G2 = (i2 & 32 | 0) != 0;
            j2 = D2 + 3 | 0;
            zo(b5, 32, f2, j2, h2 & -65537);
            to(b5, C2, D2);
            to(b5, e2 != e2 | false ? G2 ? 20274 : 20278 : G2 ? 20266 : 20270, 3);
            zo(b5, 32, f2, j2, h2 ^ 8192);
          } else {
            r2 = +Eo(e2, w2) * 2;
            j2 = r2 != 0;
            if (j2)
              c2[w2 >> 2] = (c2[w2 >> 2] | 0) + -1;
            v2 = i2 | 32;
            if ((v2 | 0) == 97) {
              o2 = i2 & 32;
              s2 = (o2 | 0) == 0 ? C2 : C2 + 9 | 0;
              p2 = D2 | 2;
              j2 = 12 - g2 | 0;
              do
                if (!(g2 >>> 0 > 11 | (j2 | 0) == 0)) {
                  e2 = 8;
                  do {
                    j2 = j2 + -1 | 0;
                    e2 = e2 * 16;
                  } while ((j2 | 0) != 0);
                  if ((a2[s2 >> 0] | 0) == 45) {
                    e2 = -(e2 + (-r2 - e2));
                    break;
                  } else {
                    e2 = r2 + e2 - e2;
                    break;
                  }
                } else
                  e2 = r2;
              while (0);
              k2 = c2[w2 >> 2] | 0;
              j2 = (k2 | 0) < 0 ? 0 - k2 | 0 : k2;
              j2 = yo(j2, ((j2 | 0) < 0) << 31 >> 31, E2) | 0;
              if ((j2 | 0) == (E2 | 0)) {
                j2 = m2 + 11 | 0;
                a2[j2 >> 0] = 48;
              }
              a2[j2 + -1 >> 0] = (k2 >> 31 & 2) + 43;
              n2 = j2 + -2 | 0;
              a2[n2 >> 0] = i2 + 15;
              k2 = (g2 | 0) < 1;
              l2 = (h2 & 8 | 0) == 0;
              m2 = G2;
              do {
                D2 = ~~e2;
                j2 = m2 + 1 | 0;
                a2[m2 >> 0] = o2 | d[640 + D2 >> 0];
                e2 = (e2 - +(D2 | 0)) * 16;
                if ((j2 - F2 | 0) == 1 ? !(l2 & (k2 & e2 == 0)) : 0) {
                  a2[j2 >> 0] = 46;
                  m2 = m2 + 2 | 0;
                } else
                  m2 = j2;
              } while (e2 != 0);
              if ((g2 | 0) != 0 ? (-2 - F2 + m2 | 0) < (g2 | 0) : 0) {
                k2 = E2;
                l2 = n2;
                j2 = g2 + 2 + k2 - l2 | 0;
              } else {
                k2 = E2;
                l2 = n2;
                j2 = k2 - F2 - l2 + m2 | 0;
              }
              E2 = j2 + p2 | 0;
              zo(b5, 32, f2, E2, h2);
              to(b5, s2, p2);
              zo(b5, 48, f2, E2, h2 ^ 65536);
              F2 = m2 - F2 | 0;
              to(b5, G2, F2);
              G2 = k2 - l2 | 0;
              zo(b5, 48, j2 - (F2 + G2) | 0, 0, 0);
              to(b5, n2, G2);
              zo(b5, 32, f2, E2, h2 ^ 8192);
              j2 = E2;
              break;
            }
            k2 = (g2 | 0) < 0 ? 6 : g2;
            if (j2) {
              j2 = (c2[w2 >> 2] | 0) + -28 | 0;
              c2[w2 >> 2] = j2;
              e2 = r2 * 268435456;
            } else {
              e2 = r2;
              j2 = c2[w2 >> 2] | 0;
            }
            B2 = (j2 | 0) < 0 ? l2 : l2 + 288 | 0;
            l2 = B2;
            do {
              z2 = ~~e2 >>> 0;
              c2[l2 >> 2] = z2;
              l2 = l2 + 4 | 0;
              e2 = (e2 - +(z2 >>> 0)) * 1e9;
            } while (e2 != 0);
            z2 = B2;
            if ((j2 | 0) > 0) {
              o2 = B2;
              while (1) {
                n2 = (j2 | 0) < 29 ? j2 : 29;
                j2 = l2 + -4 | 0;
                if (j2 >>> 0 >= o2 >>> 0) {
                  m2 = 0;
                  do {
                    t2 = rr(c2[j2 >> 2] | 0, 0, n2 | 0) | 0;
                    t2 = lr(t2 | 0, u() | 0, m2 | 0, 0) | 0;
                    x2 = u() | 0;
                    m2 = pr(t2 | 0, x2 | 0, 1e9, 0) | 0;
                    y2 = kr(m2 | 0, u() | 0, 1e9, 0) | 0;
                    y2 = mr(t2 | 0, x2 | 0, y2 | 0, u() | 0) | 0;
                    u() | 0;
                    c2[j2 >> 2] = y2;
                    j2 = j2 + -4 | 0;
                  } while (j2 >>> 0 >= o2 >>> 0);
                  if (m2) {
                    y2 = o2 + -4 | 0;
                    c2[y2 >> 2] = m2;
                    m2 = y2;
                  } else
                    m2 = o2;
                } else
                  m2 = o2;
                a:
                  do
                    if (l2 >>> 0 > m2 >>> 0) {
                      j2 = l2;
                      while (1) {
                        l2 = j2 + -4 | 0;
                        if (c2[l2 >> 2] | 0) {
                          l2 = j2;
                          break a;
                        }
                        if (l2 >>> 0 > m2 >>> 0)
                          j2 = l2;
                        else
                          break;
                      }
                    }
                  while (0);
                j2 = (c2[w2 >> 2] | 0) - n2 | 0;
                c2[w2 >> 2] = j2;
                if ((j2 | 0) > 0)
                  o2 = m2;
                else
                  break;
              }
            } else
              m2 = B2;
            if ((j2 | 0) < 0) {
              g2 = ((k2 + 25 | 0) / 9 | 0) + 1 | 0;
              t2 = (v2 | 0) == 102;
              do {
                s2 = 0 - j2 | 0;
                s2 = (s2 | 0) < 9 ? s2 : 9;
                if (m2 >>> 0 < l2 >>> 0) {
                  n2 = (1 << s2) + -1 | 0;
                  o2 = 1e9 >>> s2;
                  p2 = 0;
                  j2 = m2;
                  do {
                    y2 = c2[j2 >> 2] | 0;
                    c2[j2 >> 2] = (y2 >>> s2) + p2;
                    p2 = q(y2 & n2, o2) | 0;
                    j2 = j2 + 4 | 0;
                  } while (j2 >>> 0 < l2 >>> 0);
                  m2 = (c2[m2 >> 2] | 0) == 0 ? m2 + 4 | 0 : m2;
                  if (p2) {
                    c2[l2 >> 2] = p2;
                    l2 = l2 + 4 | 0;
                  }
                } else
                  m2 = (c2[m2 >> 2] | 0) == 0 ? m2 + 4 | 0 : m2;
                j2 = t2 ? B2 : m2;
                l2 = (l2 - j2 >> 2 | 0) > (g2 | 0) ? j2 + (g2 << 2) | 0 : l2;
                j2 = (c2[w2 >> 2] | 0) + s2 | 0;
                c2[w2 >> 2] = j2;
              } while ((j2 | 0) < 0);
              t2 = m2;
            } else
              t2 = m2;
            if (t2 >>> 0 < l2 >>> 0) {
              j2 = (z2 - t2 >> 2) * 9 | 0;
              n2 = c2[t2 >> 2] | 0;
              if (n2 >>> 0 >= 10) {
                m2 = 10;
                do {
                  m2 = m2 * 10 | 0;
                  j2 = j2 + 1 | 0;
                } while (n2 >>> 0 >= m2 >>> 0);
              }
            } else
              j2 = 0;
            x2 = (v2 | 0) == 103;
            y2 = (k2 | 0) != 0;
            m2 = k2 - ((v2 | 0) == 102 ? 0 : j2) + ((y2 & x2) << 31 >> 31) | 0;
            if ((m2 | 0) < (((l2 - z2 >> 2) * 9 | 0) + -9 | 0)) {
              w2 = m2 + 9216 | 0;
              m2 = (w2 | 0) / 9 | 0;
              g2 = B2 + 4 + (m2 + -1024 << 2) | 0;
              m2 = w2 - (m2 * 9 | 0) | 0;
              if ((m2 | 0) < 8) {
                n2 = 10;
                while (1) {
                  n2 = n2 * 10 | 0;
                  if ((m2 | 0) < 7)
                    m2 = m2 + 1 | 0;
                  else
                    break;
                }
              } else
                n2 = 10;
              p2 = c2[g2 >> 2] | 0;
              m2 = (p2 >>> 0) / (n2 >>> 0) | 0;
              s2 = p2 - (q(m2, n2) | 0) | 0;
              o2 = (g2 + 4 | 0) == (l2 | 0);
              if (!(o2 & (s2 | 0) == 0)) {
                r2 = (m2 & 1 | 0) == 0 ? 9007199254740992 : 9007199254740994;
                w2 = n2 >>> 1;
                e2 = s2 >>> 0 < w2 >>> 0 ? 0.5 : o2 & (s2 | 0) == (w2 | 0) ? 1 : 1.5;
                if (D2) {
                  w2 = (a2[C2 >> 0] | 0) == 45;
                  e2 = w2 ? -e2 : e2;
                  r2 = w2 ? -r2 : r2;
                }
                m2 = p2 - s2 | 0;
                c2[g2 >> 2] = m2;
                if (r2 + e2 != r2) {
                  w2 = m2 + n2 | 0;
                  c2[g2 >> 2] = w2;
                  if (w2 >>> 0 > 999999999) {
                    n2 = g2;
                    j2 = t2;
                    while (1) {
                      m2 = n2 + -4 | 0;
                      c2[n2 >> 2] = 0;
                      if (m2 >>> 0 < j2 >>> 0) {
                        j2 = j2 + -4 | 0;
                        c2[j2 >> 2] = 0;
                      }
                      w2 = (c2[m2 >> 2] | 0) + 1 | 0;
                      c2[m2 >> 2] = w2;
                      if (w2 >>> 0 > 999999999)
                        n2 = m2;
                      else {
                        n2 = j2;
                        break;
                      }
                    }
                  } else {
                    m2 = g2;
                    n2 = t2;
                  }
                  j2 = (z2 - n2 >> 2) * 9 | 0;
                  p2 = c2[n2 >> 2] | 0;
                  if (p2 >>> 0 >= 10) {
                    o2 = 10;
                    do {
                      o2 = o2 * 10 | 0;
                      j2 = j2 + 1 | 0;
                    } while (p2 >>> 0 >= o2 >>> 0);
                  }
                } else {
                  m2 = g2;
                  n2 = t2;
                }
              } else {
                m2 = g2;
                n2 = t2;
              }
              w2 = m2 + 4 | 0;
              l2 = l2 >>> 0 > w2 >>> 0 ? w2 : l2;
            } else
              n2 = t2;
            g2 = 0 - j2 | 0;
            b:
              do
                if (l2 >>> 0 > n2 >>> 0)
                  while (1) {
                    m2 = l2 + -4 | 0;
                    if (c2[m2 >> 2] | 0) {
                      w2 = l2;
                      v2 = 1;
                      break b;
                    }
                    if (m2 >>> 0 > n2 >>> 0)
                      l2 = m2;
                    else {
                      w2 = m2;
                      v2 = 0;
                      break;
                    }
                  }
                else {
                  w2 = l2;
                  v2 = 0;
                }
              while (0);
            do
              if (x2) {
                k2 = k2 + ((y2 ^ 1) & 1) | 0;
                if ((k2 | 0) > (j2 | 0) & (j2 | 0) > -5) {
                  o2 = i2 + -1 | 0;
                  k2 = k2 + -1 - j2 | 0;
                } else {
                  o2 = i2 + -2 | 0;
                  k2 = k2 + -1 | 0;
                }
                if (!(h2 & 8)) {
                  if (v2 ? (A2 = c2[w2 + -4 >> 2] | 0, (A2 | 0) != 0) : 0)
                    if (!((A2 >>> 0) % 10 | 0)) {
                      m2 = 0;
                      l2 = 10;
                      do {
                        l2 = l2 * 10 | 0;
                        m2 = m2 + 1 | 0;
                      } while (!((A2 >>> 0) % (l2 >>> 0) | 0 | 0));
                    } else
                      m2 = 0;
                  else
                    m2 = 9;
                  l2 = ((w2 - z2 >> 2) * 9 | 0) + -9 | 0;
                  if ((o2 | 32 | 0) == 102) {
                    i2 = l2 - m2 | 0;
                    i2 = (i2 | 0) > 0 ? i2 : 0;
                    k2 = (k2 | 0) < (i2 | 0) ? k2 : i2;
                    break;
                  } else {
                    i2 = l2 + j2 - m2 | 0;
                    i2 = (i2 | 0) > 0 ? i2 : 0;
                    k2 = (k2 | 0) < (i2 | 0) ? k2 : i2;
                    break;
                  }
                }
              } else
                o2 = i2;
            while (0);
            t2 = (k2 | 0) != 0;
            p2 = t2 ? 1 : h2 >>> 3 & 1;
            s2 = (o2 | 32 | 0) == 102;
            if (s2) {
              x2 = 0;
              j2 = (j2 | 0) > 0 ? j2 : 0;
            } else {
              l2 = (j2 | 0) < 0 ? g2 : j2;
              l2 = yo(l2, ((l2 | 0) < 0) << 31 >> 31, E2) | 0;
              m2 = E2;
              if ((m2 - l2 | 0) < 2)
                do {
                  l2 = l2 + -1 | 0;
                  a2[l2 >> 0] = 48;
                } while ((m2 - l2 | 0) < 2);
              a2[l2 + -1 >> 0] = (j2 >> 31 & 2) + 43;
              j2 = l2 + -2 | 0;
              a2[j2 >> 0] = o2;
              x2 = j2;
              j2 = m2 - j2 | 0;
            }
            j2 = D2 + 1 + k2 + p2 + j2 | 0;
            zo(b5, 32, f2, j2, h2);
            to(b5, C2, D2);
            zo(b5, 48, f2, j2, h2 ^ 65536);
            if (s2) {
              p2 = n2 >>> 0 > B2 >>> 0 ? B2 : n2;
              s2 = G2 + 9 | 0;
              n2 = s2;
              o2 = G2 + 8 | 0;
              m2 = p2;
              do {
                l2 = yo(c2[m2 >> 2] | 0, 0, s2) | 0;
                if ((m2 | 0) == (p2 | 0)) {
                  if ((l2 | 0) == (s2 | 0)) {
                    a2[o2 >> 0] = 48;
                    l2 = o2;
                  }
                } else if (l2 >>> 0 > G2 >>> 0) {
                  wr(G2 | 0, 48, l2 - F2 | 0) | 0;
                  do
                    l2 = l2 + -1 | 0;
                  while (l2 >>> 0 > G2 >>> 0);
                }
                to(b5, l2, n2 - l2 | 0);
                m2 = m2 + 4 | 0;
              } while (m2 >>> 0 <= B2 >>> 0);
              if (!((h2 & 8 | 0) == 0 & (t2 ^ 1)))
                to(b5, 20282, 1);
              if (m2 >>> 0 < w2 >>> 0 & (k2 | 0) > 0)
                while (1) {
                  l2 = yo(c2[m2 >> 2] | 0, 0, s2) | 0;
                  if (l2 >>> 0 > G2 >>> 0) {
                    wr(G2 | 0, 48, l2 - F2 | 0) | 0;
                    do
                      l2 = l2 + -1 | 0;
                    while (l2 >>> 0 > G2 >>> 0);
                  }
                  to(b5, l2, (k2 | 0) < 9 ? k2 : 9);
                  m2 = m2 + 4 | 0;
                  l2 = k2 + -9 | 0;
                  if (!(m2 >>> 0 < w2 >>> 0 & (k2 | 0) > 9)) {
                    k2 = l2;
                    break;
                  } else
                    k2 = l2;
                }
              zo(b5, 48, k2 + 9 | 0, 9, 0);
            } else {
              w2 = v2 ? w2 : n2 + 4 | 0;
              if (n2 >>> 0 < w2 >>> 0 & (k2 | 0) > -1) {
                g2 = G2 + 9 | 0;
                t2 = (h2 & 8 | 0) == 0;
                v2 = g2;
                p2 = 0 - F2 | 0;
                s2 = G2 + 8 | 0;
                o2 = n2;
                do {
                  l2 = yo(c2[o2 >> 2] | 0, 0, g2) | 0;
                  if ((l2 | 0) == (g2 | 0)) {
                    a2[s2 >> 0] = 48;
                    l2 = s2;
                  }
                  do
                    if ((o2 | 0) == (n2 | 0)) {
                      m2 = l2 + 1 | 0;
                      to(b5, l2, 1);
                      if (t2 & (k2 | 0) < 1) {
                        l2 = m2;
                        break;
                      }
                      to(b5, 20282, 1);
                      l2 = m2;
                    } else {
                      if (l2 >>> 0 <= G2 >>> 0)
                        break;
                      wr(G2 | 0, 48, l2 + p2 | 0) | 0;
                      do
                        l2 = l2 + -1 | 0;
                      while (l2 >>> 0 > G2 >>> 0);
                    }
                  while (0);
                  F2 = v2 - l2 | 0;
                  to(b5, l2, (k2 | 0) > (F2 | 0) ? F2 : k2);
                  k2 = k2 - F2 | 0;
                  o2 = o2 + 4 | 0;
                } while (o2 >>> 0 < w2 >>> 0 & (k2 | 0) > -1);
              }
              zo(b5, 48, k2 + 18 | 0, 18, 0);
              to(b5, x2, E2 - x2 | 0);
            }
            zo(b5, 32, f2, j2, h2 ^ 8192);
          }
        while (0);
        V = H2;
        return ((j2 | 0) < (f2 | 0) ? f2 : j2) | 0;
      }
      function qo(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0;
        e2 = (c2[b5 >> 2] | 0) + (8 - 1) & ~(8 - 1);
        d2 = +g[e2 >> 3];
        c2[b5 >> 2] = e2 + 8;
        g[a3 >> 3] = d2;
        return;
      }
      function ro(b5, d2, e2, f2, g2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        var h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0, m2 = 0, n2 = 0, o2 = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0;
        t2 = V;
        V = V + 224 | 0;
        p2 = t2 + 208 | 0;
        q2 = t2 + 160 | 0;
        r2 = t2 + 80 | 0;
        s2 = t2;
        h2 = q2;
        i2 = h2 + 40 | 0;
        do {
          c2[h2 >> 2] = 0;
          h2 = h2 + 4 | 0;
        } while ((h2 | 0) < (i2 | 0));
        c2[p2 >> 2] = c2[e2 >> 2];
        if ((so(0, d2, p2, r2, q2, f2, g2) | 0) < 0)
          e2 = -1;
        else {
          if ((c2[b5 + 76 >> 2] | 0) > -1)
            o2 = ho(b5) | 0;
          else
            o2 = 0;
          e2 = c2[b5 >> 2] | 0;
          n2 = e2 & 32;
          if ((a2[b5 + 74 >> 0] | 0) < 1)
            c2[b5 >> 2] = e2 & -33;
          h2 = b5 + 48 | 0;
          if (!(c2[h2 >> 2] | 0)) {
            i2 = b5 + 44 | 0;
            j2 = c2[i2 >> 2] | 0;
            c2[i2 >> 2] = s2;
            k2 = b5 + 28 | 0;
            c2[k2 >> 2] = s2;
            l2 = b5 + 20 | 0;
            c2[l2 >> 2] = s2;
            c2[h2 >> 2] = 80;
            m2 = b5 + 16 | 0;
            c2[m2 >> 2] = s2 + 80;
            e2 = so(b5, d2, p2, r2, q2, f2, g2) | 0;
            if (j2) {
              aa[c2[b5 + 36 >> 2] & 7](b5, 0, 0) | 0;
              e2 = (c2[l2 >> 2] | 0) == 0 ? -1 : e2;
              c2[i2 >> 2] = j2;
              c2[h2 >> 2] = 0;
              c2[m2 >> 2] = 0;
              c2[k2 >> 2] = 0;
              c2[l2 >> 2] = 0;
            }
          } else
            e2 = so(b5, d2, p2, r2, q2, f2, g2) | 0;
          h2 = c2[b5 >> 2] | 0;
          c2[b5 >> 2] = h2 | n2;
          if (o2 | 0)
            go(b5);
          e2 = (h2 & 32 | 0) == 0 ? e2 : -1;
        }
        V = t2;
        return e2 | 0;
      }
      function so(d2, e2, f2, h2, i2, j2, k2) {
        d2 = d2 | 0;
        e2 = e2 | 0;
        f2 = f2 | 0;
        h2 = h2 | 0;
        i2 = i2 | 0;
        j2 = j2 | 0;
        k2 = k2 | 0;
        var l2 = 0, m2 = 0, n2 = 0, o2 = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0, v2 = 0, w2 = 0, x2 = 0, y2 = 0, z2 = 0, A2 = 0, B2 = 0, C2 = 0, D2 = 0, E2 = 0, F2 = 0, G2 = 0, H2 = 0, I2 = 0, J2 = 0, K2 = 0;
        J2 = V;
        V = V + 64 | 0;
        G2 = J2 + 56 | 0;
        I2 = J2 + 40 | 0;
        B2 = J2;
        D2 = J2 + 48 | 0;
        E2 = J2 + 60 | 0;
        c2[G2 >> 2] = e2;
        y2 = (d2 | 0) != 0;
        z2 = B2 + 40 | 0;
        A2 = z2;
        B2 = B2 + 39 | 0;
        C2 = D2 + 4 | 0;
        l2 = 0;
        e2 = 0;
        n2 = 0;
        a:
          while (1) {
            do {
              do
                if ((e2 | 0) > -1)
                  if ((l2 | 0) > (2147483647 - e2 | 0)) {
                    c2[(ao() | 0) >> 2] = 61;
                    e2 = -1;
                    break;
                  } else {
                    e2 = l2 + e2 | 0;
                    break;
                  }
              while (0);
              r2 = c2[G2 >> 2] | 0;
              l2 = a2[r2 >> 0] | 0;
              if (!(l2 << 24 >> 24)) {
                x2 = 92;
                break a;
              }
              m2 = r2;
              b:
                while (1) {
                  switch (l2 << 24 >> 24) {
                    case 37: {
                      x2 = 10;
                      break b;
                    }
                    case 0: {
                      l2 = m2;
                      break b;
                    }
                    default: {
                    }
                  }
                  w2 = m2 + 1 | 0;
                  c2[G2 >> 2] = w2;
                  l2 = a2[w2 >> 0] | 0;
                  m2 = w2;
                }
              c:
                do
                  if ((x2 | 0) == 10) {
                    x2 = 0;
                    l2 = m2;
                    do {
                      if ((a2[m2 + 1 >> 0] | 0) != 37)
                        break c;
                      l2 = l2 + 1 | 0;
                      m2 = m2 + 2 | 0;
                      c2[G2 >> 2] = m2;
                    } while ((a2[m2 >> 0] | 0) == 37);
                  }
                while (0);
              l2 = l2 - r2 | 0;
              if (y2)
                to(d2, r2, l2);
            } while ((l2 | 0) != 0);
            w2 = (bo(a2[(c2[G2 >> 2] | 0) + 1 >> 0] | 0) | 0) == 0;
            m2 = c2[G2 >> 2] | 0;
            if (!w2 ? (a2[m2 + 2 >> 0] | 0) == 36 : 0) {
              t2 = (a2[m2 + 1 >> 0] | 0) + -48 | 0;
              p2 = 1;
              l2 = 3;
            } else {
              t2 = -1;
              p2 = n2;
              l2 = 1;
            }
            l2 = m2 + l2 | 0;
            c2[G2 >> 2] = l2;
            m2 = a2[l2 >> 0] | 0;
            n2 = (m2 << 24 >> 24) + -32 | 0;
            if (n2 >>> 0 > 31 | (1 << n2 & 75913 | 0) == 0)
              o2 = 0;
            else {
              o2 = 0;
              do {
                o2 = 1 << n2 | o2;
                l2 = l2 + 1 | 0;
                c2[G2 >> 2] = l2;
                m2 = a2[l2 >> 0] | 0;
                n2 = (m2 << 24 >> 24) + -32 | 0;
              } while (!(n2 >>> 0 > 31 | (1 << n2 & 75913 | 0) == 0));
            }
            if (m2 << 24 >> 24 == 42) {
              if ((bo(a2[l2 + 1 >> 0] | 0) | 0) != 0 ? (H2 = c2[G2 >> 2] | 0, (a2[H2 + 2 >> 0] | 0) == 36) : 0) {
                l2 = H2 + 1 | 0;
                c2[i2 + ((a2[l2 >> 0] | 0) + -48 << 2) >> 2] = 10;
                l2 = c2[h2 + ((a2[l2 >> 0] | 0) + -48 << 3) >> 2] | 0;
                n2 = 1;
                m2 = H2 + 3 | 0;
              } else {
                if (p2 | 0) {
                  e2 = -1;
                  break;
                }
                if (y2) {
                  w2 = (c2[f2 >> 2] | 0) + (4 - 1) & ~(4 - 1);
                  l2 = c2[w2 >> 2] | 0;
                  c2[f2 >> 2] = w2 + 4;
                } else
                  l2 = 0;
                n2 = 0;
                m2 = (c2[G2 >> 2] | 0) + 1 | 0;
              }
              c2[G2 >> 2] = m2;
              w2 = (l2 | 0) < 0;
              v2 = w2 ? 0 - l2 | 0 : l2;
              o2 = w2 ? o2 | 8192 : o2;
              w2 = n2;
            } else {
              l2 = uo(G2) | 0;
              if ((l2 | 0) < 0) {
                e2 = -1;
                break;
              }
              v2 = l2;
              w2 = p2;
              m2 = c2[G2 >> 2] | 0;
            }
            do
              if ((a2[m2 >> 0] | 0) == 46) {
                l2 = m2 + 1 | 0;
                if ((a2[l2 >> 0] | 0) != 42) {
                  c2[G2 >> 2] = l2;
                  l2 = uo(G2) | 0;
                  m2 = c2[G2 >> 2] | 0;
                  break;
                }
                if (bo(a2[m2 + 2 >> 0] | 0) | 0 ? (F2 = c2[G2 >> 2] | 0, (a2[F2 + 3 >> 0] | 0) == 36) : 0) {
                  l2 = F2 + 2 | 0;
                  c2[i2 + ((a2[l2 >> 0] | 0) + -48 << 2) >> 2] = 10;
                  l2 = c2[h2 + ((a2[l2 >> 0] | 0) + -48 << 3) >> 2] | 0;
                  m2 = F2 + 4 | 0;
                  c2[G2 >> 2] = m2;
                  break;
                }
                if (w2 | 0) {
                  e2 = -1;
                  break a;
                }
                if (y2) {
                  s2 = (c2[f2 >> 2] | 0) + (4 - 1) & ~(4 - 1);
                  l2 = c2[s2 >> 2] | 0;
                  c2[f2 >> 2] = s2 + 4;
                } else
                  l2 = 0;
                m2 = (c2[G2 >> 2] | 0) + 2 | 0;
                c2[G2 >> 2] = m2;
              } else
                l2 = -1;
            while (0);
            s2 = 0;
            while (1) {
              if (((a2[m2 >> 0] | 0) + -65 | 0) >>> 0 > 57) {
                e2 = -1;
                break a;
              }
              n2 = m2;
              m2 = m2 + 1 | 0;
              c2[G2 >> 2] = m2;
              n2 = a2[(a2[n2 >> 0] | 0) + -65 + (176 + (s2 * 58 | 0)) >> 0] | 0;
              p2 = n2 & 255;
              if ((p2 + -1 | 0) >>> 0 >= 8)
                break;
              else
                s2 = p2;
            }
            if (!(n2 << 24 >> 24)) {
              e2 = -1;
              break;
            }
            q2 = (t2 | 0) > -1;
            do
              if (n2 << 24 >> 24 == 19)
                if (q2) {
                  e2 = -1;
                  break a;
                } else
                  x2 = 54;
              else {
                if (q2) {
                  c2[i2 + (t2 << 2) >> 2] = p2;
                  q2 = h2 + (t2 << 3) | 0;
                  t2 = c2[q2 + 4 >> 2] | 0;
                  x2 = I2;
                  c2[x2 >> 2] = c2[q2 >> 2];
                  c2[x2 + 4 >> 2] = t2;
                  x2 = 54;
                  break;
                }
                if (!y2) {
                  e2 = 0;
                  break a;
                }
                vo(I2, p2, f2, k2);
                m2 = c2[G2 >> 2] | 0;
                x2 = 55;
              }
            while (0);
            if ((x2 | 0) == 54) {
              x2 = 0;
              if (y2)
                x2 = 55;
              else
                l2 = 0;
            }
            d:
              do
                if ((x2 | 0) == 55) {
                  x2 = 0;
                  m2 = a2[m2 + -1 >> 0] | 0;
                  m2 = (s2 | 0) != 0 & (m2 & 15 | 0) == 3 ? m2 & -33 : m2;
                  n2 = o2 & -65537;
                  t2 = (o2 & 8192 | 0) == 0 ? o2 : n2;
                  e:
                    do
                      switch (m2 | 0) {
                        case 110:
                          switch ((s2 & 255) << 24 >> 24) {
                            case 0: {
                              c2[c2[I2 >> 2] >> 2] = e2;
                              l2 = 0;
                              break d;
                            }
                            case 1: {
                              c2[c2[I2 >> 2] >> 2] = e2;
                              l2 = 0;
                              break d;
                            }
                            case 2: {
                              l2 = c2[I2 >> 2] | 0;
                              c2[l2 >> 2] = e2;
                              c2[l2 + 4 >> 2] = ((e2 | 0) < 0) << 31 >> 31;
                              l2 = 0;
                              break d;
                            }
                            case 3: {
                              b4[c2[I2 >> 2] >> 1] = e2;
                              l2 = 0;
                              break d;
                            }
                            case 4: {
                              a2[c2[I2 >> 2] >> 0] = e2;
                              l2 = 0;
                              break d;
                            }
                            case 6: {
                              c2[c2[I2 >> 2] >> 2] = e2;
                              l2 = 0;
                              break d;
                            }
                            case 7: {
                              l2 = c2[I2 >> 2] | 0;
                              c2[l2 >> 2] = e2;
                              c2[l2 + 4 >> 2] = ((e2 | 0) < 0) << 31 >> 31;
                              l2 = 0;
                              break d;
                            }
                            default: {
                              l2 = 0;
                              break d;
                            }
                          }
                        case 112: {
                          m2 = 120;
                          l2 = l2 >>> 0 > 8 ? l2 : 8;
                          n2 = t2 | 8;
                          x2 = 67;
                          break;
                        }
                        case 88:
                        case 120: {
                          n2 = t2;
                          x2 = 67;
                          break;
                        }
                        case 111: {
                          q2 = I2;
                          q2 = xo(c2[q2 >> 2] | 0, c2[q2 + 4 >> 2] | 0, z2) | 0;
                          n2 = A2 - q2 | 0;
                          o2 = 0;
                          p2 = 20230;
                          l2 = (t2 & 8 | 0) == 0 | (l2 | 0) > (n2 | 0) ? l2 : n2 + 1 | 0;
                          n2 = t2;
                          x2 = 73;
                          break;
                        }
                        case 105:
                        case 100: {
                          n2 = I2;
                          m2 = c2[n2 >> 2] | 0;
                          n2 = c2[n2 + 4 >> 2] | 0;
                          if ((n2 | 0) < 0) {
                            m2 = mr(0, 0, m2 | 0, n2 | 0) | 0;
                            n2 = u() | 0;
                            o2 = I2;
                            c2[o2 >> 2] = m2;
                            c2[o2 + 4 >> 2] = n2;
                            o2 = 1;
                            p2 = 20230;
                            x2 = 72;
                            break e;
                          } else {
                            o2 = (t2 & 2049 | 0) != 0 & 1;
                            p2 = (t2 & 2048 | 0) == 0 ? (t2 & 1 | 0) == 0 ? 20230 : 20232 : 20231;
                            x2 = 72;
                            break e;
                          }
                        }
                        case 117: {
                          n2 = I2;
                          o2 = 0;
                          p2 = 20230;
                          m2 = c2[n2 >> 2] | 0;
                          n2 = c2[n2 + 4 >> 2] | 0;
                          x2 = 72;
                          break;
                        }
                        case 99: {
                          a2[B2 >> 0] = c2[I2 >> 2];
                          r2 = B2;
                          o2 = 0;
                          p2 = 20230;
                          q2 = 1;
                          m2 = n2;
                          l2 = A2;
                          break;
                        }
                        case 115: {
                          s2 = c2[I2 >> 2] | 0;
                          s2 = (s2 | 0) == 0 ? 20240 : s2;
                          t2 = no(s2, 0, l2) | 0;
                          K2 = (t2 | 0) == 0;
                          r2 = s2;
                          o2 = 0;
                          p2 = 20230;
                          q2 = K2 ? l2 : t2 - s2 | 0;
                          m2 = n2;
                          l2 = K2 ? s2 + l2 | 0 : t2;
                          break;
                        }
                        case 67: {
                          c2[D2 >> 2] = c2[I2 >> 2];
                          c2[C2 >> 2] = 0;
                          c2[I2 >> 2] = D2;
                          p2 = -1;
                          x2 = 79;
                          break;
                        }
                        case 83: {
                          if (!l2) {
                            zo(d2, 32, v2, 0, t2);
                            l2 = 0;
                            x2 = 89;
                          } else {
                            p2 = l2;
                            x2 = 79;
                          }
                          break;
                        }
                        case 65:
                        case 71:
                        case 70:
                        case 69:
                        case 97:
                        case 103:
                        case 102:
                        case 101: {
                          l2 = _[j2 & 1](d2, +g[I2 >> 3], v2, l2, t2, m2) | 0;
                          break d;
                        }
                        default: {
                          o2 = 0;
                          p2 = 20230;
                          q2 = l2;
                          m2 = t2;
                          l2 = A2;
                        }
                      }
                    while (0);
                  f:
                    do
                      if ((x2 | 0) == 67) {
                        q2 = I2;
                        q2 = wo(c2[q2 >> 2] | 0, c2[q2 + 4 >> 2] | 0, z2, m2 & 32) | 0;
                        p2 = I2;
                        p2 = (n2 & 8 | 0) == 0 | (c2[p2 >> 2] | 0) == 0 & (c2[p2 + 4 >> 2] | 0) == 0;
                        o2 = p2 ? 0 : 2;
                        p2 = p2 ? 20230 : 20230 + (m2 >>> 4) | 0;
                        x2 = 73;
                      } else if ((x2 | 0) == 72) {
                        q2 = yo(m2, n2, z2) | 0;
                        n2 = t2;
                        x2 = 73;
                      } else if ((x2 | 0) == 79) {
                        x2 = 0;
                        o2 = c2[I2 >> 2] | 0;
                        l2 = 0;
                        while (1) {
                          m2 = c2[o2 >> 2] | 0;
                          if (!m2)
                            break;
                          m2 = Ao(E2, m2) | 0;
                          n2 = (m2 | 0) < 0;
                          if (n2 | m2 >>> 0 > (p2 - l2 | 0) >>> 0) {
                            x2 = 83;
                            break;
                          }
                          l2 = m2 + l2 | 0;
                          if (p2 >>> 0 > l2 >>> 0)
                            o2 = o2 + 4 | 0;
                          else
                            break;
                        }
                        if ((x2 | 0) == 83) {
                          x2 = 0;
                          if (n2) {
                            e2 = -1;
                            break a;
                          }
                        }
                        zo(d2, 32, v2, l2, t2);
                        if (!l2) {
                          l2 = 0;
                          x2 = 89;
                        } else {
                          n2 = c2[I2 >> 2] | 0;
                          o2 = 0;
                          while (1) {
                            m2 = c2[n2 >> 2] | 0;
                            if (!m2) {
                              x2 = 89;
                              break f;
                            }
                            m2 = Ao(E2, m2) | 0;
                            o2 = m2 + o2 | 0;
                            if ((o2 | 0) > (l2 | 0)) {
                              x2 = 89;
                              break f;
                            }
                            to(d2, E2, m2);
                            if (o2 >>> 0 >= l2 >>> 0) {
                              x2 = 89;
                              break;
                            } else
                              n2 = n2 + 4 | 0;
                          }
                        }
                      }
                    while (0);
                  if ((x2 | 0) == 73) {
                    x2 = 0;
                    m2 = I2;
                    m2 = (c2[m2 >> 2] | 0) != 0 | (c2[m2 + 4 >> 2] | 0) != 0;
                    K2 = (l2 | 0) != 0 | m2;
                    m2 = A2 - q2 + ((m2 ^ 1) & 1) | 0;
                    r2 = K2 ? q2 : z2;
                    q2 = K2 ? (l2 | 0) > (m2 | 0) ? l2 : m2 : 0;
                    m2 = (l2 | 0) > -1 ? n2 & -65537 : n2;
                    l2 = A2;
                  } else if ((x2 | 0) == 89) {
                    x2 = 0;
                    zo(d2, 32, v2, l2, t2 ^ 8192);
                    l2 = (v2 | 0) > (l2 | 0) ? v2 : l2;
                    break;
                  }
                  t2 = l2 - r2 | 0;
                  s2 = (q2 | 0) < (t2 | 0) ? t2 : q2;
                  K2 = s2 + o2 | 0;
                  l2 = (v2 | 0) < (K2 | 0) ? K2 : v2;
                  zo(d2, 32, l2, K2, m2);
                  to(d2, p2, o2);
                  zo(d2, 48, l2, K2, m2 ^ 65536);
                  zo(d2, 48, s2, t2, 0);
                  to(d2, r2, t2);
                  zo(d2, 32, l2, K2, m2 ^ 8192);
                }
              while (0);
            n2 = w2;
          }
        g:
          do
            if ((x2 | 0) == 92) {
              if (!d2)
                if (!n2)
                  e2 = 0;
                else {
                  e2 = 1;
                  while (1) {
                    l2 = c2[i2 + (e2 << 2) >> 2] | 0;
                    if (!l2)
                      break;
                    vo(h2 + (e2 << 3) | 0, l2, f2, k2);
                    e2 = e2 + 1 | 0;
                    if (e2 >>> 0 >= 10) {
                      e2 = 1;
                      break g;
                    }
                  }
                  while (1) {
                    if (c2[i2 + (e2 << 2) >> 2] | 0) {
                      e2 = -1;
                      break g;
                    }
                    e2 = e2 + 1 | 0;
                    if (e2 >>> 0 >= 10) {
                      e2 = 1;
                      break;
                    }
                  }
                }
            }
          while (0);
        V = J2;
        return e2 | 0;
      }
      function to(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        if (!(c2[a3 >> 2] & 32))
          jo(b5, d2, a3) | 0;
        return;
      }
      function uo(b5) {
        b5 = b5 | 0;
        var d2 = 0, e2 = 0;
        if (!(bo(a2[c2[b5 >> 2] >> 0] | 0) | 0))
          d2 = 0;
        else {
          d2 = 0;
          do {
            e2 = c2[b5 >> 2] | 0;
            d2 = (d2 * 10 | 0) + -48 + (a2[e2 >> 0] | 0) | 0;
            e2 = e2 + 1 | 0;
            c2[b5 >> 2] = e2;
          } while ((bo(a2[e2 >> 0] | 0) | 0) != 0);
        }
        return d2 | 0;
      }
      function vo(a3, b5, d2, e2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f2 = 0, h2 = 0;
        a:
          do
            if (b5 >>> 0 <= 20)
              do
                switch (b5 | 0) {
                  case 9: {
                    b5 = (c2[d2 >> 2] | 0) + (4 - 1) & ~(4 - 1);
                    e2 = c2[b5 >> 2] | 0;
                    c2[d2 >> 2] = b5 + 4;
                    c2[a3 >> 2] = e2;
                    break a;
                  }
                  case 10: {
                    e2 = (c2[d2 >> 2] | 0) + (4 - 1) & ~(4 - 1);
                    b5 = c2[e2 >> 2] | 0;
                    c2[d2 >> 2] = e2 + 4;
                    e2 = a3;
                    c2[e2 >> 2] = b5;
                    c2[e2 + 4 >> 2] = ((b5 | 0) < 0) << 31 >> 31;
                    break a;
                  }
                  case 11: {
                    e2 = (c2[d2 >> 2] | 0) + (4 - 1) & ~(4 - 1);
                    b5 = c2[e2 >> 2] | 0;
                    c2[d2 >> 2] = e2 + 4;
                    e2 = a3;
                    c2[e2 >> 2] = b5;
                    c2[e2 + 4 >> 2] = 0;
                    break a;
                  }
                  case 12: {
                    e2 = (c2[d2 >> 2] | 0) + (8 - 1) & ~(8 - 1);
                    b5 = e2;
                    f2 = c2[b5 >> 2] | 0;
                    b5 = c2[b5 + 4 >> 2] | 0;
                    c2[d2 >> 2] = e2 + 8;
                    e2 = a3;
                    c2[e2 >> 2] = f2;
                    c2[e2 + 4 >> 2] = b5;
                    break a;
                  }
                  case 13: {
                    f2 = (c2[d2 >> 2] | 0) + (4 - 1) & ~(4 - 1);
                    e2 = c2[f2 >> 2] | 0;
                    c2[d2 >> 2] = f2 + 4;
                    e2 = (e2 & 65535) << 16 >> 16;
                    f2 = a3;
                    c2[f2 >> 2] = e2;
                    c2[f2 + 4 >> 2] = ((e2 | 0) < 0) << 31 >> 31;
                    break a;
                  }
                  case 14: {
                    f2 = (c2[d2 >> 2] | 0) + (4 - 1) & ~(4 - 1);
                    e2 = c2[f2 >> 2] | 0;
                    c2[d2 >> 2] = f2 + 4;
                    f2 = a3;
                    c2[f2 >> 2] = e2 & 65535;
                    c2[f2 + 4 >> 2] = 0;
                    break a;
                  }
                  case 15: {
                    f2 = (c2[d2 >> 2] | 0) + (4 - 1) & ~(4 - 1);
                    e2 = c2[f2 >> 2] | 0;
                    c2[d2 >> 2] = f2 + 4;
                    e2 = (e2 & 255) << 24 >> 24;
                    f2 = a3;
                    c2[f2 >> 2] = e2;
                    c2[f2 + 4 >> 2] = ((e2 | 0) < 0) << 31 >> 31;
                    break a;
                  }
                  case 16: {
                    f2 = (c2[d2 >> 2] | 0) + (4 - 1) & ~(4 - 1);
                    e2 = c2[f2 >> 2] | 0;
                    c2[d2 >> 2] = f2 + 4;
                    f2 = a3;
                    c2[f2 >> 2] = e2 & 255;
                    c2[f2 + 4 >> 2] = 0;
                    break a;
                  }
                  case 17: {
                    f2 = (c2[d2 >> 2] | 0) + (8 - 1) & ~(8 - 1);
                    h2 = +g[f2 >> 3];
                    c2[d2 >> 2] = f2 + 8;
                    g[a3 >> 3] = h2;
                    break a;
                  }
                  case 18: {
                    da[e2 & 15](a3, d2);
                    break a;
                  }
                  default:
                    break a;
                }
              while (0);
          while (0);
        return;
      }
      function wo(b5, c3, e2, f2) {
        b5 = b5 | 0;
        c3 = c3 | 0;
        e2 = e2 | 0;
        f2 = f2 | 0;
        if (!((b5 | 0) == 0 & (c3 | 0) == 0))
          do {
            e2 = e2 + -1 | 0;
            a2[e2 >> 0] = d[640 + (b5 & 15) >> 0] | 0 | f2;
            b5 = qr(b5 | 0, c3 | 0, 4) | 0;
            c3 = u() | 0;
          } while (!((b5 | 0) == 0 & (c3 | 0) == 0));
        return e2 | 0;
      }
      function xo(b5, c3, d2) {
        b5 = b5 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        if (!((b5 | 0) == 0 & (c3 | 0) == 0))
          do {
            d2 = d2 + -1 | 0;
            a2[d2 >> 0] = b5 & 7 | 48;
            b5 = qr(b5 | 0, c3 | 0, 3) | 0;
            c3 = u() | 0;
          } while (!((b5 | 0) == 0 & (c3 | 0) == 0));
        return d2 | 0;
      }
      function yo(b5, c3, d2) {
        b5 = b5 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0, g2 = 0;
        if (c3 >>> 0 > 0 | (c3 | 0) == 0 & b5 >>> 0 > 4294967295) {
          do {
            e2 = b5;
            b5 = pr(b5 | 0, c3 | 0, 10, 0) | 0;
            f2 = c3;
            c3 = u() | 0;
            g2 = kr(b5 | 0, c3 | 0, 10, 0) | 0;
            g2 = mr(e2 | 0, f2 | 0, g2 | 0, u() | 0) | 0;
            u() | 0;
            d2 = d2 + -1 | 0;
            a2[d2 >> 0] = g2 & 255 | 48;
          } while (f2 >>> 0 > 9 | (f2 | 0) == 9 & e2 >>> 0 > 4294967295);
          c3 = b5;
        } else
          c3 = b5;
        if (c3)
          do {
            g2 = c3;
            c3 = (c3 >>> 0) / 10 | 0;
            d2 = d2 + -1 | 0;
            a2[d2 >> 0] = g2 - (c3 * 10 | 0) | 48;
          } while (g2 >>> 0 >= 10);
        return d2 | 0;
      }
      function zo(a3, b5, c3, d2, e2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f2 = 0, g2 = 0;
        g2 = V;
        V = V + 256 | 0;
        f2 = g2;
        if ((c3 | 0) > (d2 | 0) & (e2 & 73728 | 0) == 0) {
          e2 = c3 - d2 | 0;
          wr(f2 | 0, b5 << 24 >> 24 | 0, (e2 >>> 0 < 256 ? e2 : 256) | 0) | 0;
          if (e2 >>> 0 > 255) {
            b5 = c3 - d2 | 0;
            do {
              to(a3, f2, 256);
              e2 = e2 + -256 | 0;
            } while (e2 >>> 0 > 255);
            e2 = b5 & 255;
          }
          to(a3, f2, e2);
        }
        V = g2;
        return;
      }
      function Ao(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        if (!a3)
          a3 = 0;
        else
          a3 = Bo(a3, b5, 0) | 0;
        return a3 | 0;
      }
      function Bo(b5, d2, e2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        do
          if (b5) {
            if (d2 >>> 0 < 128) {
              a2[b5 >> 0] = d2;
              b5 = 1;
              break;
            }
            if (!(c2[c2[(Co() | 0) + 176 >> 2] >> 2] | 0))
              if ((d2 & -128 | 0) == 57216) {
                a2[b5 >> 0] = d2;
                b5 = 1;
                break;
              } else {
                c2[(ao() | 0) >> 2] = 25;
                b5 = -1;
                break;
              }
            if (d2 >>> 0 < 2048) {
              a2[b5 >> 0] = d2 >>> 6 | 192;
              a2[b5 + 1 >> 0] = d2 & 63 | 128;
              b5 = 2;
              break;
            }
            if (d2 >>> 0 < 55296 | (d2 & -8192 | 0) == 57344) {
              a2[b5 >> 0] = d2 >>> 12 | 224;
              a2[b5 + 1 >> 0] = d2 >>> 6 & 63 | 128;
              a2[b5 + 2 >> 0] = d2 & 63 | 128;
              b5 = 3;
              break;
            }
            if ((d2 + -65536 | 0) >>> 0 < 1048576) {
              a2[b5 >> 0] = d2 >>> 18 | 240;
              a2[b5 + 1 >> 0] = d2 >>> 12 & 63 | 128;
              a2[b5 + 2 >> 0] = d2 >>> 6 & 63 | 128;
              a2[b5 + 3 >> 0] = d2 & 63 | 128;
              b5 = 4;
              break;
            } else {
              c2[(ao() | 0) >> 2] = 25;
              b5 = -1;
              break;
            }
          } else
            b5 = 1;
        while (0);
        return b5 | 0;
      }
      function Co() {
        return co() | 0;
      }
      function Do(a3) {
        a3 = +a3;
        var b5 = 0;
        g[h >> 3] = a3;
        b5 = c2[h >> 2] | 0;
        t(c2[h + 4 >> 2] | 0);
        return b5 | 0;
      }
      function Eo(a3, b5) {
        a3 = +a3;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0;
        g[h >> 3] = a3;
        d2 = c2[h >> 2] | 0;
        e2 = c2[h + 4 >> 2] | 0;
        f2 = qr(d2 | 0, e2 | 0, 52) | 0;
        u() | 0;
        switch (f2 & 2047) {
          case 0: {
            if (a3 != 0) {
              a3 = +Eo(a3 * 18446744073709552e3, b5);
              d2 = (c2[b5 >> 2] | 0) + -64 | 0;
            } else
              d2 = 0;
            c2[b5 >> 2] = d2;
            break;
          }
          case 2047:
            break;
          default: {
            c2[b5 >> 2] = (f2 & 2047) + -1022;
            c2[h >> 2] = d2;
            c2[h + 4 >> 2] = e2 & -2146435073 | 1071644672;
            a3 = +g[h >> 3];
          }
        }
        return +a3;
      }
      function Fo(b5, c3, d2) {
        b5 = b5 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0;
        a:
          do
            if (!d2)
              b5 = 0;
            else {
              while (1) {
                e2 = a2[b5 >> 0] | 0;
                f2 = a2[c3 >> 0] | 0;
                if (e2 << 24 >> 24 != f2 << 24 >> 24)
                  break;
                d2 = d2 + -1 | 0;
                if (!d2) {
                  b5 = 0;
                  break a;
                } else {
                  b5 = b5 + 1 | 0;
                  c3 = c3 + 1 | 0;
                }
              }
              b5 = (e2 & 255) - (f2 & 255) | 0;
            }
          while (0);
        return b5 | 0;
      }
      function Go(a3, b5, d2, e2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f2 = 0, g2 = 0;
        f2 = V;
        V = V + 16 | 0;
        g2 = f2;
        c2[g2 >> 2] = e2;
        e2 = Ho(a3, b5, d2, g2) | 0;
        V = f2;
        return e2 | 0;
      }
      function Ho(b5, d2, e2, f2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        f2 = f2 | 0;
        var g2 = 0, h2 = 0, i2 = 0, j2 = 0;
        j2 = V;
        V = V + 160 | 0;
        g2 = j2 + 144 | 0;
        i2 = j2;
        ur(i2 | 0, 3672, 144) | 0;
        if ((d2 + -1 | 0) >>> 0 > 2147483646)
          if (!d2) {
            b5 = g2;
            d2 = 1;
            h2 = 4;
          } else {
            c2[(ao() | 0) >> 2] = 61;
            d2 = -1;
          }
        else
          h2 = 4;
        if ((h2 | 0) == 4) {
          h2 = -2 - b5 | 0;
          h2 = d2 >>> 0 > h2 >>> 0 ? h2 : d2;
          c2[i2 + 48 >> 2] = h2;
          g2 = i2 + 20 | 0;
          c2[g2 >> 2] = b5;
          c2[i2 + 44 >> 2] = b5;
          d2 = b5 + h2 | 0;
          b5 = i2 + 16 | 0;
          c2[b5 >> 2] = d2;
          c2[i2 + 28 >> 2] = d2;
          d2 = oo(i2, e2, f2) | 0;
          if (h2) {
            i2 = c2[g2 >> 2] | 0;
            a2[i2 + (((i2 | 0) == (c2[b5 >> 2] | 0)) << 31 >> 31) >> 0] = 0;
          }
        }
        V = j2;
        return d2 | 0;
      }
      function Io(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0;
        e2 = a3 + 20 | 0;
        f2 = c2[e2 >> 2] | 0;
        a3 = (c2[a3 + 16 >> 2] | 0) - f2 | 0;
        a3 = a3 >>> 0 > d2 >>> 0 ? d2 : a3;
        ur(f2 | 0, b5 | 0, a3 | 0) | 0;
        c2[e2 >> 2] = (c2[e2 >> 2] | 0) + a3;
        return d2 | 0;
      }
      function Jo(a3) {
        a3 = a3 | 0;
        var b5 = 0, c3 = 0;
        b5 = (fo(a3) | 0) + 1 | 0;
        c3 = dr(b5) | 0;
        if (!c3)
          a3 = 0;
        else
          a3 = ur(c3 | 0, a3 | 0, b5 | 0) | 0;
        return a3 | 0;
      }
      function Ko(b5, e2) {
        b5 = b5 | 0;
        e2 = e2 | 0;
        var f2 = 0, g2 = 0;
        f2 = 0;
        while (1) {
          if ((d[656 + f2 >> 0] | 0) == (b5 | 0)) {
            g2 = 4;
            break;
          }
          f2 = f2 + 1 | 0;
          if ((f2 | 0) == 87) {
            b5 = 87;
            g2 = 5;
            break;
          }
        }
        if ((g2 | 0) == 4)
          if (!f2)
            f2 = 752;
          else {
            b5 = f2;
            g2 = 5;
          }
        if ((g2 | 0) == 5) {
          f2 = 752;
          do {
            do {
              g2 = f2;
              f2 = f2 + 1 | 0;
            } while ((a2[g2 >> 0] | 0) != 0);
            b5 = b5 + -1 | 0;
          } while ((b5 | 0) != 0);
        }
        return Lo(f2, c2[e2 + 20 >> 2] | 0) | 0;
      }
      function Lo(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return ko(a3, b5) | 0;
      }
      function Mo(a3) {
        a3 = a3 | 0;
        return Ko(a3, c2[(No() | 0) + 176 >> 2] | 0) | 0;
      }
      function No() {
        return co() | 0;
      }
      function Oo(b5, c3, d2) {
        b5 = b5 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var e2 = 0;
        e2 = Mo(b5) | 0;
        b5 = fo(e2) | 0;
        if (b5 >>> 0 >= d2 >>> 0) {
          b5 = d2 + -1 | 0;
          if (!d2)
            b5 = 68;
          else {
            ur(c3 | 0, e2 | 0, b5 | 0) | 0;
            a2[c3 + b5 >> 0] = 0;
            b5 = 68;
          }
        } else {
          ur(c3 | 0, e2 | 0, b5 + 1 | 0) | 0;
          b5 = 0;
        }
        return b5 | 0;
      }
      function Po() {
        var a3 = 0, b5 = 0, d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0;
        e2 = V;
        V = V + 48 | 0;
        g2 = e2 + 32 | 0;
        b5 = e2 + 24 | 0;
        h2 = e2 + 16 | 0;
        f2 = e2;
        e2 = e2 + 36 | 0;
        a3 = Qo() | 0;
        if (a3 | 0 ? (d2 = c2[a3 >> 2] | 0, d2 | 0) : 0) {
          a3 = d2 + 48 | 0;
          if (!(Ro(a3) | 0)) {
            c2[b5 >> 2] = 20420;
            To(20370, b5);
          }
          b5 = So(a3) | 0;
          if ((b5 | 0) == 1126902529 & (u() | 0) == 1129074247)
            a3 = c2[d2 + 44 >> 2] | 0;
          else
            a3 = d2 + 80 | 0;
          c2[e2 >> 2] = a3;
          d2 = c2[d2 >> 2] | 0;
          a3 = c2[d2 + 4 >> 2] | 0;
          if (aa[c2[(c2[954] | 0) + 16 >> 2] & 7](3816, d2, e2) | 0) {
            h2 = c2[e2 >> 2] | 0;
            h2 = Z[c2[(c2[h2 >> 2] | 0) + 8 >> 2] & 15](h2) | 0;
            c2[f2 >> 2] = 20420;
            c2[f2 + 4 >> 2] = a3;
            c2[f2 + 8 >> 2] = h2;
            To(20284, f2);
          } else {
            c2[h2 >> 2] = 20420;
            c2[h2 + 4 >> 2] = a3;
            To(20329, h2);
          }
        }
        To(20408, g2);
      }
      function Qo() {
        return 21640;
      }
      function Ro(a3) {
        a3 = a3 | 0;
        a3 = So(a3) | 0;
        return (a3 & -256 | 0) == 1126902528 & (u() | 0) == 1129074247 | 0;
      }
      function So(a3) {
        a3 = a3 | 0;
        var b5 = 0;
        b5 = a3;
        a3 = c2[b5 >> 2] | 0;
        t(c2[b5 + 4 >> 2] | 0);
        return a3 | 0;
      }
      function To(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        U();
      }
      function Uo(a3) {
        a3 = a3 | 0;
        return;
      }
      function Vo(a3) {
        a3 = a3 | 0;
        Uo(a3);
        jp(a3);
        return;
      }
      function Wo(a3) {
        a3 = a3 | 0;
        return;
      }
      function Xo(a3) {
        a3 = a3 | 0;
        return;
      }
      function Yo(d2, e2, f2) {
        d2 = d2 | 0;
        e2 = e2 | 0;
        f2 = f2 | 0;
        var g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0;
        l2 = V;
        V = V + 64 | 0;
        j2 = l2;
        if (!(ap(d2, e2, 0) | 0))
          if ((e2 | 0) != 0 ? (k2 = ep(e2, 3840, 3824, 0) | 0, (k2 | 0) != 0) : 0) {
            c2[j2 >> 2] = k2;
            c2[j2 + 4 >> 2] = 0;
            c2[j2 + 8 >> 2] = d2;
            c2[j2 + 12 >> 2] = -1;
            d2 = j2 + 16 | 0;
            e2 = j2 + 24 | 0;
            g2 = j2 + 48 | 0;
            h2 = d2;
            i2 = h2 + 36 | 0;
            do {
              c2[h2 >> 2] = 0;
              h2 = h2 + 4 | 0;
            } while ((h2 | 0) < (i2 | 0));
            b4[d2 + 36 >> 1] = 0;
            a2[d2 + 38 >> 0] = 0;
            c2[g2 >> 2] = 1;
            fa[c2[(c2[k2 >> 2] | 0) + 28 >> 2] & 7](k2, j2, c2[f2 >> 2] | 0, 1);
            if ((c2[e2 >> 2] | 0) == 1) {
              c2[f2 >> 2] = c2[d2 >> 2];
              d2 = 1;
            } else
              d2 = 0;
          } else
            d2 = 0;
        else
          d2 = 1;
        V = l2;
        return d2 | 0;
      }
      function Zo(a3, b5, d2, e2, f2, g2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        if (ap(a3, c2[b5 + 8 >> 2] | 0, g2) | 0)
          dp(0, b5, d2, e2, f2);
        return;
      }
      function _o(b5, d2, e2, f2, g2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        var h2 = 0;
        do
          if (!(ap(b5, c2[d2 + 8 >> 2] | 0, g2) | 0)) {
            if (ap(b5, c2[d2 >> 2] | 0, g2) | 0) {
              if ((c2[d2 + 16 >> 2] | 0) != (e2 | 0) ? (h2 = d2 + 20 | 0, (c2[h2 >> 2] | 0) != (e2 | 0)) : 0) {
                c2[d2 + 32 >> 2] = f2;
                c2[h2 >> 2] = e2;
                g2 = d2 + 40 | 0;
                c2[g2 >> 2] = (c2[g2 >> 2] | 0) + 1;
                if ((c2[d2 + 36 >> 2] | 0) == 1 ? (c2[d2 + 24 >> 2] | 0) == 2 : 0)
                  a2[d2 + 54 >> 0] = 1;
                c2[d2 + 44 >> 2] = 4;
                break;
              }
              if ((f2 | 0) == 1)
                c2[d2 + 32 >> 2] = 1;
            }
          } else
            cp(0, d2, e2, f2);
        while (0);
        return;
      }
      function $o(a3, b5, d2, e2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        if (ap(a3, c2[b5 + 8 >> 2] | 0, 0) | 0)
          bp(0, b5, d2, e2);
        return;
      }
      function ap(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        if (d2)
          if ((a3 | 0) == (b5 | 0))
            a3 = 1;
          else
            a3 = (eo(c2[a3 + 4 >> 2] | 0, c2[b5 + 4 >> 2] | 0) | 0) == 0;
        else
          a3 = (c2[a3 + 4 >> 2] | 0) == (c2[b5 + 4 >> 2] | 0);
        return a3 | 0;
      }
      function bp(b5, d2, e2, f2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        f2 = f2 | 0;
        var g2 = 0;
        b5 = d2 + 16 | 0;
        g2 = c2[b5 >> 2] | 0;
        do
          if (g2) {
            if ((g2 | 0) != (e2 | 0)) {
              f2 = d2 + 36 | 0;
              c2[f2 >> 2] = (c2[f2 >> 2] | 0) + 1;
              c2[d2 + 24 >> 2] = 2;
              a2[d2 + 54 >> 0] = 1;
              break;
            }
            b5 = d2 + 24 | 0;
            if ((c2[b5 >> 2] | 0) == 2)
              c2[b5 >> 2] = f2;
          } else {
            c2[b5 >> 2] = e2;
            c2[d2 + 24 >> 2] = f2;
            c2[d2 + 36 >> 2] = 1;
          }
        while (0);
        return;
      }
      function cp(a3, b5, d2, e2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f2 = 0;
        if ((c2[b5 + 4 >> 2] | 0) == (d2 | 0) ? (f2 = b5 + 28 | 0, (c2[f2 >> 2] | 0) != 1) : 0)
          c2[f2 >> 2] = e2;
        return;
      }
      function dp(b5, d2, e2, f2, g2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        a2[d2 + 53 >> 0] = 1;
        do
          if ((c2[d2 + 4 >> 2] | 0) == (f2 | 0)) {
            a2[d2 + 52 >> 0] = 1;
            b5 = d2 + 16 | 0;
            f2 = c2[b5 >> 2] | 0;
            if (!f2) {
              c2[b5 >> 2] = e2;
              c2[d2 + 24 >> 2] = g2;
              c2[d2 + 36 >> 2] = 1;
              if (!((g2 | 0) == 1 ? (c2[d2 + 48 >> 2] | 0) == 1 : 0))
                break;
              a2[d2 + 54 >> 0] = 1;
              break;
            }
            if ((f2 | 0) != (e2 | 0)) {
              g2 = d2 + 36 | 0;
              c2[g2 >> 2] = (c2[g2 >> 2] | 0) + 1;
              a2[d2 + 54 >> 0] = 1;
              break;
            }
            f2 = d2 + 24 | 0;
            b5 = c2[f2 >> 2] | 0;
            if ((b5 | 0) == 2) {
              c2[f2 >> 2] = g2;
              b5 = g2;
            }
            if ((b5 | 0) == 1 ? (c2[d2 + 48 >> 2] | 0) == 1 : 0)
              a2[d2 + 54 >> 0] = 1;
          }
        while (0);
        return;
      }
      function ep(d2, e2, f2, g2) {
        d2 = d2 | 0;
        e2 = e2 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        var h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0, m2 = 0, n2 = 0, o2 = 0, p2 = 0;
        p2 = V;
        V = V + 64 | 0;
        n2 = p2;
        m2 = c2[d2 >> 2] | 0;
        o2 = d2 + (c2[m2 + -8 >> 2] | 0) | 0;
        m2 = c2[m2 + -4 >> 2] | 0;
        c2[n2 >> 2] = f2;
        c2[n2 + 4 >> 2] = d2;
        c2[n2 + 8 >> 2] = e2;
        c2[n2 + 12 >> 2] = g2;
        d2 = n2 + 16 | 0;
        e2 = n2 + 20 | 0;
        g2 = n2 + 24 | 0;
        h2 = n2 + 28 | 0;
        i2 = n2 + 32 | 0;
        j2 = n2 + 40 | 0;
        k2 = d2;
        l2 = k2 + 36 | 0;
        do {
          c2[k2 >> 2] = 0;
          k2 = k2 + 4 | 0;
        } while ((k2 | 0) < (l2 | 0));
        b4[d2 + 36 >> 1] = 0;
        a2[d2 + 38 >> 0] = 0;
        a:
          do
            if (ap(m2, f2, 0) | 0) {
              c2[n2 + 48 >> 2] = 1;
              ha[c2[(c2[m2 >> 2] | 0) + 20 >> 2] & 3](m2, n2, o2, o2, 1, 0);
              d2 = (c2[g2 >> 2] | 0) == 1 ? o2 : 0;
            } else {
              ga[c2[(c2[m2 >> 2] | 0) + 24 >> 2] & 3](m2, n2, o2, 1, 0);
              switch (c2[n2 + 36 >> 2] | 0) {
                case 0: {
                  d2 = (c2[j2 >> 2] | 0) == 1 & (c2[h2 >> 2] | 0) == 1 & (c2[i2 >> 2] | 0) == 1 ? c2[e2 >> 2] | 0 : 0;
                  break a;
                }
                case 1:
                  break;
                default: {
                  d2 = 0;
                  break a;
                }
              }
              if ((c2[g2 >> 2] | 0) != 1 ? !((c2[j2 >> 2] | 0) == 0 & (c2[h2 >> 2] | 0) == 1 & (c2[i2 >> 2] | 0) == 1) : 0) {
                d2 = 0;
                break;
              }
              d2 = c2[d2 >> 2] | 0;
            }
          while (0);
        V = p2;
        return d2 | 0;
      }
      function fp(a3) {
        a3 = a3 | 0;
        Uo(a3);
        jp(a3);
        return;
      }
      function gp(a3, b5, d2, e2, f2, g2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        if (ap(a3, c2[b5 + 8 >> 2] | 0, g2) | 0)
          dp(0, b5, d2, e2, f2);
        else {
          a3 = c2[a3 + 8 >> 2] | 0;
          ha[c2[(c2[a3 >> 2] | 0) + 20 >> 2] & 3](a3, b5, d2, e2, f2, g2);
        }
        return;
      }
      function hp(b5, d2, e2, f2, g2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        var h2 = 0, i2 = 0, j2 = 0;
        a:
          do
            if (!(ap(b5, c2[d2 + 8 >> 2] | 0, g2) | 0)) {
              if (!(ap(b5, c2[d2 >> 2] | 0, g2) | 0)) {
                i2 = c2[b5 + 8 >> 2] | 0;
                ga[c2[(c2[i2 >> 2] | 0) + 24 >> 2] & 3](i2, d2, e2, f2, g2);
                break;
              }
              if ((c2[d2 + 16 >> 2] | 0) != (e2 | 0) ? (i2 = d2 + 20 | 0, (c2[i2 >> 2] | 0) != (e2 | 0)) : 0) {
                c2[d2 + 32 >> 2] = f2;
                f2 = d2 + 44 | 0;
                do
                  if ((c2[f2 >> 2] | 0) != 4) {
                    h2 = d2 + 52 | 0;
                    a2[h2 >> 0] = 0;
                    j2 = d2 + 53 | 0;
                    a2[j2 >> 0] = 0;
                    b5 = c2[b5 + 8 >> 2] | 0;
                    ha[c2[(c2[b5 >> 2] | 0) + 20 >> 2] & 3](b5, d2, e2, e2, 1, g2);
                    if (a2[j2 >> 0] | 0) {
                      j2 = (a2[h2 >> 0] | 0) == 0;
                      c2[f2 >> 2] = 3;
                      if (j2)
                        break;
                      else
                        break a;
                    } else {
                      c2[f2 >> 2] = 4;
                      break;
                    }
                  }
                while (0);
                c2[i2 >> 2] = e2;
                j2 = d2 + 40 | 0;
                c2[j2 >> 2] = (c2[j2 >> 2] | 0) + 1;
                if ((c2[d2 + 36 >> 2] | 0) != 1)
                  break;
                if ((c2[d2 + 24 >> 2] | 0) != 2)
                  break;
                a2[d2 + 54 >> 0] = 1;
                break;
              }
              if ((f2 | 0) == 1)
                c2[d2 + 32 >> 2] = 1;
            } else
              cp(0, d2, e2, f2);
          while (0);
        return;
      }
      function ip(a3, b5, d2, e2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        if (ap(a3, c2[b5 + 8 >> 2] | 0, 0) | 0)
          bp(0, b5, d2, e2);
        else {
          a3 = c2[a3 + 8 >> 2] | 0;
          fa[c2[(c2[a3 >> 2] | 0) + 28 >> 2] & 7](a3, b5, d2, e2);
        }
        return;
      }
      function jp(a3) {
        a3 = a3 | 0;
        er(a3);
        return;
      }
      function kp(a3) {
        a3 = a3 | 0;
        return;
      }
      function lp() {
        var a3 = 0, b5 = 0;
        a3 = Qo() | 0;
        if ((a3 | 0 ? (b5 = c2[a3 >> 2] | 0, b5 | 0) : 0) ? Ro(b5 + 48 | 0) | 0 : 0)
          mp(c2[b5 + 12 >> 2] | 0);
        mp(np() | 0);
      }
      function mp(a3) {
        a3 = a3 | 0;
        var b5 = 0;
        b5 = V;
        V = V + 16 | 0;
        ba[a3 & 3]();
        To(20559, b5);
      }
      function np() {
        return 2;
      }
      function op(a3) {
        a3 = a3 | 0;
        return;
      }
      function pp(a3) {
        a3 = a3 | 0;
        jp(a3);
        return;
      }
      function qp(a3) {
        a3 = a3 | 0;
        return 20599;
      }
      function rp(a3) {
        a3 = a3 | 0;
        c2[a3 >> 2] = 5916;
        vp(a3 + 4 | 0);
        return;
      }
      function sp(a3) {
        a3 = a3 | 0;
        rp(a3);
        jp(a3);
        return;
      }
      function tp(a3) {
        a3 = a3 | 0;
        return up(a3 + 4 | 0) | 0;
      }
      function up(a3) {
        a3 = a3 | 0;
        return c2[a3 >> 2] | 0;
      }
      function vp(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        if (wp(a3) | 0 ? (b5 = xp(c2[a3 >> 2] | 0) | 0, d2 = b5 + 8 | 0, a3 = c2[d2 >> 2] | 0, c2[d2 >> 2] = a3 + -1, (a3 | 0) < 1) : 0)
          jp(b5);
        return;
      }
      function wp(a3) {
        a3 = a3 | 0;
        return 1;
      }
      function xp(a3) {
        a3 = a3 | 0;
        return a3 + -12 | 0;
      }
      function yp(a3) {
        a3 = a3 | 0;
        c2[a3 >> 2] = 5936;
        vp(a3 + 4 | 0);
        return;
      }
      function zp(a3) {
        a3 = a3 | 0;
        yp(a3);
        jp(a3);
        return;
      }
      function Ap(a3) {
        a3 = a3 | 0;
        return up(a3 + 4 | 0) | 0;
      }
      function Bp(a3) {
        a3 = a3 | 0;
        rp(a3);
        jp(a3);
        return;
      }
      function Cp(a3) {
        a3 = a3 | 0;
        rp(a3);
        jp(a3);
        return;
      }
      function Dp() {
        var a3 = 0;
        a3 = V;
        V = V + 16 | 0;
        To(20848, a3);
      }
      function Ep(a3) {
        a3 = a3 | 0;
        Uo(a3);
        jp(a3);
        return;
      }
      function Fp(a3, b5, c3) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        return ap(a3, b5, 0) | 0;
      }
      function Gp(a3) {
        a3 = a3 | 0;
        Uo(a3);
        jp(a3);
        return;
      }
      function Hp(d2, e2, f2) {
        d2 = d2 | 0;
        e2 = e2 | 0;
        f2 = f2 | 0;
        var g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0, m2 = 0, n2 = 0;
        n2 = V;
        V = V + 64 | 0;
        l2 = n2;
        do
          if (!(ap(e2, 4048, 0) | 0)) {
            if (Ip(d2, e2, 0) | 0) {
              e2 = c2[f2 >> 2] | 0;
              if (!e2) {
                e2 = 1;
                break;
              }
              c2[f2 >> 2] = c2[e2 >> 2];
              e2 = 1;
              break;
            }
            if ((e2 | 0) != 0 ? (g2 = ep(e2, 3840, 3976, 0) | 0, (g2 | 0) != 0) : 0) {
              e2 = c2[f2 >> 2] | 0;
              if (e2 | 0)
                c2[f2 >> 2] = c2[e2 >> 2];
              e2 = c2[g2 + 8 >> 2] | 0;
              i2 = d2 + 8 | 0;
              h2 = c2[i2 >> 2] | 0;
              if ((e2 & 7 & (h2 ^ 7) | 0) == 0 ? ((e2 & 96 ^ 96) & h2 | 0) == 0 : 0) {
                h2 = d2 + 12 | 0;
                d2 = c2[h2 >> 2] | 0;
                g2 = g2 + 12 | 0;
                e2 = c2[g2 >> 2] | 0;
                if (!(ap(d2, e2, 0) | 0)) {
                  if (ap(d2, 4040, 0) | 0) {
                    if (!e2) {
                      e2 = 1;
                      break;
                    }
                    e2 = (ep(e2, 3840, 3992, 0) | 0) == 0;
                    break;
                  }
                  if (d2) {
                    e2 = ep(d2, 3840, 3976, 0) | 0;
                    if (e2 | 0) {
                      if (!(c2[i2 >> 2] & 1)) {
                        e2 = 0;
                        break;
                      }
                      e2 = Jp(e2, c2[g2 >> 2] | 0) | 0;
                      break;
                    }
                    e2 = c2[h2 >> 2] | 0;
                    if (e2) {
                      e2 = ep(e2, 3840, 4008, 0) | 0;
                      if (e2 | 0) {
                        if (!(c2[i2 >> 2] & 1)) {
                          e2 = 0;
                          break;
                        }
                        e2 = Kp(e2, c2[g2 >> 2] | 0) | 0;
                        break;
                      }
                      e2 = c2[h2 >> 2] | 0;
                      if ((((e2 | 0) != 0 ? (j2 = ep(e2, 3840, 3824, 0) | 0, (j2 | 0) != 0) : 0) ? (k2 = c2[g2 >> 2] | 0, (k2 | 0) != 0) : 0) ? (m2 = ep(k2, 3840, 3824, 0) | 0, (m2 | 0) != 0) : 0) {
                        c2[l2 >> 2] = m2;
                        c2[l2 + 4 >> 2] = 0;
                        c2[l2 + 8 >> 2] = j2;
                        c2[l2 + 12 >> 2] = -1;
                        e2 = l2 + 16 | 0;
                        d2 = l2 + 24 | 0;
                        g2 = l2 + 48 | 0;
                        h2 = e2;
                        i2 = h2 + 36 | 0;
                        do {
                          c2[h2 >> 2] = 0;
                          h2 = h2 + 4 | 0;
                        } while ((h2 | 0) < (i2 | 0));
                        b4[e2 + 36 >> 1] = 0;
                        a2[e2 + 38 >> 0] = 0;
                        c2[g2 >> 2] = 1;
                        fa[c2[(c2[m2 >> 2] | 0) + 28 >> 2] & 7](m2, l2, c2[f2 >> 2] | 0, 1);
                        do
                          if ((c2[d2 >> 2] | 0) == 1) {
                            if (!(c2[f2 >> 2] | 0)) {
                              e2 = 1;
                              break;
                            }
                            c2[f2 >> 2] = c2[e2 >> 2];
                            e2 = 1;
                          } else
                            e2 = 0;
                        while (0);
                      } else
                        e2 = 0;
                    } else
                      e2 = 0;
                  } else
                    e2 = 0;
                } else
                  e2 = 1;
              } else
                e2 = 0;
            } else
              e2 = 0;
          } else {
            c2[f2 >> 2] = 0;
            e2 = 1;
          }
        while (0);
        V = n2;
        return e2 | 0;
      }
      function Ip(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0;
        if (!(c2[a3 + 8 >> 2] & 24))
          if ((b5 | 0) != 0 ? (e2 = ep(b5, 3840, 3960, 0) | 0, (e2 | 0) != 0) : 0) {
            d2 = (c2[e2 + 8 >> 2] & 24 | 0) != 0;
            f2 = 5;
          } else
            d2 = 0;
        else {
          d2 = 1;
          f2 = 5;
        }
        if ((f2 | 0) == 5)
          d2 = ap(a3, b5, d2) | 0;
        return d2 | 0;
      }
      function Jp(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0;
        while (1) {
          if (!b5) {
            b5 = 0;
            break;
          }
          d2 = ep(b5, 3840, 3976, 0) | 0;
          if (!d2) {
            b5 = 0;
            break;
          }
          f2 = c2[a3 + 8 >> 2] | 0;
          if (c2[d2 + 8 >> 2] & ~f2 | 0) {
            b5 = 0;
            break;
          }
          e2 = a3 + 12 | 0;
          b5 = c2[e2 >> 2] | 0;
          d2 = d2 + 12 | 0;
          if (ap(b5, c2[d2 >> 2] | 0, 0) | 0) {
            b5 = 1;
            break;
          }
          if ((f2 & 1 | 0) == 0 | (b5 | 0) == 0) {
            b5 = 0;
            break;
          }
          a3 = ep(b5, 3840, 3976, 0) | 0;
          if (!a3) {
            h2 = 9;
            break;
          }
          b5 = c2[d2 >> 2] | 0;
        }
        if ((h2 | 0) == 9) {
          b5 = c2[e2 >> 2] | 0;
          if ((b5 | 0) != 0 ? (g2 = ep(b5, 3840, 4008, 0) | 0, (g2 | 0) != 0) : 0)
            b5 = Kp(g2, c2[d2 >> 2] | 0) | 0;
          else
            b5 = 0;
        }
        return b5 | 0;
      }
      function Kp(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0;
        if ((((b5 | 0) != 0 ? (d2 = ep(b5, 3840, 4008, 0) | 0, (d2 | 0) != 0) : 0) ? (c2[d2 + 8 >> 2] & ~c2[a3 + 8 >> 2] | 0) == 0 : 0) ? ap(c2[a3 + 12 >> 2] | 0, c2[d2 + 12 >> 2] | 0, 0) | 0 : 0)
          a3 = ap(c2[a3 + 16 >> 2] | 0, c2[d2 + 16 >> 2] | 0, 0) | 0;
        else
          a3 = 0;
        return a3 | 0;
      }
      function Lp(a3) {
        a3 = a3 | 0;
        Uo(a3);
        jp(a3);
        return;
      }
      function Mp(b5, d2, e2, f2, g2, h2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        h2 = h2 | 0;
        var i2 = 0, j2 = 0, k2 = 0, l2 = 0, m2 = 0, n2 = 0, o2 = 0, p2 = 0, q2 = 0, r2 = 0;
        if (ap(b5, c2[d2 + 8 >> 2] | 0, h2) | 0)
          dp(0, d2, e2, f2, g2);
        else {
          r2 = d2 + 52 | 0;
          j2 = a2[r2 >> 0] | 0;
          q2 = d2 + 53 | 0;
          i2 = a2[q2 >> 0] | 0;
          p2 = c2[b5 + 12 >> 2] | 0;
          m2 = b5 + 16 + (p2 << 3) | 0;
          a2[r2 >> 0] = 0;
          a2[q2 >> 0] = 0;
          Qp(b5 + 16 | 0, d2, e2, f2, g2, h2);
          k2 = a2[r2 >> 0] | 0;
          j2 = k2 | j2;
          l2 = a2[q2 >> 0] | 0;
          i2 = l2 | i2;
          a:
            do
              if ((p2 | 0) > 1) {
                n2 = d2 + 24 | 0;
                o2 = b5 + 8 | 0;
                p2 = d2 + 54 | 0;
                b5 = b5 + 24 | 0;
                do {
                  i2 = i2 & 1;
                  j2 = j2 & 1;
                  if (a2[p2 >> 0] | 0)
                    break a;
                  if (!(k2 << 24 >> 24)) {
                    if (l2 << 24 >> 24 ? (c2[o2 >> 2] & 1 | 0) == 0 : 0)
                      break a;
                  } else {
                    if ((c2[n2 >> 2] | 0) == 1)
                      break a;
                    if (!(c2[o2 >> 2] & 2))
                      break a;
                  }
                  a2[r2 >> 0] = 0;
                  a2[q2 >> 0] = 0;
                  Qp(b5, d2, e2, f2, g2, h2);
                  k2 = a2[r2 >> 0] | 0;
                  j2 = k2 | j2;
                  l2 = a2[q2 >> 0] | 0;
                  i2 = l2 | i2;
                  b5 = b5 + 8 | 0;
                } while (b5 >>> 0 < m2 >>> 0);
              }
            while (0);
          a2[r2 >> 0] = j2 << 24 >> 24 != 0 & 1;
          a2[q2 >> 0] = i2 << 24 >> 24 != 0 & 1;
        }
        return;
      }
      function Np(b5, d2, e2, f2, g2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        var h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0, m2 = 0, n2 = 0, o2 = 0, p2 = 0;
        a:
          do
            if (!(ap(b5, c2[d2 + 8 >> 2] | 0, g2) | 0)) {
              if (!(ap(b5, c2[d2 >> 2] | 0, g2) | 0)) {
                p2 = c2[b5 + 12 >> 2] | 0;
                k2 = b5 + 16 + (p2 << 3) | 0;
                Rp(b5 + 16 | 0, d2, e2, f2, g2);
                h2 = b5 + 24 | 0;
                if ((p2 | 0) <= 1)
                  break;
                b5 = c2[b5 + 8 >> 2] | 0;
                if ((b5 & 2 | 0) == 0 ? (j2 = d2 + 36 | 0, (c2[j2 >> 2] | 0) != 1) : 0) {
                  if (!(b5 & 1)) {
                    b5 = d2 + 54 | 0;
                    while (1) {
                      if (a2[b5 >> 0] | 0)
                        break a;
                      if ((c2[j2 >> 2] | 0) == 1)
                        break a;
                      Rp(h2, d2, e2, f2, g2);
                      h2 = h2 + 8 | 0;
                      if (h2 >>> 0 >= k2 >>> 0)
                        break a;
                    }
                  }
                  b5 = d2 + 24 | 0;
                  i2 = d2 + 54 | 0;
                  while (1) {
                    if (a2[i2 >> 0] | 0)
                      break a;
                    if ((c2[j2 >> 2] | 0) == 1 ? (c2[b5 >> 2] | 0) == 1 : 0)
                      break a;
                    Rp(h2, d2, e2, f2, g2);
                    h2 = h2 + 8 | 0;
                    if (h2 >>> 0 >= k2 >>> 0)
                      break a;
                  }
                }
                b5 = d2 + 54 | 0;
                while (1) {
                  if (a2[b5 >> 0] | 0)
                    break a;
                  Rp(h2, d2, e2, f2, g2);
                  h2 = h2 + 8 | 0;
                  if (h2 >>> 0 >= k2 >>> 0)
                    break a;
                }
              }
              if ((c2[d2 + 16 >> 2] | 0) != (e2 | 0) ? (p2 = d2 + 20 | 0, (c2[p2 >> 2] | 0) != (e2 | 0)) : 0) {
                c2[d2 + 32 >> 2] = f2;
                o2 = d2 + 44 | 0;
                if ((c2[o2 >> 2] | 0) != 4) {
                  j2 = b5 + 16 + (c2[b5 + 12 >> 2] << 3) | 0;
                  k2 = d2 + 52 | 0;
                  f2 = d2 + 53 | 0;
                  l2 = d2 + 54 | 0;
                  m2 = b5 + 8 | 0;
                  n2 = d2 + 24 | 0;
                  h2 = 0;
                  i2 = b5 + 16 | 0;
                  b5 = 0;
                  b:
                    while (1) {
                      if (i2 >>> 0 >= j2 >>> 0) {
                        i2 = 18;
                        break;
                      }
                      a2[k2 >> 0] = 0;
                      a2[f2 >> 0] = 0;
                      Qp(i2, d2, e2, e2, 1, g2);
                      if (a2[l2 >> 0] | 0) {
                        i2 = 18;
                        break;
                      }
                      do
                        if (a2[f2 >> 0] | 0) {
                          if (!(a2[k2 >> 0] | 0))
                            if (!(c2[m2 >> 2] & 1)) {
                              i2 = 19;
                              break b;
                            } else {
                              b5 = 1;
                              break;
                            }
                          if ((c2[n2 >> 2] | 0) == 1) {
                            h2 = 1;
                            i2 = 19;
                            break b;
                          }
                          if (!(c2[m2 >> 2] & 2)) {
                            h2 = 1;
                            i2 = 19;
                            break b;
                          } else {
                            h2 = 1;
                            b5 = 1;
                          }
                        }
                      while (0);
                      i2 = i2 + 8 | 0;
                    }
                  if ((i2 | 0) == 18)
                    if (b5)
                      i2 = 19;
                    else
                      b5 = 4;
                  if ((i2 | 0) == 19)
                    b5 = 3;
                  c2[o2 >> 2] = b5;
                  if (h2 & 1)
                    break;
                }
                c2[p2 >> 2] = e2;
                e2 = d2 + 40 | 0;
                c2[e2 >> 2] = (c2[e2 >> 2] | 0) + 1;
                if ((c2[d2 + 36 >> 2] | 0) != 1)
                  break;
                if ((c2[d2 + 24 >> 2] | 0) != 2)
                  break;
                a2[d2 + 54 >> 0] = 1;
                break;
              }
              if ((f2 | 0) == 1)
                c2[d2 + 32 >> 2] = 1;
            } else
              cp(0, d2, e2, f2);
          while (0);
        return;
      }
      function Op(b5, d2, e2, f2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        f2 = f2 | 0;
        var g2 = 0, h2 = 0;
        a:
          do
            if (!(ap(b5, c2[d2 + 8 >> 2] | 0, 0) | 0)) {
              h2 = c2[b5 + 12 >> 2] | 0;
              g2 = b5 + 16 + (h2 << 3) | 0;
              Pp(b5 + 16 | 0, d2, e2, f2);
              if ((h2 | 0) > 1) {
                h2 = d2 + 54 | 0;
                b5 = b5 + 24 | 0;
                do {
                  Pp(b5, d2, e2, f2);
                  if (a2[h2 >> 0] | 0)
                    break a;
                  b5 = b5 + 8 | 0;
                } while (b5 >>> 0 < g2 >>> 0);
              }
            } else
              bp(0, d2, e2, f2);
          while (0);
        return;
      }
      function Pp(a3, b5, d2, e2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f2 = 0, g2 = 0;
        g2 = c2[a3 + 4 >> 2] | 0;
        if (d2) {
          f2 = g2 >> 8;
          if (g2 & 1)
            f2 = c2[(c2[d2 >> 2] | 0) + f2 >> 2] | 0;
        } else
          f2 = 0;
        a3 = c2[a3 >> 2] | 0;
        fa[c2[(c2[a3 >> 2] | 0) + 28 >> 2] & 7](a3, b5, d2 + f2 | 0, (g2 & 2 | 0) == 0 ? 2 : e2);
        return;
      }
      function Qp(a3, b5, d2, e2, f2, g2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        var h2 = 0, i2 = 0;
        i2 = c2[a3 + 4 >> 2] | 0;
        h2 = i2 >> 8;
        if (i2 & 1)
          h2 = c2[(c2[e2 >> 2] | 0) + h2 >> 2] | 0;
        a3 = c2[a3 >> 2] | 0;
        ha[c2[(c2[a3 >> 2] | 0) + 20 >> 2] & 3](a3, b5, d2, e2 + h2 | 0, (i2 & 2 | 0) == 0 ? 2 : f2, g2);
        return;
      }
      function Rp(a3, b5, d2, e2, f2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        f2 = f2 | 0;
        var g2 = 0, h2 = 0;
        h2 = c2[a3 + 4 >> 2] | 0;
        g2 = h2 >> 8;
        if (h2 & 1)
          g2 = c2[(c2[d2 >> 2] | 0) + g2 >> 2] | 0;
        a3 = c2[a3 >> 2] | 0;
        ga[c2[(c2[a3 >> 2] | 0) + 24 >> 2] & 3](a3, b5, d2 + g2 | 0, (h2 & 2 | 0) == 0 ? 2 : e2, f2);
        return;
      }
      function Sp(a3) {
        a3 = a3 | 0;
        c2[a3 >> 2] = 5896;
        return;
      }
      function Tp(a3) {
        a3 = a3 | 0;
        var b5 = 0, c3 = 0;
        b5 = V;
        V = V + 16 | 0;
        c3 = b5;
        Up(c3, a3);
        a3 = Vp(c3) | 0;
        V = b5;
        return a3 | 0;
      }
      function Up(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        _p(a3, b5);
        return;
      }
      function Vp(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        b5 = V;
        V = V + 16 | 0;
        d2 = b5;
        Wp(d2, c2[a3 + 4 >> 2] | 0);
        if (!((Xp(d2) | 0) << 24 >> 24))
          a3 = Zp(Yp(a3) | 0) | 0;
        else
          a3 = 0;
        V = b5;
        return a3 | 0;
      }
      function Wp(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c2[a3 >> 2] = b5;
        return;
      }
      function Xp(b5) {
        b5 = b5 | 0;
        return a2[c2[b5 >> 2] >> 0] | 0;
      }
      function Yp(a3) {
        a3 = a3 | 0;
        return a3 | 0;
      }
      function Zp(b5) {
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0, g2 = 0;
        g2 = V;
        V = V + 16 | 0;
        f2 = g2;
        b5 = c2[b5 + 8 >> 2] | 0;
        d2 = a2[b5 >> 0] | 0;
        do
          if (d2 << 24 >> 24 != 1)
            if (!(d2 & 2)) {
              a2[b5 >> 0] = 2;
              e2 = 1;
              break;
            } else
              To(20985, f2);
          else
            e2 = 0;
        while (0);
        V = g2;
        return e2 | 0;
      }
      function _p(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c2[a3 >> 2] = b5;
        c2[a3 + 4 >> 2] = b5;
        c2[a3 + 8 >> 2] = b5 + 1;
        c2[a3 + 12 >> 2] = 0;
        return;
      }
      function $p(a3) {
        a3 = a3 | 0;
        var b5 = 0, c3 = 0;
        b5 = V;
        V = V + 16 | 0;
        c3 = b5;
        Up(c3, a3);
        aq(c3);
        V = b5;
        return;
      }
      function aq(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        b5 = V;
        V = V + 16 | 0;
        d2 = b5;
        Wp(d2, c2[a3 + 4 >> 2] | 0);
        bq(d2);
        cq(Yp(a3) | 0);
        V = b5;
        return;
      }
      function bq(b5) {
        b5 = b5 | 0;
        a2[c2[b5 >> 2] >> 0] = 1;
        return;
      }
      function cq(b5) {
        b5 = b5 | 0;
        a2[c2[b5 + 8 >> 2] >> 0] = 1;
        return;
      }
      function dq() {
        return 0;
      }
      function eq(a3) {
        a3 = a3 | 0;
        var b5 = 0, c3 = 0;
        c3 = (a3 | 0) == 0 ? 1 : a3;
        while (1) {
          b5 = dr(c3) | 0;
          if (b5 | 0) {
            a3 = 6;
            break;
          }
          a3 = dq() | 0;
          if (!a3) {
            a3 = 5;
            break;
          }
          ba[a3 & 3]();
        }
        if ((a3 | 0) == 5) {
          c3 = v(4) | 0;
          Sp(c3);
          x(c3 | 0, 3880, 121);
        } else if ((a3 | 0) == 6)
          return b5 | 0;
        return 0;
      }
      function fq(a3) {
        a3 = a3 | 0;
        return eq(a3) | 0;
      }
      function gq(a3) {
        a3 = a3 | 0;
        jp(a3);
        return;
      }
      function hq(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0;
        f2 = V;
        V = V + 16 | 0;
        e2 = f2;
        c2[e2 >> 2] = c2[d2 >> 2];
        a3 = aa[c2[(c2[a3 >> 2] | 0) + 16 >> 2] & 7](a3, b5, e2) | 0;
        if (a3)
          c2[d2 >> 2] = c2[e2 >> 2];
        V = f2;
        return a3 & 1 | 0;
      }
      function iq(a3) {
        a3 = a3 | 0;
        if (!a3)
          a3 = 0;
        else
          a3 = (ep(a3, 3840, 3976, 0) | 0) != 0 & 1;
        return a3 | 0;
      }
      function jq(a3) {
        a3 = a3 | 0;
        return 0;
      }
      function kq() {
        return (lq() | 0) > 0 | 0;
      }
      function lq() {
        return y() | 0;
      }
      function mq(a3) {
        a3 = a3 | 0;
        return;
      }
      function nq(a3) {
        a3 = a3 | 0;
        mq(a3);
        jp(a3);
        return;
      }
      function oq(a3) {
        a3 = a3 | 0;
        return 21039;
      }
      function pq(a3) {
        a3 = a3 | 0;
        return;
      }
      function qq(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0;
        b5 = a3 + 8 | 0;
        if (!((c2[b5 >> 2] | 0) != 0 ? (d2 = c2[b5 >> 2] | 0, c2[b5 >> 2] = d2 + -1, (d2 | 0) != 0) : 0))
          ca[c2[(c2[a3 >> 2] | 0) + 16 >> 2] & 255](a3);
        return;
      }
      function rq(a3) {
        a3 = a3 | 0;
        a3 = jq(a3) | 0;
        if (!a3)
          return;
        else
          br(a3, 21145);
      }
      function sq(a3) {
        a3 = a3 | 0;
        return;
      }
      function tq(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0;
        e2 = fo(b5) | 0;
        d2 = eq(e2 + 13 | 0) | 0;
        c2[d2 >> 2] = e2;
        c2[d2 + 4 >> 2] = e2;
        c2[d2 + 8 >> 2] = 0;
        d2 = uq(d2) | 0;
        ur(d2 | 0, b5 | 0, e2 + 1 | 0) | 0;
        c2[a3 >> 2] = d2;
        return;
      }
      function uq(a3) {
        a3 = a3 | 0;
        return a3 + 12 | 0;
      }
      function vq(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c2[a3 >> 2] = 5916;
        tq(a3 + 4 | 0, b5);
        return;
      }
      function wq(b5, d2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        c2[b5 >> 2] = 5936;
        tq(b5 + 4 | 0, (a2[d2 + 11 >> 0] | 0) < 0 ? c2[d2 >> 2] | 0 : d2);
        return;
      }
      function xq(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c2[a3 >> 2] = 5936;
        tq(a3 + 4 | 0, b5);
        return;
      }
      function yq(a3) {
        a3 = a3 | 0;
        a3 = v(8) | 0;
        vq(a3, 21163);
        c2[a3 >> 2] = 5956;
        x(a3 | 0, 3928, 123);
      }
      function zq(a3) {
        a3 = a3 | 0;
        a3 = v(8) | 0;
        vq(a3, 21163);
        c2[a3 >> 2] = 5976;
        x(a3 | 0, 3944, 123);
      }
      function Aq(b5, d2, e2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f2 = 0, g2 = 0, h2 = 0, i2 = 0;
        g2 = V;
        V = V + 16 | 0;
        f2 = g2;
        if (e2 >>> 0 > 4294967279)
          yq(b5);
        if (e2 >>> 0 < 11)
          a2[b5 + 11 >> 0] = e2;
        else {
          i2 = e2 + 16 & -16;
          h2 = eq(i2) | 0;
          c2[b5 >> 2] = h2;
          c2[b5 + 8 >> 2] = i2 | -2147483648;
          c2[b5 + 4 >> 2] = e2;
          b5 = h2;
        }
        Bq(b5, d2, e2) | 0;
        a2[f2 >> 0] = 0;
        nb(b5 + e2 | 0, f2);
        V = g2;
        return;
      }
      function Bq(a3, b5, c3) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        if (c3 | 0)
          ur(a3 | 0, b5 | 0, c3 | 0) | 0;
        return a3 | 0;
      }
      function Cq(b5) {
        b5 = b5 | 0;
        if ((a2[b5 + 11 >> 0] | 0) < 0)
          Da(c2[b5 >> 2] | 0, c2[b5 + 8 >> 2] & 2147483647);
        return;
      }
      function Dq(b5, d2, e2, f2, g2, h2, i2, j2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        h2 = h2 | 0;
        i2 = i2 | 0;
        j2 = j2 | 0;
        var k2 = 0, l2 = 0, m2 = 0, n2 = 0, o2 = 0;
        o2 = V;
        V = V + 16 | 0;
        n2 = o2;
        if ((-18 - d2 | 0) >>> 0 < e2 >>> 0)
          yq(b5);
        if ((a2[b5 + 11 >> 0] | 0) < 0)
          m2 = c2[b5 >> 2] | 0;
        else
          m2 = b5;
        if (d2 >>> 0 < 2147483623) {
          k2 = e2 + d2 | 0;
          l2 = d2 << 1;
          k2 = k2 >>> 0 < l2 >>> 0 ? l2 : k2;
          k2 = k2 >>> 0 < 11 ? 11 : k2 + 16 & -16;
        } else
          k2 = -17;
        l2 = eq(k2) | 0;
        if (g2 | 0)
          Bq(l2, m2, g2) | 0;
        if (i2 | 0)
          Bq(l2 + g2 | 0, j2, i2) | 0;
        f2 = f2 - h2 | 0;
        e2 = f2 - g2 | 0;
        if (e2 | 0)
          Bq(l2 + g2 + i2 | 0, m2 + g2 + h2 | 0, e2) | 0;
        e2 = d2 + 1 | 0;
        if ((e2 | 0) != 11)
          Da(m2, e2);
        c2[b5 >> 2] = l2;
        c2[b5 + 8 >> 2] = k2 | -2147483648;
        i2 = f2 + i2 | 0;
        c2[b5 + 4 >> 2] = i2;
        a2[n2 >> 0] = 0;
        nb(l2 + i2 | 0, n2);
        V = o2;
        return;
      }
      function Eq(b5, d2, e2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0;
        k2 = V;
        V = V + 16 | 0;
        i2 = k2;
        j2 = b5 + 11 | 0;
        f2 = a2[j2 >> 0] | 0;
        h2 = f2 << 24 >> 24 < 0;
        if (h2) {
          g2 = (c2[b5 + 8 >> 2] & 2147483647) + -1 | 0;
          f2 = c2[b5 + 4 >> 2] | 0;
        } else {
          g2 = 10;
          f2 = f2 & 255;
        }
        if ((g2 - f2 | 0) >>> 0 >= e2 >>> 0) {
          if (e2 | 0) {
            if (h2)
              g2 = c2[b5 >> 2] | 0;
            else
              g2 = b5;
            Bq(g2 + f2 | 0, d2, e2) | 0;
            f2 = f2 + e2 | 0;
            if ((a2[j2 >> 0] | 0) < 0)
              c2[b5 + 4 >> 2] = f2;
            else
              a2[j2 >> 0] = f2;
            a2[i2 >> 0] = 0;
            nb(g2 + f2 | 0, i2);
          }
        } else
          Dq(b5, g2, f2 + e2 - g2 | 0, f2, f2, 0, e2, d2);
        V = k2;
        return b5 | 0;
      }
      function Fq(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return Eq(a3, b5, lb(b5) | 0) | 0;
      }
      function Gq(a3, b5, c3) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        if (!c3)
          a3 = 0;
        else
          a3 = Fo(a3, b5, c3) | 0;
        return a3 | 0;
      }
      function Hq(b5, d2, e2, f2, g2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        var h2 = 0, i2 = 0;
        h2 = a2[b5 + 11 >> 0] | 0;
        i2 = h2 << 24 >> 24 < 0;
        if (i2)
          h2 = c2[b5 + 4 >> 2] | 0;
        else
          h2 = h2 & 255;
        if ((g2 | 0) == -1 | h2 >>> 0 < d2 >>> 0)
          zq(b5);
        h2 = h2 - d2 | 0;
        e2 = h2 >>> 0 < e2 >>> 0 ? h2 : e2;
        if (i2)
          b5 = c2[b5 >> 2] | 0;
        h2 = e2 >>> 0 > g2 >>> 0;
        b5 = Gq(b5 + d2 | 0, f2, h2 ? g2 : e2) | 0;
        if (!b5)
          return (e2 >>> 0 < g2 >>> 0 ? -1 : h2 & 1) | 0;
        else
          return b5 | 0;
        return 0;
      }
      function Iq(a3) {
        a3 = a3 | 0;
        return;
      }
      function Jq(a3) {
        a3 = a3 | 0;
        jp(a3);
        return;
      }
      function Kq(a3) {
        a3 = a3 | 0;
        return 21228;
      }
      function Lq(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        c2[a3 >> 2] = d2;
        c2[a3 + 4 >> 2] = b5;
        return;
      }
      function Mq(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0;
        f2 = V;
        V = V + 16 | 0;
        e2 = f2;
        ea[c2[(c2[a3 >> 2] | 0) + 12 >> 2] & 15](e2, a3, b5);
        if ((c2[e2 + 4 >> 2] | 0) == (c2[d2 + 4 >> 2] | 0))
          a3 = (c2[e2 >> 2] | 0) == (c2[d2 >> 2] | 0);
        else
          a3 = 0;
        V = f2;
        return a3 | 0;
      }
      function Nq(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        return ((c2[b5 >> 2] | 0) == (d2 | 0) ? (c2[b5 + 4 >> 2] | 0) == (a3 | 0) : 0) | 0;
      }
      function Oq(a3, b5, c3) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        if ((c3 | 0) > 256)
          Aq(a3, 21176, lb(21176) | 0);
        else
          Pq(a3, 0, c3);
        return;
      }
      function Pq(a3, b5, c3) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        Qq(a3, c3);
        return;
      }
      function Qq(b5, d2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0;
        i2 = V;
        V = V + 1040 | 0;
        g2 = i2 + 1024 | 0;
        e2 = i2;
        h2 = c2[(ao() | 0) >> 2] | 0;
        f2 = Rq(Oo(d2, e2, 1024) | 0, e2) | 0;
        if (!(a2[f2 >> 0] | 0)) {
          c2[g2 >> 2] = d2;
          Go(e2, 1024, 21211, g2) | 0;
        } else
          e2 = f2;
        c2[(ao() | 0) >> 2] = h2;
        Aq(b5, e2, lb(e2) | 0);
        V = i2;
        return;
      }
      function Rq(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0;
        switch (a3 | 0) {
          case 0: {
            d2 = b5;
            break;
          }
          case -1: {
            a3 = c2[(ao() | 0) >> 2] | 0;
            e2 = 3;
            break;
          }
          default:
            e2 = 3;
        }
        if ((e2 | 0) == 3)
          if ((a3 | 0) == 28)
            d2 = 22145;
          else
            P();
        return d2 | 0;
      }
      function Sq(a3) {
        a3 = a3 | 0;
        jp(a3);
        return;
      }
      function Tq(a3) {
        a3 = a3 | 0;
        return 21353;
      }
      function Uq(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        if ((d2 | 0) > 256) {
          Wq() | 0;
          b5 = 6180;
        } else {
          Xq() | 0;
          b5 = 6176;
        }
        c2[a3 >> 2] = d2;
        c2[a3 + 4 >> 2] = b5;
        return;
      }
      function Vq(a3, b5, c3) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        if ((c3 | 0) > 256)
          Aq(a3, 21319, lb(21319) | 0);
        else
          Pq(a3, 0, c3);
        return;
      }
      function Wq() {
        if ((a2[21488] | 0) == 0 ? Tp(21488) | 0 : 0)
          $p(21488);
        return 6180;
      }
      function Xq() {
        if ((a2[21480] | 0) == 0 ? Tp(21480) | 0 : 0)
          $p(21480);
        return 6176;
      }
      function Yq(a3) {
        a3 = a3 | 0;
        yp(a3);
        return;
      }
      function Zq(a3) {
        a3 = a3 | 0;
        Yq(a3);
        jp(a3);
        return;
      }
      function _q(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0;
        d2 = c2[b5 + 4 >> 2] | 0;
        ea[c2[(c2[d2 >> 2] | 0) + 24 >> 2] & 15](a3, d2, c2[b5 >> 2] | 0);
        return;
      }
      function $q(b5, d2, e2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f2 = 0, g2 = 0, h2 = 0;
        h2 = V;
        V = V + 16 | 0;
        g2 = h2;
        if (c2[d2 >> 2] | 0) {
          f2 = a2[e2 + 11 >> 0] | 0;
          if (f2 << 24 >> 24 < 0)
            f2 = c2[e2 + 4 >> 2] | 0;
          else
            f2 = f2 & 255;
          if (f2 | 0)
            Fq(e2, 21417) | 0;
          _q(g2, d2);
          d2 = a2[g2 + 11 >> 0] | 0;
          f2 = d2 << 24 >> 24 < 0;
          Eq(e2, f2 ? c2[g2 >> 2] | 0 : g2, f2 ? c2[g2 + 4 >> 2] | 0 : d2 & 255) | 0;
          Cq(g2);
        }
        c2[b5 >> 2] = c2[e2 >> 2];
        c2[b5 + 4 >> 2] = c2[e2 + 4 >> 2];
        c2[b5 + 8 >> 2] = c2[e2 + 8 >> 2];
        f2 = 0;
        while (1) {
          if ((f2 | 0) == 3)
            break;
          c2[e2 + (f2 << 2) >> 2] = 0;
          f2 = f2 + 1 | 0;
        }
        V = h2;
        return;
      }
      function ar(a3, b5, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0, g2 = 0;
        e2 = V;
        V = V + 32 | 0;
        g2 = e2 + 12 | 0;
        f2 = e2;
        Aq(f2, d2, lb(d2) | 0);
        $q(g2, b5, f2);
        wq(a3, g2);
        Cq(g2);
        Cq(f2);
        c2[a3 >> 2] = 6192;
        f2 = b5;
        b5 = c2[f2 + 4 >> 2] | 0;
        d2 = a3 + 8 | 0;
        c2[d2 >> 2] = c2[f2 >> 2];
        c2[d2 + 4 >> 2] = b5;
        V = e2;
        return;
      }
      function br(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var d2 = 0, e2 = 0, f2 = 0;
        f2 = V;
        V = V + 16 | 0;
        e2 = f2 + 8 | 0;
        d2 = v(16) | 0;
        Wq() | 0;
        c2[f2 >> 2] = a3;
        c2[f2 + 4 >> 2] = 6180;
        c2[e2 >> 2] = c2[f2 >> 2];
        c2[e2 + 4 >> 2] = c2[f2 + 4 >> 2];
        ar(d2, e2, b5);
        x(d2 | 0, 4272, 136);
      }
      function cr(a3) {
        a3 = a3 | 0;
        a3 = v(8) | 0;
        vq(a3, 21420);
        c2[a3 >> 2] = 5956;
        x(a3 | 0, 3928, 123);
      }
      function dr(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0, m2 = 0, n2 = 0, o2 = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0, u2 = 0, v2 = 0, w2 = 0;
        w2 = V;
        V = V + 16 | 0;
        n2 = w2;
        do
          if (a3 >>> 0 < 245) {
            k2 = a3 >>> 0 < 11 ? 16 : a3 + 11 & -8;
            a3 = k2 >>> 3;
            m2 = c2[5412] | 0;
            d2 = m2 >>> a3;
            if (d2 & 3 | 0) {
              b5 = (d2 & 1 ^ 1) + a3 | 0;
              a3 = 21688 + (b5 << 1 << 2) | 0;
              d2 = a3 + 8 | 0;
              e2 = c2[d2 >> 2] | 0;
              f2 = e2 + 8 | 0;
              g2 = c2[f2 >> 2] | 0;
              if ((g2 | 0) == (a3 | 0))
                c2[5412] = m2 & ~(1 << b5);
              else {
                c2[g2 + 12 >> 2] = a3;
                c2[d2 >> 2] = g2;
              }
              v2 = b5 << 3;
              c2[e2 + 4 >> 2] = v2 | 3;
              v2 = e2 + v2 + 4 | 0;
              c2[v2 >> 2] = c2[v2 >> 2] | 1;
              v2 = f2;
              V = w2;
              return v2 | 0;
            }
            l2 = c2[5414] | 0;
            if (k2 >>> 0 > l2 >>> 0) {
              if (d2 | 0) {
                b5 = 2 << a3;
                b5 = d2 << a3 & (b5 | 0 - b5);
                b5 = (b5 & 0 - b5) + -1 | 0;
                i2 = b5 >>> 12 & 16;
                b5 = b5 >>> i2;
                d2 = b5 >>> 5 & 8;
                b5 = b5 >>> d2;
                g2 = b5 >>> 2 & 4;
                b5 = b5 >>> g2;
                a3 = b5 >>> 1 & 2;
                b5 = b5 >>> a3;
                e2 = b5 >>> 1 & 1;
                e2 = (d2 | i2 | g2 | a3 | e2) + (b5 >>> e2) | 0;
                b5 = 21688 + (e2 << 1 << 2) | 0;
                a3 = b5 + 8 | 0;
                g2 = c2[a3 >> 2] | 0;
                i2 = g2 + 8 | 0;
                d2 = c2[i2 >> 2] | 0;
                if ((d2 | 0) == (b5 | 0)) {
                  a3 = m2 & ~(1 << e2);
                  c2[5412] = a3;
                } else {
                  c2[d2 + 12 >> 2] = b5;
                  c2[a3 >> 2] = d2;
                  a3 = m2;
                }
                v2 = e2 << 3;
                h2 = v2 - k2 | 0;
                c2[g2 + 4 >> 2] = k2 | 3;
                f2 = g2 + k2 | 0;
                c2[f2 + 4 >> 2] = h2 | 1;
                c2[g2 + v2 >> 2] = h2;
                if (l2 | 0) {
                  e2 = c2[5417] | 0;
                  b5 = l2 >>> 3;
                  d2 = 21688 + (b5 << 1 << 2) | 0;
                  b5 = 1 << b5;
                  if (!(a3 & b5)) {
                    c2[5412] = a3 | b5;
                    b5 = d2;
                    a3 = d2 + 8 | 0;
                  } else {
                    a3 = d2 + 8 | 0;
                    b5 = c2[a3 >> 2] | 0;
                  }
                  c2[a3 >> 2] = e2;
                  c2[b5 + 12 >> 2] = e2;
                  c2[e2 + 8 >> 2] = b5;
                  c2[e2 + 12 >> 2] = d2;
                }
                c2[5414] = h2;
                c2[5417] = f2;
                v2 = i2;
                V = w2;
                return v2 | 0;
              }
              g2 = c2[5413] | 0;
              if (g2) {
                d2 = (g2 & 0 - g2) + -1 | 0;
                f2 = d2 >>> 12 & 16;
                d2 = d2 >>> f2;
                e2 = d2 >>> 5 & 8;
                d2 = d2 >>> e2;
                h2 = d2 >>> 2 & 4;
                d2 = d2 >>> h2;
                i2 = d2 >>> 1 & 2;
                d2 = d2 >>> i2;
                j2 = d2 >>> 1 & 1;
                j2 = c2[21952 + ((e2 | f2 | h2 | i2 | j2) + (d2 >>> j2) << 2) >> 2] | 0;
                d2 = j2;
                i2 = j2;
                j2 = (c2[j2 + 4 >> 2] & -8) - k2 | 0;
                while (1) {
                  a3 = c2[d2 + 16 >> 2] | 0;
                  if (!a3) {
                    a3 = c2[d2 + 20 >> 2] | 0;
                    if (!a3)
                      break;
                  }
                  h2 = (c2[a3 + 4 >> 2] & -8) - k2 | 0;
                  f2 = h2 >>> 0 < j2 >>> 0;
                  d2 = a3;
                  i2 = f2 ? a3 : i2;
                  j2 = f2 ? h2 : j2;
                }
                h2 = i2 + k2 | 0;
                if (h2 >>> 0 > i2 >>> 0) {
                  f2 = c2[i2 + 24 >> 2] | 0;
                  b5 = c2[i2 + 12 >> 2] | 0;
                  do
                    if ((b5 | 0) == (i2 | 0)) {
                      a3 = i2 + 20 | 0;
                      b5 = c2[a3 >> 2] | 0;
                      if (!b5) {
                        a3 = i2 + 16 | 0;
                        b5 = c2[a3 >> 2] | 0;
                        if (!b5) {
                          d2 = 0;
                          break;
                        }
                      }
                      while (1) {
                        e2 = b5 + 20 | 0;
                        d2 = c2[e2 >> 2] | 0;
                        if (!d2) {
                          e2 = b5 + 16 | 0;
                          d2 = c2[e2 >> 2] | 0;
                          if (!d2)
                            break;
                          else {
                            b5 = d2;
                            a3 = e2;
                          }
                        } else {
                          b5 = d2;
                          a3 = e2;
                        }
                      }
                      c2[a3 >> 2] = 0;
                      d2 = b5;
                    } else {
                      d2 = c2[i2 + 8 >> 2] | 0;
                      c2[d2 + 12 >> 2] = b5;
                      c2[b5 + 8 >> 2] = d2;
                      d2 = b5;
                    }
                  while (0);
                  do
                    if (f2 | 0) {
                      b5 = c2[i2 + 28 >> 2] | 0;
                      a3 = 21952 + (b5 << 2) | 0;
                      if ((i2 | 0) == (c2[a3 >> 2] | 0)) {
                        c2[a3 >> 2] = d2;
                        if (!d2) {
                          c2[5413] = g2 & ~(1 << b5);
                          break;
                        }
                      } else {
                        v2 = f2 + 16 | 0;
                        c2[((c2[v2 >> 2] | 0) == (i2 | 0) ? v2 : f2 + 20 | 0) >> 2] = d2;
                        if (!d2)
                          break;
                      }
                      c2[d2 + 24 >> 2] = f2;
                      b5 = c2[i2 + 16 >> 2] | 0;
                      if (b5 | 0) {
                        c2[d2 + 16 >> 2] = b5;
                        c2[b5 + 24 >> 2] = d2;
                      }
                      b5 = c2[i2 + 20 >> 2] | 0;
                      if (b5 | 0) {
                        c2[d2 + 20 >> 2] = b5;
                        c2[b5 + 24 >> 2] = d2;
                      }
                    }
                  while (0);
                  if (j2 >>> 0 < 16) {
                    v2 = j2 + k2 | 0;
                    c2[i2 + 4 >> 2] = v2 | 3;
                    v2 = i2 + v2 + 4 | 0;
                    c2[v2 >> 2] = c2[v2 >> 2] | 1;
                  } else {
                    c2[i2 + 4 >> 2] = k2 | 3;
                    c2[h2 + 4 >> 2] = j2 | 1;
                    c2[h2 + j2 >> 2] = j2;
                    if (l2 | 0) {
                      e2 = c2[5417] | 0;
                      b5 = l2 >>> 3;
                      d2 = 21688 + (b5 << 1 << 2) | 0;
                      b5 = 1 << b5;
                      if (!(b5 & m2)) {
                        c2[5412] = b5 | m2;
                        b5 = d2;
                        a3 = d2 + 8 | 0;
                      } else {
                        a3 = d2 + 8 | 0;
                        b5 = c2[a3 >> 2] | 0;
                      }
                      c2[a3 >> 2] = e2;
                      c2[b5 + 12 >> 2] = e2;
                      c2[e2 + 8 >> 2] = b5;
                      c2[e2 + 12 >> 2] = d2;
                    }
                    c2[5414] = j2;
                    c2[5417] = h2;
                  }
                  v2 = i2 + 8 | 0;
                  V = w2;
                  return v2 | 0;
                } else
                  m2 = k2;
              } else
                m2 = k2;
            } else
              m2 = k2;
          } else if (a3 >>> 0 <= 4294967231) {
            a3 = a3 + 11 | 0;
            k2 = a3 & -8;
            e2 = c2[5413] | 0;
            if (e2) {
              f2 = 0 - k2 | 0;
              a3 = a3 >>> 8;
              if (a3)
                if (k2 >>> 0 > 16777215)
                  j2 = 31;
                else {
                  m2 = (a3 + 1048320 | 0) >>> 16 & 8;
                  q2 = a3 << m2;
                  i2 = (q2 + 520192 | 0) >>> 16 & 4;
                  q2 = q2 << i2;
                  j2 = (q2 + 245760 | 0) >>> 16 & 2;
                  j2 = 14 - (i2 | m2 | j2) + (q2 << j2 >>> 15) | 0;
                  j2 = k2 >>> (j2 + 7 | 0) & 1 | j2 << 1;
                }
              else
                j2 = 0;
              d2 = c2[21952 + (j2 << 2) >> 2] | 0;
              a:
                do
                  if (!d2) {
                    d2 = 0;
                    a3 = 0;
                    q2 = 61;
                  } else {
                    a3 = 0;
                    i2 = k2 << ((j2 | 0) == 31 ? 0 : 25 - (j2 >>> 1) | 0);
                    g2 = 0;
                    while (1) {
                      h2 = (c2[d2 + 4 >> 2] & -8) - k2 | 0;
                      if (h2 >>> 0 < f2 >>> 0)
                        if (!h2) {
                          a3 = d2;
                          f2 = 0;
                          q2 = 65;
                          break a;
                        } else {
                          a3 = d2;
                          f2 = h2;
                        }
                      q2 = c2[d2 + 20 >> 2] | 0;
                      d2 = c2[d2 + 16 + (i2 >>> 31 << 2) >> 2] | 0;
                      g2 = (q2 | 0) == 0 | (q2 | 0) == (d2 | 0) ? g2 : q2;
                      if (!d2) {
                        d2 = g2;
                        q2 = 61;
                        break;
                      } else
                        i2 = i2 << 1;
                    }
                  }
                while (0);
              if ((q2 | 0) == 61) {
                if ((d2 | 0) == 0 & (a3 | 0) == 0) {
                  a3 = 2 << j2;
                  a3 = (a3 | 0 - a3) & e2;
                  if (!a3) {
                    m2 = k2;
                    break;
                  }
                  m2 = (a3 & 0 - a3) + -1 | 0;
                  h2 = m2 >>> 12 & 16;
                  m2 = m2 >>> h2;
                  g2 = m2 >>> 5 & 8;
                  m2 = m2 >>> g2;
                  i2 = m2 >>> 2 & 4;
                  m2 = m2 >>> i2;
                  j2 = m2 >>> 1 & 2;
                  m2 = m2 >>> j2;
                  d2 = m2 >>> 1 & 1;
                  a3 = 0;
                  d2 = c2[21952 + ((g2 | h2 | i2 | j2 | d2) + (m2 >>> d2) << 2) >> 2] | 0;
                }
                if (!d2) {
                  i2 = a3;
                  h2 = f2;
                } else
                  q2 = 65;
              }
              if ((q2 | 0) == 65) {
                g2 = d2;
                while (1) {
                  m2 = (c2[g2 + 4 >> 2] & -8) - k2 | 0;
                  d2 = m2 >>> 0 < f2 >>> 0;
                  f2 = d2 ? m2 : f2;
                  a3 = d2 ? g2 : a3;
                  d2 = c2[g2 + 16 >> 2] | 0;
                  if (!d2)
                    d2 = c2[g2 + 20 >> 2] | 0;
                  if (!d2) {
                    i2 = a3;
                    h2 = f2;
                    break;
                  } else
                    g2 = d2;
                }
              }
              if (((i2 | 0) != 0 ? h2 >>> 0 < ((c2[5414] | 0) - k2 | 0) >>> 0 : 0) ? (l2 = i2 + k2 | 0, l2 >>> 0 > i2 >>> 0) : 0) {
                g2 = c2[i2 + 24 >> 2] | 0;
                b5 = c2[i2 + 12 >> 2] | 0;
                do
                  if ((b5 | 0) == (i2 | 0)) {
                    a3 = i2 + 20 | 0;
                    b5 = c2[a3 >> 2] | 0;
                    if (!b5) {
                      a3 = i2 + 16 | 0;
                      b5 = c2[a3 >> 2] | 0;
                      if (!b5) {
                        b5 = 0;
                        break;
                      }
                    }
                    while (1) {
                      f2 = b5 + 20 | 0;
                      d2 = c2[f2 >> 2] | 0;
                      if (!d2) {
                        f2 = b5 + 16 | 0;
                        d2 = c2[f2 >> 2] | 0;
                        if (!d2)
                          break;
                        else {
                          b5 = d2;
                          a3 = f2;
                        }
                      } else {
                        b5 = d2;
                        a3 = f2;
                      }
                    }
                    c2[a3 >> 2] = 0;
                  } else {
                    v2 = c2[i2 + 8 >> 2] | 0;
                    c2[v2 + 12 >> 2] = b5;
                    c2[b5 + 8 >> 2] = v2;
                  }
                while (0);
                do
                  if (g2) {
                    a3 = c2[i2 + 28 >> 2] | 0;
                    d2 = 21952 + (a3 << 2) | 0;
                    if ((i2 | 0) == (c2[d2 >> 2] | 0)) {
                      c2[d2 >> 2] = b5;
                      if (!b5) {
                        e2 = e2 & ~(1 << a3);
                        c2[5413] = e2;
                        break;
                      }
                    } else {
                      v2 = g2 + 16 | 0;
                      c2[((c2[v2 >> 2] | 0) == (i2 | 0) ? v2 : g2 + 20 | 0) >> 2] = b5;
                      if (!b5)
                        break;
                    }
                    c2[b5 + 24 >> 2] = g2;
                    a3 = c2[i2 + 16 >> 2] | 0;
                    if (a3 | 0) {
                      c2[b5 + 16 >> 2] = a3;
                      c2[a3 + 24 >> 2] = b5;
                    }
                    a3 = c2[i2 + 20 >> 2] | 0;
                    if (a3) {
                      c2[b5 + 20 >> 2] = a3;
                      c2[a3 + 24 >> 2] = b5;
                    }
                  }
                while (0);
                b:
                  do
                    if (h2 >>> 0 < 16) {
                      v2 = h2 + k2 | 0;
                      c2[i2 + 4 >> 2] = v2 | 3;
                      v2 = i2 + v2 + 4 | 0;
                      c2[v2 >> 2] = c2[v2 >> 2] | 1;
                    } else {
                      c2[i2 + 4 >> 2] = k2 | 3;
                      c2[l2 + 4 >> 2] = h2 | 1;
                      c2[l2 + h2 >> 2] = h2;
                      b5 = h2 >>> 3;
                      if (h2 >>> 0 < 256) {
                        d2 = 21688 + (b5 << 1 << 2) | 0;
                        a3 = c2[5412] | 0;
                        b5 = 1 << b5;
                        if (!(a3 & b5)) {
                          c2[5412] = a3 | b5;
                          b5 = d2;
                          a3 = d2 + 8 | 0;
                        } else {
                          a3 = d2 + 8 | 0;
                          b5 = c2[a3 >> 2] | 0;
                        }
                        c2[a3 >> 2] = l2;
                        c2[b5 + 12 >> 2] = l2;
                        c2[l2 + 8 >> 2] = b5;
                        c2[l2 + 12 >> 2] = d2;
                        break;
                      }
                      b5 = h2 >>> 8;
                      if (b5)
                        if (h2 >>> 0 > 16777215)
                          d2 = 31;
                        else {
                          u2 = (b5 + 1048320 | 0) >>> 16 & 8;
                          v2 = b5 << u2;
                          t2 = (v2 + 520192 | 0) >>> 16 & 4;
                          v2 = v2 << t2;
                          d2 = (v2 + 245760 | 0) >>> 16 & 2;
                          d2 = 14 - (t2 | u2 | d2) + (v2 << d2 >>> 15) | 0;
                          d2 = h2 >>> (d2 + 7 | 0) & 1 | d2 << 1;
                        }
                      else
                        d2 = 0;
                      b5 = 21952 + (d2 << 2) | 0;
                      c2[l2 + 28 >> 2] = d2;
                      a3 = l2 + 16 | 0;
                      c2[a3 + 4 >> 2] = 0;
                      c2[a3 >> 2] = 0;
                      a3 = 1 << d2;
                      if (!(e2 & a3)) {
                        c2[5413] = e2 | a3;
                        c2[b5 >> 2] = l2;
                        c2[l2 + 24 >> 2] = b5;
                        c2[l2 + 12 >> 2] = l2;
                        c2[l2 + 8 >> 2] = l2;
                        break;
                      }
                      b5 = c2[b5 >> 2] | 0;
                      c:
                        do
                          if ((c2[b5 + 4 >> 2] & -8 | 0) != (h2 | 0)) {
                            e2 = h2 << ((d2 | 0) == 31 ? 0 : 25 - (d2 >>> 1) | 0);
                            while (1) {
                              d2 = b5 + 16 + (e2 >>> 31 << 2) | 0;
                              a3 = c2[d2 >> 2] | 0;
                              if (!a3)
                                break;
                              if ((c2[a3 + 4 >> 2] & -8 | 0) == (h2 | 0)) {
                                b5 = a3;
                                break c;
                              } else {
                                e2 = e2 << 1;
                                b5 = a3;
                              }
                            }
                            c2[d2 >> 2] = l2;
                            c2[l2 + 24 >> 2] = b5;
                            c2[l2 + 12 >> 2] = l2;
                            c2[l2 + 8 >> 2] = l2;
                            break b;
                          }
                        while (0);
                      u2 = b5 + 8 | 0;
                      v2 = c2[u2 >> 2] | 0;
                      c2[v2 + 12 >> 2] = l2;
                      c2[u2 >> 2] = l2;
                      c2[l2 + 8 >> 2] = v2;
                      c2[l2 + 12 >> 2] = b5;
                      c2[l2 + 24 >> 2] = 0;
                    }
                  while (0);
                v2 = i2 + 8 | 0;
                V = w2;
                return v2 | 0;
              } else
                m2 = k2;
            } else
              m2 = k2;
          } else
            m2 = -1;
        while (0);
        d2 = c2[5414] | 0;
        if (d2 >>> 0 >= m2 >>> 0) {
          b5 = d2 - m2 | 0;
          a3 = c2[5417] | 0;
          if (b5 >>> 0 > 15) {
            v2 = a3 + m2 | 0;
            c2[5417] = v2;
            c2[5414] = b5;
            c2[v2 + 4 >> 2] = b5 | 1;
            c2[a3 + d2 >> 2] = b5;
            c2[a3 + 4 >> 2] = m2 | 3;
          } else {
            c2[5414] = 0;
            c2[5417] = 0;
            c2[a3 + 4 >> 2] = d2 | 3;
            v2 = a3 + d2 + 4 | 0;
            c2[v2 >> 2] = c2[v2 >> 2] | 1;
          }
          v2 = a3 + 8 | 0;
          V = w2;
          return v2 | 0;
        }
        h2 = c2[5415] | 0;
        if (h2 >>> 0 > m2 >>> 0) {
          t2 = h2 - m2 | 0;
          c2[5415] = t2;
          v2 = c2[5418] | 0;
          u2 = v2 + m2 | 0;
          c2[5418] = u2;
          c2[u2 + 4 >> 2] = t2 | 1;
          c2[v2 + 4 >> 2] = m2 | 3;
          v2 = v2 + 8 | 0;
          V = w2;
          return v2 | 0;
        }
        if (!(c2[5530] | 0)) {
          c2[5532] = 4096;
          c2[5531] = 4096;
          c2[5533] = -1;
          c2[5534] = -1;
          c2[5535] = 0;
          c2[5523] = 0;
          c2[5530] = n2 & -16 ^ 1431655768;
          a3 = 4096;
        } else
          a3 = c2[5532] | 0;
        i2 = m2 + 48 | 0;
        j2 = m2 + 47 | 0;
        g2 = a3 + j2 | 0;
        f2 = 0 - a3 | 0;
        k2 = g2 & f2;
        if (k2 >>> 0 <= m2 >>> 0) {
          v2 = 0;
          V = w2;
          return v2 | 0;
        }
        a3 = c2[5522] | 0;
        if (a3 | 0 ? (l2 = c2[5520] | 0, n2 = l2 + k2 | 0, n2 >>> 0 <= l2 >>> 0 | n2 >>> 0 > a3 >>> 0) : 0) {
          v2 = 0;
          V = w2;
          return v2 | 0;
        }
        d:
          do
            if (!(c2[5523] & 4)) {
              d2 = c2[5418] | 0;
              e:
                do
                  if (d2) {
                    e2 = 22096;
                    while (1) {
                      n2 = c2[e2 >> 2] | 0;
                      if (n2 >>> 0 <= d2 >>> 0 ? (n2 + (c2[e2 + 4 >> 2] | 0) | 0) >>> 0 > d2 >>> 0 : 0)
                        break;
                      a3 = c2[e2 + 8 >> 2] | 0;
                      if (!a3) {
                        q2 = 128;
                        break e;
                      } else
                        e2 = a3;
                    }
                    b5 = g2 - h2 & f2;
                    if (b5 >>> 0 < 2147483647) {
                      a3 = fr(b5) | 0;
                      if ((a3 | 0) == ((c2[e2 >> 2] | 0) + (c2[e2 + 4 >> 2] | 0) | 0)) {
                        if ((a3 | 0) != (-1 | 0)) {
                          h2 = b5;
                          g2 = a3;
                          q2 = 145;
                          break d;
                        }
                      } else {
                        e2 = a3;
                        q2 = 136;
                      }
                    } else
                      b5 = 0;
                  } else
                    q2 = 128;
                while (0);
              do
                if ((q2 | 0) == 128) {
                  d2 = fr(0) | 0;
                  if ((d2 | 0) != (-1 | 0) ? (b5 = d2, o2 = c2[5531] | 0, p2 = o2 + -1 | 0, b5 = ((p2 & b5 | 0) == 0 ? 0 : (p2 + b5 & 0 - o2) - b5 | 0) + k2 | 0, o2 = c2[5520] | 0, p2 = b5 + o2 | 0, b5 >>> 0 > m2 >>> 0 & b5 >>> 0 < 2147483647) : 0) {
                    n2 = c2[5522] | 0;
                    if (n2 | 0 ? p2 >>> 0 <= o2 >>> 0 | p2 >>> 0 > n2 >>> 0 : 0) {
                      b5 = 0;
                      break;
                    }
                    a3 = fr(b5) | 0;
                    if ((a3 | 0) == (d2 | 0)) {
                      h2 = b5;
                      g2 = d2;
                      q2 = 145;
                      break d;
                    } else {
                      e2 = a3;
                      q2 = 136;
                    }
                  } else
                    b5 = 0;
                }
              while (0);
              do
                if ((q2 | 0) == 136) {
                  d2 = 0 - b5 | 0;
                  if (!(i2 >>> 0 > b5 >>> 0 & (b5 >>> 0 < 2147483647 & (e2 | 0) != (-1 | 0))))
                    if ((e2 | 0) == (-1 | 0)) {
                      b5 = 0;
                      break;
                    } else {
                      h2 = b5;
                      g2 = e2;
                      q2 = 145;
                      break d;
                    }
                  a3 = c2[5532] | 0;
                  a3 = j2 - b5 + a3 & 0 - a3;
                  if (a3 >>> 0 >= 2147483647) {
                    h2 = b5;
                    g2 = e2;
                    q2 = 145;
                    break d;
                  }
                  if ((fr(a3) | 0) == (-1 | 0)) {
                    fr(d2) | 0;
                    b5 = 0;
                    break;
                  } else {
                    h2 = a3 + b5 | 0;
                    g2 = e2;
                    q2 = 145;
                    break d;
                  }
                }
              while (0);
              c2[5523] = c2[5523] | 4;
              q2 = 143;
            } else {
              b5 = 0;
              q2 = 143;
            }
          while (0);
        if (((q2 | 0) == 143 ? k2 >>> 0 < 2147483647 : 0) ? (t2 = fr(k2) | 0, p2 = fr(0) | 0, r2 = p2 - t2 | 0, s2 = r2 >>> 0 > (m2 + 40 | 0) >>> 0, !((t2 | 0) == (-1 | 0) | s2 ^ 1 | t2 >>> 0 < p2 >>> 0 & ((t2 | 0) != (-1 | 0) & (p2 | 0) != (-1 | 0)) ^ 1)) : 0) {
          h2 = s2 ? r2 : b5;
          g2 = t2;
          q2 = 145;
        }
        if ((q2 | 0) == 145) {
          b5 = (c2[5520] | 0) + h2 | 0;
          c2[5520] = b5;
          if (b5 >>> 0 > (c2[5521] | 0) >>> 0)
            c2[5521] = b5;
          j2 = c2[5418] | 0;
          f:
            do
              if (j2) {
                b5 = 22096;
                while (1) {
                  a3 = c2[b5 >> 2] | 0;
                  d2 = c2[b5 + 4 >> 2] | 0;
                  if ((g2 | 0) == (a3 + d2 | 0)) {
                    q2 = 154;
                    break;
                  }
                  e2 = c2[b5 + 8 >> 2] | 0;
                  if (!e2)
                    break;
                  else
                    b5 = e2;
                }
                if (((q2 | 0) == 154 ? (u2 = b5 + 4 | 0, (c2[b5 + 12 >> 2] & 8 | 0) == 0) : 0) ? g2 >>> 0 > j2 >>> 0 & a3 >>> 0 <= j2 >>> 0 : 0) {
                  c2[u2 >> 2] = d2 + h2;
                  v2 = (c2[5415] | 0) + h2 | 0;
                  t2 = j2 + 8 | 0;
                  t2 = (t2 & 7 | 0) == 0 ? 0 : 0 - t2 & 7;
                  u2 = j2 + t2 | 0;
                  t2 = v2 - t2 | 0;
                  c2[5418] = u2;
                  c2[5415] = t2;
                  c2[u2 + 4 >> 2] = t2 | 1;
                  c2[j2 + v2 + 4 >> 2] = 40;
                  c2[5419] = c2[5534];
                  break;
                }
                if (g2 >>> 0 < (c2[5416] | 0) >>> 0)
                  c2[5416] = g2;
                d2 = g2 + h2 | 0;
                b5 = 22096;
                while (1) {
                  if ((c2[b5 >> 2] | 0) == (d2 | 0)) {
                    q2 = 162;
                    break;
                  }
                  a3 = c2[b5 + 8 >> 2] | 0;
                  if (!a3)
                    break;
                  else
                    b5 = a3;
                }
                if ((q2 | 0) == 162 ? (c2[b5 + 12 >> 2] & 8 | 0) == 0 : 0) {
                  c2[b5 >> 2] = g2;
                  l2 = b5 + 4 | 0;
                  c2[l2 >> 2] = (c2[l2 >> 2] | 0) + h2;
                  l2 = g2 + 8 | 0;
                  l2 = g2 + ((l2 & 7 | 0) == 0 ? 0 : 0 - l2 & 7) | 0;
                  b5 = d2 + 8 | 0;
                  b5 = d2 + ((b5 & 7 | 0) == 0 ? 0 : 0 - b5 & 7) | 0;
                  k2 = l2 + m2 | 0;
                  i2 = b5 - l2 - m2 | 0;
                  c2[l2 + 4 >> 2] = m2 | 3;
                  g:
                    do
                      if ((j2 | 0) == (b5 | 0)) {
                        v2 = (c2[5415] | 0) + i2 | 0;
                        c2[5415] = v2;
                        c2[5418] = k2;
                        c2[k2 + 4 >> 2] = v2 | 1;
                      } else {
                        if ((c2[5417] | 0) == (b5 | 0)) {
                          v2 = (c2[5414] | 0) + i2 | 0;
                          c2[5414] = v2;
                          c2[5417] = k2;
                          c2[k2 + 4 >> 2] = v2 | 1;
                          c2[k2 + v2 >> 2] = v2;
                          break;
                        }
                        a3 = c2[b5 + 4 >> 2] | 0;
                        if ((a3 & 3 | 0) == 1) {
                          h2 = a3 & -8;
                          e2 = a3 >>> 3;
                          h:
                            do
                              if (a3 >>> 0 < 256) {
                                a3 = c2[b5 + 8 >> 2] | 0;
                                d2 = c2[b5 + 12 >> 2] | 0;
                                if ((d2 | 0) == (a3 | 0)) {
                                  c2[5412] = c2[5412] & ~(1 << e2);
                                  break;
                                } else {
                                  c2[a3 + 12 >> 2] = d2;
                                  c2[d2 + 8 >> 2] = a3;
                                  break;
                                }
                              } else {
                                g2 = c2[b5 + 24 >> 2] | 0;
                                a3 = c2[b5 + 12 >> 2] | 0;
                                do
                                  if ((a3 | 0) == (b5 | 0)) {
                                    d2 = b5 + 16 | 0;
                                    e2 = d2 + 4 | 0;
                                    a3 = c2[e2 >> 2] | 0;
                                    if (!a3) {
                                      a3 = c2[d2 >> 2] | 0;
                                      if (!a3) {
                                        a3 = 0;
                                        break;
                                      }
                                    } else
                                      d2 = e2;
                                    while (1) {
                                      f2 = a3 + 20 | 0;
                                      e2 = c2[f2 >> 2] | 0;
                                      if (!e2) {
                                        f2 = a3 + 16 | 0;
                                        e2 = c2[f2 >> 2] | 0;
                                        if (!e2)
                                          break;
                                        else {
                                          a3 = e2;
                                          d2 = f2;
                                        }
                                      } else {
                                        a3 = e2;
                                        d2 = f2;
                                      }
                                    }
                                    c2[d2 >> 2] = 0;
                                  } else {
                                    v2 = c2[b5 + 8 >> 2] | 0;
                                    c2[v2 + 12 >> 2] = a3;
                                    c2[a3 + 8 >> 2] = v2;
                                  }
                                while (0);
                                if (!g2)
                                  break;
                                d2 = c2[b5 + 28 >> 2] | 0;
                                e2 = 21952 + (d2 << 2) | 0;
                                do
                                  if ((c2[e2 >> 2] | 0) != (b5 | 0)) {
                                    v2 = g2 + 16 | 0;
                                    c2[((c2[v2 >> 2] | 0) == (b5 | 0) ? v2 : g2 + 20 | 0) >> 2] = a3;
                                    if (!a3)
                                      break h;
                                  } else {
                                    c2[e2 >> 2] = a3;
                                    if (a3 | 0)
                                      break;
                                    c2[5413] = c2[5413] & ~(1 << d2);
                                    break h;
                                  }
                                while (0);
                                c2[a3 + 24 >> 2] = g2;
                                d2 = b5 + 16 | 0;
                                e2 = c2[d2 >> 2] | 0;
                                if (e2 | 0) {
                                  c2[a3 + 16 >> 2] = e2;
                                  c2[e2 + 24 >> 2] = a3;
                                }
                                d2 = c2[d2 + 4 >> 2] | 0;
                                if (!d2)
                                  break;
                                c2[a3 + 20 >> 2] = d2;
                                c2[d2 + 24 >> 2] = a3;
                              }
                            while (0);
                          b5 = b5 + h2 | 0;
                          f2 = h2 + i2 | 0;
                        } else
                          f2 = i2;
                        b5 = b5 + 4 | 0;
                        c2[b5 >> 2] = c2[b5 >> 2] & -2;
                        c2[k2 + 4 >> 2] = f2 | 1;
                        c2[k2 + f2 >> 2] = f2;
                        b5 = f2 >>> 3;
                        if (f2 >>> 0 < 256) {
                          d2 = 21688 + (b5 << 1 << 2) | 0;
                          a3 = c2[5412] | 0;
                          b5 = 1 << b5;
                          if (!(a3 & b5)) {
                            c2[5412] = a3 | b5;
                            b5 = d2;
                            a3 = d2 + 8 | 0;
                          } else {
                            a3 = d2 + 8 | 0;
                            b5 = c2[a3 >> 2] | 0;
                          }
                          c2[a3 >> 2] = k2;
                          c2[b5 + 12 >> 2] = k2;
                          c2[k2 + 8 >> 2] = b5;
                          c2[k2 + 12 >> 2] = d2;
                          break;
                        }
                        b5 = f2 >>> 8;
                        do
                          if (!b5)
                            e2 = 0;
                          else {
                            if (f2 >>> 0 > 16777215) {
                              e2 = 31;
                              break;
                            }
                            u2 = (b5 + 1048320 | 0) >>> 16 & 8;
                            v2 = b5 << u2;
                            t2 = (v2 + 520192 | 0) >>> 16 & 4;
                            v2 = v2 << t2;
                            e2 = (v2 + 245760 | 0) >>> 16 & 2;
                            e2 = 14 - (t2 | u2 | e2) + (v2 << e2 >>> 15) | 0;
                            e2 = f2 >>> (e2 + 7 | 0) & 1 | e2 << 1;
                          }
                        while (0);
                        b5 = 21952 + (e2 << 2) | 0;
                        c2[k2 + 28 >> 2] = e2;
                        a3 = k2 + 16 | 0;
                        c2[a3 + 4 >> 2] = 0;
                        c2[a3 >> 2] = 0;
                        a3 = c2[5413] | 0;
                        d2 = 1 << e2;
                        if (!(a3 & d2)) {
                          c2[5413] = a3 | d2;
                          c2[b5 >> 2] = k2;
                          c2[k2 + 24 >> 2] = b5;
                          c2[k2 + 12 >> 2] = k2;
                          c2[k2 + 8 >> 2] = k2;
                          break;
                        }
                        b5 = c2[b5 >> 2] | 0;
                        i:
                          do
                            if ((c2[b5 + 4 >> 2] & -8 | 0) != (f2 | 0)) {
                              e2 = f2 << ((e2 | 0) == 31 ? 0 : 25 - (e2 >>> 1) | 0);
                              while (1) {
                                d2 = b5 + 16 + (e2 >>> 31 << 2) | 0;
                                a3 = c2[d2 >> 2] | 0;
                                if (!a3)
                                  break;
                                if ((c2[a3 + 4 >> 2] & -8 | 0) == (f2 | 0)) {
                                  b5 = a3;
                                  break i;
                                } else {
                                  e2 = e2 << 1;
                                  b5 = a3;
                                }
                              }
                              c2[d2 >> 2] = k2;
                              c2[k2 + 24 >> 2] = b5;
                              c2[k2 + 12 >> 2] = k2;
                              c2[k2 + 8 >> 2] = k2;
                              break g;
                            }
                          while (0);
                        u2 = b5 + 8 | 0;
                        v2 = c2[u2 >> 2] | 0;
                        c2[v2 + 12 >> 2] = k2;
                        c2[u2 >> 2] = k2;
                        c2[k2 + 8 >> 2] = v2;
                        c2[k2 + 12 >> 2] = b5;
                        c2[k2 + 24 >> 2] = 0;
                      }
                    while (0);
                  v2 = l2 + 8 | 0;
                  V = w2;
                  return v2 | 0;
                }
                b5 = 22096;
                while (1) {
                  a3 = c2[b5 >> 2] | 0;
                  if (a3 >>> 0 <= j2 >>> 0 ? (v2 = a3 + (c2[b5 + 4 >> 2] | 0) | 0, v2 >>> 0 > j2 >>> 0) : 0)
                    break;
                  b5 = c2[b5 + 8 >> 2] | 0;
                }
                f2 = v2 + -47 | 0;
                a3 = f2 + 8 | 0;
                a3 = f2 + ((a3 & 7 | 0) == 0 ? 0 : 0 - a3 & 7) | 0;
                f2 = j2 + 16 | 0;
                a3 = a3 >>> 0 < f2 >>> 0 ? j2 : a3;
                b5 = a3 + 8 | 0;
                d2 = h2 + -40 | 0;
                t2 = g2 + 8 | 0;
                t2 = (t2 & 7 | 0) == 0 ? 0 : 0 - t2 & 7;
                u2 = g2 + t2 | 0;
                t2 = d2 - t2 | 0;
                c2[5418] = u2;
                c2[5415] = t2;
                c2[u2 + 4 >> 2] = t2 | 1;
                c2[g2 + d2 + 4 >> 2] = 40;
                c2[5419] = c2[5534];
                d2 = a3 + 4 | 0;
                c2[d2 >> 2] = 27;
                c2[b5 >> 2] = c2[5524];
                c2[b5 + 4 >> 2] = c2[5525];
                c2[b5 + 8 >> 2] = c2[5526];
                c2[b5 + 12 >> 2] = c2[5527];
                c2[5524] = g2;
                c2[5525] = h2;
                c2[5527] = 0;
                c2[5526] = b5;
                b5 = a3 + 24 | 0;
                do {
                  u2 = b5;
                  b5 = b5 + 4 | 0;
                  c2[b5 >> 2] = 7;
                } while ((u2 + 8 | 0) >>> 0 < v2 >>> 0);
                if ((a3 | 0) != (j2 | 0)) {
                  g2 = a3 - j2 | 0;
                  c2[d2 >> 2] = c2[d2 >> 2] & -2;
                  c2[j2 + 4 >> 2] = g2 | 1;
                  c2[a3 >> 2] = g2;
                  b5 = g2 >>> 3;
                  if (g2 >>> 0 < 256) {
                    d2 = 21688 + (b5 << 1 << 2) | 0;
                    a3 = c2[5412] | 0;
                    b5 = 1 << b5;
                    if (!(a3 & b5)) {
                      c2[5412] = a3 | b5;
                      b5 = d2;
                      a3 = d2 + 8 | 0;
                    } else {
                      a3 = d2 + 8 | 0;
                      b5 = c2[a3 >> 2] | 0;
                    }
                    c2[a3 >> 2] = j2;
                    c2[b5 + 12 >> 2] = j2;
                    c2[j2 + 8 >> 2] = b5;
                    c2[j2 + 12 >> 2] = d2;
                    break;
                  }
                  b5 = g2 >>> 8;
                  if (b5)
                    if (g2 >>> 0 > 16777215)
                      e2 = 31;
                    else {
                      u2 = (b5 + 1048320 | 0) >>> 16 & 8;
                      v2 = b5 << u2;
                      t2 = (v2 + 520192 | 0) >>> 16 & 4;
                      v2 = v2 << t2;
                      e2 = (v2 + 245760 | 0) >>> 16 & 2;
                      e2 = 14 - (t2 | u2 | e2) + (v2 << e2 >>> 15) | 0;
                      e2 = g2 >>> (e2 + 7 | 0) & 1 | e2 << 1;
                    }
                  else
                    e2 = 0;
                  d2 = 21952 + (e2 << 2) | 0;
                  c2[j2 + 28 >> 2] = e2;
                  c2[j2 + 20 >> 2] = 0;
                  c2[f2 >> 2] = 0;
                  b5 = c2[5413] | 0;
                  a3 = 1 << e2;
                  if (!(b5 & a3)) {
                    c2[5413] = b5 | a3;
                    c2[d2 >> 2] = j2;
                    c2[j2 + 24 >> 2] = d2;
                    c2[j2 + 12 >> 2] = j2;
                    c2[j2 + 8 >> 2] = j2;
                    break;
                  }
                  b5 = c2[d2 >> 2] | 0;
                  j:
                    do
                      if ((c2[b5 + 4 >> 2] & -8 | 0) != (g2 | 0)) {
                        e2 = g2 << ((e2 | 0) == 31 ? 0 : 25 - (e2 >>> 1) | 0);
                        while (1) {
                          d2 = b5 + 16 + (e2 >>> 31 << 2) | 0;
                          a3 = c2[d2 >> 2] | 0;
                          if (!a3)
                            break;
                          if ((c2[a3 + 4 >> 2] & -8 | 0) == (g2 | 0)) {
                            b5 = a3;
                            break j;
                          } else {
                            e2 = e2 << 1;
                            b5 = a3;
                          }
                        }
                        c2[d2 >> 2] = j2;
                        c2[j2 + 24 >> 2] = b5;
                        c2[j2 + 12 >> 2] = j2;
                        c2[j2 + 8 >> 2] = j2;
                        break f;
                      }
                    while (0);
                  u2 = b5 + 8 | 0;
                  v2 = c2[u2 >> 2] | 0;
                  c2[v2 + 12 >> 2] = j2;
                  c2[u2 >> 2] = j2;
                  c2[j2 + 8 >> 2] = v2;
                  c2[j2 + 12 >> 2] = b5;
                  c2[j2 + 24 >> 2] = 0;
                }
              } else {
                v2 = c2[5416] | 0;
                if ((v2 | 0) == 0 | g2 >>> 0 < v2 >>> 0)
                  c2[5416] = g2;
                c2[5524] = g2;
                c2[5525] = h2;
                c2[5527] = 0;
                c2[5421] = c2[5530];
                c2[5420] = -1;
                c2[5425] = 21688;
                c2[5424] = 21688;
                c2[5427] = 21696;
                c2[5426] = 21696;
                c2[5429] = 21704;
                c2[5428] = 21704;
                c2[5431] = 21712;
                c2[5430] = 21712;
                c2[5433] = 21720;
                c2[5432] = 21720;
                c2[5435] = 21728;
                c2[5434] = 21728;
                c2[5437] = 21736;
                c2[5436] = 21736;
                c2[5439] = 21744;
                c2[5438] = 21744;
                c2[5441] = 21752;
                c2[5440] = 21752;
                c2[5443] = 21760;
                c2[5442] = 21760;
                c2[5445] = 21768;
                c2[5444] = 21768;
                c2[5447] = 21776;
                c2[5446] = 21776;
                c2[5449] = 21784;
                c2[5448] = 21784;
                c2[5451] = 21792;
                c2[5450] = 21792;
                c2[5453] = 21800;
                c2[5452] = 21800;
                c2[5455] = 21808;
                c2[5454] = 21808;
                c2[5457] = 21816;
                c2[5456] = 21816;
                c2[5459] = 21824;
                c2[5458] = 21824;
                c2[5461] = 21832;
                c2[5460] = 21832;
                c2[5463] = 21840;
                c2[5462] = 21840;
                c2[5465] = 21848;
                c2[5464] = 21848;
                c2[5467] = 21856;
                c2[5466] = 21856;
                c2[5469] = 21864;
                c2[5468] = 21864;
                c2[5471] = 21872;
                c2[5470] = 21872;
                c2[5473] = 21880;
                c2[5472] = 21880;
                c2[5475] = 21888;
                c2[5474] = 21888;
                c2[5477] = 21896;
                c2[5476] = 21896;
                c2[5479] = 21904;
                c2[5478] = 21904;
                c2[5481] = 21912;
                c2[5480] = 21912;
                c2[5483] = 21920;
                c2[5482] = 21920;
                c2[5485] = 21928;
                c2[5484] = 21928;
                c2[5487] = 21936;
                c2[5486] = 21936;
                v2 = h2 + -40 | 0;
                t2 = g2 + 8 | 0;
                t2 = (t2 & 7 | 0) == 0 ? 0 : 0 - t2 & 7;
                u2 = g2 + t2 | 0;
                t2 = v2 - t2 | 0;
                c2[5418] = u2;
                c2[5415] = t2;
                c2[u2 + 4 >> 2] = t2 | 1;
                c2[g2 + v2 + 4 >> 2] = 40;
                c2[5419] = c2[5534];
              }
            while (0);
          b5 = c2[5415] | 0;
          if (b5 >>> 0 > m2 >>> 0) {
            t2 = b5 - m2 | 0;
            c2[5415] = t2;
            v2 = c2[5418] | 0;
            u2 = v2 + m2 | 0;
            c2[5418] = u2;
            c2[u2 + 4 >> 2] = t2 | 1;
            c2[v2 + 4 >> 2] = m2 | 3;
            v2 = v2 + 8 | 0;
            V = w2;
            return v2 | 0;
          }
        }
        c2[(ao() | 0) >> 2] = 48;
        v2 = 0;
        V = w2;
        return v2 | 0;
      }
      function er(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0, f2 = 0, g2 = 0, h2 = 0, i2 = 0, j2 = 0;
        if (!a3)
          return;
        d2 = a3 + -8 | 0;
        f2 = c2[5416] | 0;
        a3 = c2[a3 + -4 >> 2] | 0;
        b5 = a3 & -8;
        j2 = d2 + b5 | 0;
        do
          if (!(a3 & 1)) {
            e2 = c2[d2 >> 2] | 0;
            if (!(a3 & 3))
              return;
            h2 = d2 + (0 - e2) | 0;
            g2 = e2 + b5 | 0;
            if (h2 >>> 0 < f2 >>> 0)
              return;
            if ((c2[5417] | 0) == (h2 | 0)) {
              a3 = j2 + 4 | 0;
              b5 = c2[a3 >> 2] | 0;
              if ((b5 & 3 | 0) != 3) {
                i2 = h2;
                b5 = g2;
                break;
              }
              c2[5414] = g2;
              c2[a3 >> 2] = b5 & -2;
              c2[h2 + 4 >> 2] = g2 | 1;
              c2[h2 + g2 >> 2] = g2;
              return;
            }
            d2 = e2 >>> 3;
            if (e2 >>> 0 < 256) {
              a3 = c2[h2 + 8 >> 2] | 0;
              b5 = c2[h2 + 12 >> 2] | 0;
              if ((b5 | 0) == (a3 | 0)) {
                c2[5412] = c2[5412] & ~(1 << d2);
                i2 = h2;
                b5 = g2;
                break;
              } else {
                c2[a3 + 12 >> 2] = b5;
                c2[b5 + 8 >> 2] = a3;
                i2 = h2;
                b5 = g2;
                break;
              }
            }
            f2 = c2[h2 + 24 >> 2] | 0;
            a3 = c2[h2 + 12 >> 2] | 0;
            do
              if ((a3 | 0) == (h2 | 0)) {
                b5 = h2 + 16 | 0;
                d2 = b5 + 4 | 0;
                a3 = c2[d2 >> 2] | 0;
                if (!a3) {
                  a3 = c2[b5 >> 2] | 0;
                  if (!a3) {
                    a3 = 0;
                    break;
                  }
                } else
                  b5 = d2;
                while (1) {
                  e2 = a3 + 20 | 0;
                  d2 = c2[e2 >> 2] | 0;
                  if (!d2) {
                    e2 = a3 + 16 | 0;
                    d2 = c2[e2 >> 2] | 0;
                    if (!d2)
                      break;
                    else {
                      a3 = d2;
                      b5 = e2;
                    }
                  } else {
                    a3 = d2;
                    b5 = e2;
                  }
                }
                c2[b5 >> 2] = 0;
              } else {
                i2 = c2[h2 + 8 >> 2] | 0;
                c2[i2 + 12 >> 2] = a3;
                c2[a3 + 8 >> 2] = i2;
              }
            while (0);
            if (f2) {
              b5 = c2[h2 + 28 >> 2] | 0;
              d2 = 21952 + (b5 << 2) | 0;
              if ((c2[d2 >> 2] | 0) == (h2 | 0)) {
                c2[d2 >> 2] = a3;
                if (!a3) {
                  c2[5413] = c2[5413] & ~(1 << b5);
                  i2 = h2;
                  b5 = g2;
                  break;
                }
              } else {
                i2 = f2 + 16 | 0;
                c2[((c2[i2 >> 2] | 0) == (h2 | 0) ? i2 : f2 + 20 | 0) >> 2] = a3;
                if (!a3) {
                  i2 = h2;
                  b5 = g2;
                  break;
                }
              }
              c2[a3 + 24 >> 2] = f2;
              b5 = h2 + 16 | 0;
              d2 = c2[b5 >> 2] | 0;
              if (d2 | 0) {
                c2[a3 + 16 >> 2] = d2;
                c2[d2 + 24 >> 2] = a3;
              }
              b5 = c2[b5 + 4 >> 2] | 0;
              if (b5) {
                c2[a3 + 20 >> 2] = b5;
                c2[b5 + 24 >> 2] = a3;
                i2 = h2;
                b5 = g2;
              } else {
                i2 = h2;
                b5 = g2;
              }
            } else {
              i2 = h2;
              b5 = g2;
            }
          } else {
            i2 = d2;
            h2 = d2;
          }
        while (0);
        if (h2 >>> 0 >= j2 >>> 0)
          return;
        a3 = j2 + 4 | 0;
        e2 = c2[a3 >> 2] | 0;
        if (!(e2 & 1))
          return;
        if (!(e2 & 2)) {
          if ((c2[5418] | 0) == (j2 | 0)) {
            j2 = (c2[5415] | 0) + b5 | 0;
            c2[5415] = j2;
            c2[5418] = i2;
            c2[i2 + 4 >> 2] = j2 | 1;
            if ((i2 | 0) != (c2[5417] | 0))
              return;
            c2[5417] = 0;
            c2[5414] = 0;
            return;
          }
          if ((c2[5417] | 0) == (j2 | 0)) {
            j2 = (c2[5414] | 0) + b5 | 0;
            c2[5414] = j2;
            c2[5417] = h2;
            c2[i2 + 4 >> 2] = j2 | 1;
            c2[h2 + j2 >> 2] = j2;
            return;
          }
          f2 = (e2 & -8) + b5 | 0;
          d2 = e2 >>> 3;
          do
            if (e2 >>> 0 < 256) {
              b5 = c2[j2 + 8 >> 2] | 0;
              a3 = c2[j2 + 12 >> 2] | 0;
              if ((a3 | 0) == (b5 | 0)) {
                c2[5412] = c2[5412] & ~(1 << d2);
                break;
              } else {
                c2[b5 + 12 >> 2] = a3;
                c2[a3 + 8 >> 2] = b5;
                break;
              }
            } else {
              g2 = c2[j2 + 24 >> 2] | 0;
              a3 = c2[j2 + 12 >> 2] | 0;
              do
                if ((a3 | 0) == (j2 | 0)) {
                  b5 = j2 + 16 | 0;
                  d2 = b5 + 4 | 0;
                  a3 = c2[d2 >> 2] | 0;
                  if (!a3) {
                    a3 = c2[b5 >> 2] | 0;
                    if (!a3) {
                      d2 = 0;
                      break;
                    }
                  } else
                    b5 = d2;
                  while (1) {
                    e2 = a3 + 20 | 0;
                    d2 = c2[e2 >> 2] | 0;
                    if (!d2) {
                      e2 = a3 + 16 | 0;
                      d2 = c2[e2 >> 2] | 0;
                      if (!d2)
                        break;
                      else {
                        a3 = d2;
                        b5 = e2;
                      }
                    } else {
                      a3 = d2;
                      b5 = e2;
                    }
                  }
                  c2[b5 >> 2] = 0;
                  d2 = a3;
                } else {
                  d2 = c2[j2 + 8 >> 2] | 0;
                  c2[d2 + 12 >> 2] = a3;
                  c2[a3 + 8 >> 2] = d2;
                  d2 = a3;
                }
              while (0);
              if (g2 | 0) {
                a3 = c2[j2 + 28 >> 2] | 0;
                b5 = 21952 + (a3 << 2) | 0;
                if ((c2[b5 >> 2] | 0) == (j2 | 0)) {
                  c2[b5 >> 2] = d2;
                  if (!d2) {
                    c2[5413] = c2[5413] & ~(1 << a3);
                    break;
                  }
                } else {
                  e2 = g2 + 16 | 0;
                  c2[((c2[e2 >> 2] | 0) == (j2 | 0) ? e2 : g2 + 20 | 0) >> 2] = d2;
                  if (!d2)
                    break;
                }
                c2[d2 + 24 >> 2] = g2;
                a3 = j2 + 16 | 0;
                b5 = c2[a3 >> 2] | 0;
                if (b5 | 0) {
                  c2[d2 + 16 >> 2] = b5;
                  c2[b5 + 24 >> 2] = d2;
                }
                a3 = c2[a3 + 4 >> 2] | 0;
                if (a3 | 0) {
                  c2[d2 + 20 >> 2] = a3;
                  c2[a3 + 24 >> 2] = d2;
                }
              }
            }
          while (0);
          c2[i2 + 4 >> 2] = f2 | 1;
          c2[h2 + f2 >> 2] = f2;
          if ((i2 | 0) == (c2[5417] | 0)) {
            c2[5414] = f2;
            return;
          }
        } else {
          c2[a3 >> 2] = e2 & -2;
          c2[i2 + 4 >> 2] = b5 | 1;
          c2[h2 + b5 >> 2] = b5;
          f2 = b5;
        }
        a3 = f2 >>> 3;
        if (f2 >>> 0 < 256) {
          d2 = 21688 + (a3 << 1 << 2) | 0;
          b5 = c2[5412] | 0;
          a3 = 1 << a3;
          if (!(b5 & a3)) {
            c2[5412] = b5 | a3;
            a3 = d2;
            b5 = d2 + 8 | 0;
          } else {
            b5 = d2 + 8 | 0;
            a3 = c2[b5 >> 2] | 0;
          }
          c2[b5 >> 2] = i2;
          c2[a3 + 12 >> 2] = i2;
          c2[i2 + 8 >> 2] = a3;
          c2[i2 + 12 >> 2] = d2;
          return;
        }
        a3 = f2 >>> 8;
        if (a3)
          if (f2 >>> 0 > 16777215)
            e2 = 31;
          else {
            h2 = (a3 + 1048320 | 0) >>> 16 & 8;
            j2 = a3 << h2;
            g2 = (j2 + 520192 | 0) >>> 16 & 4;
            j2 = j2 << g2;
            e2 = (j2 + 245760 | 0) >>> 16 & 2;
            e2 = 14 - (g2 | h2 | e2) + (j2 << e2 >>> 15) | 0;
            e2 = f2 >>> (e2 + 7 | 0) & 1 | e2 << 1;
          }
        else
          e2 = 0;
        a3 = 21952 + (e2 << 2) | 0;
        c2[i2 + 28 >> 2] = e2;
        c2[i2 + 20 >> 2] = 0;
        c2[i2 + 16 >> 2] = 0;
        b5 = c2[5413] | 0;
        d2 = 1 << e2;
        a:
          do
            if (!(b5 & d2)) {
              c2[5413] = b5 | d2;
              c2[a3 >> 2] = i2;
              c2[i2 + 24 >> 2] = a3;
              c2[i2 + 12 >> 2] = i2;
              c2[i2 + 8 >> 2] = i2;
            } else {
              a3 = c2[a3 >> 2] | 0;
              b:
                do
                  if ((c2[a3 + 4 >> 2] & -8 | 0) != (f2 | 0)) {
                    e2 = f2 << ((e2 | 0) == 31 ? 0 : 25 - (e2 >>> 1) | 0);
                    while (1) {
                      d2 = a3 + 16 + (e2 >>> 31 << 2) | 0;
                      b5 = c2[d2 >> 2] | 0;
                      if (!b5)
                        break;
                      if ((c2[b5 + 4 >> 2] & -8 | 0) == (f2 | 0)) {
                        a3 = b5;
                        break b;
                      } else {
                        e2 = e2 << 1;
                        a3 = b5;
                      }
                    }
                    c2[d2 >> 2] = i2;
                    c2[i2 + 24 >> 2] = a3;
                    c2[i2 + 12 >> 2] = i2;
                    c2[i2 + 8 >> 2] = i2;
                    break a;
                  }
                while (0);
              h2 = a3 + 8 | 0;
              j2 = c2[h2 >> 2] | 0;
              c2[j2 + 12 >> 2] = i2;
              c2[h2 >> 2] = i2;
              c2[i2 + 8 >> 2] = j2;
              c2[i2 + 12 >> 2] = a3;
              c2[i2 + 24 >> 2] = 0;
            }
          while (0);
        j2 = (c2[5420] | 0) + -1 | 0;
        c2[5420] = j2;
        if (j2 | 0)
          return;
        a3 = 22104;
        while (1) {
          a3 = c2[a3 >> 2] | 0;
          if (!a3)
            break;
          else
            a3 = a3 + 8 | 0;
        }
        c2[5420] = -1;
        return;
      }
      function fr(a3) {
        a3 = a3 | 0;
        var b5 = 0, d2 = 0, e2 = 0;
        e2 = a3 + 3 & -4;
        a3 = sr() | 0;
        b5 = c2[a3 >> 2] | 0;
        d2 = b5 + e2 | 0;
        do
          if ((e2 | 0) < 1 | d2 >>> 0 > b5 >>> 0) {
            if (d2 >>> 0 > (R() | 0) >>> 0 ? (T(d2 | 0) | 0) == 0 : 0)
              break;
            c2[a3 >> 2] = d2;
            e2 = b5;
            return e2 | 0;
          }
        while (0);
        c2[(ao() | 0) >> 2] = 48;
        e2 = -1;
        return e2 | 0;
      }
      function gr(a3) {
        a3 = a3 | 0;
        var b5 = 0;
        b5 = V;
        V = V + a3 | 0;
        V = V + 15 & -16;
        return b5 | 0;
      }
      function hr(a3) {
        a3 = a3 | 0;
        V = a3;
      }
      function ir() {
        return V | 0;
      }
      function jr(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        var c3 = 0, d2 = 0, e2 = 0, f2 = 0;
        f2 = a3 & 65535;
        e2 = b5 & 65535;
        c3 = q(e2, f2) | 0;
        d2 = a3 >>> 16;
        a3 = (c3 >>> 16) + (q(e2, d2) | 0) | 0;
        e2 = b5 >>> 16;
        b5 = q(e2, f2) | 0;
        return (t((a3 >>> 16) + (q(e2, d2) | 0) + (((a3 & 65535) + b5 | 0) >>> 16) | 0), a3 + b5 << 16 | c3 & 65535 | 0) | 0;
      }
      function kr(a3, b5, c3, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var e2 = 0, f2 = 0;
        e2 = a3;
        f2 = c3;
        c3 = jr(e2, f2) | 0;
        a3 = u() | 0;
        return (t((q(b5, f2) | 0) + (q(d2, e2) | 0) + a3 | a3 & 0 | 0), c3 | 0 | 0) | 0;
      }
      function lr(a3, b5, c3, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        c3 = a3 + c3 >>> 0;
        return (t(b5 + d2 + (c3 >>> 0 < a3 >>> 0 | 0) >>> 0 | 0), c3 | 0) | 0;
      }
      function mr(a3, b5, c3, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        d2 = b5 - d2 - (c3 >>> 0 > a3 >>> 0 | 0) >>> 0;
        return (t(d2 | 0), a3 - c3 >>> 0 | 0) | 0;
      }
      function nr(a3) {
        a3 = a3 | 0;
        return (a3 ? 31 - (r(a3 ^ a3 - 1) | 0) | 0 : 32) | 0;
      }
      function or(a3, b5, d2, e2, f2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        f2 = f2 | 0;
        var g2 = 0, h2 = 0, i2 = 0, j2 = 0, k2 = 0, l2 = 0, m2 = 0, n2 = 0, o2 = 0, p2 = 0;
        l2 = a3;
        j2 = b5;
        k2 = j2;
        h2 = d2;
        n2 = e2;
        i2 = n2;
        if (!k2) {
          g2 = (f2 | 0) != 0;
          if (!i2) {
            if (g2) {
              c2[f2 >> 2] = (l2 >>> 0) % (h2 >>> 0);
              c2[f2 + 4 >> 2] = 0;
            }
            n2 = 0;
            f2 = (l2 >>> 0) / (h2 >>> 0) >>> 0;
            return (t(n2 | 0), f2) | 0;
          } else {
            if (!g2) {
              n2 = 0;
              f2 = 0;
              return (t(n2 | 0), f2) | 0;
            }
            c2[f2 >> 2] = a3 | 0;
            c2[f2 + 4 >> 2] = b5 & 0;
            n2 = 0;
            f2 = 0;
            return (t(n2 | 0), f2) | 0;
          }
        }
        g2 = (i2 | 0) == 0;
        do
          if (h2) {
            if (!g2) {
              g2 = (r(i2 | 0) | 0) - (r(k2 | 0) | 0) | 0;
              if (g2 >>> 0 <= 31) {
                m2 = g2 + 1 | 0;
                i2 = 31 - g2 | 0;
                b5 = g2 - 31 >> 31;
                h2 = m2;
                a3 = l2 >>> (m2 >>> 0) & b5 | k2 << i2;
                b5 = k2 >>> (m2 >>> 0) & b5;
                g2 = 0;
                i2 = l2 << i2;
                break;
              }
              if (!f2) {
                n2 = 0;
                f2 = 0;
                return (t(n2 | 0), f2) | 0;
              }
              c2[f2 >> 2] = a3 | 0;
              c2[f2 + 4 >> 2] = j2 | b5 & 0;
              n2 = 0;
              f2 = 0;
              return (t(n2 | 0), f2) | 0;
            }
            g2 = h2 - 1 | 0;
            if (g2 & h2 | 0) {
              i2 = (r(h2 | 0) | 0) + 33 - (r(k2 | 0) | 0) | 0;
              p2 = 64 - i2 | 0;
              m2 = 32 - i2 | 0;
              j2 = m2 >> 31;
              o2 = i2 - 32 | 0;
              b5 = o2 >> 31;
              h2 = i2;
              a3 = m2 - 1 >> 31 & k2 >>> (o2 >>> 0) | (k2 << m2 | l2 >>> (i2 >>> 0)) & b5;
              b5 = b5 & k2 >>> (i2 >>> 0);
              g2 = l2 << p2 & j2;
              i2 = (k2 << p2 | l2 >>> (o2 >>> 0)) & j2 | l2 << m2 & i2 - 33 >> 31;
              break;
            }
            if (f2 | 0) {
              c2[f2 >> 2] = g2 & l2;
              c2[f2 + 4 >> 2] = 0;
            }
            if ((h2 | 0) == 1) {
              o2 = j2 | b5 & 0;
              p2 = a3 | 0 | 0;
              return (t(o2 | 0), p2) | 0;
            } else {
              p2 = nr(h2 | 0) | 0;
              o2 = k2 >>> (p2 >>> 0) | 0;
              p2 = k2 << 32 - p2 | l2 >>> (p2 >>> 0) | 0;
              return (t(o2 | 0), p2) | 0;
            }
          } else {
            if (g2) {
              if (f2 | 0) {
                c2[f2 >> 2] = (k2 >>> 0) % (h2 >>> 0);
                c2[f2 + 4 >> 2] = 0;
              }
              o2 = 0;
              p2 = (k2 >>> 0) / (h2 >>> 0) >>> 0;
              return (t(o2 | 0), p2) | 0;
            }
            if (!l2) {
              if (f2 | 0) {
                c2[f2 >> 2] = 0;
                c2[f2 + 4 >> 2] = (k2 >>> 0) % (i2 >>> 0);
              }
              o2 = 0;
              p2 = (k2 >>> 0) / (i2 >>> 0) >>> 0;
              return (t(o2 | 0), p2) | 0;
            }
            g2 = i2 - 1 | 0;
            if (!(g2 & i2)) {
              if (f2 | 0) {
                c2[f2 >> 2] = a3 | 0;
                c2[f2 + 4 >> 2] = g2 & k2 | b5 & 0;
              }
              o2 = 0;
              p2 = k2 >>> ((nr(i2 | 0) | 0) >>> 0);
              return (t(o2 | 0), p2) | 0;
            }
            g2 = (r(i2 | 0) | 0) - (r(k2 | 0) | 0) | 0;
            if (g2 >>> 0 <= 30) {
              b5 = g2 + 1 | 0;
              i2 = 31 - g2 | 0;
              h2 = b5;
              a3 = k2 << i2 | l2 >>> (b5 >>> 0);
              b5 = k2 >>> (b5 >>> 0);
              g2 = 0;
              i2 = l2 << i2;
              break;
            }
            if (!f2) {
              o2 = 0;
              p2 = 0;
              return (t(o2 | 0), p2) | 0;
            }
            c2[f2 >> 2] = a3 | 0;
            c2[f2 + 4 >> 2] = j2 | b5 & 0;
            o2 = 0;
            p2 = 0;
            return (t(o2 | 0), p2) | 0;
          }
        while (0);
        if (!h2) {
          k2 = i2;
          j2 = 0;
          i2 = 0;
        } else {
          m2 = d2 | 0 | 0;
          l2 = n2 | e2 & 0;
          k2 = lr(m2 | 0, l2 | 0, -1, -1) | 0;
          d2 = u() | 0;
          j2 = i2;
          i2 = 0;
          do {
            e2 = j2;
            j2 = g2 >>> 31 | j2 << 1;
            g2 = i2 | g2 << 1;
            e2 = a3 << 1 | e2 >>> 31 | 0;
            n2 = a3 >>> 31 | b5 << 1 | 0;
            mr(k2 | 0, d2 | 0, e2 | 0, n2 | 0) | 0;
            p2 = u() | 0;
            o2 = p2 >> 31 | ((p2 | 0) < 0 ? -1 : 0) << 1;
            i2 = o2 & 1;
            a3 = mr(e2 | 0, n2 | 0, o2 & m2 | 0, (((p2 | 0) < 0 ? -1 : 0) >> 31 | ((p2 | 0) < 0 ? -1 : 0) << 1) & l2 | 0) | 0;
            b5 = u() | 0;
            h2 = h2 - 1 | 0;
          } while ((h2 | 0) != 0);
          k2 = j2;
          j2 = 0;
        }
        h2 = 0;
        if (f2 | 0) {
          c2[f2 >> 2] = a3;
          c2[f2 + 4 >> 2] = b5;
        }
        o2 = (g2 | 0) >>> 31 | (k2 | h2) << 1 | (h2 << 1 | g2 >>> 31) & 0 | j2;
        p2 = (g2 << 1 | 0 >>> 31) & -2 | i2;
        return (t(o2 | 0), p2) | 0;
      }
      function pr(a3, b5, c3, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        return or(a3, b5, c3, d2, 0) | 0;
      }
      function qr(a3, b5, c3) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        if ((c3 | 0) < 32) {
          t(b5 >>> c3 | 0);
          return a3 >>> c3 | (b5 & (1 << c3) - 1) << 32 - c3;
        }
        t(0);
        return b5 >>> c3 - 32 | 0;
      }
      function rr(a3, b5, c3) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        if ((c3 | 0) < 32) {
          t(b5 << c3 | (a3 & (1 << c3) - 1 << 32 - c3) >>> 32 - c3 | 0);
          return a3 << c3;
        }
        t(a3 << c3 - 32 | 0);
        return 0;
      }
      function sr() {
        return 22176;
      }
      function tr(a3) {
        a3 = a3 | 0;
        return (a3 & 255) << 24 | (a3 >> 8 & 255) << 16 | (a3 >> 16 & 255) << 8 | a3 >>> 24 | 0;
      }
      function ur(b5, d2, e2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f2 = 0, g2 = 0, h2 = 0;
        if ((e2 | 0) >= 512) {
          S(b5 | 0, d2 | 0, e2 | 0) | 0;
          return b5 | 0;
        }
        h2 = b5 | 0;
        g2 = b5 + e2 | 0;
        if ((b5 & 3) == (d2 & 3)) {
          while (b5 & 3) {
            if (!e2)
              return h2 | 0;
            a2[b5 >> 0] = a2[d2 >> 0] | 0;
            b5 = b5 + 1 | 0;
            d2 = d2 + 1 | 0;
            e2 = e2 - 1 | 0;
          }
          e2 = g2 & -4 | 0;
          f2 = e2 - 64 | 0;
          while ((b5 | 0) <= (f2 | 0)) {
            c2[b5 >> 2] = c2[d2 >> 2];
            c2[b5 + 4 >> 2] = c2[d2 + 4 >> 2];
            c2[b5 + 8 >> 2] = c2[d2 + 8 >> 2];
            c2[b5 + 12 >> 2] = c2[d2 + 12 >> 2];
            c2[b5 + 16 >> 2] = c2[d2 + 16 >> 2];
            c2[b5 + 20 >> 2] = c2[d2 + 20 >> 2];
            c2[b5 + 24 >> 2] = c2[d2 + 24 >> 2];
            c2[b5 + 28 >> 2] = c2[d2 + 28 >> 2];
            c2[b5 + 32 >> 2] = c2[d2 + 32 >> 2];
            c2[b5 + 36 >> 2] = c2[d2 + 36 >> 2];
            c2[b5 + 40 >> 2] = c2[d2 + 40 >> 2];
            c2[b5 + 44 >> 2] = c2[d2 + 44 >> 2];
            c2[b5 + 48 >> 2] = c2[d2 + 48 >> 2];
            c2[b5 + 52 >> 2] = c2[d2 + 52 >> 2];
            c2[b5 + 56 >> 2] = c2[d2 + 56 >> 2];
            c2[b5 + 60 >> 2] = c2[d2 + 60 >> 2];
            b5 = b5 + 64 | 0;
            d2 = d2 + 64 | 0;
          }
          while ((b5 | 0) < (e2 | 0)) {
            c2[b5 >> 2] = c2[d2 >> 2];
            b5 = b5 + 4 | 0;
            d2 = d2 + 4 | 0;
          }
        } else {
          e2 = g2 - 4 | 0;
          while ((b5 | 0) < (e2 | 0)) {
            a2[b5 >> 0] = a2[d2 >> 0] | 0;
            a2[b5 + 1 >> 0] = a2[d2 + 1 >> 0] | 0;
            a2[b5 + 2 >> 0] = a2[d2 + 2 >> 0] | 0;
            a2[b5 + 3 >> 0] = a2[d2 + 3 >> 0] | 0;
            b5 = b5 + 4 | 0;
            d2 = d2 + 4 | 0;
          }
        }
        while ((b5 | 0) < (g2 | 0)) {
          a2[b5 >> 0] = a2[d2 >> 0] | 0;
          b5 = b5 + 1 | 0;
          d2 = d2 + 1 | 0;
        }
        return h2 | 0;
      }
      function vr(b5, c3, d2) {
        b5 = b5 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var e2 = 0;
        if ((c3 | 0) < (b5 | 0) & (b5 | 0) < (c3 + d2 | 0)) {
          e2 = b5;
          c3 = c3 + d2 | 0;
          b5 = b5 + d2 | 0;
          while ((d2 | 0) > 0) {
            b5 = b5 - 1 | 0;
            c3 = c3 - 1 | 0;
            d2 = d2 - 1 | 0;
            a2[b5 >> 0] = a2[c3 >> 0] | 0;
          }
          b5 = e2;
        } else
          ur(b5, c3, d2) | 0;
        return b5 | 0;
      }
      function wr(b5, d2, e2) {
        b5 = b5 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        var f2 = 0, g2 = 0, h2 = 0, i2 = 0;
        h2 = b5 + e2 | 0;
        d2 = d2 & 255;
        if ((e2 | 0) >= 67) {
          while (b5 & 3) {
            a2[b5 >> 0] = d2;
            b5 = b5 + 1 | 0;
          }
          f2 = h2 & -4 | 0;
          i2 = d2 | d2 << 8 | d2 << 16 | d2 << 24;
          g2 = f2 - 64 | 0;
          while ((b5 | 0) <= (g2 | 0)) {
            c2[b5 >> 2] = i2;
            c2[b5 + 4 >> 2] = i2;
            c2[b5 + 8 >> 2] = i2;
            c2[b5 + 12 >> 2] = i2;
            c2[b5 + 16 >> 2] = i2;
            c2[b5 + 20 >> 2] = i2;
            c2[b5 + 24 >> 2] = i2;
            c2[b5 + 28 >> 2] = i2;
            c2[b5 + 32 >> 2] = i2;
            c2[b5 + 36 >> 2] = i2;
            c2[b5 + 40 >> 2] = i2;
            c2[b5 + 44 >> 2] = i2;
            c2[b5 + 48 >> 2] = i2;
            c2[b5 + 52 >> 2] = i2;
            c2[b5 + 56 >> 2] = i2;
            c2[b5 + 60 >> 2] = i2;
            b5 = b5 + 64 | 0;
          }
          while ((b5 | 0) < (f2 | 0)) {
            c2[b5 >> 2] = i2;
            b5 = b5 + 4 | 0;
          }
        }
        while ((b5 | 0) < (h2 | 0)) {
          a2[b5 >> 0] = d2;
          b5 = b5 + 1 | 0;
        }
        return h2 - e2 | 0;
      }
      function xr(a3) {
        a3 = a3 | 0;
        return Y[a3 & 3]() | 0;
      }
      function yr(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        return Z[a3 & 15](b5 | 0) | 0;
      }
      function zr(a3, b5, c3, d2, e2, f2, g2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = +c3;
        d2 = d2 | 0;
        e2 = e2 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        return _[a3 & 1](b5 | 0, +c3, d2 | 0, e2 | 0, f2 | 0, g2 | 0) | 0;
      }
      function Ar(a3, b5, c3) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        return $[a3 & 63](b5 | 0, c3 | 0) | 0;
      }
      function Br(a3, b5, c3, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        return aa[a3 & 7](b5 | 0, c3 | 0, d2 | 0) | 0;
      }
      function Cr(a3) {
        a3 = a3 | 0;
        ba[a3 & 3]();
      }
      function Dr(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        ca[a3 & 255](b5 | 0);
      }
      function Er(a3, b5, c3) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        da[a3 & 15](b5 | 0, c3 | 0);
      }
      function Fr(a3, b5, c3, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        ea[a3 & 15](b5 | 0, c3 | 0, d2 | 0);
      }
      function Gr(a3, b5, c3, d2, e2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        fa[a3 & 7](b5 | 0, c3 | 0, d2 | 0, e2 | 0);
      }
      function Hr(a3, b5, c3, d2, e2, f2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        f2 = f2 | 0;
        ga[a3 & 3](b5 | 0, c3 | 0, d2 | 0, e2 | 0, f2 | 0);
      }
      function Ir(a3, b5, c3, d2, e2, f2, g2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        ha[a3 & 3](b5 | 0, c3 | 0, d2 | 0, e2 | 0, f2 | 0, g2 | 0);
      }
      function Jr() {
        s(0);
        return 0;
      }
      function Kr(a3) {
        a3 = a3 | 0;
        s(1);
        return 0;
      }
      function Lr(a3, b5, c3, d2, e2, f2) {
        a3 = a3 | 0;
        b5 = +b5;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        f2 = f2 | 0;
        s(2);
        return 0;
      }
      function Mr(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        s(3);
        return 0;
      }
      function Nr(a3, b5, c3) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        s(4);
        return 0;
      }
      function Or() {
        s(5);
      }
      function Pr(a3) {
        a3 = a3 | 0;
        s(6);
      }
      function Qr(a3, b5) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        s(7);
      }
      function Rr(a3, b5, c3) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        s(8);
      }
      function Sr(a3, b5, c3, d2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        s(9);
      }
      function Tr(a3, b5, c3, d2, e2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        s(10);
      }
      function Ur(a3, b5, c3, d2, e2, f2) {
        a3 = a3 | 0;
        b5 = b5 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e2 = e2 | 0;
        f2 = f2 | 0;
        s(11);
      }
      var Y = [Jr, Mk, Fl, Jr];
      var Z = [Kr, Ap, zb, Fb, qp, tp, oq, Kq, Tq, wk, na, tl, Ok, Hl, Kr, Kr];
      var _ = [Lr, po];
      var $ = [
        Mr,
        Ba,
        Ka,
        Eb,
        jd,
        Nd,
        Xd,
        je,
        ke,
        ne,
        _e,
        ff,
        yf,
        Ff,
        Of,
        Vf,
        Hg,
        Qg,
        Zg,
        ch,
        lh,
        qh,
        zh,
        Eh,
        Nh,
        _h,
        fi,
        ki,
        si,
        Bi,
        Si,
        Zi,
        fj,
        oj,
        yj,
        Fj,
        Pj,
        Yj,
        ek,
        lk,
        tk,
        ll,
        Mr,
        Mr,
        Mr,
        Mr,
        Mr,
        Mr,
        Mr,
        Mr,
        Mr,
        Mr,
        Mr,
        Mr,
        Mr,
        Mr,
        Mr,
        Mr,
        Mr,
        Mr,
        Mr,
        Mr,
        Mr,
        Mr
      ];
      var aa = [Nr, Io, Yo, Fp, Hp, Mq, Nq, Nr];
      var ba = [Or, Dp, Po, Or];
      var ca = [
        Pr,
        pq,
        za,
        Aa,
        Ca,
        Ia,
        Ja,
        La,
        yp,
        ob,
        Gb,
        yb,
        Bb,
        Cb,
        Lb,
        Mb,
        Xb,
        Yb,
        sc,
        tc,
        uc,
        Nc,
        hd,
        id,
        kd,
        Jd,
        Od,
        Pd,
        Qd,
        Rd,
        Vd,
        Wd,
        Yd,
        he,
        ie,
        le,
        me,
        Ye,
        Ze,
        $e,
        df,
        ef,
        wf,
        xf,
        zf,
        Df,
        Ef,
        Mf,
        Nf,
        Pf,
        Tf,
        Uf,
        Fg,
        Gg,
        Ig,
        Rg,
        Sg,
        Xg,
        Yg,
        _g,
        dh,
        eh,
        jh,
        kh,
        mh,
        rh,
        sh,
        xh,
        yh,
        Ah,
        Fh,
        Gh,
        Lh,
        Mh,
        Oh,
        Yh,
        Zh,
        $h,
        di,
        ei,
        gi,
        li,
        mi,
        qi,
        ri,
        ti,
        zi,
        Ai,
        Qi,
        Ri,
        Ti,
        Xi,
        Yi,
        dj,
        ej,
        gj,
        mj,
        nj,
        wj,
        xj,
        zj,
        Dj,
        Ej,
        Nj,
        Oj,
        Qj,
        Wj,
        Xj,
        ck,
        dk,
        fk,
        jk,
        kk,
        rk,
        sk,
        uk,
        Uo,
        Vo,
        Wo,
        Xo,
        fp,
        op,
        pp,
        rp,
        sp,
        zp,
        Bp,
        Cp,
        Ep,
        Gp,
        Lp,
        mq,
        nq,
        Iq,
        Jq,
        Sq,
        Yq,
        Zq,
        zk,
        wl,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr,
        Pr
      ];
      var da = [Qr, Ab, Db, ma, pa, qa, ra, sa, qo, Qr, Qr, Qr, Qr, Qr, Qr, Qr];
      var ea = [Rr, Lq, Oq, Uq, Vq, la, oa, dl, Vl, $l, Rr, Rr, Rr, Rr, Rr, Rr];
      var fa = [Sr, $o, ip, Op, Vk, Ol, Sr, Sr];
      var ga = [Tr, _o, hp, Np];
      var ha = [Ur, Zo, gp, Mp];
      return {
        __ZSt18uncaught_exceptionv: kq,
        ___cxa_can_catch: hq,
        ___cxa_is_pointer_type: iq,
        ___embind_register_native_and_builtin_types: im,
        ___errno_location: ao,
        ___getTypeName: $n,
        ___muldi3: kr,
        ___udivdi3: pr,
        _bitshift64Lshr: qr,
        _bitshift64Shl: rr,
        _emscripten_get_sbrk_ptr: sr,
        _free: er,
        _i64Add: lr,
        _i64Subtract: mr,
        _llvm_bswap_i32: tr,
        _malloc: dr,
        _memcpy: ur,
        _memmove: vr,
        _memset: wr,
        dynCall_i: xr,
        dynCall_ii: yr,
        dynCall_iidiiii: zr,
        dynCall_iii: Ar,
        dynCall_iiii: Br,
        dynCall_v: Cr,
        dynCall_vi: Dr,
        dynCall_vii: Er,
        dynCall_viii: Fr,
        dynCall_viiii: Gr,
        dynCall_viiiii: Hr,
        dynCall_viiiiii: Ir,
        globalCtors: ia,
        stackAlloc: gr,
        stackRestore: hr,
        stackSave: ir
      };
    }(
      // EMSCRIPTEN_END_ASM
      asmGlobalArg,
      asmLibraryArg,
      buffer
    )
  );
  var __ZSt18uncaught_exceptionv = Module2["__ZSt18uncaught_exceptionv"] = asm["__ZSt18uncaught_exceptionv"];
  var ___cxa_can_catch = Module2["___cxa_can_catch"] = asm["___cxa_can_catch"];
  var ___cxa_is_pointer_type = Module2["___cxa_is_pointer_type"] = asm["___cxa_is_pointer_type"];
  var ___embind_register_native_and_builtin_types = Module2["___embind_register_native_and_builtin_types"] = asm["___embind_register_native_and_builtin_types"];
  var ___errno_location = Module2["___errno_location"] = asm["___errno_location"];
  var ___getTypeName = Module2["___getTypeName"] = asm["___getTypeName"];
  var ___muldi3 = Module2["___muldi3"] = asm["___muldi3"];
  var ___udivdi3 = Module2["___udivdi3"] = asm["___udivdi3"];
  var _bitshift64Lshr = Module2["_bitshift64Lshr"] = asm["_bitshift64Lshr"];
  var _bitshift64Shl = Module2["_bitshift64Shl"] = asm["_bitshift64Shl"];
  var _emscripten_get_sbrk_ptr = Module2["_emscripten_get_sbrk_ptr"] = asm["_emscripten_get_sbrk_ptr"];
  var _free = Module2["_free"] = asm["_free"];
  var _i64Add = Module2["_i64Add"] = asm["_i64Add"];
  var _i64Subtract = Module2["_i64Subtract"] = asm["_i64Subtract"];
  var _llvm_bswap_i32 = Module2["_llvm_bswap_i32"] = asm["_llvm_bswap_i32"];
  var _malloc = Module2["_malloc"] = asm["_malloc"];
  var _memcpy = Module2["_memcpy"] = asm["_memcpy"];
  var _memmove = Module2["_memmove"] = asm["_memmove"];
  var _memset = Module2["_memset"] = asm["_memset"];
  var globalCtors = Module2["globalCtors"] = asm["globalCtors"];
  var stackAlloc = Module2["stackAlloc"] = asm["stackAlloc"];
  var stackRestore = Module2["stackRestore"] = asm["stackRestore"];
  var stackSave = Module2["stackSave"] = asm["stackSave"];
  var dynCall_i = Module2["dynCall_i"] = asm["dynCall_i"];
  var dynCall_ii = Module2["dynCall_ii"] = asm["dynCall_ii"];
  var dynCall_iidiiii = Module2["dynCall_iidiiii"] = asm["dynCall_iidiiii"];
  var dynCall_iii = Module2["dynCall_iii"] = asm["dynCall_iii"];
  var dynCall_iiii = Module2["dynCall_iiii"] = asm["dynCall_iiii"];
  var dynCall_v = Module2["dynCall_v"] = asm["dynCall_v"];
  var dynCall_vi = Module2["dynCall_vi"] = asm["dynCall_vi"];
  var dynCall_vii = Module2["dynCall_vii"] = asm["dynCall_vii"];
  var dynCall_viii = Module2["dynCall_viii"] = asm["dynCall_viii"];
  var dynCall_viiii = Module2["dynCall_viiii"] = asm["dynCall_viiii"];
  var dynCall_viiiii = Module2["dynCall_viiiii"] = asm["dynCall_viiiii"];
  var dynCall_viiiiii = Module2["dynCall_viiiiii"] = asm["dynCall_viiiiii"];
  Module2["asm"] = asm;
  if (memoryInitializer) {
    if (!isDataURI(memoryInitializer)) {
      memoryInitializer = locateFile(memoryInitializer);
    }
    if (ENVIRONMENT_IS_NODE || ENVIRONMENT_IS_SHELL) {
      var data = readBinary(memoryInitializer);
      HEAPU8.set(data, GLOBAL_BASE);
    } else {
      addRunDependency("memory initializer");
      var applyMemoryInitializer = function(data2) {
        if (data2.byteLength)
          data2 = new Uint8Array(data2);
        HEAPU8.set(data2, GLOBAL_BASE);
        if (Module2["memoryInitializerRequest"])
          delete Module2["memoryInitializerRequest"].response;
        removeRunDependency("memory initializer");
      };
      var doBrowserLoad = function() {
        readAsync(memoryInitializer, applyMemoryInitializer, function() {
          var e = new Error("could not load memory initializer " + memoryInitializer);
          throw e;
        });
      };
      var memoryInitializerBytes = tryParseAsDataURI(memoryInitializer);
      if (memoryInitializerBytes) {
        applyMemoryInitializer(memoryInitializerBytes.buffer);
      } else if (Module2["memoryInitializerRequest"]) {
        var useRequest = function() {
          var request = Module2["memoryInitializerRequest"];
          var response = request.response;
          if (request.status !== 200 && request.status !== 0) {
            var data2 = tryParseAsDataURI(Module2["memoryInitializerRequestURL"]);
            if (data2) {
              response = data2.buffer;
            } else {
              console.warn("a problem seems to have happened with Module.memoryInitializerRequest, status: " + request.status + ", retrying " + memoryInitializer);
              doBrowserLoad();
              return;
            }
          }
          applyMemoryInitializer(response);
        };
        if (Module2["memoryInitializerRequest"].response) {
          setTimeout(useRequest, 0);
        } else {
          Module2["memoryInitializerRequest"].addEventListener("load", useRequest);
        }
      } else {
        doBrowserLoad();
      }
    }
  }
  var calledRun;
  function ExitStatus(status) {
    this.name = "ExitStatus";
    this.message = "Program terminated with exit(" + status + ")";
    this.status = status;
  }
  dependenciesFulfilled = function runCaller() {
    if (!calledRun)
      run();
    if (!calledRun)
      dependenciesFulfilled = runCaller;
  };
  function run(args) {
    args = args || arguments_;
    if (runDependencies > 0) {
      return;
    }
    preRun();
    if (runDependencies > 0)
      return;
    function doRun() {
      if (calledRun)
        return;
      calledRun = true;
      Module2["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      preMain();
      if (Module2["onRuntimeInitialized"])
        Module2["onRuntimeInitialized"]();
      postRun();
    }
    if (Module2["setStatus"]) {
      Module2["setStatus"]("Running...");
      setTimeout(function() {
        setTimeout(function() {
          Module2["setStatus"]("");
        }, 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  Module2["run"] = run;
  if (Module2["preInit"]) {
    if (typeof Module2["preInit"] == "function")
      Module2["preInit"] = [Module2["preInit"]];
    while (Module2["preInit"].length > 0) {
      Module2["preInit"].pop()();
    }
  }
  noExitRuntime = true;
  run();
  return Module2;
}

// ../../node_modules/.pnpm/@loaders.gl+las@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/las/dist/lib/laslaz-decoder.js
var Module = null;
var POINT_FORMAT_READERS = {
  0: (dv) => {
    return {
      position: [dv.getInt32(0, true), dv.getInt32(4, true), dv.getInt32(8, true)],
      intensity: dv.getUint16(12, true),
      classification: dv.getUint8(15)
    };
  },
  1: (dv) => {
    return {
      position: [dv.getInt32(0, true), dv.getInt32(4, true), dv.getInt32(8, true)],
      intensity: dv.getUint16(12, true),
      classification: dv.getUint8(15)
    };
  },
  2: (dv) => {
    return {
      position: [dv.getInt32(0, true), dv.getInt32(4, true), dv.getInt32(8, true)],
      intensity: dv.getUint16(12, true),
      classification: dv.getUint8(15),
      color: [dv.getUint16(20, true), dv.getUint16(22, true), dv.getUint16(24, true)]
    };
  },
  3: (dv) => {
    return {
      position: [dv.getInt32(0, true), dv.getInt32(4, true), dv.getInt32(8, true)],
      intensity: dv.getUint16(12, true),
      classification: dv.getUint8(15),
      color: [dv.getUint16(28, true), dv.getUint16(30, true), dv.getUint16(32, true)]
    };
  }
};
function readAs(buf, Type = {}, offset, count) {
  count = count === void 0 || count === 0 ? 1 : count;
  const sub = buf.slice(offset, offset + Type.BYTES_PER_ELEMENT * count);
  const r = new Type(sub);
  if (count === 1) {
    return r[0];
  }
  const ret = [];
  for (let i = 0; i < count; i++) {
    ret.push(r[i]);
  }
  return ret;
}
function parseLASHeader(arraybuffer) {
  let start = 32 * 3 + 35;
  const o = {
    pointsOffset: readAs(arraybuffer, Uint32Array, 32 * 3),
    pointsFormatId: readAs(arraybuffer, Uint8Array, 32 * 3 + 8),
    pointsStructSize: readAs(arraybuffer, Uint16Array, 32 * 3 + 8 + 1),
    pointsCount: readAs(arraybuffer, Uint32Array, 32 * 3 + 11),
    scale: readAs(arraybuffer, Float64Array, start, 3)
  };
  start += 24;
  o.offset = readAs(arraybuffer, Float64Array, start, 3);
  start += 24;
  const bounds = readAs(arraybuffer, Float64Array, start, 6);
  start += 48;
  o.maxs = [bounds[0], bounds[2], bounds[4]];
  o.mins = [bounds[1], bounds[3], bounds[5]];
  return o;
}
var LASLoader2 = class {
  arraybuffer;
  readOffset = 0;
  header = {
    pointsOffset: 0,
    pointsFormatId: 0,
    pointsStructSize: 0,
    pointsCount: 0,
    scale: [0, 0, 0],
    offset: [0, 0, 0],
    maxs: [0],
    mins: [0],
    totalToRead: 0,
    totalRead: 0,
    versionAsString: "",
    isCompressed: true
  };
  constructor(arraybuffer) {
    this.arraybuffer = arraybuffer;
  }
  /**
   * @returns boolean
   */
  open() {
    return true;
  }
  /**
   * Parsing of incoming binary
   * @returns LASHeader
   */
  getHeader() {
    this.header = parseLASHeader(this.arraybuffer);
    return this.header;
  }
  /**
   * Reading data
   * @param count
   * @param skip
   * @returns new ArrayBuffer, count, hasMoreData
   */
  readData(count, skip) {
    const { header, arraybuffer } = this;
    if (!header) {
      throw new Error("Cannot start reading data till a header request is issued");
    }
    let { readOffset } = this;
    let start;
    if (skip <= 1) {
      count = Math.min(count, header.pointsCount - readOffset);
      start = header.pointsOffset + readOffset * header.pointsStructSize;
      const end = start + count * header.pointsStructSize;
      readOffset += count;
      this.readOffset = readOffset;
      return {
        buffer: arraybuffer.slice(start, end),
        count,
        hasMoreData: readOffset < header.pointsCount
      };
    }
    const pointsToRead = Math.min(count * skip, header.pointsCount - readOffset);
    const bufferSize = Math.ceil(pointsToRead / skip);
    let pointsRead = 0;
    const buf = new Uint8Array(bufferSize * header.pointsStructSize);
    for (let i = 0; i < pointsToRead; i++) {
      if (i % skip === 0) {
        start = header.pointsOffset + readOffset * header.pointsStructSize;
        const src = new Uint8Array(arraybuffer, start, header.pointsStructSize);
        buf.set(src, pointsRead * header.pointsStructSize);
        pointsRead++;
      }
      readOffset++;
    }
    this.readOffset = readOffset;
    return {
      buffer: buf.buffer,
      count: pointsRead,
      hasMoreData: readOffset < header.pointsCount
    };
  }
  /**
   * Method which brings data to null to close the file
   * @returns
   */
  close() {
    this.arraybuffer = null;
    return true;
  }
};
var LAZLoader = class {
  arraybuffer;
  instance = null;
  // LASZip instance
  header = null;
  constructor(arraybuffer) {
    this.arraybuffer = arraybuffer;
    if (!Module) {
      Module = getModule();
    }
  }
  /**
   * Opens the file
   * @returns boolean
   */
  open() {
    try {
      const { arraybuffer } = this;
      this.instance = new Module.LASZip();
      const abInt = new Uint8Array(arraybuffer);
      const buf = Module._malloc(arraybuffer.byteLength);
      this.instance.arraybuffer = arraybuffer;
      this.instance.buf = buf;
      Module.HEAPU8.set(abInt, buf);
      this.instance.open(buf, arraybuffer.byteLength);
      this.instance.readOffset = 0;
      return true;
    } catch (error) {
      throw new Error(`Failed to open file: ${error.message}`);
    }
  }
  getHeader() {
    if (!this.instance) {
      throw new Error("You need to open the file before trying to read header");
    }
    try {
      const header = parseLASHeader(this.instance.arraybuffer);
      header.pointsFormatId &= 63;
      this.header = header;
      return header;
    } catch (error) {
      throw new Error(`Failed to get header: ${error.message}`);
    }
  }
  /**
   * @param count
   * @param offset
   * @param skip
   * @returns Data
   */
  readData(count, offset, skip) {
    if (!this.instance) {
      throw new Error("You need to open the file before trying to read stuff");
    }
    const { header, instance } = this;
    if (!header) {
      throw new Error("You need to query header before reading, I maintain state that way, sorry :(");
    }
    try {
      const pointsToRead = Math.min(count * skip, header.pointsCount - instance.readOffset);
      const bufferSize = Math.ceil(pointsToRead / skip);
      let pointsRead = 0;
      const thisBuf = new Uint8Array(bufferSize * header.pointsStructSize);
      const bufRead = Module._malloc(header.pointsStructSize);
      for (let i = 0; i < pointsToRead; i++) {
        instance.getPoint(bufRead);
        if (i % skip === 0) {
          const a2 = new Uint8Array(Module.HEAPU8.buffer, bufRead, header.pointsStructSize);
          thisBuf.set(a2, pointsRead * header.pointsStructSize);
          pointsRead++;
        }
        instance.readOffset++;
      }
      Module._free(bufRead);
      return {
        buffer: thisBuf.buffer,
        count: pointsRead,
        hasMoreData: instance.readOffset < header.pointsCount
      };
    } catch (error) {
      throw new Error(`Failed to read data: ${error.message}`);
    }
  }
  /**
   * Deletes the instance
   * @returns boolean
   */
  close() {
    try {
      if (this.instance !== null) {
        Module._free(this.instance.buf);
        this.instance.delete();
        this.instance = null;
      }
      return true;
    } catch (error) {
      throw new Error(`Failed to close file: ${error.message}`);
    }
  }
};
var LASDecoder = class {
  arrayb;
  decoder;
  pointsCount;
  pointSize;
  scale;
  offset;
  mins;
  maxs;
  constructor(buffer, len, header) {
    this.arrayb = buffer;
    this.decoder = POINT_FORMAT_READERS[header.pointsFormatId];
    this.pointsCount = len;
    this.pointSize = header.pointsStructSize;
    this.scale = header.scale;
    this.offset = header.offset;
    this.mins = header.mins;
    this.maxs = header.maxs;
  }
  /**
   * Decodes data depends on this point size
   * @param index
   * @returns New object
   */
  getPoint(index) {
    if (index < 0 || index >= this.pointsCount) {
      throw new Error("Point index out of range");
    }
    const dv = new DataView(this.arrayb, index * this.pointSize, this.pointSize);
    return this.decoder(dv);
  }
};
var LASFile = class {
  arraybuffer;
  formatId = 0;
  loader;
  isCompressed = true;
  isOpen = false;
  version = 0;
  versionAsString = "";
  constructor(arraybuffer) {
    this.arraybuffer = arraybuffer;
    if (this.determineVersion() > 13) {
      throw new Error("Only file versions <= 1.3 are supported at this time");
    }
    this.determineFormat();
    if (POINT_FORMAT_READERS[this.formatId] === void 0) {
      throw new Error("The point format ID is not supported");
    }
    this.loader = this.isCompressed ? new LAZLoader(this.arraybuffer) : new LASLoader2(this.arraybuffer);
  }
  /**
   * Determines format in parameters of LASHeaer
   */
  determineFormat() {
    const formatId = readAs(this.arraybuffer, Uint8Array, 32 * 3 + 8);
    const bit7 = (formatId & 128) >> 7;
    const bit6 = (formatId & 64) >> 6;
    if (bit7 === 1 && bit6 === 1) {
      throw new Error("Old style compression not supported");
    }
    this.formatId = formatId & 63;
    this.isCompressed = bit7 === 1 || bit6 === 1;
  }
  /**
   * Determines version
   * @returns version
   */
  determineVersion() {
    const ver = new Int8Array(this.arraybuffer, 24, 2);
    this.version = ver[0] * 10 + ver[1];
    this.versionAsString = `${ver[0]}.${ver[1]}`;
    return this.version;
  }
  /**
   * Reads if the file is open
   * @returns boolean
   */
  open() {
    if (this.loader.open()) {
      this.isOpen = true;
    }
  }
  /**
   * Gets the header
   * @returns Header
   */
  getHeader() {
    return this.loader.getHeader();
  }
  /**
   * @param count
   * @param start
   * @param skip
   * @returns Data
   */
  readData(count, start, skip) {
    return this.loader.readData(count, start, skip);
  }
  /**
   * Closes the file
   */
  close() {
    if (this.loader.close()) {
      this.isOpen = false;
    }
  }
  /**
   */
  getUnpacker() {
    return LASDecoder;
  }
};

// ../../node_modules/.pnpm/@loaders.gl+las@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/las/dist/lib/get-las-schema.js
function getLASSchema(lasHeader, attributes) {
  const metadataMap = makeMetadataFromLasHeader(lasHeader);
  const schema = deduceMeshSchema(attributes, metadataMap);
  return schema;
}
function makeMetadataFromLasHeader(lasHeader) {
  const metadata = {};
  metadata.las_pointsOffset = lasHeader.pointsOffset.toString(10);
  metadata.las_pointsFormatId = lasHeader.pointsFormatId.toString(10);
  metadata.las_pointsStructSize = lasHeader.pointsStructSize.toString(10);
  metadata.las_pointsCount = lasHeader.pointsCount.toString(10);
  metadata.las_scale = JSON.stringify(lasHeader.scale);
  metadata.las_offset = JSON.stringify(lasHeader.offset);
  if (lasHeader.maxs !== void 0) {
    metadata.las_maxs = JSON.stringify(lasHeader.maxs);
  }
  if (lasHeader.mins !== void 0) {
    metadata.las_mins = JSON.stringify(lasHeader.mins);
  }
  metadata.las_totalToRead = lasHeader.totalToRead.toString(10);
  metadata.las_pointsFortotalReadmatId = lasHeader.totalRead.toString(10);
  if (lasHeader.versionAsString !== void 0) {
    metadata.las_versionAsString = lasHeader.versionAsString;
  }
  if (lasHeader.isCompressed !== void 0) {
    metadata.las_isCompressed = lasHeader.isCompressed.toString();
  }
  return metadata;
}

// ../../node_modules/.pnpm/@loaders.gl+las@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/las/dist/lib/parse-las.js
function parseLAS(arrayBuffer, options) {
  return parseLASMesh(arrayBuffer, options);
}
function parseLASMesh(arrayBuffer, options = {}) {
  let pointIndex = 0;
  let positions;
  let colors;
  let intensities;
  let classifications;
  let originalHeader;
  const lasMesh = {
    loader: "las",
    loaderData: {},
    // shape: 'mesh',
    schema: { fields: [], metadata: {} },
    header: {
      vertexCount: 0,
      boundingBox: [
        [0, 0, 0],
        [0, 0, 0]
      ]
    },
    attributes: {},
    topology: "point-list",
    mode: 0
    // GL.POINTS
  };
  parseLASChunked(arrayBuffer, options.las?.skip, (decoder = {}, lasHeader) => {
    if (!originalHeader) {
      originalHeader = lasHeader;
      const total = lasHeader.totalToRead;
      const PositionsType = options.las?.fp64 ? Float64Array : Float32Array;
      positions = new PositionsType(total * 3);
      colors = lasHeader.pointsFormatId >= 2 ? new Uint8Array(total * 4) : null;
      intensities = new Uint16Array(total);
      classifications = new Uint8Array(total);
      lasMesh.loaderData = lasHeader;
      lasMesh.attributes = {
        POSITION: { value: positions, size: 3 },
        // non-gltf attributes, use non-capitalized names for now
        intensity: { value: intensities, size: 1 },
        classification: { value: classifications, size: 1 }
      };
      if (colors) {
        lasMesh.attributes.COLOR_0 = { value: colors, size: 4 };
      }
    }
    const batchSize = decoder.pointsCount;
    const { scale: [scaleX, scaleY, scaleZ], offset: [offsetX, offsetY, offsetZ] } = lasHeader;
    const twoByteColor = detectTwoByteColors(decoder, batchSize, options.las?.colorDepth);
    for (let i = 0; i < batchSize; i++) {
      const { position, color: color2, intensity, classification } = decoder.getPoint(i);
      positions[pointIndex * 3] = position[0] * scaleX + offsetX;
      positions[pointIndex * 3 + 1] = position[1] * scaleY + offsetY;
      positions[pointIndex * 3 + 2] = position[2] * scaleZ + offsetZ;
      if (color2 && colors) {
        if (twoByteColor) {
          colors[pointIndex * 4] = color2[0] / 256;
          colors[pointIndex * 4 + 1] = color2[1] / 256;
          colors[pointIndex * 4 + 2] = color2[2] / 256;
        } else {
          colors[pointIndex * 4] = color2[0];
          colors[pointIndex * 4 + 1] = color2[1];
          colors[pointIndex * 4 + 2] = color2[2];
        }
        colors[pointIndex * 4 + 3] = 255;
      }
      intensities[pointIndex] = intensity;
      classifications[pointIndex] = classification;
      pointIndex++;
    }
    const meshBatch = {
      ...lasMesh,
      header: {
        vertexCount: lasHeader.totalRead
      },
      progress: lasHeader.totalRead / lasHeader.totalToRead
    };
    options?.onProgress?.(meshBatch);
  });
  lasMesh.header = {
    vertexCount: originalHeader.totalToRead,
    boundingBox: getMeshBoundingBox(lasMesh?.attributes || {})
  };
  if (lasMesh) {
    lasMesh.schema = getLASSchema(lasMesh.loaderData, lasMesh.attributes);
  }
  return lasMesh;
}
function parseLASChunked(rawData, skip, onParseData = {}) {
  const dataHandler = new LASFile(rawData);
  try {
    dataHandler.open();
    const header = dataHandler.getHeader();
    const Unpacker = dataHandler.getUnpacker();
    const totalToRead = Math.ceil(header.pointsCount / Math.max(1, skip));
    header.totalToRead = totalToRead;
    let totalRead = 0;
    while (true) {
      const chunk = dataHandler.readData(1e3 * 100, 0, skip);
      totalRead += chunk.count;
      header.totalRead = totalRead;
      header.versionAsString = chunk.versionAsString;
      header.isCompressed = chunk.isCompressed;
      const unpacker = new Unpacker(chunk.buffer, chunk.count, header);
      onParseData(unpacker, header);
      if (!chunk.hasMoreData || totalRead >= totalToRead) {
        break;
      }
    }
  } catch (e) {
    throw e;
  } finally {
    dataHandler.close();
  }
}
function detectTwoByteColors(decoder = {}, batchSize, colorDepth) {
  let twoByteColor = false;
  switch (colorDepth) {
    case 8:
      twoByteColor = false;
      break;
    case 16:
      twoByteColor = true;
      break;
    case "auto":
      if (decoder.getPoint(0).color) {
        for (let i = 0; i < batchSize; i++) {
          const { color: color2 } = decoder.getPoint(i);
          if (color2[0] > 255 || color2[1] > 255 || color2[2] > 255) {
            twoByteColor = true;
          }
        }
      }
      break;
    default:
      console.warn("las: illegal value for options.las.colorDepth");
      break;
  }
  return twoByteColor;
}

// ../../node_modules/.pnpm/@loaders.gl+las@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/las/dist/index.js
var LASLoader3 = {
  ...LASLoader,
  parse: async (arrayBuffer, options) => parseLAS(arrayBuffer, options),
  parseSync: (arrayBuffer, options) => parseLAS(arrayBuffer, options)
};

// ../sdk/src/las/LASLoader.ts
var MAX_VERTICES = 5e5;
var LASLoader4 = class extends ModelLoader {
  constructor() {
    super({
      fileDataType: "arraybuffer",
      parsers: {
        "*": parseLAS2
      },
      getVersion: (fileData) => {
        return "*";
      }
    });
  }
  /**
   * Loads LAS/LAZ file data into a {@link scene!SceneModel | SceneModel} and/or a {@link data!DataModel | DataModel}.
   *
   * This function expects the following conditions:
   * - The {@link scene!SceneModel.built | SceneModel.built} and {@link scene!SceneModel.destroyed | SceneModel.destroyed} properties must be `false`.
   * - It does not invoke the {@link scene!SceneModel.build | SceneModel.build} and {@link data!DataModel.build | DataModel.build} methods; those are to be managed by the caller.
   *
   * @param params - The parameters used for loading the file data.
   * @param options - Options for loading the LAS/LAZ file.
   * @returns {Promise} Resolves when the file data has been successfully loaded into the SceneModel and/or DataModel.
   *
   * @throws {@link core!SDKError | SDKError}
   * - If the SceneModel has already been destroyed.
   * - If the SceneModel has already been built.
   * - If the DataModel has already been destroyed.
   * - If the DataModel has already been built.
   */
  load(params2, options = {}) {
    return super.load(params2, options);
  }
};
function parseLAS2(params2, options = {}) {
  return new Promise(function(resolve2, reject) {
    const { sceneModel, dataModel, fileData } = params2;
    if (!sceneModel && !dataModel) {
      return resolve2();
    }
    const skip = options.skip || 1;
    const log2 = (msg) => {
      if (params2.log) {
        params2.log(msg);
      }
    };
    parse7(params2.fileData, LASLoader3, {
      las: {
        colorDepth: options.colorDepth || "auto",
        fp64: options.fp64 !== void 0 ? options.fp64 : false
      }
    }).then((parsedData) => {
      const entityId = createUUID2();
      if (sceneModel) {
        const meshIds = [];
        const attributes = parsedData.attributes;
        const loaderData = parsedData.loaderData;
        const pointsFormatId = loaderData.pointsFormatId !== void 0 ? loaderData.pointsFormatId : -1;
        if (!attributes.POSITION) {
          log2("No positions found in file (expected for all LAS point formats)");
          return;
        }
        let readAttributes = {};
        switch (pointsFormatId) {
          case 0:
            if (!attributes.intensity) {
              log2("No intensities found in file (expected for LAS point format 0)");
              return;
            }
            readAttributes = readIntensities(attributes.POSITION, attributes.intensity);
            break;
          case 1:
            if (!attributes.intensity) {
              log2("No intensities found in file (expected for LAS point format 1)");
              return;
            }
            readAttributes = readIntensities(attributes.POSITION, attributes.intensity);
            break;
          case 2:
            if (!attributes.intensity) {
              log2("No intensities found in file (expected for LAS point format 2)");
              return;
            }
            readAttributes = readColorsAndIntensities(attributes.POSITION, attributes.COLOR_0, attributes.intensity);
            break;
          case 3:
            if (!attributes.intensity) {
              log2("No intensities found in file (expected for LAS point format 3)");
              return;
            }
            readAttributes = readColorsAndIntensities(attributes.POSITION, attributes.COLOR_0, attributes.intensity);
            break;
        }
        const pointsChunks = chunkArray(readPositions(readAttributes.positions), MAX_VERTICES * 3);
        const colorsChunks = chunkArray(readAttributes.colors, MAX_VERTICES * 4);
        for (let j = 0, lenj = pointsChunks.length; j < lenj; j++) {
          const geometryId = `geometry-${j}`;
          const geometry = sceneModel.createGeometry({
            id: geometryId,
            primitive: PointsPrimitive,
            positions: pointsChunks[j],
            colorsCompressed: colorsChunks[j]
          });
          if (geometry instanceof SDKError) {
            log2(`[ERROR] Failed to load point cloud: ${geometry.message}`);
          } else {
            const meshId = `mesh-${j}`;
            meshIds.push(meshId);
            const mesh = sceneModel.createMesh({
              id: meshId,
              geometryId
            });
            if (mesh instanceof SDKError) {
              log2(`[ERROR] Failed to load point cloud: ${mesh.message}`);
            }
          }
        }
        sceneModel.createObject({
          id: entityId,
          meshIds
        });
      }
      if (dataModel) {
        const rootMetaObjectId = createUUID2();
        dataModel.createObject({
          id: rootMetaObjectId,
          type: BasicEntity,
          name: "Model"
        });
        dataModel.createObject({
          id: entityId,
          type: BasicEntity,
          name: "PointCloud (LAZ)"
        });
        dataModel.createRelationship({
          type: BasicAggregation,
          relatingObjectId: rootMetaObjectId,
          relatedObjectId: entityId
        });
      }
      resolve2();
    }, (errMsg) => {
      return reject(`Error parsing LAS/LAZ data: ${errMsg}`);
    });
    function readPositions(positionsValue) {
      if (positionsValue) {
        if (options.center) {
          const centerPos = createVec3();
          const numPoints = positionsValue.length;
          for (let i = 0, len = positionsValue.length; i < len; i += 3) {
            centerPos[0] += positionsValue[i + 0];
            centerPos[1] += positionsValue[i + 1];
            centerPos[2] += positionsValue[i + 2];
          }
          centerPos[0] /= numPoints;
          centerPos[1] /= numPoints;
          centerPos[2] /= numPoints;
          for (let i = 0, len = positionsValue.length; i < len; i += 3) {
            positionsValue[i + 0] -= centerPos[0];
            positionsValue[i + 1] -= centerPos[1];
            positionsValue[i + 2] -= centerPos[2];
          }
        }
        if (options.transform) {
          const mat = createMat4(options.transform);
          const pos = createVec3();
          for (let i = 0, len = positionsValue.length; i < len; i += 3) {
            pos[0] = positionsValue[i + 0];
            pos[1] = positionsValue[i + 1];
            pos[2] = positionsValue[i + 2];
            transformPoint3(mat, pos, pos);
            positionsValue[i + 0] = pos[0];
            positionsValue[i + 1] = pos[1];
            positionsValue[i + 2] = pos[2];
          }
        }
      }
      return positionsValue;
    }
    function readColorsAndIntensities(attributesPosition, attributesColor, attributesIntensity) {
      const positionsValue = attributesPosition.value;
      const colors = attributesColor.value;
      const colorSize = attributesColor.size;
      const intensities = attributesIntensity.value;
      const colorsCompressedSize = intensities.length * 4;
      const positions = [];
      const colorsCompressed = new Uint8Array(colorsCompressedSize / skip);
      let count = skip;
      for (let i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, len = intensities.length; i < len; i++, k += colorSize, j += 4, l += 3) {
        if (count <= 0) {
          colorsCompressed[m++] = colors[k + 0];
          colorsCompressed[m++] = colors[k + 1];
          colorsCompressed[m++] = colors[k + 2];
          colorsCompressed[m++] = Math.round(intensities[i] / 65536 * 255);
          positions[n++] = positionsValue[l + 0];
          positions[n++] = positionsValue[l + 1];
          positions[n++] = positionsValue[l + 2];
          count = skip;
        } else {
          count--;
        }
      }
      return {
        positions,
        colors: colorsCompressed
      };
    }
    function readIntensities(attributesPosition, attributesIntensity) {
      const positionsValue = attributesPosition.value;
      const intensities = attributesIntensity.intensity;
      const colorsCompressedSize = intensities.length * 4;
      const positions = [];
      const colorsCompressed = new Uint8Array(colorsCompressedSize / skip);
      let count = skip;
      for (let i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, len = intensities.length; i < len; i++, k += 3, j += 4, l += 3) {
        if (count <= 0) {
          colorsCompressed[m++] = 0;
          colorsCompressed[m++] = 0;
          colorsCompressed[m++] = 0;
          colorsCompressed[m++] = Math.round(intensities[i] / 65536 * 255);
          positions[n++] = positionsValue[l + 0];
          positions[n++] = positionsValue[l + 1];
          positions[n++] = positionsValue[l + 2];
          count = skip;
        } else {
          count--;
        }
      }
      return {
        positions,
        colors: colorsCompressed
      };
    }
    function chunkArray(array, chunkSize) {
      if (chunkSize >= array.length) {
        return [array];
      }
      let result = [];
      for (let i = 0; i < array.length; i += chunkSize) {
        result.push(array.slice(i, i + chunkSize));
      }
      return result;
    }
  });
}

// ../sdk/src/gltf/index.ts
var gltf_exports = {};
__export(gltf_exports, {
  GLTFLoader: () => GLTFLoader2
});

// ../../node_modules/.pnpm/@loaders.gl+gltf@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_mesh_features.js
var EXT_mesh_features_exports = {};
__export(EXT_mesh_features_exports, {
  createExtMeshFeatures: () => createExtMeshFeatures,
  decode: () => decode,
  encode: () => encode6,
  name: () => name
});

// ../../node_modules/.pnpm/@loaders.gl+images@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/images/dist/lib/utils/version.js
var VERSION5 = true ? "4.3.2" : "latest";

// ../../node_modules/.pnpm/@loaders.gl+images@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/images/dist/lib/category-api/image-type.js
var parseImageNode = globalThis.loaders?.parseImageNode;
var IMAGE_SUPPORTED = typeof Image !== "undefined";
var IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== "undefined";
var NODE_IMAGE_SUPPORTED = Boolean(parseImageNode);
var DATA_SUPPORTED = isBrowser ? true : NODE_IMAGE_SUPPORTED;
function isImageTypeSupported(type) {
  switch (type) {
    case "auto":
      return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;
    case "imagebitmap":
      return IMAGE_BITMAP_SUPPORTED;
    case "image":
      return IMAGE_SUPPORTED;
    case "data":
      return DATA_SUPPORTED;
    default:
      throw new Error(`@loaders.gl/images: image ${type} not supported in this environment`);
  }
}
function getDefaultImageType() {
  if (IMAGE_BITMAP_SUPPORTED) {
    return "imagebitmap";
  }
  if (IMAGE_SUPPORTED) {
    return "image";
  }
  if (DATA_SUPPORTED) {
    return "data";
  }
  throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
}

// ../../node_modules/.pnpm/@loaders.gl+images@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/images/dist/lib/category-api/parsed-image-api.js
function getImageType(image) {
  const format = getImageTypeOrNull(image);
  if (!format) {
    throw new Error("Not an image");
  }
  return format;
}
function getImageData(image) {
  switch (getImageType(image)) {
    case "data":
      return image;
    case "image":
    case "imagebitmap":
      const canvas2 = document.createElement("canvas");
      const context = canvas2.getContext("2d");
      if (!context) {
        throw new Error("getImageData");
      }
      canvas2.width = image.width;
      canvas2.height = image.height;
      context.drawImage(image, 0, 0);
      return context.getImageData(0, 0, image.width, image.height);
    default:
      throw new Error("getImageData");
  }
}
function getImageTypeOrNull(image) {
  if (typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return "imagebitmap";
  }
  if (typeof Image !== "undefined" && image instanceof Image) {
    return "image";
  }
  if (image && typeof image === "object" && image.data && image.width && image.height) {
    return "data";
  }
  return null;
}

// ../../node_modules/.pnpm/@loaders.gl+images@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/images/dist/lib/parsers/svg-utils.js
var SVG_DATA_URL_PATTERN = /^data:image\/svg\+xml/;
var SVG_URL_PATTERN = /\.svg((\?|#).*)?$/;
function isSVG(url) {
  return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));
}
function getBlobOrSVGDataUrl(arrayBuffer, url) {
  if (isSVG(url)) {
    const textDecoder = new TextDecoder();
    let xmlText = textDecoder.decode(arrayBuffer);
    try {
      if (typeof unescape === "function" && typeof encodeURIComponent === "function") {
        xmlText = unescape(encodeURIComponent(xmlText));
      }
    } catch (error) {
      throw new Error(error.message);
    }
    const src = `data:image/svg+xml;base64,${btoa(xmlText)}`;
    return src;
  }
  return getBlob(arrayBuffer, url);
}
function getBlob(arrayBuffer, url) {
  if (isSVG(url)) {
    throw new Error("SVG cannot be parsed directly to imagebitmap");
  }
  return new Blob([new Uint8Array(arrayBuffer)]);
}

// ../../node_modules/.pnpm/@loaders.gl+images@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-image.js
async function parseToImage(arrayBuffer, options, url) {
  const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);
  const URL2 = self.URL || self.webkitURL;
  const objectUrl = typeof blobOrDataUrl !== "string" && URL2.createObjectURL(blobOrDataUrl);
  try {
    return await loadToImage(objectUrl || blobOrDataUrl, options);
  } finally {
    if (objectUrl) {
      URL2.revokeObjectURL(objectUrl);
    }
  }
}
async function loadToImage(url, options) {
  const image = new Image();
  image.src = url;
  if (options.image && options.image.decode && image.decode) {
    await image.decode();
    return image;
  }
  return await new Promise((resolve2, reject) => {
    try {
      image.onload = () => resolve2(image);
      image.onerror = (error) => {
        const message = error instanceof Error ? error.message : "error";
        reject(new Error(message));
      };
    } catch (error) {
      reject(error);
    }
  });
}

// ../../node_modules/.pnpm/@loaders.gl+images@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-image-bitmap.js
var EMPTY_OBJECT = {};
var imagebitmapOptionsSupported = true;
async function parseToImageBitmap(arrayBuffer, options, url) {
  let blob;
  if (isSVG(url)) {
    const image = await parseToImage(arrayBuffer, options, url);
    blob = image;
  } else {
    blob = getBlob(arrayBuffer, url);
  }
  const imagebitmapOptions = options && options.imagebitmap;
  return await safeCreateImageBitmap(blob, imagebitmapOptions);
}
async function safeCreateImageBitmap(blob, imagebitmapOptions = null) {
  if (isEmptyObject2(imagebitmapOptions) || !imagebitmapOptionsSupported) {
    imagebitmapOptions = null;
  }
  if (imagebitmapOptions) {
    try {
      return await createImageBitmap(blob, imagebitmapOptions);
    } catch (error) {
      console.warn(error);
      imagebitmapOptionsSupported = false;
    }
  }
  return await createImageBitmap(blob);
}
function isEmptyObject2(object) {
  for (const key in object || EMPTY_OBJECT) {
    return false;
  }
  return true;
}

// ../../node_modules/.pnpm/@loaders.gl+images@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/images/dist/lib/category-api/parse-isobmff-binary.js
function getISOBMFFMediaType(buffer) {
  if (!checkString(buffer, "ftyp", 4)) {
    return null;
  }
  if ((buffer[8] & 96) === 0) {
    return null;
  }
  return decodeMajorBrand(buffer);
}
function decodeMajorBrand(buffer) {
  const brandMajor = getUTF8String(buffer, 8, 12).replace("\0", " ").trim();
  switch (brandMajor) {
    case "avif":
    case "avis":
      return { extension: "avif", mimeType: "image/avif" };
    default:
      return null;
  }
}
function getUTF8String(array, start, end) {
  return String.fromCharCode(...array.slice(start, end));
}
function stringToBytes(string) {
  return [...string].map((character) => character.charCodeAt(0));
}
function checkString(buffer, header, offset = 0) {
  const headerBytes = stringToBytes(header);
  for (let i = 0; i < headerBytes.length; ++i) {
    if (headerBytes[i] !== buffer[i + offset]) {
      return false;
    }
  }
  return true;
}

// ../../node_modules/.pnpm/@loaders.gl+images@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/images/dist/lib/category-api/binary-image-api.js
var BIG_ENDIAN = false;
var LITTLE_ENDIAN = true;
function getBinaryImageMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  return getPngMetadata(dataView) || getJpegMetadata(dataView) || getGifMetadata(dataView) || getBmpMetadata(dataView) || getISOBMFFMetadata(dataView);
}
function getISOBMFFMetadata(binaryData) {
  const buffer = new Uint8Array(binaryData instanceof DataView ? binaryData.buffer : binaryData);
  const mediaType = getISOBMFFMediaType(buffer);
  if (!mediaType) {
    return null;
  }
  return {
    mimeType: mediaType.mimeType,
    // TODO - decode width and height
    width: 0,
    height: 0
  };
}
function getPngMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 2303741511;
  if (!isPng) {
    return null;
  }
  return {
    mimeType: "image/png",
    width: dataView.getUint32(16, BIG_ENDIAN),
    height: dataView.getUint32(20, BIG_ENDIAN)
  };
}
function getGifMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 1195984440;
  if (!isGif) {
    return null;
  }
  return {
    mimeType: "image/gif",
    width: dataView.getUint16(6, LITTLE_ENDIAN),
    height: dataView.getUint16(8, LITTLE_ENDIAN)
  };
}
function getBmpMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isBmp = dataView.byteLength >= 14 && dataView.getUint16(0, BIG_ENDIAN) === 16973 && dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;
  if (!isBmp) {
    return null;
  }
  return {
    mimeType: "image/bmp",
    width: dataView.getUint32(18, LITTLE_ENDIAN),
    height: dataView.getUint32(22, LITTLE_ENDIAN)
  };
}
function getJpegMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isJpeg = dataView.byteLength >= 3 && dataView.getUint16(0, BIG_ENDIAN) === 65496 && dataView.getUint8(2) === 255;
  if (!isJpeg) {
    return null;
  }
  const { tableMarkers, sofMarkers } = getJpegMarkers();
  let i = 2;
  while (i + 9 < dataView.byteLength) {
    const marker = dataView.getUint16(i, BIG_ENDIAN);
    if (sofMarkers.has(marker)) {
      return {
        mimeType: "image/jpeg",
        height: dataView.getUint16(i + 5, BIG_ENDIAN),
        // Number of lines
        width: dataView.getUint16(i + 7, BIG_ENDIAN)
        // Number of pixels per line
      };
    }
    if (!tableMarkers.has(marker)) {
      return null;
    }
    i += 2;
    i += dataView.getUint16(i, BIG_ENDIAN);
  }
  return null;
}
function getJpegMarkers() {
  const tableMarkers = /* @__PURE__ */ new Set([65499, 65476, 65484, 65501, 65534]);
  for (let i = 65504; i < 65520; ++i) {
    tableMarkers.add(i);
  }
  const sofMarkers = /* @__PURE__ */ new Set([
    65472,
    65473,
    65474,
    65475,
    65477,
    65478,
    65479,
    65481,
    65482,
    65483,
    65485,
    65486,
    65487,
    65502
  ]);
  return { tableMarkers, sofMarkers };
}
function toDataView(data) {
  if (data instanceof DataView) {
    return data;
  }
  if (ArrayBuffer.isView(data)) {
    return new DataView(data.buffer);
  }
  if (data instanceof ArrayBuffer) {
    return new DataView(data);
  }
  throw new Error("toDataView");
}

// ../../node_modules/.pnpm/@loaders.gl+images@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-node-image.js
async function parseToNodeImage(arrayBuffer, options) {
  const { mimeType } = getBinaryImageMetadata(arrayBuffer) || {};
  const parseImageNode2 = globalThis.loaders?.parseImageNode;
  assert(parseImageNode2);
  return await parseImageNode2(arrayBuffer, mimeType);
}

// ../../node_modules/.pnpm/@loaders.gl+images@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/images/dist/lib/parsers/parse-image.js
async function parseImage(arrayBuffer, options, context) {
  options = options || {};
  const imageOptions = options.image || {};
  const imageType = imageOptions.type || "auto";
  const { url } = context || {};
  const loadType = getLoadableImageType(imageType);
  let image;
  switch (loadType) {
    case "imagebitmap":
      image = await parseToImageBitmap(arrayBuffer, options, url);
      break;
    case "image":
      image = await parseToImage(arrayBuffer, options, url);
      break;
    case "data":
      image = await parseToNodeImage(arrayBuffer, options);
      break;
    default:
      assert(false);
  }
  if (imageType === "data") {
    image = getImageData(image);
  }
  return image;
}
function getLoadableImageType(type) {
  switch (type) {
    case "auto":
    case "data":
      return getDefaultImageType();
    default:
      isImageTypeSupported(type);
      return type;
  }
}

// ../../node_modules/.pnpm/@loaders.gl+images@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/images/dist/image-loader.js
var EXTENSIONS = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg", "avif"];
var MIME_TYPES = [
  "image/png",
  "image/jpeg",
  "image/gif",
  "image/webp",
  "image/avif",
  "image/bmp",
  "image/vnd.microsoft.icon",
  "image/svg+xml"
];
var DEFAULT_IMAGE_LOADER_OPTIONS = {
  image: {
    type: "auto",
    decode: true
    // if format is HTML
  }
  // imagebitmap: {} - passes (platform dependent) parameters to ImageBitmap constructor
};
var ImageLoader = {
  dataType: null,
  batchType: null,
  id: "image",
  module: "images",
  name: "Images",
  version: VERSION5,
  mimeTypes: MIME_TYPES,
  extensions: EXTENSIONS,
  parse: parseImage,
  // TODO: byteOffset, byteLength;
  tests: [(arrayBuffer) => Boolean(getBinaryImageMetadata(new DataView(arrayBuffer)))],
  options: DEFAULT_IMAGE_LOADER_OPTIONS
};

// ../../node_modules/.pnpm/@loaders.gl+images@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/images/dist/lib/category-api/image-format.js
var mimeTypeSupportedSync = {};
function isImageFormatSupported(mimeType) {
  if (mimeTypeSupportedSync[mimeType] === void 0) {
    const supported = isBrowser ? checkBrowserImageFormatSupport(mimeType) : checkNodeImageFormatSupport(mimeType);
    mimeTypeSupportedSync[mimeType] = supported;
  }
  return mimeTypeSupportedSync[mimeType];
}
function checkNodeImageFormatSupport(mimeType) {
  const NODE_FORMAT_SUPPORT = ["image/png", "image/jpeg", "image/gif"];
  const imageFormatsNode = globalThis.loaders?.imageFormatsNode || NODE_FORMAT_SUPPORT;
  const parseImageNode2 = globalThis.loaders?.parseImageNode;
  return Boolean(parseImageNode2) && imageFormatsNode.includes(mimeType);
}
function checkBrowserImageFormatSupport(mimeType) {
  switch (mimeType) {
    case "image/avif":
    case "image/webp":
      return testBrowserImageFormatSupport(mimeType);
    default:
      return true;
  }
}
function testBrowserImageFormatSupport(mimeType) {
  try {
    const element = document.createElement("canvas");
    const dataURL = element.toDataURL(mimeType);
    return dataURL.indexOf(`data:${mimeType}`) === 0;
  } catch {
    return false;
  }
}

// ../../node_modules/.pnpm/@loaders.gl+gltf@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/gltf/dist/lib/utils/assert.js
function assert4(condition, message) {
  if (!condition) {
    throw new Error(message || "assert failed: gltf");
  }
}

// ../../node_modules/.pnpm/@loaders.gl+gltf@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/gltf/dist/lib/gltf-utils/gltf-constants.js
var COMPONENTS = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var BYTES = {
  5120: 1,
  // BYTE
  5121: 1,
  // UNSIGNED_BYTE
  5122: 2,
  // SHORT
  5123: 2,
  // UNSIGNED_SHORT
  5125: 4,
  // UNSIGNED_INT
  5126: 4
  // FLOAT
};

// ../../node_modules/.pnpm/@loaders.gl+gltf@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/gltf/dist/lib/gltf-utils/gltf-utils.js
var TYPES = ["SCALAR", "VEC2", "VEC3", "VEC4"];
var ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT = [
  [Int8Array, 5120],
  [Uint8Array, 5121],
  [Int16Array, 5122],
  [Uint16Array, 5123],
  [Uint32Array, 5125],
  [Float32Array, 5126],
  [Float64Array, 5130]
];
var ARRAY_TO_COMPONENT_TYPE = new Map(ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT);
var ATTRIBUTE_TYPE_TO_COMPONENTS = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE = {
  5120: 1,
  5121: 1,
  5122: 2,
  5123: 2,
  5125: 4,
  5126: 4
};
var ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
function getAccessorTypeFromSize(size) {
  const type = TYPES[size - 1];
  return type || TYPES[0];
}
function getComponentTypeFromArray(typedArray) {
  const componentType = ARRAY_TO_COMPONENT_TYPE.get(typedArray.constructor);
  if (!componentType) {
    throw new Error("Illegal typed array");
  }
  return componentType;
}
function getAccessorArrayTypeAndLength(accessor, bufferView) {
  const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];
  const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];
  const bytesPerComponent = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[accessor.componentType];
  const length = accessor.count * components;
  const byteLength = accessor.count * components * bytesPerComponent;
  assert4(byteLength >= 0 && byteLength <= bufferView.byteLength);
  const componentByteSize = BYTES[accessor.componentType];
  const numberOfComponentsInElement = COMPONENTS[accessor.type];
  return { ArrayType, length, byteLength, componentByteSize, numberOfComponentsInElement };
}

// ../../node_modules/.pnpm/@loaders.gl+gltf@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/gltf/dist/lib/gltf-utils/get-typed-array.js
function getTypedArrayForBufferView(json, buffers, bufferViewIndex) {
  const bufferView = json.bufferViews[bufferViewIndex];
  assert4(bufferView);
  const bufferIndex = bufferView.buffer;
  const binChunk = buffers[bufferIndex];
  assert4(binChunk);
  const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;
  return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);
}
function getTypedArrayForAccessor(json, buffers, accessor) {
  const gltfAccessor = typeof accessor === "number" ? json.accessors?.[accessor] : accessor;
  if (!gltfAccessor) {
    throw new Error(`No gltf accessor ${JSON.stringify(accessor)}`);
  }
  const bufferView = json.bufferViews?.[gltfAccessor.bufferView || 0];
  if (!bufferView) {
    throw new Error(`No gltf buffer view for accessor ${bufferView}`);
  }
  const { arrayBuffer, byteOffset: bufferByteOffset } = buffers[bufferView.buffer];
  const byteOffset = (bufferByteOffset || 0) + (gltfAccessor.byteOffset || 0) + (bufferView.byteOffset || 0);
  const { ArrayType, length, componentByteSize, numberOfComponentsInElement } = getAccessorArrayTypeAndLength(gltfAccessor, bufferView);
  const elementByteSize = componentByteSize * numberOfComponentsInElement;
  const elementAddressScale = bufferView.byteStride || elementByteSize;
  if (typeof bufferView.byteStride === "undefined" || bufferView.byteStride === elementByteSize) {
    const result2 = new ArrayType(arrayBuffer, byteOffset, length);
    return result2;
  }
  const result = new ArrayType(length);
  for (let i = 0; i < gltfAccessor.count; i++) {
    const values = new ArrayType(arrayBuffer, byteOffset + i * elementAddressScale, numberOfComponentsInElement);
    result.set(values, i * numberOfComponentsInElement);
  }
  return result;
}

// ../../node_modules/.pnpm/@loaders.gl+gltf@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/gltf/dist/lib/api/gltf-scenegraph.js
function makeDefaultGLTFJson() {
  return {
    asset: {
      version: "2.0",
      generator: "loaders.gl"
    },
    buffers: [],
    extensions: {},
    extensionsRequired: [],
    extensionsUsed: []
  };
}
var GLTFScenegraph = class {
  // internal
  gltf;
  sourceBuffers;
  byteLength;
  // TODO - why is this not GLTFWithBuffers - what happens to images?
  constructor(gltf) {
    this.gltf = {
      json: gltf?.json || makeDefaultGLTFJson(),
      buffers: gltf?.buffers || [],
      images: gltf?.images || []
    };
    this.sourceBuffers = [];
    this.byteLength = 0;
    if (this.gltf.buffers && this.gltf.buffers[0]) {
      this.byteLength = this.gltf.buffers[0].byteLength;
      this.sourceBuffers = [this.gltf.buffers[0]];
    }
  }
  // Accessors
  get json() {
    return this.gltf.json;
  }
  getApplicationData(key) {
    const data = this.json[key];
    return data;
  }
  getExtraData(key) {
    const extras = this.json.extras || {};
    return extras[key];
  }
  hasExtension(extensionName) {
    const isUsedExtension = this.getUsedExtensions().find((name12) => name12 === extensionName);
    const isRequiredExtension = this.getRequiredExtensions().find((name12) => name12 === extensionName);
    return typeof isUsedExtension === "string" || typeof isRequiredExtension === "string";
  }
  getExtension(extensionName) {
    const isExtension = this.getUsedExtensions().find((name12) => name12 === extensionName);
    const extensions = this.json.extensions || {};
    return isExtension ? extensions[extensionName] : null;
  }
  getRequiredExtension(extensionName) {
    const isRequired = this.getRequiredExtensions().find((name12) => name12 === extensionName);
    return isRequired ? this.getExtension(extensionName) : null;
  }
  getRequiredExtensions() {
    return this.json.extensionsRequired || [];
  }
  getUsedExtensions() {
    return this.json.extensionsUsed || [];
  }
  getRemovedExtensions() {
    return this.json.extensionsRemoved || [];
  }
  getObjectExtension(object, extensionName) {
    const extensions = object.extensions || {};
    return extensions[extensionName];
  }
  getScene(index) {
    return this.getObject("scenes", index);
  }
  getNode(index) {
    return this.getObject("nodes", index);
  }
  getSkin(index) {
    return this.getObject("skins", index);
  }
  getMesh(index) {
    return this.getObject("meshes", index);
  }
  getMaterial(index) {
    return this.getObject("materials", index);
  }
  getAccessor(index) {
    return this.getObject("accessors", index);
  }
  // getCamera(index: number): object | null {
  //   return null; // TODO: fix thi: object  as null;
  // }
  getTexture(index) {
    return this.getObject("textures", index);
  }
  getSampler(index) {
    return this.getObject("samplers", index);
  }
  getImage(index) {
    return this.getObject("images", index);
  }
  getBufferView(index) {
    return this.getObject("bufferViews", index);
  }
  getBuffer(index) {
    return this.getObject("buffers", index);
  }
  getObject(array, index) {
    if (typeof index === "object") {
      return index;
    }
    const object = this.json[array] && this.json[array][index];
    if (!object) {
      throw new Error(`glTF file error: Could not find ${array}[${index}]`);
    }
    return object;
  }
  /**
   * Accepts buffer view index or buffer view object
   * @returns a `Uint8Array`
   */
  getTypedArrayForBufferView(bufferView) {
    bufferView = this.getBufferView(bufferView);
    const bufferIndex = bufferView.buffer;
    const binChunk = this.gltf.buffers[bufferIndex];
    assert4(binChunk);
    const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;
    return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);
  }
  /** Accepts accessor index or accessor object
   * @returns a typed array with type that matches the types
   */
  getTypedArrayForAccessor(accessor) {
    const gltfAccessor = this.getAccessor(accessor);
    return getTypedArrayForAccessor(this.gltf.json, this.gltf.buffers, gltfAccessor);
  }
  /** accepts accessor index or accessor object
   * returns a `Uint8Array`
   */
  getTypedArrayForImageData(image) {
    image = this.getAccessor(image);
    const bufferView = this.getBufferView(image.bufferView);
    const buffer = this.getBuffer(bufferView.buffer);
    const arrayBuffer = buffer.data;
    const byteOffset = bufferView.byteOffset || 0;
    return new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);
  }
  // MODIFERS
  /**
   * Add an extra application-defined key to the top-level data structure
   */
  addApplicationData(key, data) {
    this.json[key] = data;
    return this;
  }
  /**
   * `extras` - Standard GLTF field for storing application specific data
   */
  addExtraData(key, data) {
    this.json.extras = this.json.extras || {};
    this.json.extras[key] = data;
    return this;
  }
  addObjectExtension(object, extensionName, data) {
    object.extensions = object.extensions || {};
    object.extensions[extensionName] = data;
    this.registerUsedExtension(extensionName);
    return this;
  }
  setObjectExtension(object, extensionName, data) {
    const extensions = object.extensions || {};
    extensions[extensionName] = data;
  }
  removeObjectExtension(object, extensionName) {
    const extensions = object?.extensions || {};
    if (extensions[extensionName]) {
      this.json.extensionsRemoved = this.json.extensionsRemoved || [];
      const extensionsRemoved = this.json.extensionsRemoved;
      if (!extensionsRemoved.includes(extensionName)) {
        extensionsRemoved.push(extensionName);
      }
    }
    delete extensions[extensionName];
  }
  /**
   * Add to standard GLTF top level extension object, mark as used
   */
  addExtension(extensionName, extensionData = {}) {
    assert4(extensionData);
    this.json.extensions = this.json.extensions || {};
    this.json.extensions[extensionName] = extensionData;
    this.registerUsedExtension(extensionName);
    return extensionData;
  }
  /**
   * Standard GLTF top level extension object, mark as used and required
   */
  addRequiredExtension(extensionName, extensionData = {}) {
    assert4(extensionData);
    this.addExtension(extensionName, extensionData);
    this.registerRequiredExtension(extensionName);
    return extensionData;
  }
  /**
   * Add extensionName to list of used extensions
   */
  registerUsedExtension(extensionName) {
    this.json.extensionsUsed = this.json.extensionsUsed || [];
    if (!this.json.extensionsUsed.find((ext) => ext === extensionName)) {
      this.json.extensionsUsed.push(extensionName);
    }
  }
  /**
   * Add extensionName to list of required extensions
   */
  registerRequiredExtension(extensionName) {
    this.registerUsedExtension(extensionName);
    this.json.extensionsRequired = this.json.extensionsRequired || [];
    if (!this.json.extensionsRequired.find((ext) => ext === extensionName)) {
      this.json.extensionsRequired.push(extensionName);
    }
  }
  /**
   * Removes an extension from the top-level list
   */
  removeExtension(extensionName) {
    if (this.json.extensions?.[extensionName]) {
      this.json.extensionsRemoved = this.json.extensionsRemoved || [];
      const extensionsRemoved = this.json.extensionsRemoved;
      if (!extensionsRemoved.includes(extensionName)) {
        extensionsRemoved.push(extensionName);
      }
    }
    if (this.json.extensions) {
      delete this.json.extensions[extensionName];
    }
    if (this.json.extensionsRequired) {
      this._removeStringFromArray(this.json.extensionsRequired, extensionName);
    }
    if (this.json.extensionsUsed) {
      this._removeStringFromArray(this.json.extensionsUsed, extensionName);
    }
  }
  /**
   *  Set default scene which is to be displayed at load time
   */
  setDefaultScene(sceneIndex) {
    this.json.scene = sceneIndex;
  }
  /**
   * @todo: add more properties for scene initialization:
   *   name`, `extensions`, `extras`
   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-scene
   */
  addScene(scene) {
    const { nodeIndices } = scene;
    this.json.scenes = this.json.scenes || [];
    this.json.scenes.push({ nodes: nodeIndices });
    return this.json.scenes.length - 1;
  }
  /**
   * @todo: add more properties for node initialization:
   *   `name`, `extensions`, `extras`, `camera`, `children`, `skin`, `rotation`, `scale`, `translation`, `weights`
   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#node
   */
  addNode(node) {
    const { meshIndex, matrix } = node;
    this.json.nodes = this.json.nodes || [];
    const nodeData = { mesh: meshIndex };
    if (matrix) {
      nodeData.matrix = matrix;
    }
    this.json.nodes.push(nodeData);
    return this.json.nodes.length - 1;
  }
  /** Adds a mesh to the json part */
  addMesh(mesh) {
    const { attributes, indices, material, mode = 4 } = mesh;
    const accessors = this._addAttributes(attributes);
    const glTFMesh = {
      primitives: [
        {
          attributes: accessors,
          mode
        }
      ]
    };
    if (indices) {
      const indicesAccessor = this._addIndices(indices);
      glTFMesh.primitives[0].indices = indicesAccessor;
    }
    if (Number.isFinite(material)) {
      glTFMesh.primitives[0].material = material;
    }
    this.json.meshes = this.json.meshes || [];
    this.json.meshes.push(glTFMesh);
    return this.json.meshes.length - 1;
  }
  addPointCloud(attributes) {
    const accessorIndices = this._addAttributes(attributes);
    const glTFMesh = {
      primitives: [
        {
          attributes: accessorIndices,
          mode: 0
          // GL.POINTS
        }
      ]
    };
    this.json.meshes = this.json.meshes || [];
    this.json.meshes.push(glTFMesh);
    return this.json.meshes.length - 1;
  }
  /**
   * Adds a binary image. Builds glTF "JSON metadata" and saves buffer reference
   * Buffer will be copied into BIN chunk during "pack"
   * Currently encodes as glTF image
   * @param imageData
   * @param mimeType
   */
  addImage(imageData, mimeTypeOpt) {
    const metadata = getBinaryImageMetadata(imageData);
    const mimeType = mimeTypeOpt || metadata?.mimeType;
    const bufferViewIndex = this.addBufferView(imageData);
    const glTFImage = {
      bufferView: bufferViewIndex,
      mimeType
    };
    this.json.images = this.json.images || [];
    this.json.images.push(glTFImage);
    return this.json.images.length - 1;
  }
  /**
   * Add one untyped source buffer, create a matching glTF `bufferView`, and return its index
   * @param buffer
   */
  addBufferView(buffer, bufferIndex = 0, byteOffset = this.byteLength) {
    const byteLength = buffer.byteLength;
    assert4(Number.isFinite(byteLength));
    this.sourceBuffers = this.sourceBuffers || [];
    this.sourceBuffers.push(buffer);
    const glTFBufferView = {
      buffer: bufferIndex,
      // Write offset from the start of the binary body
      byteOffset,
      byteLength
    };
    this.byteLength += padToNBytes(byteLength, 4);
    this.json.bufferViews = this.json.bufferViews || [];
    this.json.bufferViews.push(glTFBufferView);
    return this.json.bufferViews.length - 1;
  }
  /**
   * Adds an accessor to a bufferView
   * @param bufferViewIndex
   * @param accessor
   */
  addAccessor(bufferViewIndex, accessor) {
    const glTFAccessor = {
      bufferView: bufferViewIndex,
      // @ts-ignore
      type: getAccessorTypeFromSize(accessor.size),
      // @ts-ignore
      componentType: accessor.componentType,
      // @ts-ignore
      count: accessor.count,
      // @ts-ignore
      max: accessor.max,
      // @ts-ignore
      min: accessor.min
    };
    this.json.accessors = this.json.accessors || [];
    this.json.accessors.push(glTFAccessor);
    return this.json.accessors.length - 1;
  }
  /**
   * Add a binary buffer. Builds glTF "JSON metadata" and saves buffer reference
   * Buffer will be copied into BIN chunk during "pack"
   * Currently encodes buffers as glTF accessors, but this could be optimized
   * @param sourceBuffer
   * @param accessor
   */
  addBinaryBuffer(sourceBuffer, accessor = { size: 3 }) {
    const bufferViewIndex = this.addBufferView(sourceBuffer);
    let minMax = { min: accessor.min, max: accessor.max };
    if (!minMax.min || !minMax.max) {
      minMax = this._getAccessorMinMax(sourceBuffer, accessor.size);
    }
    const accessorDefaults = {
      // @ts-ignore
      size: accessor.size,
      componentType: getComponentTypeFromArray(sourceBuffer),
      // @ts-ignore
      count: Math.round(sourceBuffer.length / accessor.size),
      min: minMax.min,
      max: minMax.max
    };
    return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));
  }
  /**
   * Adds a texture to the json part
   * @todo: add more properties for texture initialization
   * `sampler`, `name`, `extensions`, `extras`
   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture
   */
  addTexture(texture) {
    const { imageIndex } = texture;
    const glTFTexture = {
      source: imageIndex
    };
    this.json.textures = this.json.textures || [];
    this.json.textures.push(glTFTexture);
    return this.json.textures.length - 1;
  }
  /** Adds a material to the json part */
  addMaterial(pbrMaterialInfo) {
    this.json.materials = this.json.materials || [];
    this.json.materials.push(pbrMaterialInfo);
    return this.json.materials.length - 1;
  }
  /** Pack the binary chunk */
  createBinaryChunk() {
    const totalByteLength = this.byteLength;
    const arrayBuffer = new ArrayBuffer(totalByteLength);
    const targetArray = new Uint8Array(arrayBuffer);
    let dstByteOffset = 0;
    for (const sourceBuffer of this.sourceBuffers || []) {
      dstByteOffset = copyToArray(sourceBuffer, targetArray, dstByteOffset);
    }
    if (this.json?.buffers?.[0]) {
      this.json.buffers[0].byteLength = totalByteLength;
    } else {
      this.json.buffers = [{ byteLength: totalByteLength }];
    }
    this.gltf.binary = arrayBuffer;
    this.sourceBuffers = [arrayBuffer];
    this.gltf.buffers = [{ arrayBuffer, byteOffset: 0, byteLength: arrayBuffer.byteLength }];
  }
  // PRIVATE
  _removeStringFromArray(array, string) {
    let found = true;
    while (found) {
      const index = array.indexOf(string);
      if (index > -1) {
        array.splice(index, 1);
      } else {
        found = false;
      }
    }
  }
  /**
   * Add attributes to buffers and create `attributes` object which is part of `mesh`
   */
  _addAttributes(attributes = {}) {
    const result = {};
    for (const attributeKey in attributes) {
      const attributeData = attributes[attributeKey];
      const attrName = this._getGltfAttributeName(attributeKey);
      const accessor = this.addBinaryBuffer(attributeData.value, attributeData);
      result[attrName] = accessor;
    }
    return result;
  }
  /**
   * Add indices to buffers
   */
  _addIndices(indices) {
    return this.addBinaryBuffer(indices, { size: 1 });
  }
  /**
   * Deduce gltf specific attribue name from input attribute name
   */
  _getGltfAttributeName(attributeName) {
    switch (attributeName.toLowerCase()) {
      case "position":
      case "positions":
      case "vertices":
        return "POSITION";
      case "normal":
      case "normals":
        return "NORMAL";
      case "color":
      case "colors":
        return "COLOR_0";
      case "texcoord":
      case "texcoords":
        return "TEXCOORD_0";
      default:
        return attributeName;
    }
  }
  /**
   * Calculate `min` and `max` arrays of accessor according to spec:
   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-accessor
   */
  _getAccessorMinMax(buffer, size) {
    const result = { min: null, max: null };
    if (buffer.length < size) {
      return result;
    }
    result.min = [];
    result.max = [];
    const initValues = buffer.subarray(0, size);
    for (const value of initValues) {
      result.min.push(value);
      result.max.push(value);
    }
    for (let index = size; index < buffer.length; index += size) {
      for (let componentIndex = 0; componentIndex < size; componentIndex++) {
        result.min[0 + componentIndex] = Math.min(
          // @ts-ignore
          result.min[0 + componentIndex],
          buffer[index + componentIndex]
        );
        result.max[0 + componentIndex] = Math.max(
          // @ts-ignore
          result.max[0 + componentIndex],
          buffer[index + componentIndex]
        );
      }
    }
    return result;
  }
};

// ../../node_modules/.pnpm/@loaders.gl+gltf@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/gltf/dist/lib/extensions/utils/3d-tiles-utils.js
function emod(n) {
  return (n % 1 + 1) % 1;
}
var ATTRIBUTE_TYPE_TO_COMPONENTS2 = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16,
  BOOLEAN: 1,
  STRING: 1,
  ENUM: 1
};
var ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY2 = {
  INT8: Int8Array,
  UINT8: Uint8Array,
  INT16: Int16Array,
  UINT16: Uint16Array,
  INT32: Int32Array,
  UINT32: Uint32Array,
  INT64: BigInt64Array,
  UINT64: BigUint64Array,
  FLOAT32: Float32Array,
  FLOAT64: Float64Array
};
var ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE2 = {
  INT8: 1,
  UINT8: 1,
  INT16: 2,
  UINT16: 2,
  INT32: 4,
  UINT32: 4,
  INT64: 8,
  UINT64: 8,
  FLOAT32: 4,
  FLOAT64: 8
};
function getArrayElementByteSize(attributeType, componentType) {
  return ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE2[componentType] * ATTRIBUTE_TYPE_TO_COMPONENTS2[attributeType];
}
function getOffsetsForProperty(scenegraph, bufferViewIndex, offsetType, numberOfElements) {
  if (offsetType !== "UINT8" && offsetType !== "UINT16" && offsetType !== "UINT32" && offsetType !== "UINT64") {
    return null;
  }
  const arrayOffsetsBytes = scenegraph.getTypedArrayForBufferView(bufferViewIndex);
  const arrayOffsets = convertRawBufferToMetadataArray(
    arrayOffsetsBytes,
    "SCALAR",
    // offsets consist of ONE component
    offsetType,
    numberOfElements + 1
    // The number of offsets is equal to the property table `count` plus one.
  );
  if (arrayOffsets instanceof BigInt64Array || arrayOffsets instanceof BigUint64Array) {
    return null;
  }
  return arrayOffsets;
}
function convertRawBufferToMetadataArray(data, attributeType, componentType, elementCount = 1) {
  const numberOfComponents = ATTRIBUTE_TYPE_TO_COMPONENTS2[attributeType];
  const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY2[componentType];
  const size = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE2[componentType];
  const length = elementCount * numberOfComponents;
  const byteLength = length * size;
  let buffer = data.buffer;
  let offset = data.byteOffset;
  if (offset % size !== 0) {
    const bufferArray = new Uint8Array(buffer);
    buffer = bufferArray.slice(offset, offset + byteLength).buffer;
    offset = 0;
  }
  return new ArrayType(buffer, offset, length);
}
function getPrimitiveTextureData(scenegraph, textureInfo, primitive) {
  const texCoordAccessorKey = `TEXCOORD_${textureInfo.texCoord || 0}`;
  const texCoordAccessorIndex = primitive.attributes[texCoordAccessorKey];
  const textureCoordinates = scenegraph.getTypedArrayForAccessor(texCoordAccessorIndex);
  const json = scenegraph.gltf.json;
  const textureIndex = textureInfo.index;
  const imageIndex = json.textures?.[textureIndex]?.source;
  if (typeof imageIndex !== "undefined") {
    const mimeType = json.images?.[imageIndex]?.mimeType;
    const parsedImage = scenegraph.gltf.images?.[imageIndex];
    if (parsedImage && typeof parsedImage.width !== "undefined") {
      const textureData = [];
      for (let index = 0; index < textureCoordinates.length; index += 2) {
        const value = getImageValueByCoordinates(parsedImage, mimeType, textureCoordinates, index, textureInfo.channels);
        textureData.push(value);
      }
      return textureData;
    }
  }
  return [];
}
function primitivePropertyDataToAttributes(scenegraph, attributeName, propertyData, featureTable, primitive) {
  if (!propertyData?.length) {
    return;
  }
  const featureIndices = [];
  for (const texelData of propertyData) {
    let index = featureTable.findIndex((item) => item === texelData);
    if (index === -1) {
      index = featureTable.push(texelData) - 1;
    }
    featureIndices.push(index);
  }
  const typedArray = new Uint32Array(featureIndices);
  const bufferIndex = scenegraph.gltf.buffers.push({
    arrayBuffer: typedArray.buffer,
    byteOffset: typedArray.byteOffset,
    byteLength: typedArray.byteLength
  }) - 1;
  const bufferViewIndex = scenegraph.addBufferView(typedArray, bufferIndex, 0);
  const accessorIndex = scenegraph.addAccessor(bufferViewIndex, {
    size: 1,
    componentType: getComponentTypeFromArray(typedArray),
    count: typedArray.length
  });
  primitive.attributes[attributeName] = accessorIndex;
}
function getImageValueByCoordinates(parsedImage, mimeType, textureCoordinates, index, channels = [0]) {
  const CHANNELS_MAP = {
    r: { offset: 0, shift: 0 },
    g: { offset: 1, shift: 8 },
    b: { offset: 2, shift: 16 },
    a: { offset: 3, shift: 24 }
  };
  const u = textureCoordinates[index];
  const v = textureCoordinates[index + 1];
  let components = 1;
  if (mimeType && (mimeType.indexOf("image/jpeg") !== -1 || mimeType.indexOf("image/png") !== -1))
    components = 4;
  const offset = coordinatesToOffset(u, v, parsedImage, components);
  let value = 0;
  for (const c2 of channels) {
    const map = typeof c2 === "number" ? Object.values(CHANNELS_MAP)[c2] : CHANNELS_MAP[c2];
    const imageOffset = offset + map.offset;
    const imageData = getImageData(parsedImage);
    if (imageData.data.length <= imageOffset) {
      throw new Error(`${imageData.data.length} <= ${imageOffset}`);
    }
    const imageValue = imageData.data[imageOffset];
    value |= imageValue << map.shift;
  }
  return value;
}
function coordinatesToOffset(u, v, parsedImage, componentsCount = 1) {
  const w = parsedImage.width;
  const iX = emod(u) * (w - 1);
  const indX = Math.round(iX);
  const h = parsedImage.height;
  const iY = emod(v) * (h - 1);
  const indY = Math.round(iY);
  const components = parsedImage.components ? parsedImage.components : componentsCount;
  const offset = (indY * w + indX) * components;
  return offset;
}
function parseVariableLengthArrayNumeric(valuesData, numberOfElements, arrayOffsets, valuesDataBytesLength, valueSize) {
  const attributeValueArray = [];
  for (let index = 0; index < numberOfElements; index++) {
    const arrayOffset = arrayOffsets[index];
    const arrayByteSize = arrayOffsets[index + 1] - arrayOffsets[index];
    if (arrayByteSize + arrayOffset > valuesDataBytesLength) {
      break;
    }
    const typedArrayOffset = arrayOffset / valueSize;
    const elementCount = arrayByteSize / valueSize;
    attributeValueArray.push(valuesData.slice(typedArrayOffset, typedArrayOffset + elementCount));
  }
  return attributeValueArray;
}
function parseFixedLengthArrayNumeric(valuesData, numberOfElements, arrayCount) {
  const attributeValueArray = [];
  for (let index = 0; index < numberOfElements; index++) {
    const elementOffset = index * arrayCount;
    attributeValueArray.push(valuesData.slice(elementOffset, elementOffset + arrayCount));
  }
  return attributeValueArray;
}
function getPropertyDataString(numberOfElements, valuesDataBytes, arrayOffsets, stringOffsets) {
  if (arrayOffsets) {
    throw new Error("Not implemented - arrayOffsets for strings is specified");
  }
  if (stringOffsets) {
    const stringsArray = [];
    const textDecoder = new TextDecoder("utf8");
    let stringOffset = 0;
    for (let index = 0; index < numberOfElements; index++) {
      const stringByteSize = stringOffsets[index + 1] - stringOffsets[index];
      if (stringByteSize + stringOffset <= valuesDataBytes.length) {
        const stringData = valuesDataBytes.subarray(stringOffset, stringByteSize + stringOffset);
        const stringAttribute = textDecoder.decode(stringData);
        stringsArray.push(stringAttribute);
        stringOffset += stringByteSize;
      }
    }
    return stringsArray;
  }
  return [];
}

// ../../node_modules/.pnpm/@loaders.gl+gltf@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_mesh_features.js
var EXT_MESH_FEATURES_NAME = "EXT_mesh_features";
var name = EXT_MESH_FEATURES_NAME;
async function decode(gltfData, options) {
  const scenegraph = new GLTFScenegraph(gltfData);
  decodeExtMeshFeatures(scenegraph, options);
}
function encode6(gltfData, options) {
  const scenegraph = new GLTFScenegraph(gltfData);
  encodeExtMeshFeatures(scenegraph, options);
  scenegraph.createBinaryChunk();
  return scenegraph.gltf;
}
function decodeExtMeshFeatures(scenegraph, options) {
  const json = scenegraph.gltf.json;
  if (!json.meshes) {
    return;
  }
  for (const mesh of json.meshes) {
    for (const primitive of mesh.primitives) {
      processMeshPrimitiveFeatures(scenegraph, primitive, options);
    }
  }
}
function processMeshPrimitiveFeatures(scenegraph, primitive, options) {
  if (!options?.gltf?.loadBuffers) {
    return;
  }
  const extension = primitive.extensions?.[EXT_MESH_FEATURES_NAME];
  const featureIds = extension?.featureIds;
  if (!featureIds) {
    return;
  }
  for (const featureId of featureIds) {
    let featureIdData;
    if (typeof featureId.attribute !== "undefined") {
      const accessorKey = `_FEATURE_ID_${featureId.attribute}`;
      const accessorIndex = primitive.attributes[accessorKey];
      featureIdData = scenegraph.getTypedArrayForAccessor(accessorIndex);
    } else if (typeof featureId.texture !== "undefined" && options?.gltf?.loadImages) {
      featureIdData = getPrimitiveTextureData(scenegraph, featureId.texture, primitive);
    } else {
      featureIdData = [];
    }
    featureId.data = featureIdData;
  }
}
function encodeExtMeshFeatures(scenegraph, options) {
  const meshes = scenegraph.gltf.json.meshes;
  if (!meshes) {
    return;
  }
  for (const mesh of meshes) {
    for (const primitive of mesh.primitives) {
      encodeExtMeshFeaturesForPrimitive(scenegraph, primitive);
    }
  }
}
function createExtMeshFeatures(scenegraph, primitive, featureIdArray, propertyTableIndex) {
  if (!primitive.extensions) {
    primitive.extensions = {};
  }
  let extension = primitive.extensions[EXT_MESH_FEATURES_NAME];
  if (!extension) {
    extension = { featureIds: [] };
    primitive.extensions[EXT_MESH_FEATURES_NAME] = extension;
  }
  const { featureIds } = extension;
  const featureId = {
    featureCount: featureIdArray.length,
    propertyTable: propertyTableIndex,
    data: featureIdArray
  };
  featureIds.push(featureId);
  scenegraph.addObjectExtension(primitive, EXT_MESH_FEATURES_NAME, extension);
}
function encodeExtMeshFeaturesForPrimitive(scenegraph, primitive) {
  const extension = primitive.extensions?.[EXT_MESH_FEATURES_NAME];
  if (!extension) {
    return;
  }
  const featureIds = extension.featureIds;
  featureIds.forEach((featureId, elementIndex) => {
    if (featureId.data) {
      const { accessorKey, index } = createAccessorKey(primitive.attributes);
      const typedArray = new Uint32Array(featureId.data);
      featureIds[elementIndex] = {
        featureCount: typedArray.length,
        propertyTable: featureId.propertyTable,
        attribute: index
      };
      scenegraph.gltf.buffers.push({
        arrayBuffer: typedArray.buffer,
        byteOffset: typedArray.byteOffset,
        byteLength: typedArray.byteLength
      });
      const bufferViewIndex = scenegraph.addBufferView(typedArray);
      const accessorIndex = scenegraph.addAccessor(bufferViewIndex, {
        size: 1,
        componentType: getComponentTypeFromArray(typedArray),
        count: typedArray.length
      });
      primitive.attributes[accessorKey] = accessorIndex;
    }
  });
}
function createAccessorKey(attributes) {
  const prefix = "_FEATURE_ID_";
  const attrs = Object.keys(attributes).filter((item) => item.indexOf(prefix) === 0);
  let max = -1;
  for (const a2 of attrs) {
    const n = Number(a2.substring(prefix.length));
    if (n > max) {
      max = n;
    }
  }
  max++;
  const accessorKey = `${prefix}${max}`;
  return { accessorKey, index: max };
}

// ../../node_modules/.pnpm/@loaders.gl+gltf@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_structural_metadata.js
var EXT_structural_metadata_exports = {};
__export(EXT_structural_metadata_exports, {
  createExtStructuralMetadata: () => createExtStructuralMetadata,
  decode: () => decode2,
  encode: () => encode7,
  name: () => name2
});
var EXT_STRUCTURAL_METADATA_NAME = "EXT_structural_metadata";
var name2 = EXT_STRUCTURAL_METADATA_NAME;
async function decode2(gltfData, options) {
  const scenegraph = new GLTFScenegraph(gltfData);
  decodeExtStructuralMetadata(scenegraph, options);
}
function encode7(gltfData, options) {
  const scenegraph = new GLTFScenegraph(gltfData);
  encodeExtStructuralMetadata(scenegraph, options);
  scenegraph.createBinaryChunk();
  return scenegraph.gltf;
}
function decodeExtStructuralMetadata(scenegraph, options) {
  if (!options.gltf?.loadBuffers) {
    return;
  }
  const extension = scenegraph.getExtension(EXT_STRUCTURAL_METADATA_NAME);
  if (!extension) {
    return;
  }
  if (options.gltf?.loadImages) {
    decodePropertyTextures(scenegraph, extension);
  }
  decodePropertyTables(scenegraph, extension);
}
function decodePropertyTextures(scenegraph, extension) {
  const propertyTextures = extension.propertyTextures;
  const json = scenegraph.gltf.json;
  if (propertyTextures && json.meshes) {
    for (const mesh of json.meshes) {
      for (const primitive of mesh.primitives) {
        processPrimitivePropertyTextures(scenegraph, propertyTextures, primitive, extension);
      }
    }
  }
}
function decodePropertyTables(scenegraph, extension) {
  const schema = extension.schema;
  if (!schema) {
    return;
  }
  const schemaClasses = schema.classes;
  const propertyTables = extension.propertyTables;
  if (schemaClasses && propertyTables) {
    for (const schemaName in schemaClasses) {
      const propertyTable = findPropertyTableByClass(propertyTables, schemaName);
      if (propertyTable) {
        processPropertyTable(scenegraph, schema, propertyTable);
      }
    }
  }
}
function findPropertyTableByClass(propertyTables, schemaClassName) {
  for (const propertyTable of propertyTables) {
    if (propertyTable.class === schemaClassName) {
      return propertyTable;
    }
  }
  return null;
}
function processPrimitivePropertyTextures(scenegraph, propertyTextures, primitive, extension) {
  if (!propertyTextures) {
    return;
  }
  const primitiveExtension = primitive.extensions?.[EXT_STRUCTURAL_METADATA_NAME];
  const primitivePropertyTextureIndices = primitiveExtension?.propertyTextures;
  if (!primitivePropertyTextureIndices) {
    return;
  }
  for (const primitivePropertyTextureIndex of primitivePropertyTextureIndices) {
    const propertyTexture = propertyTextures[primitivePropertyTextureIndex];
    processPrimitivePropertyTexture(scenegraph, propertyTexture, primitive, extension);
  }
}
function processPrimitivePropertyTexture(scenegraph, propertyTexture, primitive, extension) {
  if (!propertyTexture.properties) {
    return;
  }
  if (!extension.dataAttributeNames) {
    extension.dataAttributeNames = [];
  }
  const className = propertyTexture.class;
  for (const propertyName in propertyTexture.properties) {
    const attributeName = `${className}_${propertyName}`;
    const textureInfoTopLevel = propertyTexture.properties?.[propertyName];
    if (!textureInfoTopLevel) {
      continue;
    }
    if (!textureInfoTopLevel.data) {
      textureInfoTopLevel.data = [];
    }
    const featureTextureTable = textureInfoTopLevel.data;
    const propertyData = getPrimitiveTextureData(scenegraph, textureInfoTopLevel, primitive);
    if (propertyData === null) {
      continue;
    }
    primitivePropertyDataToAttributes(scenegraph, attributeName, propertyData, featureTextureTable, primitive);
    textureInfoTopLevel.data = featureTextureTable;
    extension.dataAttributeNames.push(attributeName);
  }
}
function processPropertyTable(scenegraph, schema, propertyTable) {
  const schemaClass = schema.classes?.[propertyTable.class];
  if (!schemaClass) {
    throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${propertyTable.class}`);
  }
  const numberOfElements = propertyTable.count;
  for (const propertyName in schemaClass.properties) {
    const classProperty = schemaClass.properties[propertyName];
    const propertyTableProperty = propertyTable.properties?.[propertyName];
    if (propertyTableProperty) {
      const data = getPropertyDataFromBinarySource(scenegraph, schema, classProperty, numberOfElements, propertyTableProperty);
      propertyTableProperty.data = data;
    }
  }
}
function getPropertyDataFromBinarySource(scenegraph, schema, classProperty, numberOfElements, propertyTableProperty) {
  let data = [];
  const valuesBufferView = propertyTableProperty.values;
  const valuesDataBytes = scenegraph.getTypedArrayForBufferView(valuesBufferView);
  const arrayOffsets = getArrayOffsetsForProperty(scenegraph, classProperty, propertyTableProperty, numberOfElements);
  const stringOffsets = getStringOffsetsForProperty(scenegraph, propertyTableProperty, numberOfElements);
  switch (classProperty.type) {
    case "SCALAR":
    case "VEC2":
    case "VEC3":
    case "VEC4":
    case "MAT2":
    case "MAT3":
    case "MAT4": {
      data = getPropertyDataNumeric(classProperty, numberOfElements, valuesDataBytes, arrayOffsets);
      break;
    }
    case "BOOLEAN": {
      throw new Error(`Not implemented - classProperty.type=${classProperty.type}`);
    }
    case "STRING": {
      data = getPropertyDataString(numberOfElements, valuesDataBytes, arrayOffsets, stringOffsets);
      break;
    }
    case "ENUM": {
      data = getPropertyDataENUM(schema, classProperty, numberOfElements, valuesDataBytes, arrayOffsets);
      break;
    }
    default:
      throw new Error(`Unknown classProperty type ${classProperty.type}`);
  }
  return data;
}
function getArrayOffsetsForProperty(scenegraph, classProperty, propertyTableProperty, numberOfElements) {
  if (classProperty.array && // `count` is a number of array elements. May only be defined when `array` is true.
  // If `count` is NOT defined, it's a VARIABLE-length array
  typeof classProperty.count === "undefined" && // `arrayOffsets` is an index of the buffer view containing offsets for variable-length arrays.
  typeof propertyTableProperty.arrayOffsets !== "undefined") {
    return getOffsetsForProperty(scenegraph, propertyTableProperty.arrayOffsets, propertyTableProperty.arrayOffsetType || "UINT32", numberOfElements);
  }
  return null;
}
function getStringOffsetsForProperty(scenegraph, propertyTableProperty, numberOfElements) {
  if (typeof propertyTableProperty.stringOffsets !== "undefined") {
    return getOffsetsForProperty(scenegraph, propertyTableProperty.stringOffsets, propertyTableProperty.stringOffsetType || "UINT32", numberOfElements);
  }
  return null;
}
function getPropertyDataNumeric(classProperty, numberOfElements, valuesDataBytes, arrayOffsets) {
  const isArray3 = classProperty.array;
  const arrayCount = classProperty.count;
  const elementSize = getArrayElementByteSize(classProperty.type, classProperty.componentType);
  const elementCount = valuesDataBytes.byteLength / elementSize;
  let valuesData;
  if (classProperty.componentType) {
    valuesData = convertRawBufferToMetadataArray(
      valuesDataBytes,
      classProperty.type,
      // The datatype of the element's components. Only applicable to `SCALAR`, `VECN`, and `MATN` types.
      classProperty.componentType,
      elementCount
    );
  } else {
    valuesData = valuesDataBytes;
  }
  if (isArray3) {
    if (arrayOffsets) {
      return parseVariableLengthArrayNumeric(valuesData, numberOfElements, arrayOffsets, valuesDataBytes.length, elementSize);
    }
    if (arrayCount) {
      return parseFixedLengthArrayNumeric(valuesData, numberOfElements, arrayCount);
    }
    return [];
  }
  return valuesData;
}
function getPropertyDataENUM(schema, classProperty, numberOfElements, valuesDataBytes, arrayOffsets) {
  const enumType = classProperty.enumType;
  if (!enumType) {
    throw new Error("Incorrect data in the EXT_structural_metadata extension: classProperty.enumType is not set for type ENUM");
  }
  const enumEntry = schema.enums?.[enumType];
  if (!enumEntry) {
    throw new Error(`Incorrect data in the EXT_structural_metadata extension: schema.enums does't contain ${enumType}`);
  }
  const enumValueType = enumEntry.valueType || "UINT16";
  const elementSize = getArrayElementByteSize(classProperty.type, enumValueType);
  const elementCount = valuesDataBytes.byteLength / elementSize;
  let valuesData = convertRawBufferToMetadataArray(valuesDataBytes, classProperty.type, enumValueType, elementCount);
  if (!valuesData) {
    valuesData = valuesDataBytes;
  }
  if (classProperty.array) {
    if (arrayOffsets) {
      return parseVariableLengthArrayENUM({
        valuesData,
        numberOfElements,
        arrayOffsets,
        valuesDataBytesLength: valuesDataBytes.length,
        elementSize,
        enumEntry
      });
    }
    const arrayCount = classProperty.count;
    if (arrayCount) {
      return parseFixedLengthArrayENUM(valuesData, numberOfElements, arrayCount, enumEntry);
    }
    return [];
  }
  return getEnumsArray(valuesData, 0, numberOfElements, enumEntry);
}
function parseVariableLengthArrayENUM(params2) {
  const { valuesData, numberOfElements, arrayOffsets, valuesDataBytesLength, elementSize, enumEntry } = params2;
  const attributeValueArray = [];
  for (let index = 0; index < numberOfElements; index++) {
    const arrayOffset = arrayOffsets[index];
    const arrayByteSize = arrayOffsets[index + 1] - arrayOffsets[index];
    if (arrayByteSize + arrayOffset > valuesDataBytesLength) {
      break;
    }
    const typedArrayOffset = arrayOffset / elementSize;
    const elementCount = arrayByteSize / elementSize;
    const array = getEnumsArray(valuesData, typedArrayOffset, elementCount, enumEntry);
    attributeValueArray.push(array);
  }
  return attributeValueArray;
}
function parseFixedLengthArrayENUM(valuesData, numberOfElements, arrayCount, enumEntry) {
  const attributeValueArray = [];
  for (let index = 0; index < numberOfElements; index++) {
    const elementOffset = arrayCount * index;
    const array = getEnumsArray(valuesData, elementOffset, arrayCount, enumEntry);
    attributeValueArray.push(array);
  }
  return attributeValueArray;
}
function getEnumsArray(valuesData, offset, count, enumEntry) {
  const array = [];
  for (let i = 0; i < count; i++) {
    if (valuesData instanceof BigInt64Array || valuesData instanceof BigUint64Array) {
      array.push("");
    } else {
      const value = valuesData[offset + i];
      const enumObject = getEnumByValue(enumEntry, value);
      if (enumObject) {
        array.push(enumObject.name);
      } else {
        array.push("");
      }
    }
  }
  return array;
}
function getEnumByValue(enumEntry, value) {
  for (const enumValue of enumEntry.values) {
    if (enumValue.value === value) {
      return enumValue;
    }
  }
  return null;
}
var SCHEMA_CLASS_ID_DEFAULT = "schemaClassId";
function encodeExtStructuralMetadata(scenegraph, options) {
  const extension = scenegraph.getExtension(EXT_STRUCTURAL_METADATA_NAME);
  if (!extension) {
    return;
  }
  if (extension.propertyTables) {
    for (const table of extension.propertyTables) {
      const classId = table.class;
      const schemaClass = extension.schema?.classes?.[classId];
      if (table.properties && schemaClass) {
        encodeProperties(table, schemaClass, scenegraph);
      }
    }
  }
}
function encodeProperties(table, schemaClass, scenegraph) {
  for (const propertyName in table.properties) {
    const data = table.properties[propertyName].data;
    if (data) {
      const classProperty = schemaClass.properties[propertyName];
      if (classProperty) {
        const tableProperty = createPropertyTableProperty(data, classProperty, scenegraph);
        table.properties[propertyName] = tableProperty;
      }
    }
  }
}
function createExtStructuralMetadata(scenegraph, propertyAttributes, classId = SCHEMA_CLASS_ID_DEFAULT) {
  let extension = scenegraph.getExtension(EXT_STRUCTURAL_METADATA_NAME);
  if (!extension) {
    extension = scenegraph.addExtension(EXT_STRUCTURAL_METADATA_NAME);
  }
  extension.schema = createSchema(propertyAttributes, classId, extension.schema);
  const table = createPropertyTable(propertyAttributes, classId, extension.schema);
  if (!extension.propertyTables) {
    extension.propertyTables = [];
  }
  return extension.propertyTables.push(table) - 1;
}
function createSchema(propertyAttributes, classId, schemaToUpdate) {
  const schema = schemaToUpdate ?? {
    id: "schema_id"
  };
  const schemaClass = {
    properties: {}
  };
  for (const attribute of propertyAttributes) {
    const classProperty = {
      type: attribute.elementType,
      componentType: attribute.componentType
    };
    schemaClass.properties[attribute.name] = classProperty;
  }
  schema.classes = {};
  schema.classes[classId] = schemaClass;
  return schema;
}
function createPropertyTable(propertyAttributes, classId, schema) {
  const table = {
    class: classId,
    count: 0
  };
  let count = 0;
  const schemaClass = schema.classes?.[classId];
  for (const attribute of propertyAttributes) {
    if (count === 0) {
      count = attribute.values.length;
    }
    if (count !== attribute.values.length && attribute.values.length) {
      throw new Error("Illegal values in attributes");
    }
    const classProperty = schemaClass?.properties[attribute.name];
    if (classProperty) {
      if (!table.properties) {
        table.properties = {};
      }
      table.properties[attribute.name] = { values: 0, data: attribute.values };
    }
  }
  table.count = count;
  return table;
}
function createPropertyTableProperty(values, classProperty, scenegraph) {
  const prop = { values: 0 };
  if (classProperty.type === "STRING") {
    const { stringData, stringOffsets } = createPropertyDataString(values);
    prop.stringOffsets = createBufferView(stringOffsets, scenegraph);
    prop.values = createBufferView(stringData, scenegraph);
  } else if (classProperty.type === "SCALAR" && classProperty.componentType) {
    const data = createPropertyDataScalar(values, classProperty.componentType);
    prop.values = createBufferView(data, scenegraph);
  }
  return prop;
}
var COMPONENT_TYPE_TO_ARRAY_CONSTRUCTOR = {
  INT8: Int8Array,
  UINT8: Uint8Array,
  INT16: Int16Array,
  UINT16: Uint16Array,
  INT32: Int32Array,
  UINT32: Uint32Array,
  INT64: Int32Array,
  UINT64: Uint32Array,
  FLOAT32: Float32Array,
  FLOAT64: Float64Array
};
function createPropertyDataScalar(array, componentType) {
  const numberArray = [];
  for (const value of array) {
    numberArray.push(Number(value));
  }
  const Construct = COMPONENT_TYPE_TO_ARRAY_CONSTRUCTOR[componentType];
  if (!Construct) {
    throw new Error("Illegal component type");
  }
  return new Construct(numberArray);
}
function createPropertyDataString(strings2) {
  const utf8Encode = new TextEncoder();
  const arr = [];
  let len = 0;
  for (const str of strings2) {
    const uint8Array = utf8Encode.encode(str);
    len += uint8Array.length;
    arr.push(uint8Array);
  }
  const strArray = new Uint8Array(len);
  const strOffsets = [];
  let offset = 0;
  for (const str of arr) {
    strArray.set(str, offset);
    strOffsets.push(offset);
    offset += str.length;
  }
  strOffsets.push(offset);
  const stringOffsetsTypedArray = new Uint32Array(strOffsets);
  return { stringData: strArray, stringOffsets: stringOffsetsTypedArray };
}
function createBufferView(typedArray, scenegraph) {
  scenegraph.gltf.buffers.push({
    arrayBuffer: typedArray.buffer,
    byteOffset: typedArray.byteOffset,
    byteLength: typedArray.byteLength
  });
  return scenegraph.addBufferView(typedArray);
}

// ../../node_modules/.pnpm/@loaders.gl+gltf@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/gltf/dist/lib/extensions/deprecated/EXT_feature_metadata.js
var EXT_feature_metadata_exports = {};
__export(EXT_feature_metadata_exports, {
  decode: () => decode3,
  name: () => name3
});
var EXT_FEATURE_METADATA_NAME = "EXT_feature_metadata";
var name3 = EXT_FEATURE_METADATA_NAME;
async function decode3(gltfData, options) {
  const scenegraph = new GLTFScenegraph(gltfData);
  decodeExtFeatureMetadata(scenegraph, options);
}
function decodeExtFeatureMetadata(scenegraph, options) {
  if (!options.gltf?.loadBuffers) {
    return;
  }
  const extension = scenegraph.getExtension(EXT_FEATURE_METADATA_NAME);
  if (!extension) {
    return;
  }
  if (options.gltf?.loadImages) {
    decodePropertyTextures2(scenegraph, extension);
  }
  decodePropertyTables2(scenegraph, extension);
}
function decodePropertyTextures2(scenegraph, extension) {
  const schema = extension.schema;
  if (!schema) {
    return;
  }
  const schemaClasses = schema.classes;
  const { featureTextures } = extension;
  if (schemaClasses && featureTextures) {
    for (const schemaName in schemaClasses) {
      const schemaClass = schemaClasses[schemaName];
      const featureTexture = findFeatureTextureByClass(featureTextures, schemaName);
      if (featureTexture) {
        handleFeatureTextureProperties(scenegraph, featureTexture, schemaClass);
      }
    }
  }
}
function decodePropertyTables2(scenegraph, extension) {
  const schema = extension.schema;
  if (!schema) {
    return;
  }
  const schemaClasses = schema.classes;
  const propertyTables = extension.featureTables;
  if (schemaClasses && propertyTables) {
    for (const schemaName in schemaClasses) {
      const propertyTable = findPropertyTableByClass2(propertyTables, schemaName);
      if (propertyTable) {
        processPropertyTable2(scenegraph, schema, propertyTable);
      }
    }
  }
}
function findPropertyTableByClass2(propertyTables, schemaClassName) {
  for (const propertyTableName in propertyTables) {
    const propertyTable = propertyTables[propertyTableName];
    if (propertyTable.class === schemaClassName) {
      return propertyTable;
    }
  }
  return null;
}
function findFeatureTextureByClass(featureTextures, schemaClassName) {
  for (const featureTexturesName in featureTextures) {
    const featureTable = featureTextures[featureTexturesName];
    if (featureTable.class === schemaClassName) {
      return featureTable;
    }
  }
  return null;
}
function processPropertyTable2(scenegraph, schema, propertyTable) {
  if (!propertyTable.class) {
    return;
  }
  const schemaClass = schema.classes?.[propertyTable.class];
  if (!schemaClass) {
    throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${propertyTable.class}`);
  }
  const numberOfElements = propertyTable.count;
  for (const propertyName in schemaClass.properties) {
    const classProperty = schemaClass.properties[propertyName];
    const propertyTableProperty = propertyTable.properties?.[propertyName];
    if (propertyTableProperty) {
      const data = getPropertyDataFromBinarySource2(scenegraph, schema, classProperty, numberOfElements, propertyTableProperty);
      propertyTableProperty.data = data;
    }
  }
}
function handleFeatureTextureProperties(scenegraph, featureTexture, schemaClass) {
  const attributeName = featureTexture.class;
  for (const propertyName in schemaClass.properties) {
    const featureTextureProperty = featureTexture?.properties?.[propertyName];
    if (featureTextureProperty) {
      const data = getPropertyDataFromTexture(scenegraph, featureTextureProperty, attributeName);
      featureTextureProperty.data = data;
    }
  }
}
function getPropertyDataFromBinarySource2(scenegraph, schema, classProperty, numberOfFeatures, featureTableProperty) {
  let data = [];
  const bufferView = featureTableProperty.bufferView;
  const dataArray = scenegraph.getTypedArrayForBufferView(bufferView);
  const arrayOffsets = getArrayOffsetsForProperty2(scenegraph, classProperty, featureTableProperty, numberOfFeatures);
  const stringOffsets = getStringOffsetsForProperty2(scenegraph, classProperty, featureTableProperty, numberOfFeatures);
  if (classProperty.type === "STRING" || classProperty.componentType === "STRING") {
    data = getPropertyDataString(numberOfFeatures, dataArray, arrayOffsets, stringOffsets);
  } else if (isNumericProperty(classProperty)) {
    data = getPropertyDataNumeric2(classProperty, numberOfFeatures, dataArray, arrayOffsets);
  }
  return data;
}
function getArrayOffsetsForProperty2(scenegraph, classProperty, propertyTableProperty, numberOfElements) {
  if (classProperty.type === "ARRAY" && // `componentCount` is a number of fixed-length array elements.
  // If `componentCount` is NOT defined, it's a VARIABLE-length array
  typeof classProperty.componentCount === "undefined" && // `arrayOffsetBufferView` is an index of the buffer view containing offsets for variable-length arrays.
  typeof propertyTableProperty.arrayOffsetBufferView !== "undefined") {
    return getOffsetsForProperty(
      scenegraph,
      propertyTableProperty.arrayOffsetBufferView,
      propertyTableProperty.offsetType || "UINT32",
      // offsetType is used both for stringOffsetBufferView and arrayOffsetBufferView
      numberOfElements
    );
  }
  return null;
}
function getStringOffsetsForProperty2(scenegraph, classProperty, propertyTableProperty, numberOfElements) {
  if (typeof propertyTableProperty.stringOffsetBufferView !== "undefined") {
    return getOffsetsForProperty(
      scenegraph,
      propertyTableProperty.stringOffsetBufferView,
      propertyTableProperty.offsetType || "UINT32",
      // offsetType is used both for stringOffsetBufferView and arrayOffsetBufferView
      numberOfElements
    );
  }
  return null;
}
function isNumericProperty(schemaProperty) {
  const types = [
    "UINT8",
    "INT16",
    "UINT16",
    "INT32",
    "UINT32",
    "INT64",
    "UINT64",
    "FLOAT32",
    "FLOAT64"
  ];
  return types.includes(schemaProperty.type) || typeof schemaProperty.componentType !== "undefined" && types.includes(schemaProperty.componentType);
}
function getPropertyDataNumeric2(classProperty, numberOfElements, valuesDataBytes, arrayOffsets) {
  const isArray3 = classProperty.type === "ARRAY";
  const arrayCount = classProperty.componentCount;
  const attributeType = "SCALAR";
  const componentType = classProperty.componentType || classProperty.type;
  const elementSize = getArrayElementByteSize(attributeType, componentType);
  const elementCount = valuesDataBytes.byteLength / elementSize;
  const valuesData = convertRawBufferToMetadataArray(valuesDataBytes, attributeType, componentType, elementCount);
  if (isArray3) {
    if (arrayOffsets) {
      return parseVariableLengthArrayNumeric(valuesData, numberOfElements, arrayOffsets, valuesDataBytes.length, elementSize);
    }
    if (arrayCount) {
      return parseFixedLengthArrayNumeric(valuesData, numberOfElements, arrayCount);
    }
    return [];
  }
  return valuesData;
}
function getPropertyDataFromTexture(scenegraph, featureTextureProperty, attributeName) {
  const json = scenegraph.gltf.json;
  if (!json.meshes) {
    return [];
  }
  const featureTextureTable = [];
  for (const mesh of json.meshes) {
    for (const primitive of mesh.primitives) {
      processPrimitiveTextures(scenegraph, attributeName, featureTextureProperty, featureTextureTable, primitive);
    }
  }
  return featureTextureTable;
}
function processPrimitiveTextures(scenegraph, attributeName, featureTextureProperty, featureTextureTable, primitive) {
  const textureInfoTopLevel = {
    channels: featureTextureProperty.channels,
    ...featureTextureProperty.texture
  };
  const propertyData = getPrimitiveTextureData(scenegraph, textureInfoTopLevel, primitive);
  if (!propertyData) {
    return;
  }
  primitivePropertyDataToAttributes(scenegraph, attributeName, propertyData, featureTextureTable, primitive);
}

// ../../node_modules/.pnpm/@loaders.gl+gltf@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/gltf/dist/lib/utils/version.js
var VERSION6 = true ? "4.3.2" : "latest";

// ../../node_modules/.pnpm/@loaders.gl+textures@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/textures/dist/lib/utils/version.js
var VERSION7 = true ? "4.3.2" : "latest";

// ../../node_modules/.pnpm/@loaders.gl+textures@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/textures/dist/lib/parsers/basis-module-loader.js
var BASIS_EXTERNAL_LIBRARIES = {
  /** Basis transcoder, javascript wrapper part */
  TRANSCODER: "basis_transcoder.js",
  /** Basis transcoder, compiled web assembly part */
  TRANSCODER_WASM: "basis_transcoder.wasm",
  /** Basis encoder, javascript wrapper part */
  ENCODER: "basis_encoder.js",
  /** Basis encoder, compiled web assembly part */
  ENCODER_WASM: "basis_encoder.wasm"
};
var loadBasisTranscoderPromise;
async function loadBasisTranscoderModule(options) {
  registerJSModules(options.modules);
  const basis = getJSModuleOrNull("basis");
  if (basis) {
    return basis;
  }
  loadBasisTranscoderPromise ||= loadBasisTranscoder(options);
  return await loadBasisTranscoderPromise;
}
async function loadBasisTranscoder(options) {
  let BASIS2 = null;
  let wasmBinary = null;
  [BASIS2, wasmBinary] = await Promise.all([
    await loadLibrary(BASIS_EXTERNAL_LIBRARIES.TRANSCODER, "textures", options),
    await loadLibrary(BASIS_EXTERNAL_LIBRARIES.TRANSCODER_WASM, "textures", options)
  ]);
  BASIS2 = BASIS2 || globalThis.BASIS;
  return await initializeBasisTranscoderModule(BASIS2, wasmBinary);
}
function initializeBasisTranscoderModule(BasisModule, wasmBinary) {
  const options = {};
  if (wasmBinary) {
    options.wasmBinary = wasmBinary;
  }
  return new Promise((resolve2) => {
    BasisModule(options).then((module2) => {
      const { BasisFile, initializeBasis } = module2;
      initializeBasis();
      resolve2({ BasisFile });
    });
  });
}
var loadBasisEncoderPromise;
async function loadBasisEncoderModule(options) {
  const modules = options.modules || {};
  if (modules.basisEncoder) {
    return modules.basisEncoder;
  }
  loadBasisEncoderPromise = loadBasisEncoderPromise || loadBasisEncoder(options);
  return await loadBasisEncoderPromise;
}
async function loadBasisEncoder(options) {
  let BASIS_ENCODER = null;
  let wasmBinary = null;
  [BASIS_ENCODER, wasmBinary] = await Promise.all([
    await loadLibrary(BASIS_EXTERNAL_LIBRARIES.ENCODER, "textures", options),
    await loadLibrary(BASIS_EXTERNAL_LIBRARIES.ENCODER_WASM, "textures", options)
  ]);
  BASIS_ENCODER = BASIS_ENCODER || globalThis.BASIS;
  return await initializeBasisEncoderModule(BASIS_ENCODER, wasmBinary);
}
function initializeBasisEncoderModule(BasisEncoderModule, wasmBinary) {
  const options = {};
  if (wasmBinary) {
    options.wasmBinary = wasmBinary;
  }
  return new Promise((resolve2) => {
    BasisEncoderModule(options).then((module2) => {
      const { BasisFile, KTX2File, initializeBasis, BasisEncoder } = module2;
      initializeBasis();
      resolve2({ BasisFile, KTX2File, BasisEncoder });
    });
  });
}

// ../../node_modules/.pnpm/@loaders.gl+textures@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/textures/dist/lib/gl-extensions.js
var GL_EXTENSIONS_CONSTANTS = {
  // WEBGL_compressed_texture_s3tc
  COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
  COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,
  COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,
  COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
  // WEBGL_compressed_texture_es3
  COMPRESSED_R11_EAC: 37488,
  COMPRESSED_SIGNED_R11_EAC: 37489,
  COMPRESSED_RG11_EAC: 37490,
  COMPRESSED_SIGNED_RG11_EAC: 37491,
  COMPRESSED_RGB8_ETC2: 37492,
  COMPRESSED_RGBA8_ETC2_EAC: 37493,
  COMPRESSED_SRGB8_ETC2: 37494,
  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37495,
  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37496,
  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37497,
  // WEBGL_compressed_texture_pvrtc
  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
  COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841,
  COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843,
  // WEBGL_compressed_texture_etc1
  COMPRESSED_RGB_ETC1_WEBGL: 36196,
  // WEBGL_compressed_texture_atc
  COMPRESSED_RGB_ATC_WEBGL: 35986,
  COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 35987,
  COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 34798,
  // WEBGL_compressed_texture_astc
  COMPRESSED_RGBA_ASTC_4X4_KHR: 37808,
  COMPRESSED_RGBA_ASTC_5X4_KHR: 37809,
  COMPRESSED_RGBA_ASTC_5X5_KHR: 37810,
  COMPRESSED_RGBA_ASTC_6X5_KHR: 37811,
  COMPRESSED_RGBA_ASTC_6X6_KHR: 37812,
  COMPRESSED_RGBA_ASTC_8X5_KHR: 37813,
  COMPRESSED_RGBA_ASTC_8X6_KHR: 37814,
  COMPRESSED_RGBA_ASTC_8X8_KHR: 37815,
  COMPRESSED_RGBA_ASTC_10X5_KHR: 37816,
  COMPRESSED_RGBA_ASTC_10X6_KHR: 37817,
  COMPRESSED_RGBA_ASTC_10X8_KHR: 37818,
  COMPRESSED_RGBA_ASTC_10X10_KHR: 37819,
  COMPRESSED_RGBA_ASTC_12X10_KHR: 37820,
  COMPRESSED_RGBA_ASTC_12X12_KHR: 37821,
  COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR: 37840,
  COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR: 37841,
  COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR: 37842,
  COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR: 37843,
  COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR: 37844,
  COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR: 37845,
  COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR: 37846,
  COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR: 37847,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR: 37848,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR: 37849,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR: 37850,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR: 37851,
  COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR: 37852,
  COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR: 37853,
  // EXT_texture_compression_rgtc
  COMPRESSED_RED_RGTC1_EXT: 36283,
  COMPRESSED_SIGNED_RED_RGTC1_EXT: 36284,
  COMPRESSED_RED_GREEN_RGTC2_EXT: 36285,
  COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 36286,
  // WEBGL_compressed_texture_s3tc_srgb
  COMPRESSED_SRGB_S3TC_DXT1_EXT: 35916,
  COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 35917,
  COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 35918,
  COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 35919
};

// ../../node_modules/.pnpm/@loaders.gl+textures@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/textures/dist/lib/utils/texture-formats.js
var BROWSER_PREFIXES = ["", "WEBKIT_", "MOZ_"];
var WEBGL_EXTENSIONS = {
  /* eslint-disable camelcase */
  WEBGL_compressed_texture_s3tc: "dxt",
  WEBGL_compressed_texture_s3tc_srgb: "dxt-srgb",
  WEBGL_compressed_texture_etc1: "etc1",
  WEBGL_compressed_texture_etc: "etc2",
  WEBGL_compressed_texture_pvrtc: "pvrtc",
  WEBGL_compressed_texture_atc: "atc",
  WEBGL_compressed_texture_astc: "astc",
  EXT_texture_compression_rgtc: "rgtc"
  /* eslint-enable camelcase */
};
var formats = null;
function getSupportedGPUTextureFormats(gl) {
  if (!formats) {
    gl = gl || getWebGLContext() || void 0;
    formats = /* @__PURE__ */ new Set();
    for (const prefix of BROWSER_PREFIXES) {
      for (const extension in WEBGL_EXTENSIONS) {
        if (gl && gl.getExtension(`${prefix}${extension}`)) {
          const gpuTextureFormat = WEBGL_EXTENSIONS[extension];
          formats.add(gpuTextureFormat);
        }
      }
    }
  }
  return formats;
}
function getWebGLContext() {
  try {
    const canvas2 = document.createElement("canvas");
    return canvas2.getContext("webgl");
  } catch (error) {
    return null;
  }
}

// ../../node_modules/.pnpm/@loaders.gl+textures@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/textures/dist/lib/parsers/parse-ktx.js
var KTX2_ID = [
  // '', 'K', 'T', 'X', '2', '0', '', '\r', '\n', '\x1A', '\n'
  171,
  75,
  84,
  88,
  32,
  50,
  48,
  187,
  13,
  10,
  26,
  10
];
function isKTX(data) {
  const id = new Uint8Array(data);
  const notKTX = id.byteLength < KTX2_ID.length || id[0] !== KTX2_ID[0] || // ''
  id[1] !== KTX2_ID[1] || // 'K'
  id[2] !== KTX2_ID[2] || // 'T'
  id[3] !== KTX2_ID[3] || // 'X'
  id[4] !== KTX2_ID[4] || // ' '
  id[5] !== KTX2_ID[5] || // '2'
  id[6] !== KTX2_ID[6] || // '0'
  id[7] !== KTX2_ID[7] || // ''
  id[8] !== KTX2_ID[8] || // '\r'
  id[9] !== KTX2_ID[9] || // '\n'
  id[10] !== KTX2_ID[10] || // '\x1A'
  id[11] !== KTX2_ID[11];
  return !notKTX;
}

// ../../node_modules/.pnpm/@loaders.gl+textures@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/textures/dist/lib/parsers/parse-basis.js
var OutputFormat = {
  etc1: {
    basisFormat: 0,
    compressed: true,
    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ETC1_WEBGL
  },
  etc2: { basisFormat: 1, compressed: true },
  bc1: {
    basisFormat: 2,
    compressed: true,
    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT
  },
  bc3: {
    basisFormat: 3,
    compressed: true,
    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT
  },
  bc4: { basisFormat: 4, compressed: true },
  bc5: { basisFormat: 5, compressed: true },
  "bc7-m6-opaque-only": { basisFormat: 6, compressed: true },
  "bc7-m5": { basisFormat: 7, compressed: true },
  "pvrtc1-4-rgb": {
    basisFormat: 8,
    compressed: true,
    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
  },
  "pvrtc1-4-rgba": {
    basisFormat: 9,
    compressed: true,
    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
  },
  "astc-4x4": {
    basisFormat: 10,
    compressed: true,
    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4X4_KHR
  },
  "atc-rgb": { basisFormat: 11, compressed: true },
  "atc-rgba-interpolated-alpha": { basisFormat: 12, compressed: true },
  rgba32: { basisFormat: 13, compressed: false },
  rgb565: { basisFormat: 14, compressed: false },
  bgr565: { basisFormat: 15, compressed: false },
  rgba4444: { basisFormat: 16, compressed: false }
};
async function parseBasis(data, options) {
  if (options.basis.containerFormat === "auto") {
    if (isKTX(data)) {
      const fileConstructors = await loadBasisEncoderModule(options);
      return parseKTX2File(fileConstructors.KTX2File, data, options);
    }
    const { BasisFile } = await loadBasisTranscoderModule(options);
    return parseBasisFile(BasisFile, data, options);
  }
  switch (options.basis.module) {
    case "encoder":
      const fileConstructors = await loadBasisEncoderModule(options);
      switch (options.basis.containerFormat) {
        case "ktx2":
          return parseKTX2File(fileConstructors.KTX2File, data, options);
        case "basis":
        default:
          return parseBasisFile(fileConstructors.BasisFile, data, options);
      }
    case "transcoder":
    default:
      const { BasisFile } = await loadBasisTranscoderModule(options);
      return parseBasisFile(BasisFile, data, options);
  }
}
function parseBasisFile(BasisFile, data, options) {
  const basisFile = new BasisFile(new Uint8Array(data));
  try {
    if (!basisFile.startTranscoding()) {
      throw new Error("Failed to start basis transcoding");
    }
    const imageCount = basisFile.getNumImages();
    const images = [];
    for (let imageIndex = 0; imageIndex < imageCount; imageIndex++) {
      const levelsCount = basisFile.getNumLevels(imageIndex);
      const levels = [];
      for (let levelIndex = 0; levelIndex < levelsCount; levelIndex++) {
        levels.push(transcodeImage(basisFile, imageIndex, levelIndex, options));
      }
      images.push(levels);
    }
    return images;
  } finally {
    basisFile.close();
    basisFile.delete();
  }
}
function transcodeImage(basisFile, imageIndex, levelIndex, options) {
  const width = basisFile.getImageWidth(imageIndex, levelIndex);
  const height = basisFile.getImageHeight(imageIndex, levelIndex);
  const hasAlpha = basisFile.getHasAlpha(
    /* imageIndex, levelIndex */
  );
  const { compressed, format, basisFormat } = getBasisOptions(options, hasAlpha);
  const decodedSize = basisFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, basisFormat);
  const decodedData = new Uint8Array(decodedSize);
  if (!basisFile.transcodeImage(decodedData, imageIndex, levelIndex, basisFormat, 0, 0)) {
    throw new Error("failed to start Basis transcoding");
  }
  return {
    // standard loaders.gl image category payload
    width,
    height,
    data: decodedData,
    compressed,
    format,
    // Additional fields
    // Add levelSize field.
    hasAlpha
  };
}
function parseKTX2File(KTX2File, data, options) {
  const ktx2File = new KTX2File(new Uint8Array(data));
  try {
    if (!ktx2File.startTranscoding()) {
      throw new Error("failed to start KTX2 transcoding");
    }
    const levelsCount = ktx2File.getLevels();
    const levels = [];
    for (let levelIndex = 0; levelIndex < levelsCount; levelIndex++) {
      levels.push(transcodeKTX2Image(ktx2File, levelIndex, options));
    }
    return [levels];
  } finally {
    ktx2File.close();
    ktx2File.delete();
  }
}
function transcodeKTX2Image(ktx2File, levelIndex, options) {
  const { alphaFlag, height, width } = ktx2File.getImageLevelInfo(levelIndex, 0, 0);
  const { compressed, format, basisFormat } = getBasisOptions(options, alphaFlag);
  const decodedSize = ktx2File.getImageTranscodedSizeInBytes(levelIndex, 0, 0, basisFormat);
  const decodedData = new Uint8Array(decodedSize);
  if (!ktx2File.transcodeImage(
    decodedData,
    levelIndex,
    0,
    0,
    basisFormat,
    0,
    -1,
    -1
    /* channel1 */
  )) {
    throw new Error("Failed to transcode KTX2 image");
  }
  return {
    // standard loaders.gl image category payload
    width,
    height,
    data: decodedData,
    compressed,
    // Additional fields
    levelSize: decodedSize,
    hasAlpha: alphaFlag,
    format
  };
}
function getBasisOptions(options, hasAlpha) {
  let format = options && options.basis && options.basis.format;
  if (format === "auto") {
    format = selectSupportedBasisFormat();
  }
  if (typeof format === "object") {
    format = hasAlpha ? format.alpha : format.noAlpha;
  }
  format = format.toLowerCase();
  return OutputFormat[format];
}
function selectSupportedBasisFormat() {
  const supportedFormats = getSupportedGPUTextureFormats();
  if (supportedFormats.has("astc")) {
    return "astc-4x4";
  } else if (supportedFormats.has("dxt")) {
    return {
      alpha: "bc3",
      noAlpha: "bc1"
    };
  } else if (supportedFormats.has("pvrtc")) {
    return {
      alpha: "pvrtc1-4-rgba",
      noAlpha: "pvrtc1-4-rgb"
    };
  } else if (supportedFormats.has("etc1")) {
    return "etc1";
  } else if (supportedFormats.has("etc2")) {
    return "etc2";
  }
  return "rgb565";
}

// ../../node_modules/.pnpm/@loaders.gl+textures@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/textures/dist/basis-loader.js
var BasisWorkerLoader = {
  dataType: null,
  batchType: null,
  name: "Basis",
  id: "basis",
  module: "textures",
  version: VERSION7,
  worker: true,
  extensions: ["basis", "ktx2"],
  mimeTypes: ["application/octet-stream", "image/ktx2"],
  tests: ["sB"],
  binary: true,
  options: {
    basis: {
      format: "auto",
      libraryPath: "libs/",
      containerFormat: "auto",
      module: "transcoder"
    }
  }
};
var BasisLoader = {
  ...BasisWorkerLoader,
  parse: parseBasis
};

// ../../node_modules/.pnpm/@loaders.gl+gltf@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/gltf/dist/lib/parsers/parse-glb.js
var LITTLE_ENDIAN2 = true;
var MAGIC_glTF = 1735152710;
var GLB_FILE_HEADER_SIZE = 12;
var GLB_CHUNK_HEADER_SIZE = 8;
var GLB_CHUNK_TYPE_JSON = 1313821514;
var GLB_CHUNK_TYPE_BIN = 5130562;
var GLB_V1_CONTENT_FORMAT_JSON = 0;
var GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED = 0;
var GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED = 1;
function getMagicString3(dataView, byteOffset = 0) {
  return `${String.fromCharCode(dataView.getUint8(byteOffset + 0))}${String.fromCharCode(dataView.getUint8(byteOffset + 1))}${String.fromCharCode(dataView.getUint8(byteOffset + 2))}${String.fromCharCode(dataView.getUint8(byteOffset + 3))}`;
}
function isGLB(arrayBuffer, byteOffset = 0, options = {}) {
  const dataView = new DataView(arrayBuffer);
  const { magic = MAGIC_glTF } = options;
  const magic1 = dataView.getUint32(byteOffset, false);
  return magic1 === magic || magic1 === MAGIC_glTF;
}
function parseGLBSync(glb, arrayBuffer, byteOffset = 0, options = {}) {
  const dataView = new DataView(arrayBuffer);
  const type = getMagicString3(dataView, byteOffset + 0);
  const version2 = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN2);
  const byteLength = dataView.getUint32(byteOffset + 8, LITTLE_ENDIAN2);
  Object.assign(glb, {
    // Put less important stuff in a header, to avoid clutter
    header: {
      byteOffset,
      // Byte offset into the initial arrayBuffer
      byteLength,
      hasBinChunk: false
    },
    type,
    version: version2,
    json: {},
    binChunks: []
  });
  byteOffset += GLB_FILE_HEADER_SIZE;
  switch (glb.version) {
    case 1:
      return parseGLBV1(glb, dataView, byteOffset);
    case 2:
      return parseGLBV2(glb, dataView, byteOffset, options = {});
    default:
      throw new Error(`Invalid GLB version ${glb.version}. Only supports version 1 and 2.`);
  }
}
function parseGLBV1(glb, dataView, byteOffset) {
  assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);
  const contentLength = dataView.getUint32(byteOffset + 0, LITTLE_ENDIAN2);
  const contentFormat = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN2);
  byteOffset += GLB_CHUNK_HEADER_SIZE;
  assert(contentFormat === GLB_V1_CONTENT_FORMAT_JSON);
  parseJSONChunk(glb, dataView, byteOffset, contentLength);
  byteOffset += contentLength;
  byteOffset += parseBINChunk(glb, dataView, byteOffset, glb.header.byteLength);
  return byteOffset;
}
function parseGLBV2(glb, dataView, byteOffset, options) {
  assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);
  parseGLBChunksSync(glb, dataView, byteOffset, options);
  return byteOffset + glb.header.byteLength;
}
function parseGLBChunksSync(glb, dataView, byteOffset, options) {
  while (byteOffset + 8 <= glb.header.byteLength) {
    const chunkLength = dataView.getUint32(byteOffset + 0, LITTLE_ENDIAN2);
    const chunkFormat = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN2);
    byteOffset += GLB_CHUNK_HEADER_SIZE;
    switch (chunkFormat) {
      case GLB_CHUNK_TYPE_JSON:
        parseJSONChunk(glb, dataView, byteOffset, chunkLength);
        break;
      case GLB_CHUNK_TYPE_BIN:
        parseBINChunk(glb, dataView, byteOffset, chunkLength);
        break;
      case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED:
        if (!options.strict) {
          parseJSONChunk(glb, dataView, byteOffset, chunkLength);
        }
        break;
      case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED:
        if (!options.strict) {
          parseBINChunk(glb, dataView, byteOffset, chunkLength);
        }
        break;
      default:
        break;
    }
    byteOffset += padToNBytes(chunkLength, 4);
  }
  return byteOffset;
}
function parseJSONChunk(glb, dataView, byteOffset, chunkLength) {
  const jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);
  const textDecoder = new TextDecoder("utf8");
  const jsonText = textDecoder.decode(jsonChunk);
  glb.json = JSON.parse(jsonText);
  return padToNBytes(chunkLength, 4);
}
function parseBINChunk(glb, dataView, byteOffset, chunkLength) {
  glb.header.hasBinChunk = true;
  glb.binChunks.push({
    byteOffset,
    byteLength: chunkLength,
    arrayBuffer: dataView.buffer
    // TODO - copy, or create typed array view?
  });
  return padToNBytes(chunkLength, 4);
}

// ../../node_modules/.pnpm/@loaders.gl+gltf@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/gltf/dist/lib/gltf-utils/resolve-url.js
function resolveUrl(url, options) {
  const absolute = url.startsWith("data:") || url.startsWith("http:") || url.startsWith("https:");
  if (absolute) {
    return url;
  }
  const baseUrl = options.baseUri || options.uri;
  if (!baseUrl) {
    throw new Error(`'baseUri' must be provided to resolve relative url ${url}`);
  }
  return baseUrl.substr(0, baseUrl.lastIndexOf("/") + 1) + url;
}

// ../../node_modules/.pnpm/@loaders.gl+gltf@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_meshopt_compression.js
var EXT_meshopt_compression_exports = {};
__export(EXT_meshopt_compression_exports, {
  decode: () => decode5,
  name: () => name4
});

// ../../node_modules/.pnpm/@loaders.gl+gltf@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/gltf/dist/meshopt/meshopt-decoder.js
var wasm_base = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB";
var wasm_simd = "B9h9z9tFBBBF8dL9gBB9gLaaaaaFa9gEaaaB9gGaaB9gFaFaEQSBBFBFFGEGEGIILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBNn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBcI9z9iqlBMc/j9JSIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMkRIbaG97FaK978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAnDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAnDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBRnCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBHiCFD9tAiAPD9OD9hD9RHiDQBTFtGmEYIPLdKeOnH8ZAIAQJDBIBHpCFD9tApAPD9OD9hD9RHpAIASJDBIBHyCFD9tAyAPD9OD9hD9RHyDQBTFtGmEYIPLdKeOnH8cDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAnD9uHnDyBjGBAEAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnA8ZA8cDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNiV8ZcpMyS8cQ8df8eb8fHdApAyDQNiV8ZcpMyS8cQ8df8eb8fHiDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/xLGEaK978jUUUUBCAlHE8kUUUUBGXGXAGCI9HQBGXAFC98ZHI9FQBABRGCBRLEXAGAGDBBBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMBBAGCTJRGALCIJHLAI9JQBMMAIAF9PQFAEAFCEZHLCGWHGqCBCTAGl/8MBAEABAICGWJHIAG/8cBBGXAL9FQBAEAEDBIBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMIBMAIAEAG/8cBBSFMABAFC98ZHGT+HUUUBAGAF9PQBAEAFCEZHICEWHLJCBCAALl/8MBAEABAGCEWJHGAL/8cBBAEAIT+HUUUBAGAEAL/8cBBMAECAJ8kUUUUBM+yEGGaO97GXAF9FQBCBRGEXABCTJHEAEDBBBHICBDtHLCUU98D8cFCUU98D8cEHKD9OABDBBBHOAIDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAOAIDQBFGENVcMTtmYi8ZpyHICTD+sFD/6FHND/gFAICTD+rFCTD+sFD/6FHVD/gFD/kFD/lFHI9DB/+g6DYAVAIALD+2FHLAVCUUUU94DtHcD9OD9RD/kFHVAVD/mFAIAID/mFANALANAcD9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHLD/kFCTD+rFAVAND/mFALD/kFCggEDtD9OD9QHVAIAND/mFALD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHIDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAOAKD9OAVAIDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM94FEa8jUUUUBCAlHE8kUUUUBABAFC98ZHIT+JUUUBGXAIAF9PQBAEAFCEZHLCEWHFJCBCAAFl/8MBAEABAICEWJHBAF/8cBBAEALT+JUUUBABAEAF/8cBBMAECAJ8kUUUUBM/hEIGaF97FaL978jUUUUBCTlRGGXAF9FQBCBREEXAGABDBBBHIABCTJHLDBBBHKDQILKOSQfbPden8c8d8e8fHOCTD+sFHNCID+rFDMIBAB9DBBU8/DY9D/zI818/DYANCEDtD9QD/6FD/nFHNAIAKDQBFGENVcMTtmYi8ZpyHICTD+rFCTD+sFD/6FD/mFHKAKD/mFANAICTD+sFD/6FD/mFHVAVD/mFANAOCTD+rFCTD+sFD/6FD/mFHOAOD/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHND/mF9DBBX9LDYHID/kFCggEDtHcD9OAVAND/mFAID/kFCTD+rFD9QHVAOAND/mFAID/kFCTD+rFAKAND/mFAID/kFAcD9OD9QHNDQBFTtGEmYILPdKOenHID8dBAGDBIBDyB+t+J83EBABCNJAID8dFAGDBIBDyF+t+J83EBALAVANDQNVi8ZcMpySQ8c8dfb8e8fHND8dBAGDBIBDyG+t+J83EBABCiJAND8dFAGDBIBDyE+t+J83EBABCAJRBAECIJHEAF9JQBMMM/3FGEaF978jUUUUBCoBlREGXAGCGrAF9sHIC98ZHL9FQBCBRGABRFEXAFAFDBBBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBAFCTJRFAGCIJHGAL9JQBMMGXALAI9PQBAEAICEZHGCGWHFqCBCoBAFl/8MBAEABALCGWJHLAF/8cBBGXAG9FQBAEAEDBIBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMIBMALAEAF/8cBBMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB";
var detector = new Uint8Array([
  0,
  97,
  115,
  109,
  1,
  0,
  0,
  0,
  1,
  4,
  1,
  96,
  0,
  0,
  3,
  3,
  2,
  0,
  0,
  5,
  3,
  1,
  0,
  1,
  12,
  1,
  0,
  10,
  22,
  2,
  12,
  0,
  65,
  0,
  65,
  0,
  65,
  0,
  252,
  10,
  0,
  0,
  11,
  7,
  0,
  65,
  0,
  253,
  15,
  26,
  11
]);
var wasmpack = new Uint8Array([
  32,
  0,
  65,
  253,
  3,
  1,
  2,
  34,
  4,
  106,
  6,
  5,
  11,
  8,
  7,
  20,
  13,
  33,
  12,
  16,
  128,
  9,
  116,
  64,
  19,
  113,
  127,
  15,
  10,
  21,
  22,
  14,
  255,
  66,
  24,
  54,
  136,
  107,
  18,
  23,
  192,
  26,
  114,
  118,
  132,
  17,
  77,
  101,
  130,
  144,
  27,
  87,
  131,
  44,
  45,
  74,
  156,
  154,
  70,
  167
]);
var FILTERS = {
  // legacy index-based enums for glTF
  0: "",
  1: "meshopt_decodeFilterOct",
  2: "meshopt_decodeFilterQuat",
  3: "meshopt_decodeFilterExp",
  // string-based enums for glTF
  NONE: "",
  OCTAHEDRAL: "meshopt_decodeFilterOct",
  QUATERNION: "meshopt_decodeFilterQuat",
  EXPONENTIAL: "meshopt_decodeFilterExp"
};
var DECODERS = {
  // legacy index-based enums for glTF
  0: "meshopt_decodeVertexBuffer",
  1: "meshopt_decodeIndexBuffer",
  2: "meshopt_decodeIndexSequence",
  // string-based enums for glTF
  ATTRIBUTES: "meshopt_decodeVertexBuffer",
  TRIANGLES: "meshopt_decodeIndexBuffer",
  INDICES: "meshopt_decodeIndexSequence"
};
async function meshoptDecodeGltfBuffer(target, count, size, source, mode, filter = "NONE") {
  const instance = await loadWasmInstance();
  decode4(instance, instance.exports[DECODERS[mode]], target, count, size, source, instance.exports[FILTERS[filter || "NONE"]]);
}
var wasmPromise;
async function loadWasmInstance() {
  if (!wasmPromise) {
    wasmPromise = loadWasmModule();
  }
  return wasmPromise;
}
async function loadWasmModule() {
  let wasm = wasm_base;
  if (WebAssembly.validate(detector)) {
    wasm = wasm_simd;
    console.log("Warning: meshopt_decoder is using experimental SIMD support");
  }
  const result = await WebAssembly.instantiate(unpack(wasm), {});
  await result.instance.exports.__wasm_call_ctors();
  return result.instance;
}
function unpack(data) {
  const result = new Uint8Array(data.length);
  for (let i = 0; i < data.length; ++i) {
    const ch = data.charCodeAt(i);
    result[i] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62;
  }
  let write = 0;
  for (let i = 0; i < data.length; ++i) {
    result[write++] = result[i] < 60 ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i];
  }
  return result.buffer.slice(0, write);
}
function decode4(instance, fun, target, count, size, source, filter) {
  const sbrk = instance.exports.sbrk;
  const count4 = count + 3 & ~3;
  const tp = sbrk(count4 * size);
  const sp = sbrk(source.length);
  const heap = new Uint8Array(instance.exports.memory.buffer);
  heap.set(source, sp);
  const res = fun(tp, count, size, sp, source.length);
  if (res === 0 && filter) {
    filter(tp, count4, size);
  }
  target.set(heap.subarray(tp, tp + count * size));
  sbrk(tp - sbrk(0));
  if (res !== 0) {
    throw new Error(`Malformed buffer data: ${res}`);
  }
}

// ../../node_modules/.pnpm/@loaders.gl+gltf@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_meshopt_compression.js
var EXT_MESHOPT_COMPRESSION = "EXT_meshopt_compression";
var name4 = EXT_MESHOPT_COMPRESSION;
async function decode5(gltfData, options) {
  const scenegraph = new GLTFScenegraph(gltfData);
  if (!options?.gltf?.decompressMeshes || !options.gltf?.loadBuffers) {
    return;
  }
  const promises = [];
  for (const bufferViewIndex of gltfData.json.bufferViews || []) {
    promises.push(decodeMeshoptBufferView(scenegraph, bufferViewIndex));
  }
  await Promise.all(promises);
  scenegraph.removeExtension(EXT_MESHOPT_COMPRESSION);
}
async function decodeMeshoptBufferView(scenegraph, bufferView) {
  const meshoptExtension = scenegraph.getObjectExtension(bufferView, EXT_MESHOPT_COMPRESSION);
  if (meshoptExtension) {
    const { byteOffset = 0, byteLength = 0, byteStride, count, mode, filter = "NONE", buffer: bufferIndex } = meshoptExtension;
    const buffer = scenegraph.gltf.buffers[bufferIndex];
    const source = new Uint8Array(buffer.arrayBuffer, buffer.byteOffset + byteOffset, byteLength);
    const result = new Uint8Array(scenegraph.gltf.buffers[bufferView.buffer].arrayBuffer, bufferView.byteOffset, bufferView.byteLength);
    await meshoptDecodeGltfBuffer(result, count, byteStride, source, mode, filter);
    scenegraph.removeObjectExtension(bufferView, EXT_MESHOPT_COMPRESSION);
  }
}

// ../../node_modules/.pnpm/@loaders.gl+gltf@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_texture_webp.js
var EXT_texture_webp_exports = {};
__export(EXT_texture_webp_exports, {
  name: () => name5,
  preprocess: () => preprocess
});
var EXT_TEXTURE_WEBP = "EXT_texture_webp";
var name5 = EXT_TEXTURE_WEBP;
function preprocess(gltfData, options) {
  const scenegraph = new GLTFScenegraph(gltfData);
  if (!isImageFormatSupported("image/webp")) {
    if (scenegraph.getRequiredExtensions().includes(EXT_TEXTURE_WEBP)) {
      throw new Error(`gltf: Required extension ${EXT_TEXTURE_WEBP} not supported by browser`);
    }
    return;
  }
  const { json } = scenegraph;
  for (const texture of json.textures || []) {
    const extension = scenegraph.getObjectExtension(texture, EXT_TEXTURE_WEBP);
    if (extension) {
      texture.source = extension.source;
    }
    scenegraph.removeObjectExtension(texture, EXT_TEXTURE_WEBP);
  }
  scenegraph.removeExtension(EXT_TEXTURE_WEBP);
}

// ../../node_modules/.pnpm/@loaders.gl+gltf@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_texture_basisu.js
var KHR_texture_basisu_exports = {};
__export(KHR_texture_basisu_exports, {
  name: () => name6,
  preprocess: () => preprocess2
});
var KHR_TEXTURE_BASISU = "KHR_texture_basisu";
var name6 = KHR_TEXTURE_BASISU;
function preprocess2(gltfData, options) {
  const scene = new GLTFScenegraph(gltfData);
  const { json } = scene;
  for (const texture of json.textures || []) {
    const extension = scene.getObjectExtension(texture, KHR_TEXTURE_BASISU);
    if (extension) {
      texture.source = extension.source;
      scene.removeObjectExtension(texture, KHR_TEXTURE_BASISU);
    }
  }
  scene.removeExtension(KHR_TEXTURE_BASISU);
}

// ../../node_modules/.pnpm/@loaders.gl+gltf@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_draco_mesh_compression.js
var KHR_draco_mesh_compression_exports = {};
__export(KHR_draco_mesh_compression_exports, {
  decode: () => decode6,
  encode: () => encode8,
  name: () => name7,
  preprocess: () => preprocess3
});

// ../../node_modules/.pnpm/@loaders.gl+draco@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/draco/dist/lib/utils/version.js
var VERSION8 = true ? "4.3.2" : "latest";

// ../../node_modules/.pnpm/@loaders.gl+draco@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/draco/dist/draco-loader.js
var DracoLoader = {
  dataType: null,
  batchType: null,
  name: "Draco",
  id: "draco",
  module: "draco",
  // shapes: ['mesh'],
  version: VERSION8,
  worker: true,
  extensions: ["drc"],
  mimeTypes: ["application/octet-stream"],
  binary: true,
  tests: ["DRACO"],
  options: {
    draco: {
      decoderType: typeof WebAssembly === "object" ? "wasm" : "js",
      // 'js' for IE11
      libraryPath: "libs/",
      extraAttributes: {},
      attributeNameEntry: void 0
    }
  }
};

// ../../node_modules/.pnpm/@loaders.gl+draco@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/draco/dist/lib/utils/get-draco-schema.js
function getDracoSchema(attributes, loaderData, indices) {
  const metadata = makeMetadata(loaderData.metadata);
  const fields = [];
  const namedLoaderDataAttributes = transformAttributesLoaderData(loaderData.attributes);
  for (const attributeName in attributes) {
    const attribute = attributes[attributeName];
    const field = getArrowFieldFromAttribute(attributeName, attribute, namedLoaderDataAttributes[attributeName]);
    fields.push(field);
  }
  if (indices) {
    const indicesField = getArrowFieldFromAttribute("indices", indices);
    fields.push(indicesField);
  }
  return { fields, metadata };
}
function transformAttributesLoaderData(loaderData) {
  const result = {};
  for (const key in loaderData) {
    const dracoAttribute = loaderData[key];
    result[dracoAttribute.name || "undefined"] = dracoAttribute;
  }
  return result;
}
function getArrowFieldFromAttribute(attributeName, attribute, loaderData) {
  const metadataMap = loaderData ? makeMetadata(loaderData.metadata) : void 0;
  const field = deduceMeshField(attributeName, attribute, metadataMap);
  return field;
}
function makeMetadata(metadata) {
  Object.entries(metadata);
  const serializedMetadata = {};
  for (const key in metadata) {
    serializedMetadata[`${key}.string`] = JSON.stringify(metadata[key]);
  }
  return serializedMetadata;
}

// ../../node_modules/.pnpm/@loaders.gl+draco@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/draco/dist/lib/draco-parser.js
var DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {
  POSITION: "POSITION",
  NORMAL: "NORMAL",
  COLOR: "COLOR_0",
  TEX_COORD: "TEXCOORD_0"
};
var DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {
  1: Int8Array,
  2: Uint8Array,
  3: Int16Array,
  4: Uint16Array,
  5: Int32Array,
  6: Uint32Array,
  // 7: BigInt64Array,
  // 8: BigUint64Array,
  9: Float32Array
  // 10: Float64Array
  // 11: BOOL - What array type do we use for this?
};
var INDEX_ITEM_SIZE = 4;
var DracoParser = class {
  draco;
  decoder;
  metadataQuerier;
  // draco - the draco decoder, either import `draco3d` or load dynamically
  constructor(draco) {
    this.draco = draco;
    this.decoder = new this.draco.Decoder();
    this.metadataQuerier = new this.draco.MetadataQuerier();
  }
  /**
   * Destroy draco resources
   */
  destroy() {
    this.draco.destroy(this.decoder);
    this.draco.destroy(this.metadataQuerier);
  }
  /**
   * NOTE: caller must call `destroyGeometry` on the return value after using it
   * @param arrayBuffer
   * @param options
   */
  parseSync(arrayBuffer, options = {}) {
    const buffer = new this.draco.DecoderBuffer();
    buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);
    this._disableAttributeTransforms(options);
    const geometry_type = this.decoder.GetEncodedGeometryType(buffer);
    const dracoGeometry = geometry_type === this.draco.TRIANGULAR_MESH ? new this.draco.Mesh() : new this.draco.PointCloud();
    try {
      let dracoStatus;
      switch (geometry_type) {
        case this.draco.TRIANGULAR_MESH:
          dracoStatus = this.decoder.DecodeBufferToMesh(buffer, dracoGeometry);
          break;
        case this.draco.POINT_CLOUD:
          dracoStatus = this.decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);
          break;
        default:
          throw new Error("DRACO: Unknown geometry type.");
      }
      if (!dracoStatus.ok() || !dracoGeometry.ptr) {
        const message = `DRACO decompression failed: ${dracoStatus.error_msg()}`;
        throw new Error(message);
      }
      const loaderData = this._getDracoLoaderData(dracoGeometry, geometry_type, options);
      const geometry = this._getMeshData(dracoGeometry, loaderData, options);
      const boundingBox = getMeshBoundingBox(geometry.attributes);
      const schema = getDracoSchema(geometry.attributes, loaderData, geometry.indices);
      const data = {
        loader: "draco",
        loaderData,
        header: {
          vertexCount: dracoGeometry.num_points(),
          boundingBox
        },
        ...geometry,
        schema
      };
      return data;
    } finally {
      this.draco.destroy(buffer);
      if (dracoGeometry) {
        this.draco.destroy(dracoGeometry);
      }
    }
  }
  // Draco specific "loader data"
  /**
   * Extract
   * @param dracoGeometry
   * @param geometry_type
   * @param options
   * @returns
   */
  _getDracoLoaderData(dracoGeometry, geometry_type, options) {
    const metadata = this._getTopLevelMetadata(dracoGeometry);
    const attributes = this._getDracoAttributes(dracoGeometry, options);
    return {
      geometry_type,
      num_attributes: dracoGeometry.num_attributes(),
      num_points: dracoGeometry.num_points(),
      num_faces: dracoGeometry instanceof this.draco.Mesh ? dracoGeometry.num_faces() : 0,
      metadata,
      attributes
    };
  }
  /**
   * Extract all draco provided information and metadata for each attribute
   * @param dracoGeometry
   * @param options
   * @returns
   */
  _getDracoAttributes(dracoGeometry, options) {
    const dracoAttributes = {};
    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {
      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);
      const metadata = this._getAttributeMetadata(dracoGeometry, attributeId);
      dracoAttributes[dracoAttribute.unique_id()] = {
        unique_id: dracoAttribute.unique_id(),
        attribute_type: dracoAttribute.attribute_type(),
        data_type: dracoAttribute.data_type(),
        num_components: dracoAttribute.num_components(),
        byte_offset: dracoAttribute.byte_offset(),
        byte_stride: dracoAttribute.byte_stride(),
        normalized: dracoAttribute.normalized(),
        attribute_index: attributeId,
        metadata
      };
      const quantization = this._getQuantizationTransform(dracoAttribute, options);
      if (quantization) {
        dracoAttributes[dracoAttribute.unique_id()].quantization_transform = quantization;
      }
      const octahedron = this._getOctahedronTransform(dracoAttribute, options);
      if (octahedron) {
        dracoAttributes[dracoAttribute.unique_id()].octahedron_transform = octahedron;
      }
    }
    return dracoAttributes;
  }
  /**
   * Get standard loaders.gl mesh category data
   * Extracts the geometry from draco
   * @param dracoGeometry
   * @param options
   */
  _getMeshData(dracoGeometry, loaderData, options) {
    const attributes = this._getMeshAttributes(loaderData, dracoGeometry, options);
    const positionAttribute = attributes.POSITION;
    if (!positionAttribute) {
      throw new Error("DRACO: No position attribute found.");
    }
    if (dracoGeometry instanceof this.draco.Mesh) {
      switch (options.topology) {
        case "triangle-strip":
          return {
            topology: "triangle-strip",
            mode: 4,
            // GL.TRIANGLES
            attributes,
            indices: {
              value: this._getTriangleStripIndices(dracoGeometry),
              size: 1
            }
          };
        case "triangle-list":
        default:
          return {
            topology: "triangle-list",
            mode: 5,
            // GL.TRIANGLE_STRIP
            attributes,
            indices: {
              value: this._getTriangleListIndices(dracoGeometry),
              size: 1
            }
          };
      }
    }
    return {
      topology: "point-list",
      mode: 0,
      // GL.POINTS
      attributes
    };
  }
  _getMeshAttributes(loaderData, dracoGeometry, options) {
    const attributes = {};
    for (const loaderAttribute of Object.values(loaderData.attributes)) {
      const attributeName = this._deduceAttributeName(loaderAttribute, options);
      loaderAttribute.name = attributeName;
      const values = this._getAttributeValues(dracoGeometry, loaderAttribute);
      if (values) {
        const { value, size } = values;
        attributes[attributeName] = {
          value,
          size,
          byteOffset: loaderAttribute.byte_offset,
          byteStride: loaderAttribute.byte_stride,
          normalized: loaderAttribute.normalized
        };
      }
    }
    return attributes;
  }
  // MESH INDICES EXTRACTION
  /**
   * For meshes, we need indices to define the faces.
   * @param dracoGeometry
   */
  _getTriangleListIndices(dracoGeometry) {
    const numFaces2 = dracoGeometry.num_faces();
    const numIndices = numFaces2 * 3;
    const byteLength = numIndices * INDEX_ITEM_SIZE;
    const ptr = this.draco._malloc(byteLength);
    try {
      this.decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
      return new Uint32Array(this.draco.HEAPF32.buffer, ptr, numIndices).slice();
    } finally {
      this.draco._free(ptr);
    }
  }
  /**
   * For meshes, we need indices to define the faces.
   * @param dracoGeometry
   */
  _getTriangleStripIndices(dracoGeometry) {
    const dracoArray = new this.draco.DracoInt32Array();
    try {
      this.decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);
      return getUint32Array(dracoArray);
    } finally {
      this.draco.destroy(dracoArray);
    }
  }
  /**
   *
   * @param dracoGeometry
   * @param dracoAttribute
   * @param attributeName
   */
  _getAttributeValues(dracoGeometry, attribute) {
    const TypedArrayCtor = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[attribute.data_type];
    if (!TypedArrayCtor) {
      console.warn(`DRACO: Unsupported attribute type ${attribute.data_type}`);
      return null;
    }
    const numComponents = attribute.num_components;
    const numPoints = dracoGeometry.num_points();
    const numValues = numPoints * numComponents;
    const byteLength = numValues * TypedArrayCtor.BYTES_PER_ELEMENT;
    const dataType = getDracoDataType(this.draco, TypedArrayCtor);
    let value;
    const ptr = this.draco._malloc(byteLength);
    try {
      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attribute.attribute_index);
      this.decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, dracoAttribute, dataType, byteLength, ptr);
      value = new TypedArrayCtor(this.draco.HEAPF32.buffer, ptr, numValues).slice();
    } finally {
      this.draco._free(ptr);
    }
    return { value, size: numComponents };
  }
  // Attribute names
  /**
   * DRACO does not store attribute names - We need to deduce an attribute name
   * for each attribute
  _getAttributeNames(
    dracoGeometry: Mesh | PointCloud,
    options: DracoParseOptions
  ): {[unique_id: number]: string} {
    const attributeNames: {[unique_id: number]: string} = {};
    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {
      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);
      const attributeName = this._deduceAttributeName(dracoAttribute, options);
      attributeNames[attributeName] = attributeName;
    }
    return attributeNames;
  }
   */
  /**
   * Deduce an attribute name.
   * @note DRACO does not save attribute names, just general type (POSITION, COLOR)
   * to help optimize compression. We generate GLTF compatible names for the Draco-recognized
   * types
   * @param attributeData
   */
  _deduceAttributeName(attribute, options) {
    const uniqueId = attribute.unique_id;
    for (const [attributeName, attributeUniqueId] of Object.entries(options.extraAttributes || {})) {
      if (attributeUniqueId === uniqueId) {
        return attributeName;
      }
    }
    const thisAttributeType = attribute.attribute_type;
    for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {
      const attributeType = this.draco[dracoAttributeConstant];
      if (attributeType === thisAttributeType) {
        return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];
      }
    }
    const entryName = options.attributeNameEntry || "name";
    if (attribute.metadata[entryName]) {
      return attribute.metadata[entryName].string;
    }
    return `CUSTOM_ATTRIBUTE_${uniqueId}`;
  }
  // METADATA EXTRACTION
  /** Get top level metadata */
  _getTopLevelMetadata(dracoGeometry) {
    const dracoMetadata = this.decoder.GetMetadata(dracoGeometry);
    return this._getDracoMetadata(dracoMetadata);
  }
  /** Get per attribute metadata */
  _getAttributeMetadata(dracoGeometry, attributeId) {
    const dracoMetadata = this.decoder.GetAttributeMetadata(dracoGeometry, attributeId);
    return this._getDracoMetadata(dracoMetadata);
  }
  /**
   * Extract metadata field values
   * @param dracoMetadata
   * @returns
   */
  _getDracoMetadata(dracoMetadata) {
    if (!dracoMetadata || !dracoMetadata.ptr) {
      return {};
    }
    const result = {};
    const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);
    for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {
      const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);
      result[entryName] = this._getDracoMetadataField(dracoMetadata, entryName);
    }
    return result;
  }
  /**
   * Extracts possible values for one metadata entry by name
   * @param dracoMetadata
   * @param entryName
   */
  _getDracoMetadataField(dracoMetadata, entryName) {
    const dracoArray = new this.draco.DracoInt32Array();
    try {
      this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName, dracoArray);
      const intArray = getInt32Array(dracoArray);
      return {
        int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),
        string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),
        double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),
        intArray
      };
    } finally {
      this.draco.destroy(dracoArray);
    }
  }
  // QUANTIZED ATTRIBUTE SUPPORT (NO DECOMPRESSION)
  /** Skip transforms for specific attribute types */
  _disableAttributeTransforms(options) {
    const { quantizedAttributes = [], octahedronAttributes = [] } = options;
    const skipAttributes = [...quantizedAttributes, ...octahedronAttributes];
    for (const dracoAttributeName of skipAttributes) {
      this.decoder.SkipAttributeTransform(this.draco[dracoAttributeName]);
    }
  }
  /**
   * Extract (and apply?) Position Transform
   * @todo not used
   */
  _getQuantizationTransform(dracoAttribute, options) {
    const { quantizedAttributes = [] } = options;
    const attribute_type = dracoAttribute.attribute_type();
    const skip = quantizedAttributes.map((type) => this.decoder[type]).includes(attribute_type);
    if (skip) {
      const transform = new this.draco.AttributeQuantizationTransform();
      try {
        if (transform.InitFromAttribute(dracoAttribute)) {
          return {
            quantization_bits: transform.quantization_bits(),
            range: transform.range(),
            min_values: new Float32Array([1, 2, 3]).map((i) => transform.min_value(i))
          };
        }
      } finally {
        this.draco.destroy(transform);
      }
    }
    return null;
  }
  _getOctahedronTransform(dracoAttribute, options) {
    const { octahedronAttributes = [] } = options;
    const attribute_type = dracoAttribute.attribute_type();
    const octahedron = octahedronAttributes.map((type) => this.decoder[type]).includes(attribute_type);
    if (octahedron) {
      const transform = new this.draco.AttributeQuantizationTransform();
      try {
        if (transform.InitFromAttribute(dracoAttribute)) {
          return {
            quantization_bits: transform.quantization_bits()
          };
        }
      } finally {
        this.draco.destroy(transform);
      }
    }
    return null;
  }
};
function getDracoDataType(draco, attributeType) {
  switch (attributeType) {
    case Float32Array:
      return draco.DT_FLOAT32;
    case Int8Array:
      return draco.DT_INT8;
    case Int16Array:
      return draco.DT_INT16;
    case Int32Array:
      return draco.DT_INT32;
    case Uint8Array:
      return draco.DT_UINT8;
    case Uint16Array:
      return draco.DT_UINT16;
    case Uint32Array:
      return draco.DT_UINT32;
    default:
      return draco.DT_INVALID;
  }
}
function getInt32Array(dracoArray) {
  const numValues = dracoArray.size();
  const intArray = new Int32Array(numValues);
  for (let i = 0; i < numValues; i++) {
    intArray[i] = dracoArray.GetValue(i);
  }
  return intArray;
}
function getUint32Array(dracoArray) {
  const numValues = dracoArray.size();
  const intArray = new Int32Array(numValues);
  for (let i = 0; i < numValues; i++) {
    intArray[i] = dracoArray.GetValue(i);
  }
  return intArray;
}

// ../../node_modules/.pnpm/@loaders.gl+draco@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/draco/dist/lib/draco-module-loader.js
var DRACO_DECODER_VERSION = "1.5.6";
var DRACO_ENCODER_VERSION = "1.4.1";
var STATIC_DECODER_URL = `https://www.gstatic.com/draco/versioned/decoders/${DRACO_DECODER_VERSION}`;
var DRACO_EXTERNAL_LIBRARIES = {
  /** The primary Draco3D encoder, javascript wrapper part */
  DECODER: "draco_wasm_wrapper.js",
  /** The primary draco decoder, compiled web assembly part */
  DECODER_WASM: "draco_decoder.wasm",
  /** Fallback decoder for non-webassebly environments. Very big bundle, lower performance */
  FALLBACK_DECODER: "draco_decoder.js",
  /** Draco encoder */
  ENCODER: "draco_encoder.js"
};
var DRACO_EXTERNAL_LIBRARY_URLS = {
  [DRACO_EXTERNAL_LIBRARIES.DECODER]: `${STATIC_DECODER_URL}/${DRACO_EXTERNAL_LIBRARIES.DECODER}`,
  [DRACO_EXTERNAL_LIBRARIES.DECODER_WASM]: `${STATIC_DECODER_URL}/${DRACO_EXTERNAL_LIBRARIES.DECODER_WASM}`,
  [DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER]: `${STATIC_DECODER_URL}/${DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER}`,
  [DRACO_EXTERNAL_LIBRARIES.ENCODER]: `https://raw.githubusercontent.com/google/draco/${DRACO_ENCODER_VERSION}/javascript/${DRACO_EXTERNAL_LIBRARIES.ENCODER}`
};
var loadDecoderPromise;
async function loadDracoDecoderModule(options) {
  const modules = options.modules || {};
  if (modules.draco3d) {
    loadDecoderPromise ||= modules.draco3d.createDecoderModule({}).then((draco) => {
      return { draco };
    });
  } else {
    loadDecoderPromise ||= loadDracoDecoder(options);
  }
  return await loadDecoderPromise;
}
async function loadDracoDecoder(options) {
  let DracoDecoderModule;
  let wasmBinary;
  switch (options.draco && options.draco.decoderType) {
    case "js":
      DracoDecoderModule = await loadLibrary(DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER], "draco", options, DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER);
      break;
    case "wasm":
    default:
      [DracoDecoderModule, wasmBinary] = await Promise.all([
        await loadLibrary(DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.DECODER], "draco", options, DRACO_EXTERNAL_LIBRARIES.DECODER),
        await loadLibrary(DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.DECODER_WASM], "draco", options, DRACO_EXTERNAL_LIBRARIES.DECODER_WASM)
      ]);
  }
  DracoDecoderModule = DracoDecoderModule || globalThis.DracoDecoderModule;
  return await initializeDracoDecoder(DracoDecoderModule, wasmBinary);
}
function initializeDracoDecoder(DracoDecoderModule, wasmBinary) {
  const options = {};
  if (wasmBinary) {
    options.wasmBinary = wasmBinary;
  }
  return new Promise((resolve2) => {
    DracoDecoderModule({
      ...options,
      onModuleLoaded: (draco) => resolve2({ draco })
      // Module is Promise-like. Wrap in object to avoid loop.
    });
  });
}

// ../../node_modules/.pnpm/@loaders.gl+draco@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/draco/dist/index.js
var DracoLoader2 = {
  ...DracoLoader,
  parse: parse8
};
async function parse8(arrayBuffer, options) {
  const { draco } = await loadDracoDecoderModule(options);
  const dracoParser = new DracoParser(draco);
  try {
    return dracoParser.parseSync(arrayBuffer, options?.draco);
  } finally {
    dracoParser.destroy();
  }
}

// ../../node_modules/.pnpm/@loaders.gl+gltf@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/gltf/dist/lib/gltf-utils/gltf-attribute-utils.js
function getGLTFAccessors(attributes) {
  const accessors = {};
  for (const name12 in attributes) {
    const attribute = attributes[name12];
    if (name12 !== "indices") {
      const glTFAccessor = getGLTFAccessor(attribute);
      accessors[name12] = glTFAccessor;
    }
  }
  return accessors;
}
function getGLTFAccessor(attribute) {
  const { buffer, size, count } = getAccessorData(attribute);
  const glTFAccessor = {
    // glTF Accessor values
    // TODO: Instead of a bufferView index we could have an actual buffer (typed array)
    // bufferView: null,
    // TODO: Deprecate `value` in favor of bufferView?
    // @ts-ignore
    value: buffer,
    size,
    // Decoded `type` (e.g. SCALAR)
    byteOffset: 0,
    count,
    type: getAccessorTypeFromSize(size),
    componentType: getComponentTypeFromArray(buffer)
  };
  return glTFAccessor;
}
function getAccessorData(attribute) {
  let buffer = attribute;
  let size = 1;
  let count = 0;
  if (attribute && attribute.value) {
    buffer = attribute.value;
    size = attribute.size || 1;
  }
  if (buffer) {
    if (!ArrayBuffer.isView(buffer)) {
      buffer = toTypedArray(buffer, Float32Array);
    }
    count = buffer.length / size;
  }
  return { buffer, size, count };
}
function toTypedArray(array, ArrayType, convertTypedArrays = false) {
  if (!array) {
    return null;
  }
  if (Array.isArray(array)) {
    return new ArrayType(array);
  }
  if (convertTypedArrays && !(array instanceof ArrayType)) {
    return new ArrayType(array);
  }
  return array;
}

// ../../node_modules/.pnpm/@loaders.gl+gltf@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_draco_mesh_compression.js
var KHR_DRACO_MESH_COMPRESSION = "KHR_draco_mesh_compression";
var name7 = KHR_DRACO_MESH_COMPRESSION;
function preprocess3(gltfData, options, context) {
  const scenegraph = new GLTFScenegraph(gltfData);
  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {
    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {
    }
  }
}
async function decode6(gltfData, options, context) {
  if (!options?.gltf?.decompressMeshes) {
    return;
  }
  const scenegraph = new GLTFScenegraph(gltfData);
  const promises = [];
  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {
    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {
      promises.push(decompressPrimitive(scenegraph, primitive, options, context));
    }
  }
  await Promise.all(promises);
  scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);
}
function encode8(gltfData, options = {}) {
  const scenegraph = new GLTFScenegraph(gltfData);
  for (const mesh of scenegraph.json.meshes || []) {
    compressMesh(mesh, options);
    scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);
  }
}
async function decompressPrimitive(scenegraph, primitive, options, context) {
  const dracoExtension = scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);
  if (!dracoExtension) {
    return;
  }
  const buffer = scenegraph.getTypedArrayForBufferView(dracoExtension.bufferView);
  const bufferCopy = sliceArrayBuffer(buffer.buffer, buffer.byteOffset);
  const dracoOptions = { ...options };
  delete dracoOptions["3d-tiles"];
  const decodedData = await parseFromContext(bufferCopy, DracoLoader2, dracoOptions, context);
  const decodedAttributes = getGLTFAccessors(decodedData.attributes);
  for (const [attributeName, decodedAttribute] of Object.entries(decodedAttributes)) {
    if (attributeName in primitive.attributes) {
      const accessorIndex = primitive.attributes[attributeName];
      const accessor = scenegraph.getAccessor(accessorIndex);
      if (accessor?.min && accessor?.max) {
        decodedAttribute.min = accessor.min;
        decodedAttribute.max = accessor.max;
      }
    }
  }
  primitive.attributes = decodedAttributes;
  if (decodedData.indices) {
    primitive.indices = getGLTFAccessor(decodedData.indices);
  }
  scenegraph.removeObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);
  checkPrimitive(primitive);
}
function compressMesh(attributes, indices, mode = 4, options, context) {
  if (!options.DracoWriter) {
    throw new Error("options.gltf.DracoWriter not provided");
  }
  const compressedData = options.DracoWriter.encodeSync({ attributes });
  const decodedData = context?.parseSync?.({ attributes });
  const fauxAccessors = options._addFauxAttributes(decodedData.attributes);
  const bufferViewIndex = options.addBufferView(compressedData);
  const glTFMesh = {
    primitives: [
      {
        attributes: fauxAccessors,
        // TODO - verify with spec
        mode,
        // GL.POINTS
        extensions: {
          [KHR_DRACO_MESH_COMPRESSION]: {
            bufferView: bufferViewIndex,
            attributes: fauxAccessors
            // TODO - verify with spec
          }
        }
      }
    ]
  };
  return glTFMesh;
}
function checkPrimitive(primitive) {
  if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {
    throw new Error("glTF: Empty primitive detected: Draco decompression failure?");
  }
}
function* makeMeshPrimitiveIterator(scenegraph) {
  for (const mesh of scenegraph.json.meshes || []) {
    for (const primitive of mesh.primitives) {
      yield primitive;
    }
  }
}

// ../../node_modules/.pnpm/@loaders.gl+gltf@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_texture_transform.js
var KHR_texture_transform_exports = {};
__export(KHR_texture_transform_exports, {
  decode: () => decode7,
  name: () => name8
});

// ../../node_modules/.pnpm/@math.gl+core@4.1.0/node_modules/@math.gl/core/dist/lib/common.js
var RADIANS_TO_DEGREES = 1 / Math.PI * 180;
var DEGREES_TO_RADIANS = 1 / 180 * Math.PI;
var DEFAULT_CONFIG = {
  EPSILON: 1e-12,
  debug: false,
  precision: 4,
  printTypes: false,
  printDegrees: false,
  printRowMajor: true,
  _cartographicRadians: false
};
globalThis.mathgl = globalThis.mathgl || { config: { ...DEFAULT_CONFIG } };
var config = globalThis.mathgl.config;
function formatValue(value, { precision = config.precision } = {}) {
  value = round(value);
  return `${parseFloat(value.toPrecision(precision))}`;
}
function isArray2(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
}
function equals(a2, b4, epsilon) {
  const oldEpsilon = config.EPSILON;
  if (epsilon) {
    config.EPSILON = epsilon;
  }
  try {
    if (a2 === b4) {
      return true;
    }
    if (isArray2(a2) && isArray2(b4)) {
      if (a2.length !== b4.length) {
        return false;
      }
      for (let i = 0; i < a2.length; ++i) {
        if (!equals(a2[i], b4[i])) {
          return false;
        }
      }
      return true;
    }
    if (a2 && a2.equals) {
      return a2.equals(b4);
    }
    if (b4 && b4.equals) {
      return b4.equals(a2);
    }
    if (typeof a2 === "number" && typeof b4 === "number") {
      return Math.abs(a2 - b4) <= config.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b4));
    }
    return false;
  } finally {
    config.EPSILON = oldEpsilon;
  }
}
function round(value) {
  return Math.round(value / config.EPSILON) * config.EPSILON;
}

// ../../node_modules/.pnpm/@math.gl+core@4.1.0/node_modules/@math.gl/core/dist/classes/base/math-array.js
var MathArray = class extends Array {
  // Common methods
  /**
   * Clone the current object
   * @returns a new copy of this object
   */
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = array[i + offset];
    }
    return this.check();
  }
  toArray(targetArray = [], offset = 0) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      targetArray[offset + i] = this[i];
    }
    return targetArray;
  }
  toObject(targetObject) {
    return targetObject;
  }
  from(arrayOrObject) {
    return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : (
      // @ts-ignore
      this.fromObject(arrayOrObject)
    );
  }
  to(arrayOrObject) {
    if (arrayOrObject === this) {
      return this;
    }
    return isArray2(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
  }
  toTarget(target) {
    return target ? this.to(target) : this;
  }
  /** @deprecated */
  toFloat32Array() {
    return new Float32Array(this);
  }
  toString() {
    return this.formatString(config);
  }
  /** Formats string according to options */
  formatString(opts) {
    let string = "";
    for (let i = 0; i < this.ELEMENTS; ++i) {
      string += (i > 0 ? ", " : "") + formatValue(this[i], opts);
    }
    return `${opts.printTypes ? this.constructor.name : ""}[${string}]`;
  }
  equals(array) {
    if (!array || this.length !== array.length) {
      return false;
    }
    for (let i = 0; i < this.ELEMENTS; ++i) {
      if (!equals(this[i], array[i])) {
        return false;
      }
    }
    return true;
  }
  exactEquals(array) {
    if (!array || this.length !== array.length) {
      return false;
    }
    for (let i = 0; i < this.ELEMENTS; ++i) {
      if (this[i] !== array[i]) {
        return false;
      }
    }
    return true;
  }
  // Modifiers
  /** Negates all values in this object */
  negate() {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = -this[i];
    }
    return this.check();
  }
  lerp(a2, b4, t) {
    if (t === void 0) {
      return this.lerp(this, a2, b4);
    }
    for (let i = 0; i < this.ELEMENTS; ++i) {
      const ai = a2[i];
      const endValue = typeof b4 === "number" ? b4 : b4[i];
      this[i] = ai + t * (endValue - ai);
    }
    return this.check();
  }
  /** Minimal */
  min(vector) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = Math.min(vector[i], this[i]);
    }
    return this.check();
  }
  /** Maximal */
  max(vector) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = Math.max(vector[i], this[i]);
    }
    return this.check();
  }
  clamp(minVector, maxVector) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = Math.min(Math.max(this[i], minVector[i]), maxVector[i]);
    }
    return this.check();
  }
  add(...vectors) {
    for (const vector of vectors) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] += vector[i];
      }
    }
    return this.check();
  }
  subtract(...vectors) {
    for (const vector of vectors) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] -= vector[i];
      }
    }
    return this.check();
  }
  scale(scale3) {
    if (typeof scale3 === "number") {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] *= scale3;
      }
    } else {
      for (let i = 0; i < this.ELEMENTS && i < scale3.length; ++i) {
        this[i] *= scale3[i];
      }
    }
    return this.check();
  }
  /**
   * Multiplies all elements by `scale`
   * Note: `Matrix4.multiplyByScalar` only scales its 3x3 "minor"
   */
  multiplyByScalar(scalar) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] *= scalar;
    }
    return this.check();
  }
  // Debug checks
  /** Throws an error if array length is incorrect or contains illegal values */
  check() {
    if (config.debug && !this.validate()) {
      throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);
    }
    return this;
  }
  /** Returns false if the array length is incorrect or contains illegal values */
  validate() {
    let valid = this.length === this.ELEMENTS;
    for (let i = 0; i < this.ELEMENTS; ++i) {
      valid = valid && Number.isFinite(this[i]);
    }
    return valid;
  }
  // three.js compatibility
  /** @deprecated */
  sub(a2) {
    return this.subtract(a2);
  }
  /** @deprecated */
  setScalar(a2) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = a2;
    }
    return this.check();
  }
  /** @deprecated */
  addScalar(a2) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] += a2;
    }
    return this.check();
  }
  /** @deprecated */
  subScalar(a2) {
    return this.addScalar(-a2);
  }
  /** @deprecated */
  multiplyScalar(scalar) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] *= scalar;
    }
    return this.check();
  }
  /** @deprecated */
  divideScalar(a2) {
    return this.multiplyByScalar(1 / a2);
  }
  /** @deprecated */
  clampScalar(min, max) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = Math.min(Math.max(this[i], min), max);
    }
    return this.check();
  }
  /** @deprecated */
  get elements() {
    return this;
  }
};

// ../../node_modules/.pnpm/@math.gl+core@4.1.0/node_modules/@math.gl/core/dist/lib/validators.js
function validateVector(v, length) {
  if (v.length !== length) {
    return false;
  }
  for (let i = 0; i < v.length; ++i) {
    if (!Number.isFinite(v[i])) {
      return false;
    }
  }
  return true;
}
function checkNumber(value) {
  if (!Number.isFinite(value)) {
    throw new Error(`Invalid number ${JSON.stringify(value)}`);
  }
  return value;
}
function checkVector(v, length, callerName = "") {
  if (config.debug && !validateVector(v, length)) {
    throw new Error(`math.gl: ${callerName} some fields set to invalid numbers'`);
  }
  return v;
}

// ../../node_modules/.pnpm/@math.gl+core@4.1.0/node_modules/@math.gl/core/dist/lib/assert.js
function assert5(condition, message) {
  if (!condition) {
    throw new Error(`math.gl assertion ${message}`);
  }
}

// ../../node_modules/.pnpm/@math.gl+core@4.1.0/node_modules/@math.gl/core/dist/classes/base/vector.js
var Vector = class extends MathArray {
  // ACCESSORS
  get x() {
    return this[0];
  }
  set x(value) {
    this[0] = checkNumber(value);
  }
  get y() {
    return this[1];
  }
  set y(value) {
    this[1] = checkNumber(value);
  }
  /**
   * Returns the length of the vector from the origin to the point described by this vector
   *
   * @note `length` is a reserved word for Arrays, so `v.length()` will return number of elements
   * Instead we provide `len` and `magnitude`
   */
  len() {
    return Math.sqrt(this.lengthSquared());
  }
  /**
   * Returns the length of the vector from the origin to the point described by this vector
   */
  magnitude() {
    return this.len();
  }
  /**
   * Returns the squared length of the vector from the origin to the point described by this vector
   */
  lengthSquared() {
    let length = 0;
    for (let i = 0; i < this.ELEMENTS; ++i) {
      length += this[i] * this[i];
    }
    return length;
  }
  /**
   * Returns the squared length of the vector from the origin to the point described by this vector
   */
  magnitudeSquared() {
    return this.lengthSquared();
  }
  distance(mathArray) {
    return Math.sqrt(this.distanceSquared(mathArray));
  }
  distanceSquared(mathArray) {
    let length = 0;
    for (let i = 0; i < this.ELEMENTS; ++i) {
      const dist = this[i] - mathArray[i];
      length += dist * dist;
    }
    return checkNumber(length);
  }
  dot(mathArray) {
    let product = 0;
    for (let i = 0; i < this.ELEMENTS; ++i) {
      product += this[i] * mathArray[i];
    }
    return checkNumber(product);
  }
  // MODIFIERS
  normalize() {
    const length = this.magnitude();
    if (length !== 0) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] /= length;
      }
    }
    return this.check();
  }
  multiply(...vectors) {
    for (const vector of vectors) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] *= vector[i];
      }
    }
    return this.check();
  }
  divide(...vectors) {
    for (const vector of vectors) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] /= vector[i];
      }
    }
    return this.check();
  }
  // THREE.js compatibility
  lengthSq() {
    return this.lengthSquared();
  }
  distanceTo(vector) {
    return this.distance(vector);
  }
  distanceToSquared(vector) {
    return this.distanceSquared(vector);
  }
  getComponent(i) {
    assert5(i >= 0 && i < this.ELEMENTS, "index is out of range");
    return checkNumber(this[i]);
  }
  setComponent(i, value) {
    assert5(i >= 0 && i < this.ELEMENTS, "index is out of range");
    this[i] = value;
    return this.check();
  }
  addVectors(a2, b4) {
    return this.copy(a2).add(b4);
  }
  subVectors(a2, b4) {
    return this.copy(a2).subtract(b4);
  }
  multiplyVectors(a2, b4) {
    return this.copy(a2).multiply(b4);
  }
  addScaledVector(a2, b4) {
    return this.add(new this.constructor(a2).multiplyScalar(b4));
  }
};

// ../../node_modules/.pnpm/@math.gl+core@4.1.0/node_modules/@math.gl/core/dist/gl-matrix/common.js
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var degree = Math.PI / 180;

// ../../node_modules/.pnpm/@math.gl+core@4.1.0/node_modules/@math.gl/core/dist/gl-matrix/vec2.js
function create() {
  const out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function transformMat3(out, a2, m) {
  const x = a2[0];
  const y = a2[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
var forEach2 = function() {
  const vec = create();
  return function(a2, stride, offset, count, fn, arg) {
    let i;
    let l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a2.length);
    } else {
      l = a2.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a2[i];
      vec[1] = a2[i + 1];
      fn(vec, vec, arg);
      a2[i] = vec[0];
      a2[i + 1] = vec[1];
    }
    return a2;
  };
}();

// ../../node_modules/.pnpm/@math.gl+core@4.1.0/node_modules/@math.gl/core/dist/lib/gl-matrix-extras.js
function vec3_transformMat4AsVector(out, a2, m) {
  const x = a2[0];
  const y = a2[1];
  const z = a2[2];
  const w = m[3] * x + m[7] * y + m[11] * z || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z) / w;
  return out;
}
function vec3_transformMat2(out, a2, m) {
  const x = a2[0];
  const y = a2[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  out[2] = a2[2];
  return out;
}
function vec4_transformMat3(out, a2, m) {
  const x = a2[0];
  const y = a2[1];
  const z = a2[2];
  out[0] = m[0] * x + m[3] * y + m[6] * z;
  out[1] = m[1] * x + m[4] * y + m[7] * z;
  out[2] = m[2] * x + m[5] * y + m[8] * z;
  out[3] = a2[3];
  return out;
}

// ../../node_modules/.pnpm/@math.gl+core@4.1.0/node_modules/@math.gl/core/dist/gl-matrix/vec3.js
function create2() {
  const out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function dot2(a2, b4) {
  return a2[0] * b4[0] + a2[1] * b4[1] + a2[2] * b4[2];
}
function cross2(out, a2, b4) {
  const ax = a2[0];
  const ay = a2[1];
  const az = a2[2];
  const bx = b4[0];
  const by = b4[1];
  const bz = b4[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function transformMat4(out, a2, m) {
  const x = a2[0];
  const y = a2[1];
  const z = a2[2];
  let w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
function transformMat32(out, a2, m) {
  const x = a2[0];
  const y = a2[1];
  const z = a2[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
function transformQuat(out, a2, q) {
  const qx = q[0];
  const qy = q[1];
  const qz = q[2];
  const qw = q[3];
  const x = a2[0];
  const y = a2[1];
  const z = a2[2];
  let uvx = qy * z - qz * y;
  let uvy = qz * x - qx * z;
  let uvz = qx * y - qy * x;
  let uuvx = qy * uvz - qz * uvy;
  let uuvy = qz * uvx - qx * uvz;
  let uuvz = qx * uvy - qy * uvx;
  const w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
function rotateX(out, a2, b4, rad) {
  const p = [];
  const r = [];
  p[0] = a2[0] - b4[0];
  p[1] = a2[1] - b4[1];
  p[2] = a2[2] - b4[2];
  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
  out[0] = r[0] + b4[0];
  out[1] = r[1] + b4[1];
  out[2] = r[2] + b4[2];
  return out;
}
function rotateY(out, a2, b4, rad) {
  const p = [];
  const r = [];
  p[0] = a2[0] - b4[0];
  p[1] = a2[1] - b4[1];
  p[2] = a2[2] - b4[2];
  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
  out[0] = r[0] + b4[0];
  out[1] = r[1] + b4[1];
  out[2] = r[2] + b4[2];
  return out;
}
function rotateZ(out, a2, b4, rad) {
  const p = [];
  const r = [];
  p[0] = a2[0] - b4[0];
  p[1] = a2[1] - b4[1];
  p[2] = a2[2] - b4[2];
  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2];
  out[0] = r[0] + b4[0];
  out[1] = r[1] + b4[1];
  out[2] = r[2] + b4[2];
  return out;
}
function angle(a2, b4) {
  const ax = a2[0];
  const ay = a2[1];
  const az = a2[2];
  const bx = b4[0];
  const by = b4[1];
  const bz = b4[2];
  const mag = Math.sqrt((ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz));
  const cosine = mag && dot2(a2, b4) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
var forEach3 = function() {
  const vec = create2();
  return function(a2, stride, offset, count, fn, arg) {
    let i;
    let l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a2.length);
    } else {
      l = a2.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a2[i];
      vec[1] = a2[i + 1];
      vec[2] = a2[i + 2];
      fn(vec, vec, arg);
      a2[i] = vec[0];
      a2[i + 1] = vec[1];
      a2[i + 2] = vec[2];
    }
    return a2;
  };
}();

// ../../node_modules/.pnpm/@math.gl+core@4.1.0/node_modules/@math.gl/core/dist/classes/vector3.js
var ORIGIN = [0, 0, 0];
var ZERO;
var Vector3 = class _Vector3 extends Vector {
  static get ZERO() {
    if (!ZERO) {
      ZERO = new _Vector3(0, 0, 0);
      Object.freeze(ZERO);
    }
    return ZERO;
  }
  /**
   * @class
   * @param x
   * @param y
   * @param z
   */
  constructor(x = 0, y = 0, z = 0) {
    super(-0, -0, -0);
    if (arguments.length === 1 && isArray2(x)) {
      this.copy(x);
    } else {
      if (config.debug) {
        checkNumber(x);
        checkNumber(y);
        checkNumber(z);
      }
      this[0] = x;
      this[1] = y;
      this[2] = z;
    }
  }
  set(x, y, z) {
    this[0] = x;
    this[1] = y;
    this[2] = z;
    return this.check();
  }
  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    return this.check();
  }
  fromObject(object) {
    if (config.debug) {
      checkNumber(object.x);
      checkNumber(object.y);
      checkNumber(object.z);
    }
    this[0] = object.x;
    this[1] = object.y;
    this[2] = object.z;
    return this.check();
  }
  toObject(object) {
    object.x = this[0];
    object.y = this[1];
    object.z = this[2];
    return object;
  }
  // Getters/setters
  get ELEMENTS() {
    return 3;
  }
  get z() {
    return this[2];
  }
  set z(value) {
    this[2] = checkNumber(value);
  }
  // ACCESSORS
  angle(vector) {
    return angle(this, vector);
  }
  // MODIFIERS
  cross(vector) {
    cross2(this, this, vector);
    return this.check();
  }
  rotateX({ radians, origin = ORIGIN }) {
    rotateX(this, this, origin, radians);
    return this.check();
  }
  rotateY({ radians, origin = ORIGIN }) {
    rotateY(this, this, origin, radians);
    return this.check();
  }
  rotateZ({ radians, origin = ORIGIN }) {
    rotateZ(this, this, origin, radians);
    return this.check();
  }
  // Transforms
  // transforms as point (4th component is implicitly 1)
  transform(matrix4) {
    return this.transformAsPoint(matrix4);
  }
  // transforms as point (4th component is implicitly 1)
  transformAsPoint(matrix4) {
    transformMat4(this, this, matrix4);
    return this.check();
  }
  // transforms as vector  (4th component is implicitly 0, ignores translation. slightly faster)
  transformAsVector(matrix4) {
    vec3_transformMat4AsVector(this, this, matrix4);
    return this.check();
  }
  transformByMatrix3(matrix3) {
    transformMat32(this, this, matrix3);
    return this.check();
  }
  transformByMatrix2(matrix2) {
    vec3_transformMat2(this, this, matrix2);
    return this.check();
  }
  transformByQuaternion(quaternion) {
    transformQuat(this, this, quaternion);
    return this.check();
  }
};

// ../../node_modules/.pnpm/@math.gl+core@4.1.0/node_modules/@math.gl/core/dist/classes/base/matrix.js
var Matrix = class extends MathArray {
  // fromObject(object) {
  //   const array = object.elements;
  //   return this.fromRowMajor(array);
  // }
  // toObject(object) {
  //   const array = object.elements;
  //   this.toRowMajor(array);
  //   return object;
  // }
  // TODO better override formatString?
  toString() {
    let string = "[";
    if (config.printRowMajor) {
      string += "row-major:";
      for (let row = 0; row < this.RANK; ++row) {
        for (let col = 0; col < this.RANK; ++col) {
          string += ` ${this[col * this.RANK + row]}`;
        }
      }
    } else {
      string += "column-major:";
      for (let i = 0; i < this.ELEMENTS; ++i) {
        string += ` ${this[i]}`;
      }
    }
    string += "]";
    return string;
  }
  getElementIndex(row, col) {
    return col * this.RANK + row;
  }
  // By default assumes row major indices
  getElement(row, col) {
    return this[col * this.RANK + row];
  }
  // By default assumes row major indices
  setElement(row, col, value) {
    this[col * this.RANK + row] = checkNumber(value);
    return this;
  }
  getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {
    const firstIndex = columnIndex * this.RANK;
    for (let i = 0; i < this.RANK; ++i) {
      result[i] = this[firstIndex + i];
    }
    return result;
  }
  setColumn(columnIndex, columnVector) {
    const firstIndex = columnIndex * this.RANK;
    for (let i = 0; i < this.RANK; ++i) {
      this[firstIndex + i] = columnVector[i];
    }
    return this;
  }
};

// ../../node_modules/.pnpm/@math.gl+core@4.1.0/node_modules/@math.gl/core/dist/gl-matrix/mat3.js
function transpose(out, a2) {
  if (out === a2) {
    const a01 = a2[1];
    const a02 = a2[2];
    const a12 = a2[5];
    out[1] = a2[3];
    out[2] = a2[6];
    out[3] = a01;
    out[5] = a2[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a2[0];
    out[1] = a2[3];
    out[2] = a2[6];
    out[3] = a2[1];
    out[4] = a2[4];
    out[5] = a2[7];
    out[6] = a2[2];
    out[7] = a2[5];
    out[8] = a2[8];
  }
  return out;
}
function invert(out, a2) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a10 = a2[3];
  const a11 = a2[4];
  const a12 = a2[5];
  const a20 = a2[6];
  const a21 = a2[7];
  const a22 = a2[8];
  const b01 = a22 * a11 - a12 * a21;
  const b11 = -a22 * a10 + a12 * a20;
  const b21 = a21 * a10 - a11 * a20;
  let det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
function determinant(a2) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a10 = a2[3];
  const a11 = a2[4];
  const a12 = a2[5];
  const a20 = a2[6];
  const a21 = a2[7];
  const a22 = a2[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
function multiply(out, a2, b4) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a10 = a2[3];
  const a11 = a2[4];
  const a12 = a2[5];
  const a20 = a2[6];
  const a21 = a2[7];
  const a22 = a2[8];
  const b00 = b4[0];
  const b01 = b4[1];
  const b02 = b4[2];
  const b10 = b4[3];
  const b11 = b4[4];
  const b12 = b4[5];
  const b20 = b4[6];
  const b21 = b4[7];
  const b22 = b4[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function translate2(out, a2, v) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a10 = a2[3];
  const a11 = a2[4];
  const a12 = a2[5];
  const a20 = a2[6];
  const a21 = a2[7];
  const a22 = a2[8];
  const x = v[0];
  const y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
function rotate(out, a2, rad) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a10 = a2[3];
  const a11 = a2[4];
  const a12 = a2[5];
  const a20 = a2[6];
  const a21 = a2[7];
  const a22 = a2[8];
  const s = Math.sin(rad);
  const c2 = Math.cos(rad);
  out[0] = c2 * a00 + s * a10;
  out[1] = c2 * a01 + s * a11;
  out[2] = c2 * a02 + s * a12;
  out[3] = c2 * a10 - s * a00;
  out[4] = c2 * a11 - s * a01;
  out[5] = c2 * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
function scale2(out, a2, v) {
  const x = v[0];
  const y = v[1];
  out[0] = x * a2[0];
  out[1] = x * a2[1];
  out[2] = x * a2[2];
  out[3] = y * a2[3];
  out[4] = y * a2[4];
  out[5] = y * a2[5];
  out[6] = a2[6];
  out[7] = a2[7];
  out[8] = a2[8];
  return out;
}
function fromQuat(out, q) {
  const x = q[0];
  const y = q[1];
  const z = q[2];
  const w = q[3];
  const x2 = x + x;
  const y2 = y + y;
  const z2 = z + z;
  const xx = x * x2;
  const yx = y * x2;
  const yy = y * y2;
  const zx = z * x2;
  const zy = z * y2;
  const zz = z * z2;
  const wx = w * x2;
  const wy = w * y2;
  const wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}

// ../../node_modules/.pnpm/@math.gl+core@4.1.0/node_modules/@math.gl/core/dist/classes/matrix3.js
var INDICES;
(function(INDICES2) {
  INDICES2[INDICES2["COL0ROW0"] = 0] = "COL0ROW0";
  INDICES2[INDICES2["COL0ROW1"] = 1] = "COL0ROW1";
  INDICES2[INDICES2["COL0ROW2"] = 2] = "COL0ROW2";
  INDICES2[INDICES2["COL1ROW0"] = 3] = "COL1ROW0";
  INDICES2[INDICES2["COL1ROW1"] = 4] = "COL1ROW1";
  INDICES2[INDICES2["COL1ROW2"] = 5] = "COL1ROW2";
  INDICES2[INDICES2["COL2ROW0"] = 6] = "COL2ROW0";
  INDICES2[INDICES2["COL2ROW1"] = 7] = "COL2ROW1";
  INDICES2[INDICES2["COL2ROW2"] = 8] = "COL2ROW2";
})(INDICES || (INDICES = {}));
var IDENTITY_MATRIX = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
var Matrix3 = class extends Matrix {
  static get IDENTITY() {
    return getIdentityMatrix();
  }
  static get ZERO() {
    return getZeroMatrix();
  }
  get ELEMENTS() {
    return 9;
  }
  get RANK() {
    return 3;
  }
  get INDICES() {
    return INDICES;
  }
  constructor(array, ...args) {
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0);
    if (arguments.length === 1 && Array.isArray(array)) {
      this.copy(array);
    } else if (args.length > 0) {
      this.copy([array, ...args]);
    } else {
      this.identity();
    }
  }
  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    this[3] = array[3];
    this[4] = array[4];
    this[5] = array[5];
    this[6] = array[6];
    this[7] = array[7];
    this[8] = array[8];
    return this.check();
  }
  // Constructors
  identity() {
    return this.copy(IDENTITY_MATRIX);
  }
  /**
   *
   * @param object
   * @returns self
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  fromObject(object) {
    return this.check();
  }
  /** Calculates a 3x3 matrix from the given quaternion
   * q quat  Quaternion to create matrix from
   */
  fromQuaternion(q) {
    fromQuat(this, q);
    return this.check();
  }
  /**
   * accepts column major order, stores in column major order
   */
  // eslint-disable-next-line max-params
  set(m00, m10, m20, m01, m11, m21, m02, m12, m22) {
    this[0] = m00;
    this[1] = m10;
    this[2] = m20;
    this[3] = m01;
    this[4] = m11;
    this[5] = m21;
    this[6] = m02;
    this[7] = m12;
    this[8] = m22;
    return this.check();
  }
  /**
   * accepts row major order, stores as column major
   */
  // eslint-disable-next-line max-params
  setRowMajor(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    this[0] = m00;
    this[1] = m10;
    this[2] = m20;
    this[3] = m01;
    this[4] = m11;
    this[5] = m21;
    this[6] = m02;
    this[7] = m12;
    this[8] = m22;
    return this.check();
  }
  // Accessors
  determinant() {
    return determinant(this);
  }
  // Modifiers
  transpose() {
    transpose(this, this);
    return this.check();
  }
  /** Invert a matrix. Note that this can fail if the matrix is not invertible */
  invert() {
    invert(this, this);
    return this.check();
  }
  // Operations
  multiplyLeft(a2) {
    multiply(this, a2, this);
    return this.check();
  }
  multiplyRight(a2) {
    multiply(this, this, a2);
    return this.check();
  }
  rotate(radians) {
    rotate(this, this, radians);
    return this.check();
  }
  scale(factor) {
    if (Array.isArray(factor)) {
      scale2(this, this, factor);
    } else {
      scale2(this, this, [factor, factor]);
    }
    return this.check();
  }
  translate(vec) {
    translate2(this, this, vec);
    return this.check();
  }
  // Transforms
  transform(vector, result) {
    let out;
    switch (vector.length) {
      case 2:
        out = transformMat3(result || [-0, -0], vector, this);
        break;
      case 3:
        out = transformMat32(result || [-0, -0, -0], vector, this);
        break;
      case 4:
        out = vec4_transformMat3(result || [-0, -0, -0, -0], vector, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    checkVector(out, vector.length);
    return out;
  }
  /** @deprecated */
  transformVector(vector, result) {
    return this.transform(vector, result);
  }
  /** @deprecated */
  transformVector2(vector, result) {
    return this.transform(vector, result);
  }
  /** @deprecated */
  transformVector3(vector, result) {
    return this.transform(vector, result);
  }
};
var ZERO_MATRIX3;
var IDENTITY_MATRIX3 = null;
function getZeroMatrix() {
  if (!ZERO_MATRIX3) {
    ZERO_MATRIX3 = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);
    Object.freeze(ZERO_MATRIX3);
  }
  return ZERO_MATRIX3;
}
function getIdentityMatrix() {
  if (!IDENTITY_MATRIX3) {
    IDENTITY_MATRIX3 = new Matrix3();
    Object.freeze(IDENTITY_MATRIX3);
  }
  return IDENTITY_MATRIX3;
}

// ../../node_modules/.pnpm/@loaders.gl+gltf@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_texture_transform.js
var KHR_TEXTURE_TRANSFORM = "KHR_texture_transform";
var name8 = KHR_TEXTURE_TRANSFORM;
var scratchVector = new Vector3();
var scratchRotationMatrix = new Matrix3();
var scratchScaleMatrix = new Matrix3();
async function decode7(gltfData, options) {
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const hasExtension = gltfScenegraph.hasExtension(KHR_TEXTURE_TRANSFORM);
  if (!hasExtension || !options.gltf?.loadBuffers) {
    return;
  }
  const materials = gltfData.json.materials || [];
  for (let i = 0; i < materials.length; i++) {
    transformTexCoords(i, gltfData);
  }
}
function transformTexCoords(materialIndex, gltfData) {
  const material = gltfData.json.materials?.[materialIndex];
  const materialTextures = [
    material?.pbrMetallicRoughness?.baseColorTexture,
    material?.emissiveTexture,
    material?.normalTexture,
    material?.occlusionTexture,
    material?.pbrMetallicRoughness?.metallicRoughnessTexture
  ];
  const processedTexCoords = [];
  for (const textureInfo of materialTextures) {
    if (textureInfo && textureInfo?.extensions?.[KHR_TEXTURE_TRANSFORM]) {
      transformPrimitives(gltfData, materialIndex, textureInfo, processedTexCoords);
    }
  }
}
function transformPrimitives(gltfData, materialIndex, texture, processedTexCoords) {
  const transformParameters = getTransformParameters(texture, processedTexCoords);
  if (!transformParameters) {
    return;
  }
  const meshes = gltfData.json.meshes || [];
  for (const mesh of meshes) {
    for (const primitive of mesh.primitives) {
      const material = primitive.material;
      if (Number.isFinite(material) && materialIndex === material) {
        transformPrimitive(gltfData, primitive, transformParameters);
      }
    }
  }
}
function getTransformParameters(texture, processedTexCoords) {
  const textureInfo = texture.extensions?.[KHR_TEXTURE_TRANSFORM];
  const { texCoord: originalTexCoord = 0 } = texture;
  const { texCoord = originalTexCoord } = textureInfo;
  const isProcessed = processedTexCoords.findIndex(([original, newTexCoord]) => original === originalTexCoord && newTexCoord === texCoord) !== -1;
  if (!isProcessed) {
    const matrix = makeTransformationMatrix(textureInfo);
    if (originalTexCoord !== texCoord) {
      texture.texCoord = texCoord;
    }
    processedTexCoords.push([originalTexCoord, texCoord]);
    return { originalTexCoord, texCoord, matrix };
  }
  return null;
}
function transformPrimitive(gltfData, primitive, transformParameters) {
  const { originalTexCoord, texCoord, matrix } = transformParameters;
  const texCoordAccessor = primitive.attributes[`TEXCOORD_${originalTexCoord}`];
  if (Number.isFinite(texCoordAccessor)) {
    const accessor = gltfData.json.accessors?.[texCoordAccessor];
    if (accessor && accessor.bufferView) {
      const bufferView = gltfData.json.bufferViews?.[accessor.bufferView];
      if (bufferView) {
        const { arrayBuffer, byteOffset: bufferByteOffset } = gltfData.buffers[bufferView.buffer];
        const byteOffset = (bufferByteOffset || 0) + (accessor.byteOffset || 0) + (bufferView.byteOffset || 0);
        const { ArrayType, length } = getAccessorArrayTypeAndLength(accessor, bufferView);
        const bytes = BYTES[accessor.componentType];
        const components = COMPONENTS[accessor.type];
        const elementAddressScale = bufferView.byteStride || bytes * components;
        const result = new Float32Array(length);
        for (let i = 0; i < accessor.count; i++) {
          const uv = new ArrayType(arrayBuffer, byteOffset + i * elementAddressScale, 2);
          scratchVector.set(uv[0], uv[1], 1);
          scratchVector.transformByMatrix3(matrix);
          result.set([scratchVector[0], scratchVector[1]], i * components);
        }
        if (originalTexCoord === texCoord) {
          updateGltf(accessor, bufferView, gltfData.buffers, result);
        } else {
          createAttribute(texCoord, accessor, primitive, gltfData, result);
        }
      }
    }
  }
}
function updateGltf(accessor, bufferView, buffers, newTexCoordArray) {
  accessor.componentType = 5126;
  buffers.push({
    arrayBuffer: newTexCoordArray.buffer,
    byteOffset: 0,
    byteLength: newTexCoordArray.buffer.byteLength
  });
  bufferView.buffer = buffers.length - 1;
  bufferView.byteLength = newTexCoordArray.buffer.byteLength;
  bufferView.byteOffset = 0;
  delete bufferView.byteStride;
}
function createAttribute(newTexCoord, originalAccessor, primitive, gltfData, newTexCoordArray) {
  gltfData.buffers.push({
    arrayBuffer: newTexCoordArray.buffer,
    byteOffset: 0,
    byteLength: newTexCoordArray.buffer.byteLength
  });
  const bufferViews = gltfData.json.bufferViews;
  if (!bufferViews) {
    return;
  }
  bufferViews.push({
    buffer: gltfData.buffers.length - 1,
    byteLength: newTexCoordArray.buffer.byteLength,
    byteOffset: 0
  });
  const accessors = gltfData.json.accessors;
  if (!accessors) {
    return;
  }
  accessors.push({
    bufferView: bufferViews?.length - 1,
    byteOffset: 0,
    componentType: 5126,
    count: originalAccessor.count,
    type: "VEC2"
  });
  primitive.attributes[`TEXCOORD_${newTexCoord}`] = accessors.length - 1;
}
function makeTransformationMatrix(extensionData) {
  const { offset = [0, 0], rotation = 0, scale: scale3 = [1, 1] } = extensionData;
  const translationMatrix = new Matrix3().set(1, 0, 0, 0, 1, 0, offset[0], offset[1], 1);
  const rotationMatrix = scratchRotationMatrix.set(Math.cos(rotation), Math.sin(rotation), 0, -Math.sin(rotation), Math.cos(rotation), 0, 0, 0, 1);
  const scaleMatrix = scratchScaleMatrix.set(scale3[0], 0, 0, 0, scale3[1], 0, 0, 0, 1);
  return translationMatrix.multiplyRight(rotationMatrix).multiplyRight(scaleMatrix);
}

// ../../node_modules/.pnpm/@loaders.gl+gltf@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/gltf/dist/lib/extensions/deprecated/KHR_lights_punctual.js
var KHR_lights_punctual_exports = {};
__export(KHR_lights_punctual_exports, {
  decode: () => decode8,
  encode: () => encode9,
  name: () => name9
});
var KHR_LIGHTS_PUNCTUAL = "KHR_lights_punctual";
var name9 = KHR_LIGHTS_PUNCTUAL;
async function decode8(gltfData) {
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const { json } = gltfScenegraph;
  const extension = gltfScenegraph.getExtension(KHR_LIGHTS_PUNCTUAL);
  if (extension) {
    gltfScenegraph.json.lights = extension.lights;
    gltfScenegraph.removeExtension(KHR_LIGHTS_PUNCTUAL);
  }
  for (const node of json.nodes || []) {
    const nodeExtension = gltfScenegraph.getObjectExtension(node, KHR_LIGHTS_PUNCTUAL);
    if (nodeExtension) {
      node.light = nodeExtension.light;
    }
    gltfScenegraph.removeObjectExtension(node, KHR_LIGHTS_PUNCTUAL);
  }
}
async function encode9(gltfData) {
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const { json } = gltfScenegraph;
  if (json.lights) {
    const extension = gltfScenegraph.addExtension(KHR_LIGHTS_PUNCTUAL);
    assert4(!extension.lights);
    extension.lights = json.lights;
    delete json.lights;
  }
  if (gltfScenegraph.json.lights) {
    for (const light of gltfScenegraph.json.lights) {
      const node = light.node;
      gltfScenegraph.addObjectExtension(node, KHR_LIGHTS_PUNCTUAL, light);
    }
    delete gltfScenegraph.json.lights;
  }
}

// ../../node_modules/.pnpm/@loaders.gl+gltf@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/gltf/dist/lib/extensions/deprecated/KHR_materials_unlit.js
var KHR_materials_unlit_exports = {};
__export(KHR_materials_unlit_exports, {
  decode: () => decode9,
  encode: () => encode10,
  name: () => name10
});
var KHR_MATERIALS_UNLIT = "KHR_materials_unlit";
var name10 = KHR_MATERIALS_UNLIT;
async function decode9(gltfData) {
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const { json } = gltfScenegraph;
  for (const material of json.materials || []) {
    const extension = material.extensions && material.extensions.KHR_materials_unlit;
    if (extension) {
      material.unlit = true;
    }
    gltfScenegraph.removeObjectExtension(material, KHR_MATERIALS_UNLIT);
  }
  gltfScenegraph.removeExtension(KHR_MATERIALS_UNLIT);
}
function encode10(gltfData) {
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const { json } = gltfScenegraph;
  if (gltfScenegraph.materials) {
    for (const material of json.materials || []) {
      if (material.unlit) {
        delete material.unlit;
        gltfScenegraph.addObjectExtension(material, KHR_MATERIALS_UNLIT, {});
        gltfScenegraph.addExtension(KHR_MATERIALS_UNLIT);
      }
    }
  }
}

// ../../node_modules/.pnpm/@loaders.gl+gltf@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/gltf/dist/lib/extensions/deprecated/KHR_techniques_webgl.js
var KHR_techniques_webgl_exports = {};
__export(KHR_techniques_webgl_exports, {
  decode: () => decode10,
  encode: () => encode11,
  name: () => name11
});
var KHR_TECHNIQUES_WEBGL = "KHR_techniques_webgl";
var name11 = KHR_TECHNIQUES_WEBGL;
async function decode10(gltfData) {
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const { json } = gltfScenegraph;
  const extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);
  if (extension) {
    const techniques = resolveTechniques(extension, gltfScenegraph);
    for (const material of json.materials || []) {
      const materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);
      if (materialExtension) {
        material.technique = Object.assign(
          {},
          materialExtension,
          // @ts-ignore
          techniques[materialExtension.technique]
        );
        material.technique.values = resolveValues(material.technique, gltfScenegraph);
      }
      gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);
    }
    gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);
  }
}
async function encode11(gltfData, options) {
}
function resolveTechniques(techniquesExtension, gltfScenegraph) {
  const { programs = [], shaders = [], techniques = [] } = techniquesExtension;
  const textDecoder = new TextDecoder();
  shaders.forEach((shader) => {
    if (Number.isFinite(shader.bufferView)) {
      shader.code = textDecoder.decode(gltfScenegraph.getTypedArrayForBufferView(shader.bufferView));
    } else {
      throw new Error("KHR_techniques_webgl: no shader code");
    }
  });
  programs.forEach((program) => {
    program.fragmentShader = shaders[program.fragmentShader];
    program.vertexShader = shaders[program.vertexShader];
  });
  techniques.forEach((technique) => {
    technique.program = programs[technique.program];
  });
  return techniques;
}
function resolveValues(technique, gltfScenegraph) {
  const values = Object.assign({}, technique.values);
  Object.keys(technique.uniforms || {}).forEach((uniform) => {
    if (technique.uniforms[uniform].value && !(uniform in values)) {
      values[uniform] = technique.uniforms[uniform].value;
    }
  });
  Object.keys(values).forEach((uniform) => {
    if (typeof values[uniform] === "object" && values[uniform].index !== void 0) {
      values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);
    }
  });
  return values;
}

// ../../node_modules/.pnpm/@loaders.gl+gltf@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/gltf/dist/lib/api/gltf-extensions.js
var EXTENSIONS2 = [
  // 1.0
  // KHR_binary_gltf is handled separately - must be processed before other parsing starts
  // KHR_binary_gltf,
  // 2.0
  EXT_structural_metadata_exports,
  EXT_mesh_features_exports,
  EXT_meshopt_compression_exports,
  EXT_texture_webp_exports,
  // Basisu should come after webp, we want basisu to be preferred if both are provided
  KHR_texture_basisu_exports,
  KHR_draco_mesh_compression_exports,
  KHR_lights_punctual_exports,
  KHR_materials_unlit_exports,
  KHR_techniques_webgl_exports,
  KHR_texture_transform_exports,
  EXT_feature_metadata_exports
];
function preprocessExtensions(gltf, options = {}, context) {
  const extensions = EXTENSIONS2.filter((extension) => useExtension(extension.name, options));
  for (const extension of extensions) {
    extension.preprocess?.(gltf, options, context);
  }
}
async function decodeExtensions(gltf, options = {}, context) {
  const extensions = EXTENSIONS2.filter((extension) => useExtension(extension.name, options));
  for (const extension of extensions) {
    await extension.decode?.(gltf, options, context);
  }
}
function useExtension(extensionName, options) {
  const excludes = options?.gltf?.excludeExtensions || {};
  const exclude = extensionName in excludes && !excludes[extensionName];
  return !exclude;
}

// ../../node_modules/.pnpm/@loaders.gl+gltf@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_binary_gltf.js
var KHR_BINARY_GLTF = "KHR_binary_glTF";
function preprocess4(gltfData) {
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const { json } = gltfScenegraph;
  for (const image of json.images || []) {
    const extension = gltfScenegraph.getObjectExtension(image, KHR_BINARY_GLTF);
    if (extension) {
      Object.assign(image, extension);
    }
    gltfScenegraph.removeObjectExtension(image, KHR_BINARY_GLTF);
  }
  if (json.buffers && json.buffers[0]) {
    delete json.buffers[0].uri;
  }
  gltfScenegraph.removeExtension(KHR_BINARY_GLTF);
}

// ../../node_modules/.pnpm/@loaders.gl+gltf@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/gltf/dist/lib/api/normalize-gltf-v1.js
var GLTF_ARRAYS = {
  accessors: "accessor",
  animations: "animation",
  buffers: "buffer",
  bufferViews: "bufferView",
  images: "image",
  materials: "material",
  meshes: "mesh",
  nodes: "node",
  samplers: "sampler",
  scenes: "scene",
  skins: "skin",
  textures: "texture"
};
var GLTF_KEYS = {
  accessor: "accessors",
  animations: "animation",
  buffer: "buffers",
  bufferView: "bufferViews",
  image: "images",
  material: "materials",
  mesh: "meshes",
  node: "nodes",
  sampler: "samplers",
  scene: "scenes",
  skin: "skins",
  texture: "textures"
};
var GLTFV1Normalizer = class {
  idToIndexMap = {
    animations: {},
    accessors: {},
    buffers: {},
    bufferViews: {},
    images: {},
    materials: {},
    meshes: {},
    nodes: {},
    samplers: {},
    scenes: {},
    skins: {},
    textures: {}
  };
  json;
  // constructor() {}
  /**
   * Convert (normalize) glTF < 2.0 to glTF 2.0
   * @param gltf - object with json and binChunks
   * @param options
   * @param options normalize Whether to actually normalize
   */
  normalize(gltf, options) {
    this.json = gltf.json;
    const json = gltf.json;
    switch (json.asset && json.asset.version) {
      case "2.0":
        return;
      case void 0:
      case "1.0":
        break;
      default:
        console.warn(`glTF: Unknown version ${json.asset.version}`);
        return;
    }
    if (!options.normalize) {
      throw new Error("glTF v1 is not supported.");
    }
    console.warn("Converting glTF v1 to glTF v2 format. This is experimental and may fail.");
    this._addAsset(json);
    this._convertTopLevelObjectsToArrays(json);
    preprocess4(gltf);
    this._convertObjectIdsToArrayIndices(json);
    this._updateObjects(json);
    this._updateMaterial(json);
  }
  // asset is now required, #642 https://github.com/KhronosGroup/glTF/issues/639
  _addAsset(json) {
    json.asset = json.asset || {};
    json.asset.version = "2.0";
    json.asset.generator = json.asset.generator || "Normalized to glTF 2.0 by loaders.gl";
  }
  _convertTopLevelObjectsToArrays(json) {
    for (const arrayName in GLTF_ARRAYS) {
      this._convertTopLevelObjectToArray(json, arrayName);
    }
  }
  /** Convert one top level object to array */
  _convertTopLevelObjectToArray(json, mapName) {
    const objectMap = json[mapName];
    if (!objectMap || Array.isArray(objectMap)) {
      return;
    }
    json[mapName] = [];
    for (const id in objectMap) {
      const object = objectMap[id];
      object.id = object.id || id;
      const index = json[mapName].length;
      json[mapName].push(object);
      this.idToIndexMap[mapName][id] = index;
    }
  }
  /** Go through all objects in all top-level arrays and replace ids with indices */
  _convertObjectIdsToArrayIndices(json) {
    for (const arrayName in GLTF_ARRAYS) {
      this._convertIdsToIndices(json, arrayName);
    }
    if ("scene" in json) {
      json.scene = this._convertIdToIndex(json.scene, "scene");
    }
    for (const texture of json.textures) {
      this._convertTextureIds(texture);
    }
    for (const mesh of json.meshes) {
      this._convertMeshIds(mesh);
    }
    for (const node of json.nodes) {
      this._convertNodeIds(node);
    }
    for (const node of json.scenes) {
      this._convertSceneIds(node);
    }
  }
  _convertTextureIds(texture) {
    if (texture.source) {
      texture.source = this._convertIdToIndex(texture.source, "image");
    }
  }
  _convertMeshIds(mesh) {
    for (const primitive of mesh.primitives) {
      const { attributes, indices, material } = primitive;
      for (const attributeName in attributes) {
        attributes[attributeName] = this._convertIdToIndex(attributes[attributeName], "accessor");
      }
      if (indices) {
        primitive.indices = this._convertIdToIndex(indices, "accessor");
      }
      if (material) {
        primitive.material = this._convertIdToIndex(material, "material");
      }
    }
  }
  _convertNodeIds(node) {
    if (node.children) {
      node.children = node.children.map((child) => this._convertIdToIndex(child, "node"));
    }
    if (node.meshes) {
      node.meshes = node.meshes.map((mesh) => this._convertIdToIndex(mesh, "mesh"));
    }
  }
  _convertSceneIds(scene) {
    if (scene.nodes) {
      scene.nodes = scene.nodes.map((node) => this._convertIdToIndex(node, "node"));
    }
  }
  /** Go through all objects in a top-level array and replace ids with indices */
  _convertIdsToIndices(json, topLevelArrayName) {
    if (!json[topLevelArrayName]) {
      console.warn(`gltf v1: json doesn't contain attribute ${topLevelArrayName}`);
      json[topLevelArrayName] = [];
    }
    for (const object of json[topLevelArrayName]) {
      for (const key in object) {
        const id = object[key];
        const index = this._convertIdToIndex(id, key);
        object[key] = index;
      }
    }
  }
  _convertIdToIndex(id, key) {
    const arrayName = GLTF_KEYS[key];
    if (arrayName in this.idToIndexMap) {
      const index = this.idToIndexMap[arrayName][id];
      if (!Number.isFinite(index)) {
        throw new Error(`gltf v1: failed to resolve ${key} with id ${id}`);
      }
      return index;
    }
    return id;
  }
  /**
   *
   * @param {*} json
   */
  _updateObjects(json) {
    for (const buffer of this.json.buffers) {
      delete buffer.type;
    }
  }
  /**
   * Update material (set pbrMetallicRoughness)
   * @param {*} json
   */
  _updateMaterial(json) {
    for (const material of json.materials) {
      material.pbrMetallicRoughness = {
        baseColorFactor: [1, 1, 1, 1],
        metallicFactor: 1,
        roughnessFactor: 1
      };
      const textureId = material.values?.tex || material.values?.texture2d_0 || material.values?.diffuseTex;
      const textureIndex = json.textures.findIndex((texture) => texture.id === textureId);
      if (textureIndex !== -1) {
        material.pbrMetallicRoughness.baseColorTexture = { index: textureIndex };
      }
    }
  }
};
function normalizeGLTFV1(gltf, options = {}) {
  return new GLTFV1Normalizer().normalize(gltf, options);
}

// ../../node_modules/.pnpm/@loaders.gl+gltf@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/gltf/dist/lib/parsers/parse-gltf.js
async function parseGLTF(gltf, arrayBufferOrString, byteOffset = 0, options, context) {
  parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);
  normalizeGLTFV1(gltf, { normalize: options?.gltf?.normalize });
  preprocessExtensions(gltf, options, context);
  if (options?.gltf?.loadBuffers && gltf.json.buffers) {
    await loadBuffers(gltf, options, context);
  }
  if (options?.gltf?.loadImages) {
    await loadImages(gltf, options, context);
  }
  await decodeExtensions(gltf, options, context);
  return gltf;
}
function parseGLTFContainerSync(gltf, data, byteOffset, options) {
  if (options.uri) {
    gltf.baseUri = options.uri;
  }
  if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {
    const textDecoder = new TextDecoder();
    data = textDecoder.decode(data);
  }
  if (typeof data === "string") {
    gltf.json = parseJSON(data);
  } else if (data instanceof ArrayBuffer) {
    const glb = {};
    byteOffset = parseGLBSync(glb, data, byteOffset, options.glb);
    assert4(glb.type === "glTF", `Invalid GLB magic string ${glb.type}`);
    gltf._glb = glb;
    gltf.json = glb.json;
  } else {
    assert4(false, "GLTF: must be ArrayBuffer or string");
  }
  const buffers = gltf.json.buffers || [];
  gltf.buffers = new Array(buffers.length).fill(null);
  if (gltf._glb && gltf._glb.header.hasBinChunk) {
    const { binChunks } = gltf._glb;
    gltf.buffers[0] = {
      arrayBuffer: binChunks[0].arrayBuffer,
      byteOffset: binChunks[0].byteOffset,
      byteLength: binChunks[0].byteLength
    };
  }
  const images = gltf.json.images || [];
  gltf.images = new Array(images.length).fill({});
}
async function loadBuffers(gltf, options, context) {
  const buffers = gltf.json.buffers || [];
  for (let i = 0; i < buffers.length; ++i) {
    const buffer = buffers[i];
    if (buffer.uri) {
      const { fetch: fetch2 } = context;
      assert4(fetch2);
      const uri = resolveUrl(buffer.uri, options);
      const response = await context?.fetch?.(uri);
      const arrayBuffer = await response?.arrayBuffer?.();
      gltf.buffers[i] = {
        arrayBuffer,
        byteOffset: 0,
        byteLength: arrayBuffer.byteLength
      };
      delete buffer.uri;
    } else if (gltf.buffers[i] === null) {
      gltf.buffers[i] = {
        arrayBuffer: new ArrayBuffer(buffer.byteLength),
        byteOffset: 0,
        byteLength: buffer.byteLength
      };
    }
  }
}
async function loadImages(gltf, options, context) {
  const imageIndices = getReferencesImageIndices(gltf);
  const images = gltf.json.images || [];
  const promises = [];
  for (const imageIndex of imageIndices) {
    promises.push(loadImage(gltf, images[imageIndex], imageIndex, options, context));
  }
  return await Promise.all(promises);
}
function getReferencesImageIndices(gltf) {
  const imageIndices = /* @__PURE__ */ new Set();
  const textures = gltf.json.textures || [];
  for (const texture of textures) {
    if (texture.source !== void 0) {
      imageIndices.add(texture.source);
    }
  }
  return Array.from(imageIndices).sort();
}
async function loadImage(gltf, image, index, options, context) {
  let arrayBuffer;
  if (image.uri && !image.hasOwnProperty("bufferView")) {
    const uri = resolveUrl(image.uri, options);
    const { fetch: fetch2 } = context;
    const response = await fetch2(uri);
    arrayBuffer = await response.arrayBuffer();
    image.bufferView = {
      data: arrayBuffer
    };
  }
  if (Number.isFinite(image.bufferView)) {
    const array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);
    arrayBuffer = sliceArrayBuffer(array.buffer, array.byteOffset, array.byteLength);
  }
  assert4(arrayBuffer, "glTF image has no data");
  let parsedImage = await parseFromContext(arrayBuffer, [ImageLoader, BasisLoader], {
    ...options,
    mimeType: image.mimeType,
    basis: options.basis || { format: selectSupportedBasisFormat() }
  }, context);
  if (parsedImage && parsedImage[0]) {
    parsedImage = {
      compressed: true,
      // @ts-expect-error
      mipmaps: false,
      width: parsedImage[0].width,
      height: parsedImage[0].height,
      data: parsedImage[0]
    };
  }
  gltf.images = gltf.images || [];
  gltf.images[index] = parsedImage;
}

// ../../node_modules/.pnpm/@loaders.gl+gltf@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/gltf/dist/gltf-loader.js
var GLTFLoader = {
  dataType: null,
  batchType: null,
  name: "glTF",
  id: "gltf",
  module: "gltf",
  version: VERSION6,
  extensions: ["gltf", "glb"],
  mimeTypes: ["model/gltf+json", "model/gltf-binary"],
  text: true,
  binary: true,
  tests: ["glTF"],
  parse: parse9,
  options: {
    gltf: {
      normalize: true,
      // Normalize glTF v1 to glTF v2 format (not yet stable)
      loadBuffers: true,
      // Fetch any linked .BIN buffers, decode base64
      loadImages: true,
      // Create image objects
      decompressMeshes: true
      // Decompress Draco encoded meshes
    },
    // common?
    log: console
    // eslint-disable-line
  }
};
async function parse9(arrayBuffer, options = {}, context) {
  options = { ...GLTFLoader.options, ...options };
  options.gltf = { ...GLTFLoader.options.gltf, ...options.gltf };
  const { byteOffset = 0 } = options;
  const gltf = {};
  return await parseGLTF(gltf, arrayBuffer, byteOffset, options, context);
}

// ../../node_modules/.pnpm/@loaders.gl+gltf@4.3.3_@loaders.gl+core@4.3.3/node_modules/@loaders.gl/gltf/dist/lib/api/post-process-gltf.js
var COMPONENTS2 = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var BYTES2 = {
  5120: 1,
  // BYTE
  5121: 1,
  // UNSIGNED_BYTE
  5122: 2,
  // SHORT
  5123: 2,
  // UNSIGNED_SHORT
  5125: 4,
  // UNSIGNED_INT
  5126: 4
  // FLOAT
};
var GL_SAMPLER = {
  // Sampler parameters
  TEXTURE_MAG_FILTER: 10240,
  TEXTURE_MIN_FILTER: 10241,
  TEXTURE_WRAP_S: 10242,
  TEXTURE_WRAP_T: 10243,
  // Sampler default values
  REPEAT: 10497,
  LINEAR: 9729,
  NEAREST_MIPMAP_LINEAR: 9986
};
var SAMPLER_PARAMETER_GLTF_TO_GL = {
  magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,
  minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,
  wrapS: GL_SAMPLER.TEXTURE_WRAP_S,
  wrapT: GL_SAMPLER.TEXTURE_WRAP_T
};
var DEFAULT_SAMPLER_PARAMETERS = {
  [GL_SAMPLER.TEXTURE_MAG_FILTER]: GL_SAMPLER.LINEAR,
  [GL_SAMPLER.TEXTURE_MIN_FILTER]: GL_SAMPLER.NEAREST_MIPMAP_LINEAR,
  [GL_SAMPLER.TEXTURE_WRAP_S]: GL_SAMPLER.REPEAT,
  [GL_SAMPLER.TEXTURE_WRAP_T]: GL_SAMPLER.REPEAT
};
function makeDefaultSampler() {
  return {
    id: "default-sampler",
    parameters: DEFAULT_SAMPLER_PARAMETERS
  };
}
function getBytesFromComponentType(componentType) {
  return BYTES2[componentType];
}
function getSizeFromAccessorType(type) {
  return COMPONENTS2[type];
}
var GLTFPostProcessor = class {
  baseUri = "";
  // @ts-expect-error
  jsonUnprocessed;
  // @ts-expect-error
  json;
  buffers = [];
  images = [];
  postProcess(gltf, options = {}) {
    const { json, buffers = [], images = [] } = gltf;
    const { baseUri = "" } = gltf;
    assert4(json);
    this.baseUri = baseUri;
    this.buffers = buffers;
    this.images = images;
    this.jsonUnprocessed = json;
    this.json = this._resolveTree(gltf.json, options);
    return this.json;
  }
  // Convert indexed glTF structure into tree structure
  // cross-link index resolution, enum lookup, convenience calculations
  // eslint-disable-next-line complexity, max-statements
  _resolveTree(gltf, options = {}) {
    const json = { ...gltf };
    this.json = json;
    if (gltf.bufferViews) {
      json.bufferViews = gltf.bufferViews.map((bufView, i) => this._resolveBufferView(bufView, i));
    }
    if (gltf.images) {
      json.images = gltf.images.map((image, i) => this._resolveImage(image, i));
    }
    if (gltf.samplers) {
      json.samplers = gltf.samplers.map((sampler, i) => this._resolveSampler(sampler, i));
    }
    if (gltf.textures) {
      json.textures = gltf.textures.map((texture, i) => this._resolveTexture(texture, i));
    }
    if (gltf.accessors) {
      json.accessors = gltf.accessors.map((accessor, i) => this._resolveAccessor(accessor, i));
    }
    if (gltf.materials) {
      json.materials = gltf.materials.map((material, i) => this._resolveMaterial(material, i));
    }
    if (gltf.meshes) {
      json.meshes = gltf.meshes.map((mesh, i) => this._resolveMesh(mesh, i));
    }
    if (gltf.nodes) {
      json.nodes = gltf.nodes.map((node, i) => this._resolveNode(node, i));
      json.nodes = json.nodes.map((node, i) => this._resolveNodeChildren(node));
    }
    if (gltf.skins) {
      json.skins = gltf.skins.map((skin, i) => this._resolveSkin(skin, i));
    }
    if (gltf.scenes) {
      json.scenes = gltf.scenes.map((scene, i) => this._resolveScene(scene, i));
    }
    if (typeof this.json.scene === "number" && json.scenes) {
      json.scene = json.scenes[this.json.scene];
    }
    return json;
  }
  getScene(index) {
    return this._get(this.json.scenes, index);
  }
  getNode(index) {
    return this._get(this.json.nodes, index);
  }
  getSkin(index) {
    return this._get(this.json.skins, index);
  }
  getMesh(index) {
    return this._get(this.json.meshes, index);
  }
  getMaterial(index) {
    return this._get(this.json.materials, index);
  }
  getAccessor(index) {
    return this._get(this.json.accessors, index);
  }
  getCamera(index) {
    return this._get(this.json.cameras, index);
  }
  getTexture(index) {
    return this._get(this.json.textures, index);
  }
  getSampler(index) {
    return this._get(this.json.samplers, index);
  }
  getImage(index) {
    return this._get(this.json.images, index);
  }
  getBufferView(index) {
    return this._get(this.json.bufferViews, index);
  }
  getBuffer(index) {
    return this._get(this.json.buffers, index);
  }
  _get(array, index) {
    if (typeof index === "object") {
      return index;
    }
    const object = array && array[index];
    if (!object) {
      console.warn(`glTF file error: Could not find ${array}[${index}]`);
    }
    return object;
  }
  // PARSING HELPERS
  _resolveScene(scene, index) {
    return {
      ...scene,
      // @ts-ignore
      id: scene.id || `scene-${index}`,
      nodes: (scene.nodes || []).map((node) => this.getNode(node))
    };
  }
  _resolveNode(gltfNode, index) {
    const node = {
      ...gltfNode,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: gltfNode?.id || `node-${index}`
    };
    if (gltfNode.mesh !== void 0) {
      node.mesh = this.getMesh(gltfNode.mesh);
    }
    if (gltfNode.camera !== void 0) {
      node.camera = this.getCamera(gltfNode.camera);
    }
    if (gltfNode.skin !== void 0) {
      node.skin = this.getSkin(gltfNode.skin);
    }
    if (gltfNode.meshes !== void 0 && gltfNode.meshes.length) {
      node.mesh = gltfNode.meshes.reduce((accum, meshIndex) => {
        const mesh = this.getMesh(meshIndex);
        accum.id = mesh.id;
        accum.primitives = accum.primitives.concat(mesh.primitives);
        return accum;
      }, { primitives: [] });
    }
    return node;
  }
  _resolveNodeChildren(node) {
    if (node.children) {
      node.children = node.children.map((child) => this.getNode(child));
    }
    return node;
  }
  _resolveSkin(gltfSkin, index) {
    const inverseBindMatrices = typeof gltfSkin.inverseBindMatrices === "number" ? this.getAccessor(gltfSkin.inverseBindMatrices) : void 0;
    return {
      ...gltfSkin,
      id: gltfSkin.id || `skin-${index}`,
      inverseBindMatrices
    };
  }
  _resolveMesh(gltfMesh, index) {
    const mesh = {
      ...gltfMesh,
      id: gltfMesh.id || `mesh-${index}`,
      primitives: []
    };
    if (gltfMesh.primitives) {
      mesh.primitives = gltfMesh.primitives.map((gltfPrimitive) => {
        const primitive = {
          ...gltfPrimitive,
          attributes: {},
          indices: void 0,
          material: void 0
        };
        const attributes = gltfPrimitive.attributes;
        for (const attribute in attributes) {
          primitive.attributes[attribute] = this.getAccessor(attributes[attribute]);
        }
        if (gltfPrimitive.indices !== void 0) {
          primitive.indices = this.getAccessor(gltfPrimitive.indices);
        }
        if (gltfPrimitive.material !== void 0) {
          primitive.material = this.getMaterial(gltfPrimitive.material);
        }
        return primitive;
      });
    }
    return mesh;
  }
  _resolveMaterial(gltfMaterial, index) {
    const material = {
      ...gltfMaterial,
      // @ts-expect-error
      id: gltfMaterial.id || `material-${index}`
    };
    if (material.normalTexture) {
      material.normalTexture = { ...material.normalTexture };
      material.normalTexture.texture = this.getTexture(material.normalTexture.index);
    }
    if (material.occlusionTexture) {
      material.occlusionTexture = { ...material.occlusionTexture };
      material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);
    }
    if (material.emissiveTexture) {
      material.emissiveTexture = { ...material.emissiveTexture };
      material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);
    }
    if (!material.emissiveFactor) {
      material.emissiveFactor = material.emissiveTexture ? [1, 1, 1] : [0, 0, 0];
    }
    if (material.pbrMetallicRoughness) {
      material.pbrMetallicRoughness = { ...material.pbrMetallicRoughness };
      const mr = material.pbrMetallicRoughness;
      if (mr.baseColorTexture) {
        mr.baseColorTexture = { ...mr.baseColorTexture };
        mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);
      }
      if (mr.metallicRoughnessTexture) {
        mr.metallicRoughnessTexture = { ...mr.metallicRoughnessTexture };
        mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);
      }
    }
    return material;
  }
  _resolveAccessor(gltfAccessor, index) {
    const bytesPerComponent = getBytesFromComponentType(gltfAccessor.componentType);
    const components = getSizeFromAccessorType(gltfAccessor.type);
    const bytesPerElement = bytesPerComponent * components;
    const accessor = {
      ...gltfAccessor,
      // @ts-expect-error
      id: gltfAccessor.id || `accessor-${index}`,
      bytesPerComponent,
      components,
      bytesPerElement,
      value: void 0,
      bufferView: void 0,
      sparse: void 0
    };
    if (gltfAccessor.bufferView !== void 0) {
      accessor.bufferView = this.getBufferView(gltfAccessor.bufferView);
    }
    if (accessor.bufferView) {
      const buffer = accessor.bufferView.buffer;
      const { ArrayType, byteLength } = getAccessorArrayTypeAndLength(accessor, accessor.bufferView);
      const byteOffset = (accessor.bufferView.byteOffset || 0) + (accessor.byteOffset || 0) + buffer.byteOffset;
      let cutBuffer = buffer.arrayBuffer.slice(byteOffset, byteOffset + byteLength);
      if (accessor.bufferView.byteStride) {
        cutBuffer = this._getValueFromInterleavedBuffer(buffer, byteOffset, accessor.bufferView.byteStride, accessor.bytesPerElement, accessor.count);
      }
      accessor.value = new ArrayType(cutBuffer);
    }
    return accessor;
  }
  /**
   * Take values of particular accessor from interleaved buffer
   * various parts of the buffer
   * @param buffer
   * @param byteOffset
   * @param byteStride
   * @param bytesPerElement
   * @param count
   * @returns
   */
  _getValueFromInterleavedBuffer(buffer, byteOffset, byteStride, bytesPerElement, count) {
    const result = new Uint8Array(count * bytesPerElement);
    for (let i = 0; i < count; i++) {
      const elementOffset = byteOffset + i * byteStride;
      result.set(new Uint8Array(buffer.arrayBuffer.slice(elementOffset, elementOffset + bytesPerElement)), i * bytesPerElement);
    }
    return result.buffer;
  }
  _resolveTexture(gltfTexture, index) {
    return {
      ...gltfTexture,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: gltfTexture.id || `texture-${index}`,
      sampler: typeof gltfTexture.sampler === "number" ? this.getSampler(gltfTexture.sampler) : makeDefaultSampler(),
      source: typeof gltfTexture.source === "number" ? this.getImage(gltfTexture.source) : void 0
    };
  }
  _resolveSampler(gltfSampler, index) {
    const sampler = {
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: gltfSampler.id || `sampler-${index}`,
      ...gltfSampler,
      parameters: {}
    };
    for (const key in sampler) {
      const glEnum = this._enumSamplerParameter(key);
      if (glEnum !== void 0) {
        sampler.parameters[glEnum] = sampler[key];
      }
    }
    return sampler;
  }
  _enumSamplerParameter(key) {
    return SAMPLER_PARAMETER_GLTF_TO_GL[key];
  }
  _resolveImage(gltfImage, index) {
    const image = {
      ...gltfImage,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: gltfImage.id || `image-${index}`,
      image: null,
      bufferView: gltfImage.bufferView !== void 0 ? this.getBufferView(gltfImage.bufferView) : void 0
    };
    const preloadedImage = this.images[index];
    if (preloadedImage) {
      image.image = preloadedImage;
    }
    return image;
  }
  _resolveBufferView(gltfBufferView, index) {
    const bufferIndex = gltfBufferView.buffer;
    const arrayBuffer = this.buffers[bufferIndex].arrayBuffer;
    let byteOffset = this.buffers[bufferIndex].byteOffset || 0;
    if (gltfBufferView.byteOffset) {
      byteOffset += gltfBufferView.byteOffset;
    }
    const bufferView = {
      // // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: `bufferView-${index}`,
      ...gltfBufferView,
      // ...this.buffers[bufferIndex],
      buffer: this.buffers[bufferIndex],
      data: new Uint8Array(arrayBuffer, byteOffset, gltfBufferView.byteLength)
    };
    return bufferView;
  }
  _resolveCamera(gltfCamera, index) {
    const camera = {
      ...gltfCamera,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: gltfCamera.id || `camera-${index}`
    };
    if (camera.perspective) {
    }
    if (camera.orthographic) {
    }
    return camera;
  }
};
function postProcessGLTF(gltf, options) {
  return new GLTFPostProcessor().postProcess(gltf, options);
}

// ../sdk/src/gltf/GLTFLoader.ts
var GLTFLoader2 = class extends ModelLoader {
  constructor() {
    super({
      fileDataType: "arraybuffer",
      parsers: {
        "*": parseGLTF2
      },
      getVersion: (fileData) => {
        return "*";
      }
    });
  }
};
function parseGLTF2(params2) {
  return new Promise(function(resolve2, reject) {
    const { fileData, sceneModel, dataModel } = params2;
    if (!sceneModel && !dataModel) {
      return resolve2();
    }
    parse7(fileData, GLTFLoader, {}).then((gltfData) => {
      const processedGLTF = postProcessGLTF(gltfData);
      const ctx = {
        nodesHaveNames: false,
        // determined in testIfNodesHaveNames()
        meshIds: [],
        meshIdsStack: [],
        objectIdStack: [],
        baseId: createUUID2(),
        gltfData: processedGLTF,
        nextId: 0,
        log: function(msg) {
        },
        error: function(msg) {
          console.error(msg);
        },
        dataModel,
        sceneModel,
        objectCreated: {},
        geometryCreated: {}
      };
      parseTextures(ctx);
      parseMaterials(ctx);
      parseDefaultScene(ctx);
      return resolve2();
    }, (errMsg) => {
      return reject(`Error parsing glTF: ${errMsg}`);
    });
  });
}
function parseTextures(ctx) {
  if (!ctx.sceneModel) {
    return;
  }
  const gltfData = ctx.gltfData;
  const textures = gltfData.textures;
  if (textures) {
    for (let i = 0, len = textures.length; i < len; i++) {
      parseTexture(ctx, textures[i]);
    }
  }
}
function parseTexture(ctx, texture) {
  if (!texture.source || !texture.source.image) {
    return;
  }
  const textureId = `texture-${ctx.nextId++}`;
  let minFilter = NearestMipMapLinearFilter;
  switch (texture.sampler.minFilter) {
    case 9728:
      minFilter = NearestFilter;
      break;
    case 9729:
      minFilter = LinearFilter;
      break;
    case 9984:
      minFilter = NearestMipMapNearestFilter;
      break;
    case 9985:
      minFilter = LinearMipMapNearestFilter;
      break;
    case 9986:
      minFilter = NearestMipMapLinearFilter;
      break;
    case 9987:
      minFilter = LinearMipMapLinearFilter;
      break;
  }
  let magFilter = LinearFilter;
  switch (texture.sampler.magFilter) {
    case 9728:
      magFilter = NearestFilter;
      break;
    case 9729:
      magFilter = LinearFilter;
      break;
  }
  let wrapS = RepeatWrapping;
  switch (texture.sampler.wrapS) {
    case 33071:
      wrapS = ClampToEdgeWrapping;
      break;
    case 33648:
      wrapS = MirroredRepeatWrapping;
      break;
    case 10497:
      wrapS = RepeatWrapping;
      break;
  }
  let wrapT = RepeatWrapping;
  switch (texture.sampler.wrapT) {
    case 33071:
      wrapT = ClampToEdgeWrapping;
      break;
    case 33648:
      wrapT = MirroredRepeatWrapping;
      break;
    case 10497:
      wrapT = RepeatWrapping;
      break;
  }
  let wrapR = RepeatWrapping;
  switch (texture.sampler.wrapR) {
    case 33071:
      wrapR = ClampToEdgeWrapping;
      break;
    case 33648:
      wrapR = MirroredRepeatWrapping;
      break;
    case 10497:
      wrapR = RepeatWrapping;
      break;
  }
  ctx.sceneModel.createTexture({
    id: textureId,
    imageData: texture.source.image,
    mediaType: texture.source.mediaType,
    compressed: true,
    width: texture.source.image.width,
    height: texture.source.image.height,
    minFilter,
    magFilter,
    wrapS,
    wrapT,
    wrapR,
    flipY: !!texture.flipY
    //     encoding: "sRGB"
  });
  texture._textureId = textureId;
}
function parseMaterials(ctx) {
  if (!ctx.sceneModel) {
    return;
  }
  const gltfData = ctx.gltfData;
  const materials = gltfData.materials;
  if (materials) {
    for (let i = 0, len = materials.length; i < len; i++) {
      const material = materials[i];
      material._textureSetId = parseTextureSet(ctx, material);
      material._attributes = parseMaterialAttributes(ctx, material);
    }
  }
}
function parseTextureSet(ctx, material) {
  const textureSetCfg = {
    // @ts-ignore
    id: null,
    occlusionTextureId: void 0,
    emissiveTextureId: void 0,
    colorTextureId: void 0,
    metallicRoughnessTextureId: void 0
  };
  if (material.occlusionTexture) {
    textureSetCfg.occlusionTextureId = material.occlusionTexture.texture._textureId;
  }
  if (material.emissiveTexture) {
    textureSetCfg.emissiveTextureId = material.emissiveTexture.texture._textureId;
  }
  const metallicPBR = material.pbrMetallicRoughness;
  if (material.pbrMetallicRoughness) {
    const pbrMetallicRoughness = material.pbrMetallicRoughness;
    const baseColorTexture = pbrMetallicRoughness.baseColorTexture || pbrMetallicRoughness.colorTexture;
    if (baseColorTexture) {
      if (baseColorTexture.texture) {
        textureSetCfg.colorTextureId = baseColorTexture.texture._textureId;
      } else {
        textureSetCfg.colorTextureId = ctx.gltfData.textures[baseColorTexture.index]._textureId;
      }
    }
    if (metallicPBR.metallicRoughnessTexture) {
      textureSetCfg.metallicRoughnessTextureId = metallicPBR.metallicRoughnessTexture.texture._textureId;
    }
  }
  const extensions = material.extensions;
  if (extensions) {
    const specularPBR = extensions["KHR_materials_pbrSpecularGlossiness"];
    if (specularPBR) {
      const specularTexture = specularPBR.specularTexture;
      if (specularTexture !== null && specularTexture !== void 0) {
      }
      const specularColorTexture = specularPBR.specularColorTexture;
      if (specularColorTexture !== null && specularColorTexture !== void 0) {
        textureSetCfg.colorTextureId = ctx.gltfData.textures[specularColorTexture.index]._textureId;
      }
    }
  }
  if (textureSetCfg.occlusionTextureId !== void 0 || textureSetCfg.emissiveTextureId !== void 0 || textureSetCfg.colorTextureId !== void 0 || textureSetCfg.metallicRoughnessTextureId !== void 0) {
    textureSetCfg.id = `textureSet-${ctx.nextId++};`;
    ctx.sceneModel.createTextureSet(textureSetCfg);
    return textureSetCfg.id;
  }
  return null;
}
function parseMaterialAttributes(ctx, material) {
  const extensions = material.extensions;
  const materialAttributes = {
    color: new Float32Array([1, 1, 1, 1]),
    opacity: 1,
    metallic: 0,
    roughness: 1
  };
  if (extensions) {
    const specularPBR = extensions["KHR_materials_pbrSpecularGlossiness"];
    if (specularPBR) {
      const diffuseFactor = specularPBR.diffuseFactor;
      if (diffuseFactor !== null && diffuseFactor !== void 0) {
        materialAttributes.color.set(diffuseFactor);
      }
    }
    const common2 = extensions["KHR_materials_common"];
    if (common2) {
      const technique = common2.technique;
      const values = common2.values || {};
      const blinn = technique === "BLINN";
      const phong = technique === "PHONG";
      const lambert = technique === "LAMBERT";
      const diffuse = values.diffuse;
      if (diffuse && (blinn || phong || lambert)) {
        if (!isString(diffuse)) {
          materialAttributes.color.set(diffuse);
        }
      }
      const transparency = values.transparency;
      if (transparency !== null && transparency !== void 0) {
        materialAttributes.opacity = transparency;
      }
      const transparent = values.transparent;
      if (transparent !== null && transparent !== void 0) {
        materialAttributes.opacity = transparent;
      }
    }
  }
  const metallicPBR = material.pbrMetallicRoughness;
  if (metallicPBR) {
    const baseColorFactor = metallicPBR.baseColorFactor;
    if (baseColorFactor) {
      materialAttributes.color[0] = baseColorFactor[0];
      materialAttributes.color[1] = baseColorFactor[1];
      materialAttributes.color[2] = baseColorFactor[2];
      materialAttributes.opacity = baseColorFactor[3];
    }
    const metallicFactor = metallicPBR.metallicFactor;
    if (metallicFactor !== null && metallicFactor !== void 0) {
      materialAttributes.metallic = metallicFactor;
    }
    const roughnessFactor = metallicPBR.roughnessFactor;
    if (roughnessFactor !== null && roughnessFactor !== void 0) {
      materialAttributes.roughness = roughnessFactor;
    }
  }
  return materialAttributes;
}
function parseDefaultScene(ctx) {
  const gltfData = ctx.gltfData;
  const scene = gltfData.scene || gltfData.scenes[0];
  if (!scene) {
    ctx.error("glTF has no default scene");
    return;
  }
  parseScene(ctx, scene);
}
function parseScene(ctx, scene) {
  const nodes = scene.nodes;
  if (!nodes) {
    return;
  }
  for (let i = 0, len = nodes.length; i < len && !ctx.nodesHaveNames; i++) {
    const node = nodes[i];
    if (testIfNodesHaveNames(node)) {
      ctx.nodesHaveNames = true;
    }
  }
  if (!ctx.nodesHaveNames) {
    ctx.log(`Warning: No "name" attributes found on glTF scene nodes - objects in XKT may not be what you expect`);
    for (let i = 0, len = nodes.length; i < len; i++) {
      const node = nodes[i];
      parseNodesWithoutNames(ctx, node, 0, null);
    }
  } else {
    for (let i = 0, len = nodes.length; i < len; i++) {
      const node = nodes[i];
      parseNodesWithNames(ctx, node, 0, null);
    }
  }
}
function createPrimitiveHash(ctx, primitive) {
  const hash = [ctx.baseId];
  const attributes = primitive.attributes;
  if (attributes) {
    for (let key in attributes) {
      hash.push(attributes[key].id);
      hash.push(attributes[key].count);
    }
  }
  hash.push(primitive.mode);
  if (primitive.indices) {
    hash.push(primitive.indices.id);
    hash.push(primitive.indices.count);
  }
  return hash.join(".");
}
function testIfNodesHaveNames(node, level = 0) {
  if (!node) {
    return;
  }
  if (node.name) {
    return true;
  }
  if (node.children) {
    const children = node.children;
    for (let i = 0, len = children.length; i < len; i++) {
      const childNode = children[i];
      if (testIfNodesHaveNames(childNode, level + 1)) {
        return true;
      }
    }
  }
  return false;
}
var parseNodesWithoutNames = /* @__PURE__ */ function() {
  const meshIds = [];
  return function(ctx, node, depth, matrix) {
    if (!node) {
      return;
    }
    matrix = parseNodeMatrix(node, matrix);
    if (node.mesh) {
      parseMesh(node, ctx, matrix, meshIds);
    }
    if (node.children) {
      const children = node.children;
      for (let i = 0, len = children.length; i < len; i++) {
        const childNode = children[i];
        parseNodesWithoutNames(ctx, childNode, depth + 1, matrix);
      }
    }
    if (depth === 0) {
      let objectId = "entity-" + ctx.nextId++;
      if (meshIds && meshIds.length > 0) {
        ctx.log("Creating SceneObject with default ID: " + objectId);
        ctx.sceneModel.createObject({
          id: objectId,
          meshIds
        });
        meshIds.length = 0;
      }
    }
  };
}();
var parseNodesWithNames = /* @__PURE__ */ function() {
  const objectIdStack = [];
  const meshIdsStack = [];
  let meshIds = null;
  return function(ctx, node, depth, matrix) {
    if (!node) {
      return;
    }
    matrix = parseNodeMatrix(node, matrix);
    if (node.name) {
      meshIds = [];
      let objectId = node.name;
      if (!!objectId && ctx.sceneModel.objects[objectId]) {
        ctx.log(`Warning: Two or more glTF nodes found with same 'name' attribute: '${objectId} - will randomly-generating an object ID in XKT`);
      }
      while (!objectId || ctx.sceneModel.objects[objectId]) {
        objectId = "entity-" + ctx.nextId++;
      }
      objectIdStack.push(objectId);
      meshIdsStack.push(meshIds);
    }
    if (meshIds && node.mesh) {
      parseMesh(node, ctx, matrix, meshIds);
    }
    if (node.children) {
      const children = node.children;
      for (let i = 0, len = children.length; i < len; i++) {
        const childNode = children[i];
        parseNodesWithNames(ctx, childNode, depth + 1, matrix);
      }
    }
    const nodeName = node.name;
    if (nodeName !== void 0 && nodeName !== null || depth === 0) {
      let objectId = objectIdStack.pop();
      if (!objectId) {
        objectId = "entity-" + ctx.nextId++;
      }
      let entityMeshIds = meshIdsStack.pop();
      if (meshIds && meshIds.length > 0) {
        ctx.sceneModel.createObject({
          id: objectId,
          meshIds: entityMeshIds
        });
      }
      meshIds = meshIdsStack.length > 0 ? meshIdsStack[meshIdsStack.length - 1] : null;
    }
  };
}();
function parseNodeMatrix(node, matrix) {
  if (!node) {
    return;
  }
  let localMatrix;
  if (node.matrix) {
    localMatrix = node.matrix;
    if (matrix) {
      matrix = mulMat4(matrix, localMatrix, createMat4());
    } else {
      matrix = localMatrix;
    }
  }
  if (node.translation) {
    localMatrix = translationMat4v(node.translation);
    if (matrix) {
      matrix = mulMat4(matrix, localMatrix, createMat4());
    } else {
      matrix = localMatrix;
    }
  }
  if (node.rotation) {
    localMatrix = quatToMat4(node.rotation);
    if (matrix) {
      matrix = mulMat4(matrix, localMatrix, createMat4());
    } else {
      matrix = localMatrix;
    }
  }
  if (node.scale) {
    localMatrix = scalingMat4v(node.scale);
    if (matrix) {
      matrix = mulMat4(matrix, localMatrix, createMat4());
    } else {
      matrix = localMatrix;
    }
  }
  return matrix;
}
function parseMesh(node, ctx, matrix, meshIds) {
  if (node.mesh) {
    const mesh = node.mesh;
    const numPrimitives = mesh.primitives.length;
    for (let i = 0; i < numPrimitives; i++) {
      const primitive = mesh.primitives[i];
      let geometryId = createPrimitiveHash(ctx, primitive);
      if (!ctx.geometryCreated[geometryId]) {
        const POSITION = primitive.attributes.POSITION;
        if (!POSITION) {
          continue;
        }
        const geometryParams = {
          id: geometryId,
          primitive: 0,
          // @ts-ignore
          positions: void 0
        };
        switch (primitive.mode) {
          case 0:
            geometryParams.primitive = PointsPrimitive;
            break;
          case 1:
            geometryParams.primitive = LinesPrimitive;
            break;
          case 2:
            geometryParams.primitive = LinesPrimitive;
            break;
          case 3:
            geometryParams.primitive = LinesPrimitive;
            break;
          case 4:
            geometryParams.primitive = TrianglesPrimitive;
            break;
          case 5:
            geometryParams.primitive = TrianglesPrimitive;
            break;
          case 6:
            geometryParams.primitive = TrianglesPrimitive;
            break;
          default:
            geometryParams.primitive = TrianglesPrimitive;
        }
        geometryParams.positions = primitive.attributes.POSITION.value;
        if (primitive.attributes.COLOR_0) {
          geometryParams.colors = primitive.attributes.COLOR_0.value;
        }
        if (primitive.attributes.TEXCOORD_0) {
          geometryParams.uvs = primitive.attributes.TEXCOORD_0.value;
        }
        if (primitive.indices) {
          geometryParams.indices = primitive.indices.value;
        }
        ctx.sceneModel.createGeometry(geometryParams);
        ctx.geometryCreated[geometryId] = true;
      }
      const meshId = `${ctx.nextId++}`;
      const meshParams = {
        id: meshId,
        geometryId,
        matrix: matrix ? matrix.slice() : identityMat4(),
        textureSetId: void 0
      };
      const material = primitive.material;
      if (material) {
        meshParams.color = material._attributes.color;
        meshParams.opacity = material._attributes.opacity;
      } else {
        meshParams.color = [1, 1, 1];
        meshParams.opacity = 1;
      }
      ctx.sceneModel.createMesh(meshParams);
      meshIds.push(meshId);
    }
  }
}

// ../sdk/src/xkt/index.ts
var xkt_exports = {};
__export(xkt_exports, {
  XKTLoader: () => XKTLoader,
  loadXKTManifest: () => loadXKTManifest
});

// ../../node_modules/.pnpm/pako@2.1.0/node_modules/pako/dist/pako.esm.mjs
var Z_FIXED$1 = 4;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
);
var extra_dbits = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
);
var extra_blbits = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
);
var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var DIST_CODE_LEN = 512;
var static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
var static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
var base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
var base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
var d_code = (dist) => {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
var put_short = (s, w) => {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
};
var send_bits = (s, value, length) => {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
var send_code = (s, c2, tree) => {
  send_bits(
    s,
    tree[c2 * 2],
    tree[c2 * 2 + 1]
    /*.Len*/
  );
};
var bi_reverse = (code, len) => {
  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};
var bi_flush = (s) => {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};
var gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
};
var gen_codes = (tree, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code = 0;
  let bits;
  let n;
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    code = code + bl_count[bits - 1] << 1;
    next_code[bits] = code;
  }
  for (n = 0; n <= max_code; n++) {
    let len = tree[n * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n * 2] = bi_reverse(next_code[len]++, len);
  }
};
var tr_static_init = () => {
  let n;
  let bits;
  let length;
  let code;
  let dist;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  }
  _length_code[length - 1] = code;
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  }
  dist >>= 7;
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1] = 5;
    static_dtree[n * 2] = bi_reverse(n, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
var init_block = (s) => {
  let n;
  for (n = 0; n < L_CODES$1; n++) {
    s.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n < D_CODES$1; n++) {
    s.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n < BL_CODES$1; n++) {
    s.bl_tree[n * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};
var bi_windup = (s) => {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};
var smaller = (tree, n, m, depth) => {
  const _n2 = n * 2;
  const _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
};
var pqdownheap = (s, tree, k) => {
  const v = s.heap[k];
  let j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
};
var compress_block = (s, ltree, dtree) => {
  let dist;
  let lc;
  let sx = 0;
  let code;
  let extra;
  if (s.sym_next !== 0) {
    do {
      dist = s.pending_buf[s.sym_buf + sx++] & 255;
      dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist === 0) {
        send_code(s, lc, ltree);
      } else {
        code = _length_code[lc];
        send_code(s, code + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);
        }
        dist--;
        code = d_code(dist);
        send_code(s, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);
        }
      }
    } while (sx < s.sym_next);
  }
  send_code(s, END_BLOCK, ltree);
};
var build_tree = (s, desc) => {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n, m;
  let max_code = -1;
  let node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;
  for (n = 0; n < elems; n++) {
    if (tree[n * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s.heap_len >> 1; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }
  node = elems;
  do {
    n = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
    m = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[--s.heap_max] = n;
    s.heap[--s.heap_max] = m;
    tree[node * 2] = tree[n * 2] + tree[m * 2];
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1] = tree[m * 2 + 1] = node;
    s.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s, desc);
  gen_codes(tree, max_code, s.bl_count);
};
var scan_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var send_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var build_bl_tree = (s) => {
  let max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
var send_all_trees = (s, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
};
var detect_data_type = (s) => {
  let block_mask = 4093624447;
  let n;
  for (n = 0; n <= 31; n++, block_mask >>>= 1) {
    if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
var static_init_done = false;
var _tr_init$1 = (s) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
};
var _tr_stored_block$1 = (s, buf, stored_len, last) => {
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  bi_windup(s);
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
  }
  s.pending += stored_len;
};
var _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};
var _tr_flush_block$1 = (s, buf, stored_len, last) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$1(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last) {
    bi_windup(s);
  }
};
var _tr_tally$1 = (s, dist, lc) => {
  s.pending_buf[s.sym_buf + s.sym_next++] = dist;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s.dyn_dtree[d_code(dist) * 2]++;
  }
  return s.sym_next === s.sym_end;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
var adler32 = (adler, buf, len, pos) => {
  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len !== 0) {
    n = len > 2e3 ? 2e3 : len;
    len -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
var makeTable = () => {
  let c2, table = [];
  for (var n = 0; n < 256; n++) {
    c2 = n;
    for (var k = 0; k < 8; k++) {
      c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
    }
    table[n] = c2;
  }
  return table;
};
var crcTable = new Uint32Array(makeTable());
var crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var constants$2 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;
var MAX_MEM_LEVEL = 9;
var MAX_WBITS$1 = 15;
var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var GZIP_STATE = 57;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
var err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
var rank = (f) => {
  return f * 2 - (f > 4 ? 9 : 0);
};
var zero = (buf) => {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
};
var slide_hash = (s) => {
  let n, m;
  let p;
  let wsize = s.w_size;
  n = s.hash_size;
  p = n;
  do {
    m = s.head[--p];
    s.head[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
  n = wsize;
  p = n;
  do {
    m = s.prev[--p];
    s.prev[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
};
var HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
var HASH = HASH_ZLIB;
var flush_pending = (strm) => {
  const s = strm.state;
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};
var flush_block_only = (s, last) => {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};
var put_byte = (s, b4) => {
  s.pending_buf[s.pending++] = b4;
};
var putShortMSB = (s, b4) => {
  s.pending_buf[s.pending++] = b4 >>> 8 & 255;
  s.pending_buf[s.pending++] = b4 & 255;
};
var read_buf = (strm, buf, start, size) => {
  let len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};
var longest_match = (s, cur_match) => {
  let chain_length = s.max_chain_length;
  let scan = s.strstart;
  let match;
  let len;
  let best_len = s.prev_length;
  let nice_match = s.nice_match;
  const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s.window;
  const wmask = s.w_mask;
  const prev = s.prev;
  const strend = s.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};
var fill_window = (s) => {
  const _w_size = s.w_size;
  let n, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
      while (s.insert) {
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
};
var deflate_stored = (s, flush) => {
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
  let len, left, have, last = 0;
  let used = s.strm.avail_in;
  do {
    len = 65535;
    have = s.bi_valid + 42 >> 3;
    if (s.strm.avail_out < have) {
      break;
    }
    have = s.strm.avail_out - have;
    left = s.strstart - s.block_start;
    if (len > left + s.strm.avail_in) {
      len = left + s.strm.avail_in;
    }
    if (len > have) {
      len = have;
    }
    if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) {
      break;
    }
    last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last);
    s.pending_buf[s.pending - 4] = len;
    s.pending_buf[s.pending - 3] = len >> 8;
    s.pending_buf[s.pending - 2] = ~len;
    s.pending_buf[s.pending - 1] = ~len >> 8;
    flush_pending(s.strm);
    if (left) {
      if (left > len) {
        left = len;
      }
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
      s.strm.next_out += left;
      s.strm.avail_out -= left;
      s.strm.total_out += left;
      s.block_start += left;
      len -= left;
    }
    if (len) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len);
      s.strm.next_out += len;
      s.strm.avail_out -= len;
      s.strm.total_out += len;
    }
  } while (last === 0);
  used -= s.strm.avail_in;
  if (used) {
    if (used >= s.w_size) {
      s.matches = 2;
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    } else {
      if (s.window_size - s.strstart <= used) {
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  if (last) {
    return BS_FINISH_DONE;
  }
  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++;
    }
    have += s.w_size;
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  have = s.bi_valid + 42 >> 3;
  have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left = s.strstart - s.block_start;
  if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
    len = left > have ? have : left;
    last = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len === left ? 1 : 0;
    _tr_stored_block(s, s.block_start, len, last);
    s.block_start += len;
    flush_pending(s.strm);
  }
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};
var deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_slow = (s, flush) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_rle = (s, flush) => {
  let bflush;
  let prev;
  let scan, strend;
  const _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_huff = (s, flush) => {
  let bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
var lm_init = (s) => {
  s.window_size = 2 * s.w_size;
  zero(s.head);
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
var deflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || s.status !== INIT_STATE && //#ifdef GZIP
  s.status !== GZIP_STATE && //#endif
  s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
    return 1;
  }
  return 0;
};
var deflateResetKeep = (strm) => {
  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = //#ifdef GZIP
  s.wrap === 2 ? GZIP_STATE : (
    //#endif
    s.wrap ? INIT_STATE : BUSY_STATE
  );
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK$3;
};
var deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
var deflateSetHeader = (strm, head) => {
  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};
var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);
  s.sym_buf = s.lit_bufsize;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
};
var deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
var deflate$2 = (strm, flush) => {
  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  const old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === INIT_STATE && s.wrap === 0) {
    s.status = BUSY_STATE;
  }
  if (s.status === INIT_STATE) {
    let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
    let level_flags = -1;
    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags << 6;
    if (s.strstart !== 0) {
      header |= PRESET_DICT;
    }
    header += 31 - header % 31;
    putShortMSB(s, header);
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    strm.adler = 1;
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (s.status === GZIP_STATE) {
    strm.adler = 0;
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) {
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE;
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    } else {
      put_byte(
        s,
        (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
      );
      put_byte(s, s.gzhead.time & 255);
      put_byte(s, s.gzhead.time >> 8 & 255);
      put_byte(s, s.gzhead.time >> 16 & 255);
      put_byte(s, s.gzhead.time >> 24 & 255);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, s.gzhead.os & 255);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length & 255);
        put_byte(s, s.gzhead.extra.length >> 8 & 255);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      let beg = s.pending;
      let left = (s.gzhead.extra.length & 65535) - s.gzindex;
      while (s.pending + left > s.pending_buf_size) {
        let copy2 = s.pending_buf_size - s.pending;
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy2), s.pending);
        s.pending = s.pending_buf_size;
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        s.gzindex += copy2;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy2;
      }
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
      s.pending += left;
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      strm.adler = 0;
    }
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
    let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      } else if (flush !== Z_BLOCK$1) {
        _tr_stored_block(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH$1) {
          zero(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
var deflateEnd = (strm) => {
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
var deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  const wrap = s.wrap;
  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      zero(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
var _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) => {
  let len = 0;
  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }
  const result = new Uint8Array(len);
  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign,
  flattenChunks
};
var STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
var _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf, c2, c22, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c2 = str.charCodeAt(m_pos);
    if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    buf_len += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c2 = str.charCodeAt(m_pos);
    if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    if (c2 < 128) {
      buf[i++] = c2;
    } else if (c2 < 2048) {
      buf[i++] = 192 | c2 >>> 6;
      buf[i++] = 128 | c2 & 63;
    } else if (c2 < 65536) {
      buf[i++] = 224 | c2 >>> 12;
      buf[i++] = 128 | c2 >>> 6 & 63;
      buf[i++] = 128 | c2 & 63;
    } else {
      buf[i++] = 240 | c2 >>> 18;
      buf[i++] = 128 | c2 >>> 12 & 63;
      buf[i++] = 128 | c2 >>> 6 & 63;
      buf[i++] = 128 | c2 & 63;
    }
  }
  return buf;
};
var buf2binstring = (buf, len) => {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result = "";
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};
var buf2string = (buf, max) => {
  const len = max || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }
  let i, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i = 0; i < len; ) {
    let c2 = buf[i++];
    if (c2 < 128) {
      utf16buf[out++] = c2;
      continue;
    }
    let c_len = _utf8len[c2];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c2 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len) {
      c2 = c2 << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c2 < 65536) {
      utf16buf[out++] = c2;
    } else {
      c2 -= 65536;
      utf16buf[out++] = 55296 | c2 >> 10 & 1023;
      utf16buf[out++] = 56320 | c2 & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max) => {
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf[pos]] > max ? pos : max;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
var toString$1 = Object.prototype.toString;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data === "string") {
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}
var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var constants$1 = constants$2;
var deflate_1$1 = {
  Deflate: Deflate_1$1,
  deflate: deflate_2,
  deflateRaw: deflateRaw_1$1,
  gzip: gzip_1$1,
  constants: constants$1
};
var BAD$1 = 16209;
var TYPE$1 = 16191;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len;
  let dist;
  let from;
  let from_source;
  let input, output;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from++];
                      if (len > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from++];
                      if (len > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
var lext = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
var dbase = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
var dext = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
var inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
  const bits = opts.bits;
  let len = 0;
  let sym = 0;
  let min = 0, max = 0;
  let root = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask;
  let next;
  let base = null;
  let match;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES$1 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$1) {
    base = extra = work;
    match = 20;
  } else if (type === LENS$1) {
    base = lbase;
    extra = lext;
    match = 257;
  } else {
    base = dbase;
    extra = dext;
    match = 0;
  }
  huff = 0;
  sym = 0;
  len = min;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base[work[sym] - match];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var inftrees = inflate_table;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;
var HEAD = 16180;
var FLAGS = 16181;
var TIME = 16182;
var OS = 16183;
var EXLEN = 16184;
var EXTRA = 16185;
var NAME = 16186;
var COMMENT = 16187;
var HCRC = 16188;
var DICTID = 16189;
var DICT = 16190;
var TYPE = 16191;
var TYPEDO = 16192;
var STORED = 16193;
var COPY_ = 16194;
var COPY = 16195;
var TABLE = 16196;
var LENLENS = 16197;
var CODELENS = 16198;
var LEN_ = 16199;
var LEN = 16200;
var LENEXT = 16201;
var DIST = 16202;
var DISTEXT = 16203;
var MATCH = 16204;
var LIT = 16205;
var CHECK = 16206;
var LENGTH = 16207;
var DONE = 16208;
var BAD = 16209;
var MEM = 16210;
var SYNC = 16211;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var MAX_WBITS = 15;
var DEF_WBITS = MAX_WBITS;
var zswap32 = (q) => {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
};
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
var inflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};
var inflateResetKeep = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
var inflateReset = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
var inflateReset2 = (strm, windowBits) => {
  let wrap;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};
var inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.strm = strm;
  state.window = null;
  state.mode = HEAD;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
var inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
var virgin = true;
var lenfix;
var distfix;
var fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
var updatewindow = (strm, src, end, copy2) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy2 >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy2) {
      dist = copy2;
    }
    state.window.set(src.subarray(end - copy2, end - copy2 + dist), state.wnext);
    copy2 -= dist;
    if (copy2) {
      state.window.set(src.subarray(end - copy2, end), 0);
      state.wnext = copy2;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
var inflate$2 = (strm, flush) => {
  let state;
  let input, output;
  let next;
  let put;
  let have, left;
  let hold;
  let bits;
  let _in, _out;
  let copy2;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n;
  const order = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            if (state.wbits === 0) {
              state.wbits = 15;
            }
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          }
          if (len > 15 || len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << state.wbits;
          state.flags = 0;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        case EXTRA:
          if (state.flags & 1024) {
            copy2 = state.length;
            if (copy2 > have) {
              copy2 = have;
            }
            if (copy2) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next + copy2
                  ),
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input, copy2, next);
              }
              have -= copy2;
              next += copy2;
              state.length -= copy2;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy2 = 0;
            do {
              len = input[next + copy2++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy2 < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy2, next);
            }
            have -= copy2;
            next += copy2;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy2 = 0;
            do {
              len = input[next + copy2++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy2 < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy2, next);
            }
            have -= copy2;
            next += copy2;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case COPY_:
          state.mode = COPY;
        case COPY:
          copy2 = state.length;
          if (copy2) {
            if (copy2 > have) {
              copy2 = have;
            }
            if (copy2 > left) {
              copy2 = left;
            }
            if (copy2 === 0) {
              break inf_leave;
            }
            output.set(input.subarray(next, next + copy2), put);
            have -= copy2;
            next += copy2;
            left -= copy2;
            put += copy2;
            state.length -= copy2;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy2 = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy2 = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy2 = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy2 > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy2--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case LEN_:
          state.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inffast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        case LENEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        case DISTEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy2 = _out - left;
          if (state.offset > copy2) {
            copy2 = state.offset - copy2;
            if (copy2 > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy2 > state.wnext) {
              copy2 -= state.wnext;
              from = state.wsize - copy2;
            } else {
              from = state.wnext - copy2;
            }
            if (copy2 > state.length) {
              copy2 = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from = put - state.offset;
            copy2 = state.length;
          }
          if (copy2 > left) {
            copy2 = left;
          }
          left -= copy2;
          state.length -= copy2;
          do {
            output[put++] = from_source[from++];
          } while (--copy2);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap & 4 && _out) {
              strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
              state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
            }
            _out = left;
            if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
      ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap & 4 && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
var inflateEnd = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
var inflateGetHeader = (strm, head) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1;
};
var inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
var toString = Object.prototype.toString;
var {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended)
    return false;
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail)
            strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0)
      continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err)
    throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants = constants$2;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2,
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1,
  constants
};
var { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
var { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var inflate_1 = inflate;

// ../sdk/src/xkt/versions/v10/inflateXKT.ts
function inflateXKT(xktDataDeflated) {
  function inflate2(array, options) {
    return array.length === 0 ? [] : inflate_1(array, options).buffer;
  }
  return {
    metadata: JSON.parse(inflate_1(xktDataDeflated.metadata, { to: "string" })),
    textureData: new Uint8Array(inflate2(xktDataDeflated.textureData)),
    // <<----------------------------- ??? ZIPPing to blame?
    eachTextureDataPortion: new Uint32Array(inflate2(xktDataDeflated.eachTextureDataPortion)),
    eachTextureAttributes: new Uint16Array(inflate2(xktDataDeflated.eachTextureAttributes)),
    positions: new Uint16Array(inflate2(xktDataDeflated.positions)),
    normals: new Int8Array(inflate2(xktDataDeflated.normals)),
    colors: new Uint8Array(inflate2(xktDataDeflated.colors)),
    uvs: new Float32Array(inflate2(xktDataDeflated.uvs)),
    indices: new Uint32Array(inflate2(xktDataDeflated.indices)),
    edgeIndices: new Uint32Array(inflate2(xktDataDeflated.edgeIndices)),
    eachTextureSetTextures: new Int32Array(inflate2(xktDataDeflated.eachTextureSetTextures)),
    matrices: new Float32Array(inflate2(xktDataDeflated.matrices)),
    reusedGeometriesDecodeMatrix: new Float32Array(inflate2(xktDataDeflated.reusedGeometriesDecodeMatrix)),
    eachGeometryPrimitiveType: new Uint8Array(inflate2(xktDataDeflated.eachGeometryPrimitiveType)),
    eachGeometryPositionsPortion: new Uint32Array(inflate2(xktDataDeflated.eachGeometryPositionsPortion)),
    eachGeometryNormalsPortion: new Uint32Array(inflate2(xktDataDeflated.eachGeometryNormalsPortion)),
    eachGeometryColorsPortion: new Uint32Array(inflate2(xktDataDeflated.eachGeometryColorsPortion)),
    eachGeometryUVsPortion: new Uint32Array(inflate2(xktDataDeflated.eachGeometryUVsPortion)),
    eachGeometryIndicesPortion: new Uint32Array(inflate2(xktDataDeflated.eachGeometryIndicesPortion)),
    eachGeometryEdgeIndicesPortion: new Uint32Array(inflate2(xktDataDeflated.eachGeometryEdgeIndicesPortion)),
    eachMeshGeometriesPortion: new Uint32Array(inflate2(xktDataDeflated.eachMeshGeometriesPortion)),
    eachMeshMatricesPortion: new Uint32Array(inflate2(xktDataDeflated.eachMeshMatricesPortion)),
    eachMeshTextureSet: new Int32Array(inflate2(xktDataDeflated.eachMeshTextureSet)),
    // Can be -1
    eachMeshMaterialAttributes: new Uint8Array(inflate2(xktDataDeflated.eachMeshMaterialAttributes)),
    eachEntityId: JSON.parse(inflate_1(xktDataDeflated.eachEntityId, { to: "string" })),
    eachEntityMeshesPortion: new Uint32Array(inflate2(xktDataDeflated.eachEntityMeshesPortion)),
    eachTileAABB: new Float64Array(inflate2(xktDataDeflated.eachTileAABB)),
    eachTileEntitiesPortion: new Uint32Array(inflate2(xktDataDeflated.eachTileEntitiesPortion))
  };
}

// ../sdk/src/xkt/versions/v10/unpackXKT.ts
function unpackXKT(arrayBuffer) {
  const dataView = new DataView(arrayBuffer);
  const dataArray = new Uint8Array(arrayBuffer);
  const xktVersion = dataView.getUint32(0, true);
  const numElements = dataView.getUint32(4, true);
  console.log(`Parsing XKT v${xktVersion}`);
  const elements = [];
  let byteOffset = (numElements + 2) * 4;
  for (let i2 = 0; i2 < numElements; i2++) {
    const elementSize = dataView.getUint32((i2 + 2) * 4, true);
    elements.push(dataArray.subarray(byteOffset, byteOffset + elementSize));
    byteOffset += elementSize;
  }
  let i = 0;
  return {
    metadata: elements[i++],
    textureData: elements[i++],
    eachTextureDataPortion: elements[i++],
    eachTextureAttributes: elements[i++],
    positions: elements[i++],
    normals: elements[i++],
    colors: elements[i++],
    uvs: elements[i++],
    indices: elements[i++],
    edgeIndices: elements[i++],
    eachTextureSetTextures: elements[i++],
    matrices: elements[i++],
    reusedGeometriesDecodeMatrix: elements[i++],
    eachGeometryPrimitiveType: elements[i++],
    eachGeometryPositionsPortion: elements[i++],
    eachGeometryNormalsPortion: elements[i++],
    eachGeometryColorsPortion: elements[i++],
    eachGeometryUVsPortion: elements[i++],
    eachGeometryIndicesPortion: elements[i++],
    eachGeometryEdgeIndicesPortion: elements[i++],
    eachMeshGeometriesPortion: elements[i++],
    eachMeshMatricesPortion: elements[i++],
    eachMeshTextureSet: elements[i++],
    eachMeshMaterialAttributes: elements[i++],
    eachEntityId: elements[i++],
    eachEntityMeshesPortion: elements[i++],
    eachTileAABB: elements[i++],
    eachTileEntitiesPortion: elements[i++]
  };
}

// ../sdk/src/xkt/versions/v10/xktToModel.ts
var tempVec4a3 = createVec4();
var tempVec4b3 = createVec4();
var NUM_TEXTURE_ATTRIBUTES = 9;
function lineStripToLines(positions, indices) {
  const linesIndices = [];
  if (indices.length > 1) {
    for (let i = 0, len = indices.length - 1; i < len; i++) {
      linesIndices.push(indices[i]);
      linesIndices.push(indices[i + 1]);
    }
  } else if (positions.length > 1) {
    for (let i = 0, len = positions.length / 3 - 1; i < len; i++) {
      linesIndices.push(i);
      linesIndices.push(i + 1);
    }
  }
  return linesIndices;
}
var decompressColor2 = function() {
  const floatColor = new Float32Array(3);
  return function(intColor) {
    floatColor[0] = intColor[0] / 255;
    floatColor[1] = intColor[1] / 255;
    floatColor[2] = intColor[2] / 255;
    return floatColor;
  };
}();
function xktToModel(params2) {
  let nextId = 0;
  const getNextId = () => {
    return `${nextId++}`;
  };
  const xktData = params2.xktData;
  const sceneModel = params2.sceneModel;
  const modelPartId = getNextId();
  const textureData = xktData.textureData;
  const eachTextureDataPortion = xktData.eachTextureDataPortion;
  const eachTextureAttributes = xktData.eachTextureAttributes;
  const positions = xktData.positions;
  const normals = xktData.normals;
  const colors = xktData.colors;
  const uvs = xktData.uvs;
  const indices = xktData.indices;
  const edgeIndices = xktData.edgeIndices;
  const eachTextureSetTextures = xktData.eachTextureSetTextures;
  const matrices = xktData.matrices;
  const reusedGeometriesDecodeMatrix = xktData.reusedGeometriesDecodeMatrix;
  const eachGeometryPrimitiveType = xktData.eachGeometryPrimitiveType;
  const eachGeometryPositionsPortion = xktData.eachGeometryPositionsPortion;
  const eachGeometryNormalsPortion = xktData.eachGeometryNormalsPortion;
  const eachGeometryColorsPortion = xktData.eachGeometryColorsPortion;
  const eachGeometryUVsPortion = xktData.eachGeometryUVsPortion;
  const eachGeometryIndicesPortion = xktData.eachGeometryIndicesPortion;
  const eachGeometryEdgeIndicesPortion = xktData.eachGeometryEdgeIndicesPortion;
  const eachMeshGeometriesPortion = xktData.eachMeshGeometriesPortion;
  const eachMeshMatricesPortion = xktData.eachMeshMatricesPortion;
  const eachMeshTextureSet = xktData.eachMeshTextureSet;
  const eachMeshMaterialAttributes = xktData.eachMeshMaterialAttributes;
  const eachEntityId = xktData.eachEntityId;
  const eachEntityMeshesPortion = xktData.eachEntityMeshesPortion;
  const eachTileAABB = xktData.eachTileAABB;
  const eachTileEntitiesPortion = xktData.eachTileEntitiesPortion;
  const numTextures = eachTextureDataPortion.length;
  const numTextureSets = eachTextureSetTextures.length / 5;
  const numGeometries = eachGeometryPositionsPortion.length;
  const numMeshes = eachMeshGeometriesPortion.length;
  const numEntities = eachEntityMeshesPortion.length;
  const numTiles = eachTileEntitiesPortion.length;
  for (let textureIndex = 0; textureIndex < numTextures; textureIndex++) {
    const atLastTexture = textureIndex === numTextures - 1;
    const textureDataPortionStart = eachTextureDataPortion[textureIndex];
    const textureDataPortionEnd = atLastTexture ? textureData.length : eachTextureDataPortion[textureIndex + 1];
    const textureDataPortionSize = textureDataPortionEnd - textureDataPortionStart;
    const textureDataPortionExists = textureDataPortionSize > 0;
    const textureAttrBaseIdx = textureIndex * NUM_TEXTURE_ATTRIBUTES;
    const compressed = eachTextureAttributes[textureAttrBaseIdx + 0] === 1;
    const mediaType = eachTextureAttributes[textureAttrBaseIdx + 1];
    const width = eachTextureAttributes[textureAttrBaseIdx + 2];
    const height = eachTextureAttributes[textureAttrBaseIdx + 3];
    const minFilter = eachTextureAttributes[textureAttrBaseIdx + 4];
    const magFilter = eachTextureAttributes[textureAttrBaseIdx + 5];
    const wrapS = eachTextureAttributes[textureAttrBaseIdx + 6];
    const wrapT = eachTextureAttributes[textureAttrBaseIdx + 7];
    const wrapR = eachTextureAttributes[textureAttrBaseIdx + 8];
    if (textureDataPortionExists) {
      const imageDataSubarray = new Uint8Array(textureData.subarray(textureDataPortionStart, textureDataPortionEnd));
      const arrayBuffer = imageDataSubarray.buffer;
      const textureId = `${modelPartId}-texture-${textureIndex}`;
      if (compressed) {
        sceneModel.createTexture({
          id: textureId,
          buffers: [arrayBuffer],
          minFilter,
          magFilter,
          wrapS,
          wrapT,
          wrapR
        });
      } else {
        const mimeType = mediaType === JPEGMediaType ? "image/jpeg" : mediaType === PNGMediaType ? "image/png" : "image/gif";
        const blob = new Blob([arrayBuffer], { type: mimeType });
        const urlCreator = window.URL || window.webkitURL;
        const imageUrl = urlCreator.createObjectURL(blob);
        const img = document.createElement("img");
        img.src = imageUrl;
        sceneModel.createTexture({
          id: textureId,
          image: img,
          //mediaType,
          minFilter,
          magFilter,
          wrapS,
          wrapT,
          wrapR
        });
      }
    }
  }
  for (let textureSetIndex = 0; textureSetIndex < numTextureSets; textureSetIndex++) {
    const eachTextureSetTexturesIndex = textureSetIndex * 5;
    const textureSetId = `${modelPartId}-textureSet-${textureSetIndex}`;
    const colorTextureIndex = eachTextureSetTextures[eachTextureSetTexturesIndex + 0];
    const metallicRoughnessTextureIndex = eachTextureSetTextures[eachTextureSetTexturesIndex + 1];
    const normalsTextureIndex = eachTextureSetTextures[eachTextureSetTexturesIndex + 2];
    const emissiveTextureIndex = eachTextureSetTextures[eachTextureSetTexturesIndex + 3];
    const occlusionTextureIndex = eachTextureSetTextures[eachTextureSetTexturesIndex + 4];
    sceneModel.createTextureSet({
      id: textureSetId,
      colorTextureId: colorTextureIndex >= 0 ? `${modelPartId}-texture-${colorTextureIndex}` : null,
      normalsTextureId: normalsTextureIndex >= 0 ? `${modelPartId}-texture-${normalsTextureIndex}` : null,
      metallicRoughnessTextureId: metallicRoughnessTextureIndex >= 0 ? `${modelPartId}-texture-${metallicRoughnessTextureIndex}` : null,
      emissiveTextureId: emissiveTextureIndex >= 0 ? `${modelPartId}-texture-${emissiveTextureIndex}` : null,
      occlusionTextureId: occlusionTextureIndex >= 0 ? `${modelPartId}-texture-${occlusionTextureIndex}` : null
    });
  }
  const geometryReuseCounts = new Uint32Array(numGeometries);
  for (let meshIndex = 0; meshIndex < numMeshes; meshIndex++) {
    const geometryIndex = eachMeshGeometriesPortion[meshIndex];
    if (geometryReuseCounts[geometryIndex] !== void 0) {
      geometryReuseCounts[geometryIndex]++;
    } else {
      geometryReuseCounts[geometryIndex] = 1;
    }
  }
  const tileCenter = createVec3();
  const rtcAABB = createAABB3();
  const geometryArraysCache = {};
  for (let tileIndex = 0; tileIndex < numTiles; tileIndex++) {
    const lastTileIndex = numTiles - 1;
    const atLastTile = tileIndex === lastTileIndex;
    const firstTileEntityIndex = eachTileEntitiesPortion[tileIndex];
    const lastTileEntityIndex = atLastTile ? numEntities - 1 : eachTileEntitiesPortion[tileIndex + 1] - 1;
    const tileAABBIndex = tileIndex * 6;
    const tileAABB = eachTileAABB.subarray(tileAABBIndex, tileAABBIndex + 6);
    getAABB3Center(tileAABB, tileCenter);
    rtcAABB[0] = tileAABB[0] - tileCenter[0];
    rtcAABB[1] = tileAABB[1] - tileCenter[1];
    rtcAABB[2] = tileAABB[2] - tileCenter[2];
    rtcAABB[3] = tileAABB[3] - tileCenter[0];
    rtcAABB[4] = tileAABB[4] - tileCenter[1];
    rtcAABB[5] = tileAABB[5] - tileCenter[2];
    const geometryCreatedInTile = {};
    let i = 0;
    for (let tileEntityIndex = firstTileEntityIndex; tileEntityIndex <= lastTileEntityIndex; tileEntityIndex++) {
      const xktEntityId = eachEntityId[tileEntityIndex];
      const entityId = xktEntityId;
      const finalTileEntityIndex = numEntities - 1;
      const atLastTileEntity = tileEntityIndex === finalTileEntityIndex;
      const firstMeshIndex = eachEntityMeshesPortion[tileEntityIndex];
      const lastMeshIndex = atLastTileEntity ? eachMeshGeometriesPortion.length - 1 : eachEntityMeshesPortion[tileEntityIndex + 1] - 1;
      const meshIds = [];
      for (let meshIndex = firstMeshIndex; meshIndex <= lastMeshIndex; meshIndex++) {
        const geometryIndex = eachMeshGeometriesPortion[meshIndex];
        const geometryReuseCount = geometryReuseCounts[geometryIndex];
        const isReusedGeometry = geometryReuseCount > 1;
        const atLastGeometry = geometryIndex === numGeometries - 1;
        const textureSetIndex = eachMeshTextureSet[meshIndex];
        const textureSetId = textureSetIndex >= 0 ? `${modelPartId}-textureSet-${textureSetIndex}` : null;
        const meshColor = decompressColor2(eachMeshMaterialAttributes.subarray(meshIndex * 6, meshIndex * 6 + 3));
        const meshOpacity = eachMeshMaterialAttributes[meshIndex * 6 + 3] / 255;
        const meshMetallic = eachMeshMaterialAttributes[meshIndex * 6 + 4] / 255;
        const meshRoughness = eachMeshMaterialAttributes[meshIndex * 6 + 5] / 255;
        const meshId = getNextId();
        if (isReusedGeometry) {
          const meshMatrixIndex = eachMeshMatricesPortion[meshIndex];
          const meshMatrix = matrices.slice(meshMatrixIndex, meshMatrixIndex + 16);
          const geometryId = `${modelPartId}-geometry.${tileIndex}.${geometryIndex}`;
          let geometryArrays = geometryArraysCache[geometryId];
          if (!geometryArrays) {
            geometryArrays = {};
            const primitiveType = eachGeometryPrimitiveType[geometryIndex];
            let geometryValid = false;
            switch (primitiveType) {
              case 0:
                geometryArrays.primitiveName = SolidPrimitive;
                geometryArrays.geometryPositions = positions.subarray(eachGeometryPositionsPortion[geometryIndex], atLastGeometry ? positions.length : eachGeometryPositionsPortion[geometryIndex + 1]);
                geometryArrays.geometryNormals = normals.subarray(eachGeometryNormalsPortion[geometryIndex], atLastGeometry ? normals.length : eachGeometryNormalsPortion[geometryIndex + 1]);
                geometryArrays.geometryUVs = uvs.subarray(eachGeometryUVsPortion[geometryIndex], atLastGeometry ? uvs.length : eachGeometryUVsPortion[geometryIndex + 1]);
                geometryArrays.geometryIndices = indices.subarray(eachGeometryIndicesPortion[geometryIndex], atLastGeometry ? indices.length : eachGeometryIndicesPortion[geometryIndex + 1]);
                geometryArrays.geometryEdgeIndices = edgeIndices.subarray(eachGeometryEdgeIndicesPortion[geometryIndex], atLastGeometry ? edgeIndices.length : eachGeometryEdgeIndicesPortion[geometryIndex + 1]);
                geometryValid = geometryArrays.geometryPositions.length > 0 && geometryArrays.geometryIndices.length > 0;
                break;
              case 1:
                geometryArrays.primitiveName = SurfacePrimitive;
                geometryArrays.geometryPositions = positions.subarray(eachGeometryPositionsPortion[geometryIndex], atLastGeometry ? positions.length : eachGeometryPositionsPortion[geometryIndex + 1]);
                geometryArrays.geometryNormals = normals.subarray(eachGeometryNormalsPortion[geometryIndex], atLastGeometry ? normals.length : eachGeometryNormalsPortion[geometryIndex + 1]);
                geometryArrays.geometryUVs = uvs.subarray(eachGeometryUVsPortion[geometryIndex], atLastGeometry ? uvs.length : eachGeometryUVsPortion[geometryIndex + 1]);
                geometryArrays.geometryIndices = indices.subarray(eachGeometryIndicesPortion[geometryIndex], atLastGeometry ? indices.length : eachGeometryIndicesPortion[geometryIndex + 1]);
                geometryArrays.geometryEdgeIndices = edgeIndices.subarray(eachGeometryEdgeIndicesPortion[geometryIndex], atLastGeometry ? edgeIndices.length : eachGeometryEdgeIndicesPortion[geometryIndex + 1]);
                geometryValid = geometryArrays.geometryPositions.length > 0 && geometryArrays.geometryIndices.length > 0;
                break;
              case 2:
                geometryArrays.primitiveName = PointsPrimitive;
                geometryArrays.geometryPositions = positions.subarray(eachGeometryPositionsPortion[geometryIndex], atLastGeometry ? positions.length : eachGeometryPositionsPortion[geometryIndex + 1]);
                geometryArrays.geometryColors = colors.subarray(eachGeometryColorsPortion[geometryIndex], atLastGeometry ? colors.length : eachGeometryColorsPortion[geometryIndex + 1]);
                geometryValid = geometryArrays.geometryPositions.length > 0;
                break;
              case 3:
                geometryArrays.primitiveName = LinesPrimitive;
                geometryArrays.geometryPositions = positions.subarray(eachGeometryPositionsPortion[geometryIndex], atLastGeometry ? positions.length : eachGeometryPositionsPortion[geometryIndex + 1]);
                geometryArrays.geometryIndices = indices.subarray(eachGeometryIndicesPortion[geometryIndex], atLastGeometry ? indices.length : eachGeometryIndicesPortion[geometryIndex + 1]);
                geometryValid = geometryArrays.geometryPositions.length > 0 && geometryArrays.geometryIndices.length > 0;
                break;
              case 4:
                geometryArrays.primitiveName = LinesPrimitive;
                geometryArrays.geometryPositions = positions.subarray(eachGeometryPositionsPortion[geometryIndex], atLastGeometry ? positions.length : eachGeometryPositionsPortion[geometryIndex + 1]);
                geometryArrays.geometryIndices = lineStripToLines(
                  geometryArrays.geometryPositions,
                  indices.subarray(
                    eachGeometryIndicesPortion[geometryIndex],
                    atLastGeometry ? indices.length : eachGeometryIndicesPortion[geometryIndex + 1]
                  )
                );
                geometryValid = geometryArrays.geometryPositions.length > 0 && geometryArrays.geometryIndices.length > 0;
                break;
              default:
                continue;
            }
            if (!geometryValid) {
              geometryArrays = null;
            }
          }
          if (geometryArrays) {
            if (!geometryCreatedInTile[geometryId]) {
              sceneModel.createGeometryCompressed({
                id: geometryId,
                primitive: geometryArrays.primitiveName,
                positionsCompressed: geometryArrays.geometryPositions,
                uvsCompressed: geometryArrays.geometryUVs,
                colorsCompressed: geometryArrays.geometryColors,
                indices: geometryArrays.geometryIndices,
                edgeIndices: geometryArrays.geometryEdgeIndices,
                aabb: rtcAABB
              });
              geometryCreatedInTile[geometryId] = true;
            }
            sceneModel.createMesh({
              id: meshId,
              geometryId,
              textureSetId,
              matrix: meshMatrix,
              color: meshColor,
              opacity: meshOpacity,
              ///////////////////////////////////
              // Adjust matrix?
              /////////////////////////////////////
              origin: [tileCenter[0], tileCenter[1] + i++ * 10, tileCenter[2]]
            });
            meshIds.push(meshId);
          }
        } else {
          const primitiveType = eachGeometryPrimitiveType[geometryIndex];
          let primitiveName;
          let geometryPositions;
          let geometryNormals;
          let geometryUVs;
          let geometryColors;
          let geometryIndices;
          let geometryEdgeIndices;
          let geometryValid = false;
          switch (primitiveType) {
            case 0:
              primitiveName = SolidPrimitive;
              geometryPositions = positions.subarray(eachGeometryPositionsPortion[geometryIndex], atLastGeometry ? positions.length : eachGeometryPositionsPortion[geometryIndex + 1]);
              geometryNormals = normals.subarray(eachGeometryNormalsPortion[geometryIndex], atLastGeometry ? normals.length : eachGeometryNormalsPortion[geometryIndex + 1]);
              geometryUVs = uvs.subarray(eachGeometryUVsPortion[geometryIndex], atLastGeometry ? uvs.length : eachGeometryUVsPortion[geometryIndex + 1]);
              geometryIndices = indices.subarray(eachGeometryIndicesPortion[geometryIndex], atLastGeometry ? indices.length : eachGeometryIndicesPortion[geometryIndex + 1]);
              geometryEdgeIndices = edgeIndices.subarray(eachGeometryEdgeIndicesPortion[geometryIndex], atLastGeometry ? edgeIndices.length : eachGeometryEdgeIndicesPortion[geometryIndex + 1]);
              geometryValid = geometryPositions.length > 0 && geometryIndices.length > 0;
              break;
            case 1:
              primitiveName = SurfacePrimitive;
              geometryPositions = positions.subarray(eachGeometryPositionsPortion[geometryIndex], atLastGeometry ? positions.length : eachGeometryPositionsPortion[geometryIndex + 1]);
              geometryNormals = normals.subarray(eachGeometryNormalsPortion[geometryIndex], atLastGeometry ? normals.length : eachGeometryNormalsPortion[geometryIndex + 1]);
              geometryUVs = uvs.subarray(eachGeometryUVsPortion[geometryIndex], atLastGeometry ? uvs.length : eachGeometryUVsPortion[geometryIndex + 1]);
              geometryIndices = indices.subarray(eachGeometryIndicesPortion[geometryIndex], atLastGeometry ? indices.length : eachGeometryIndicesPortion[geometryIndex + 1]);
              geometryEdgeIndices = edgeIndices.subarray(eachGeometryEdgeIndicesPortion[geometryIndex], atLastGeometry ? edgeIndices.length : eachGeometryEdgeIndicesPortion[geometryIndex + 1]);
              geometryValid = geometryPositions.length > 0 && geometryIndices.length > 0;
              break;
            case 2:
              primitiveName = PointsPrimitive;
              geometryPositions = positions.subarray(eachGeometryPositionsPortion[geometryIndex], atLastGeometry ? positions.length : eachGeometryPositionsPortion[geometryIndex + 1]);
              geometryColors = colors.subarray(eachGeometryColorsPortion[geometryIndex], atLastGeometry ? colors.length : eachGeometryColorsPortion[geometryIndex + 1]);
              geometryValid = geometryPositions.length > 0;
              break;
            case 3:
              primitiveName = LinesPrimitive;
              geometryPositions = positions.subarray(eachGeometryPositionsPortion[geometryIndex], atLastGeometry ? positions.length : eachGeometryPositionsPortion[geometryIndex + 1]);
              geometryIndices = indices.subarray(eachGeometryIndicesPortion[geometryIndex], atLastGeometry ? indices.length : eachGeometryIndicesPortion[geometryIndex + 1]);
              geometryValid = geometryPositions.length > 0 && geometryIndices.length > 0;
              break;
            case 4:
              primitiveName = LinesPrimitive;
              geometryPositions = positions.subarray(eachGeometryPositionsPortion[geometryIndex], atLastGeometry ? positions.length : eachGeometryPositionsPortion[geometryIndex + 1]);
              geometryIndices = lineStripToLines(
                geometryPositions,
                indices.subarray(eachGeometryIndicesPortion[geometryIndex], atLastGeometry ? indices.length : eachGeometryIndicesPortion[geometryIndex + 1])
              );
              geometryValid = geometryPositions.length > 0 && geometryIndices.length > 0;
              break;
            default:
              continue;
          }
          if (geometryValid) {
            const geometryId = getNextId();
            sceneModel.createGeometryCompressed({
              id: geometryId,
              primitive: primitiveName,
              positionsCompressed: geometryPositions,
              uvsCompressed: geometryUVs && geometryUVs.length > 0 ? geometryUVs : null,
              colorsCompressed: geometryColors,
              indices: geometryIndices,
              edgeIndices: geometryEdgeIndices,
              aabb: rtcAABB
            });
            sceneModel.createMesh({
              id: meshId,
              geometryId,
              textureSetId,
              //   origin: tileCenter,
              origin: [tileCenter[0], tileCenter[1] + i++ * 10, tileCenter[2]],
              color: meshColor,
              opacity: meshOpacity
            });
            meshIds.push(meshId);
          }
        }
      }
      if (meshIds.length > 0) {
        sceneModel.createObject({
          id: entityId,
          meshIds
        });
      }
    }
  }
}

// ../sdk/src/xkt/versions/v10/parse.ts
function parse10(params2, options = {}) {
  return new Promise(function(resolve2, reject) {
    const { fileData, sceneModel } = params2;
    if (sceneModel) {
      xktToModel({
        xktData: inflateXKT(unpackXKT(fileData)),
        sceneModel
      });
    }
    return resolve2();
  });
}

// ../sdk/src/xkt/XKTLoader.ts
var XKTLoader = class extends ModelLoader {
  /**
   * Constructs an XKTLoader.
   */
  constructor() {
    super({
      fileDataType: "arraybuffer",
      parsers: {
        "10": parse10
      },
      getVersion: (fileData) => {
        return "" + new DataView(fileData).getUint32(0, true);
      }
    });
  }
};

// ../sdk/src/metamodel/index.ts
var metamodel_exports = {};
__export(metamodel_exports, {
  MetaModelLoader: () => MetaModelLoader,
  convertMetaModel: () => convertMetaModel
});

// ../sdk/src/metamodel/MetaModelLoader.ts
var MetaModelLoader = class extends ModelLoader {
  /**
   * Constructs a MetaModelLoader.
   */
  constructor() {
    super({
      fileDataType: "json",
      parsers: {
        "1.0": parseMetaModel
      },
      getVersion: (fileData) => {
        return fileData.version || "1.0";
      }
    });
  }
};
function parseMetaModel(params2) {
  const { fileData, dataModel } = params2;
  if (fileData.propertySets) {
    for (let i = 0, len = fileData.propertySets.length; i < len; i++) {
      const propertySetData = fileData.propertySets[i];
      if (!propertySetData.properties) {
        propertySetData.properties = [];
      }
      let propertySet = dataModel.propertySets[propertySetData.id];
      if (!propertySet) {
        dataModel.createPropertySet({
          id: propertySetData.id,
          type: propertySetData.type,
          name: propertySetData.name,
          // FIXME: Properties not translated right here
          properties: propertySetData.properties
        });
      }
    }
  }
  if (fileData.metaObjects) {
    for (let i = 0, len = fileData.metaObjects.length; i < len; i++) {
      const metaObjectData = fileData.metaObjects[i];
      const id = metaObjectData.id;
      let dataObject = dataModel.objects[id];
      if (!dataObject) {
        const originalSystemId = metaObjectData.originalSystemId;
        const propertySetIds = metaObjectData.propertySets || metaObjectData.propertySetIds;
        const type = ifcTypeCodes[metaObjectData.type];
        dataModel.createObject({
          id,
          originalSystemId,
          type,
          name: metaObjectData.name,
          propertySetIds
        });
        if (metaObjectData.parent) {
          dataModel.createRelationship({
            relatingObjectId: metaObjectData.parent,
            relatedObjectId: id,
            type: IfcRelAggregates
          });
        }
      }
    }
  }
  return Promise.resolve();
}

// ../sdk/src/metamodel/convertMetaModel.ts
function convertMetaModel(metaModelParams) {
  const dataModelParams = {
    id: "",
    objects: [],
    relationships: [],
    propertySets: []
  };
  if (metaModelParams.propertySets) {
    for (let i = 0, len = metaModelParams.propertySets.length; i < len; i++) {
      const propertySetParams = metaModelParams.propertySets[i];
      if (!propertySetParams.properties) {
        propertySetParams.properties = [];
      }
      dataModelParams.propertySets.push(propertySetParams);
    }
  }
  if (metaModelParams.metaObjects) {
    for (let i = 0, len = metaModelParams.metaObjects.length; i < len; i++) {
      const metaObject = metaModelParams.metaObjects[i];
      dataModelParams.objects.push({
        id: metaObject.id,
        name: metaObject.name,
        type: 0
        //metaObject.type
      });
      if (metaObject.parent) {
        dataModelParams.relationships.push({
          relatingObjectId: metaObject.parent,
          relatedObjectId: metaObject.id,
          type: IfcRelAggregates
        });
      }
    }
  }
  return dataModelParams;
}

// ../sdk/src/xkt/loadXKTManifest.ts
function loadXKTManifest(params2) {
  return new Promise((resolve2, reject) => {
    if (!params2) {
      return reject("Argument expected: params");
    }
    const sceneModel = params2.sceneModel;
    if (!sceneModel) {
      return reject("Parameter expected: sceneModel");
    }
    const dataModel = params2.dataModel;
    if (!params2.manifest && !params2.src) {
      return reject("Parameter expected: manifest or src");
    }
    const metaModelReader = new MetaModelLoader();
    if (params2.src) {
      const xktReader = new XKTLoader();
      const baseDir = getBaseDirectory(params2.src);
      fetch(params2.src).then((response) => {
        response.json().then((manifest) => {
          const xktFiles = manifest.xktFiles;
          const metaModelFiles = manifest.metaModelFiles;
          const loadXKTFiles = (done) => {
            let i = 0;
            const loadNextXKT = () => {
              if (sceneModel.destroyed) {
                done();
              } else if (i >= xktFiles.length) {
                done();
              } else {
                fetch(`${baseDir}${xktFiles[i]}`).then((response2) => {
                  response2.arrayBuffer().then((fileData) => {
                    xktReader.load({
                      fileData,
                      sceneModel
                    }).then(() => {
                      i++;
                      loadNextXKT();
                    }).catch((error) => {
                      reject(`Error loading XKT file: ${error}`);
                    });
                  });
                });
              }
            };
            loadNextXKT();
          };
          const loadMetaModelFiles = (done) => {
            let i = 0;
            const loadNextMetaModelFile = () => {
              if (dataModel.destroyed) {
                done();
              } else if (i >= metaModelFiles.length) {
                done();
              } else {
                fetch(`${baseDir}${metaModelFiles[i]}`).then((response2) => {
                  response2.json().then((fileData) => {
                    metaModelReader.load({
                      fileData,
                      dataModel
                    }).then(() => {
                      i++;
                      loadNextMetaModelFile();
                    }).catch((error) => {
                      reject(`Error loading XKT metadata file: ${error}`);
                    });
                  });
                });
              }
            };
            loadNextMetaModelFile();
          };
          if (xktFiles && metaModelFiles) {
            loadXKTFiles(() => {
              loadMetaModelFiles(() => {
                resolve2();
              });
            });
          } else if (xktFiles) {
            loadXKTFiles(() => {
              resolve2();
            });
          } else if (metaModelFiles) {
            loadMetaModelFiles(() => {
              resolve2();
            });
          } else {
            resolve2();
          }
        });
      });
    }
  });
}
function getBaseDirectory(filePath) {
  const pathArray = filePath.split("/");
  pathArray.pop();
  return pathArray.join("/") + "/";
}

// ../sdk/src/modelchunksloader/index.ts
var modelchunksloader_exports = {};
__export(modelchunksloader_exports, {
  ModelChunksLoader: () => ModelChunksLoader
});

// ../sdk/src/modelchunksloader/ModelChunksLoader.ts
var ModelChunksLoader = class {
  #sceneModelLoader;
  #dataModelLoader;
  #cancelled;
  constructor(params2) {
    const { sceneModelLoader, dataModelLoader } = params2;
    this.#sceneModelLoader = sceneModelLoader;
    this.#dataModelLoader = dataModelLoader || new DataModelParamsLoader();
    this.#cancelled = false;
  }
  cancel() {
    this.#cancelled = true;
  }
  get cancelled() {
    return this.#cancelled;
  }
  /**
   * Loads the geometry and data models listed in a ModelChunksManifestParams into a SceneModel and DataModel.
   *
   * Loading can be interrupted at any time by calling {@link modelchunksloader!ModelChunksLoader.cancel | ModelChunksLoader.cancel}.
   *
   * @param params
   * @returns {Promise} Resolves when all models have been loaded.
   */
  load(params2) {
    this.#cancelled = false;
    return new Promise((resolve2, reject) => {
      if (!params2) {
        return reject("Argument expected: params");
      }
      const { modelChunksManifest, baseDir, sceneModel, dataModel } = params2;
      if (!modelChunksManifest) {
        return reject("Parameter expected: modelChunksManifest");
      }
      if (!baseDir) {
        return reject("Parameter expected: baseDir");
      }
      const sceneModelFiles = modelChunksManifest.sceneModelFiles;
      const dataModelFiles = modelChunksManifest.dataModelFiles;
      const loadSceneModelFiles = (done) => {
        let i = 0;
        const loadNextSceneModelFile = () => {
          if (this.#cancelled || sceneModel.destroyed) {
            done();
          } else if (i >= sceneModelFiles.length) {
            done();
          } else {
            fetch(`${baseDir}/${sceneModelFiles[i]}`).then((response) => {
              const fileDataType = this.#sceneModelLoader.fileDataType;
              (fileDataType === "json" ? response.json() : fileDataType === "arraybuffer" ? response.arrayBuffer() : response.arrayBuffer()).then((fileData) => {
                this.#sceneModelLoader.load({
                  fileData,
                  sceneModel
                }).then(() => {
                  i++;
                  loadNextSceneModelFile();
                }).catch((error) => {
                  reject(`Error loading SceneModel file: ${error}`);
                });
              }).catch((error) => {
                reject(`Error loading SceneModel file: ${error}`);
              });
            }).catch((error) => {
              reject(`Error loading SceneModel file: ${error}`);
            });
          }
        };
        loadNextSceneModelFile();
      };
      const loadDataModelFiles = (done) => {
        let i = 0;
        const loadNextDataModelFile = () => {
          if (this.#cancelled || dataModel.destroyed) {
            done();
          } else if (i >= dataModelFiles.length) {
            done();
          } else {
            fetch(`${baseDir}/${dataModelFiles[i]}`).then((response) => {
              const fileDataType = this.#sceneModelLoader.fileDataType;
              (fileDataType === "json" ? response.json() : fileDataType === "arraybuffer" ? response.arrayBuffer() : response.arrayBuffer()).then((fileData) => {
                this.#dataModelLoader.load({
                  fileData,
                  dataModel
                }).then(() => {
                  i++;
                  loadNextDataModelFile();
                });
              }).catch((error) => {
                reject(`Error loading DataModel file: ${error}`);
              });
            }).catch((error) => {
              reject(`Error loading DataModel file: ${error}`);
            });
          }
        };
        loadNextDataModelFile();
      };
      if (sceneModelFiles && sceneModel && dataModelFiles && dataModel) {
        loadSceneModelFiles(() => {
          loadDataModelFiles(() => {
            resolve2();
          });
        });
      } else if (sceneModelFiles && sceneModel) {
        loadSceneModelFiles(() => {
          resolve2();
        });
      } else if (dataModelFiles && dataModel) {
        loadDataModelFiles(() => {
          resolve2();
        });
      } else {
        resolve2();
      }
    });
  }
};

// ../sdk/src/viewer/index.ts
var viewer_exports = {};
__export(viewer_exports, {
  AmbientLight: () => AmbientLight,
  Camera: () => Camera,
  CustomProjection: () => CustomProjection,
  DirLight: () => DirLight,
  Edges: () => Edges,
  EmphasisMaterial: () => EmphasisMaterial,
  FrustumProjection: () => FrustumProjection,
  LinesMaterial: () => LinesMaterial,
  Metrics: () => Metrics,
  OrthoProjection: () => OrthoProjection,
  PerspectiveProjection: () => PerspectiveProjection,
  PickResult: () => PickResult,
  PointLight: () => PointLight,
  PointsMaterial: () => PointsMaterial,
  ResolutionScale: () => ResolutionScale,
  SAO: () => SAO,
  SectionPlane: () => SectionPlane,
  SnapshotResult: () => SnapshotResult,
  Texturing: () => Texturing,
  View: () => View,
  ViewLayer: () => ViewLayer,
  ViewObject: () => ViewObject,
  Viewer: () => Viewer,
  scheduler: () => scheduler
});

// ../sdk/src/viewer/Viewer.ts
var import_strongly_typed_events16 = __toESM(require_dist8());

// ../sdk/src/viewer/View.ts
var import_strongly_typed_events15 = __toESM(require_dist8());

// ../sdk/src/viewer/ViewObject.ts
var ViewObject = class {
  /**
   * Unique ID of this ViewObject within {@link ViewLayer.objects}.
   */
  id;
  /**
   * ID of this ViewObject within the originating system.
   */
  originalSystemId;
  /**
   * The ViewLayer to which this ViewObject belongs.
   */
  layer;
  /**
   * The corresponding {@link scene!SceneObject}.
   */
  sceneObject;
  /**
   * The corresponding {@link RendererObject}.
   * @internal
   */
  #rendererObject;
  #state;
  /**
   * @private
   */
  constructor(layer, sceneObject, rendererObject) {
    this.id = sceneObject.id;
    this.originalSystemId = sceneObject.originalSystemId;
    this.layer = layer;
    this.sceneObject = sceneObject;
    this.#rendererObject = rendererObject;
    this.#state = {
      visible: true,
      culled: false,
      pickable: true,
      clippable: true,
      collidable: true,
      xrayed: false,
      selected: false,
      highlighted: false,
      colorize: new Float32Array(4),
      colorized: false,
      opacityUpdated: false
    };
    this.#rendererObject.setVisible(this.layer.view.viewIndex, this.#state.visible);
    this.layer.objectVisibilityUpdated(this, this.#state.visible, true);
    this.#rendererObject.setPickable(this.layer.view.viewIndex, this.#state.pickable);
  }
  /**
   * Gets the World-space axis-aligned 3D boundary of this ViewObject.
   */
  get aabb() {
    return this.sceneObject.aabb;
  }
  /**
   * Gets if this ViewObject is visible.
   *
   * * When {@link ViewObject.visible} is ````true```` the ViewObject will be registered by {@link ViewObject.id} in {@link ViewLayer.visibleObjects}.
   * * Each ViewObject is only rendered when {@link ViewObject.visible} is ````true```` and {@link ViewObject.culled} is ````false````.
   * * Use {@link ViewLayer.setObjectsVisible} to batch-update the visibility of ViewObjects, which fires a single event for the batch.
   */
  get visible() {
    return this.#state.visible;
  }
  /**
   * Sets if this ViewObject is visible.
   *
   * * When {@link ViewObject.visible} is ````true```` the ViewObject will be registered by {@link ViewObject.id} in {@link ViewLayer.visibleObjects}.
   * * Each ViewObject is only rendered when {@link ViewObject.visible} is ````true```` and {@link ViewObject.culled} is ````false````.
   * * Fires an "objectVisibility" event on associated {@link ViewLayer}s.
   * * Use {@link ViewLayer.setObjectsVisible} to batch-update the visibility of ViewObjects, which fires a single event for the batch.
   */
  set visible(visible) {
    if (visible === this.#state.visible) {
      return;
    }
    this.#state.visible = visible;
    const result = this.#rendererObject.setVisible(this.layer.view.viewIndex, visible);
    if (result instanceof SDKError) {
      throw result;
    }
    this.layer.objectVisibilityUpdated(this, visible, true);
    this.layer.redraw();
  }
  /**
   * Gets if this ViewObject is X-rayed.
   *
   * * When {@link ViewObject.xrayed} is ````true```` the ViewObject will be registered by {@link ViewObject.id} in {@link ViewLayer.xrayedObjects | ViewLayer.xrayedObjects}.
   * * Use {@link ViewLayer.setObjectsXRayed} to batch-update the X-rayed state of ViewObjects.
   */
  get xrayed() {
    return this.#state.xrayed;
  }
  /**
   * Sets if this ViewObject is X-rayed.
   *
   * * When {@link ViewObject.xrayed} is ````true```` the ViewObject will be registered by {@link ViewObject.id} in {@link ViewLayer.xrayedObjects | ViewLayer.xrayedObjects}.
   * * Use {@link ViewLayer.setObjectsXRayed} to batch-update the X-rayed state of ViewObjects.
   */
  set xrayed(xrayed) {
    if (this.#state.xrayed === xrayed) {
      return;
    }
    this.#state.xrayed = xrayed;
    const result = this.#rendererObject.setXRayed(this.layer.view.viewIndex, xrayed);
    if (result instanceof SDKError) {
      throw result;
    }
    this.layer.objectXRayedUpdated(this, xrayed);
    this.layer.redraw();
  }
  /**
   * Gets if this ViewObject is highlighted.
   *
   * * When {@link ViewObject.highlighted} is ````true```` the ViewObject will be registered by {@link ViewObject.id} in {@link ViewLayer.highlightedObjects | ViewLayer.highlightedObjects}.
   * * Use {@link ViewLayer.setObjectsHighlighted} to batch-update the highlighted state of ViewObjects.
   */
  get highlighted() {
    return this.#state.highlighted;
  }
  /**
   * Sets if this ViewObject is highlighted.
   *
   * * When {@link ViewObject.highlighted} is ````true```` the ViewObject will be registered by {@link ViewObject.id} in {@link ViewLayer.highlightedObjects | ViewLayer.highlightedObjects}.
   * * Use {@link ViewLayer.setObjectsHighlighted} to batch-update the highlighted state of ViewObjects.
   */
  set highlighted(highlighted) {
    if (highlighted === this.#state.highlighted) {
      return;
    }
    this.#state.highlighted = highlighted;
    const result = this.#rendererObject.setHighlighted(this.layer.view.viewIndex, highlighted);
    if (result instanceof SDKError) {
      throw result;
    }
    this.layer.objectHighlightedUpdated(this, highlighted);
    this.layer.redraw();
  }
  /**
   * Gets if this ViewObject is selected.
   *
   * * When {@link ViewObject.selected} is ````true```` the ViewObject will be registered by {@link ViewObject.id} in {@link ViewLayer.selectedObjects | ViewLayer.selectedObjects}.
   * * Use {@link ViewLayer.setObjectsSelected} to batch-update the selected state of ViewObjects.
   */
  get selected() {
    return this.#state.selected;
  }
  /**
   * Sets if this ViewObject is selected.
   *
   * * When {@link ViewObject.selected} is ````true```` the ViewObject will be registered by {@link ViewObject.id} in {@link ViewLayer.selectedObjects | ViewLayer.selectedObjects}.
   * * Use {@link ViewLayer.setObjectsSelected} to batch-update the selected state of ViewObjects.
   */
  set selected(selected) {
    if (selected === this.#state.selected) {
      return;
    }
    this.#state.selected = selected;
    const result = this.#rendererObject.setSelected(this.layer.view.viewIndex, selected);
    if (result instanceof SDKError) {
      throw result;
    }
    this.layer.objectSelectedUpdated(this, selected);
    this.layer.redraw();
  }
  /**
   * Gets if this ViewObject is culled.
   *
   * * The ViewObject is only rendered when {@link ViewObject.visible} is ````true```` and {@link ViewObject.culled} is ````false````.
   * * Use {@link ViewLayer.setObjectsCulled} to batch-update the culled state of ViewObjects.
   */
  get culled() {
    return this.#state.culled;
  }
  /**
   * Sets if this ViewObject is culled.
   *
   * * The ViewObject is only rendered when {@link ViewObject.visible} is ````true```` and {@link ViewObject.culled} is ````false````.
   * * Use {@link ViewLayer.setObjectsCulled} to batch-update the culled state of ViewObjects.
   */
  set culled(culled) {
    if (culled === this.#state.culled) {
      return;
    }
    const result = this.#rendererObject.setCulled(this.layer.view.viewIndex, culled);
    if (result instanceof SDKError) {
      throw result;
    }
    this.#state.culled = culled;
    this.layer.redraw();
  }
  /**
   * Gets if this ViewObject is clippable.
   *
   * * Clipping is done by the {@link SectionPlane | SectionPlanes} in {@link View.sectionPlanes | View.sectionPlanes}.
   * * Use {@link View.setObjectsClippable | View.setObjectsClippable} or {@link ViewLayer.setObjectsClippable | ViewLayer.setObjectsClippable} to batch-update the clippable state of multiple ViewObjects.
   */
  get clippable() {
    return this.#state.clippable;
  }
  /**
   * Sets if this ViewObject is clippable.
   *
   * * Clipping is done by the {@link SectionPlane | SectionPlanes} in {@link View.sectionPlanes | View.sectionPlanes}.
   * * Use {@link View.setObjectsClippable | View.setObjectsClippable} or {@link ViewLayer.setObjectsClippable | ViewLayer.setObjectsClippable} to batch-update the clippable state of multiple ViewObjects.
   */
  set clippable(clippable) {
    if (clippable === this.#state.clippable) {
      return;
    }
    const result = this.#rendererObject.setCulled(this.layer.view.viewIndex, clippable);
    if (result instanceof SDKError) {
      throw result;
    }
    this.#state.clippable = clippable;
    this.layer.redraw();
  }
  /**
   * Gets if this ViewObject is included in boundary calculations.
   */
  get collidable() {
    return this.#state.collidable;
  }
  /**
   * Sets if this ViewObject included in boundary calculations.
   */
  set collidable(collidable) {
    if (collidable === this.#state.collidable) {
      return;
    }
    this.#state.collidable = collidable;
  }
  /**
   * Gets if this ViewObject is pickable.
   *
   * * Picking is done with {@link View.pick}.
   * * Use {@link ViewLayer.setObjectsPickable} to batch-update the pickable state of ViewObjects.
   */
  get pickable() {
    return this.#state.pickable;
  }
  /**
   * Sets if this ViewObject is pickable.
   *
   * * Picking is done with {@link View.pick}.
   * * Use {@link ViewLayer.setObjectsPickable} to batch-update the pickable state of ViewObjects.
   */
  set pickable(pickable) {
    if (this.#state.pickable === pickable) {
      return;
    }
    const result = this.#rendererObject.setPickable(this.layer.view.viewIndex, pickable);
    if (result instanceof SDKError) {
      throw result;
    }
    this.#state.pickable = pickable;
  }
  /**
   * Gets the RGB colorize color for this ViewObject.
   *
   * * Multiplies by rendered fragment colors.
   * * Each element of the color is in range ````[0..1]````.
   * * Use {@link ViewLayer.setObjectsColorized} to batch-update the colorized state of ViewObjects.
   */
  get colorize() {
    return this.#state.colorize;
  }
  /**
   * Sets the RGB colorize color for this ViewObject.
   *
   * * Multiplies by rendered fragment colors.
   * * Each element of the color is in range ````[0..1]````.
   * * Set to ````null```` or ````undefined```` to reset the colorize color to its default value of ````[1,1,1]````.
   * * Use {@link ViewLayer.setObjectsColorized} to batch-update the colorized state of ViewObjects.
   */
  set colorize(value) {
    let colorize = this.#state.colorize;
    if (value) {
      colorize[0] = value[0];
      colorize[1] = value[1];
      colorize[2] = value[2];
    } else {
      colorize[0] = 1;
      colorize[1] = 1;
      colorize[2] = 1;
    }
    const result = this.#rendererObject.setColorize(this.layer.view.viewIndex, colorize);
    if (result instanceof SDKError) {
      throw result;
    }
    this.#state.colorized = !!value;
    this.layer.objectColorizeUpdated(this, this.#state.colorized);
    this.layer.redraw();
  }
  /**
   * Gets the opacity factor for this ViewObject.
   *
   * * This is a factor in range ````[0..1]```` which multiplies by the rendered fragment alphas.
   * * Use {@link ViewLayer.setObjectsOpacity} to batch-update the opacities of ViewObjects.
   */
  get opacity() {
    return this.#state.colorize[3];
  }
  /**
   * Sets the opacity factor for this ViewObject.
   *
   * * This is a factor in range ````[0..1]```` which multiplies by the rendered fragment alphas.
   * * Set to ````null```` or ````undefined```` to reset the opacity to its default value of ````1````.
   * * Use {@link ViewLayer.setObjectsOpacity} to batch-update the opacities of ViewObjects.
   */
  set opacity(opacity) {
    let colorize = this.#state.colorize;
    this.#state.opacityUpdated = opacity !== null && opacity !== void 0;
    colorize[3] = this.#state.opacityUpdated ? opacity : 1;
    this.layer.objectOpacityUpdated(this, this.#state.opacityUpdated);
    this.layer.redraw();
  }
  /**
   * @private
   */
  _destroy() {
    if (this.#state.visible) {
      this.layer.objectVisibilityUpdated(this, false, false);
    }
    if (this.#state.xrayed) {
      this.layer.objectXRayedUpdated(this, false);
    }
    if (this.#state.selected) {
      this.layer.objectSelectedUpdated(this, false);
    }
    if (this.#state.highlighted) {
      this.layer.objectHighlightedUpdated(this, false);
    }
    if (this.#state.colorized) {
      this.layer.objectColorizeUpdated(this, false);
    }
    if (this.#state.opacityUpdated) {
      this.layer.objectOpacityUpdated(this, false);
    }
    this.layer.redraw();
  }
};

// ../sdk/src/viewer/SectionPlane.ts
var import_strongly_typed_events7 = __toESM(require_dist8());
var SectionPlane = class extends Component {
  /**
   * The View to which this SectionPlane belongs.
   *
   * @property view
   * @type {View}
   *
   */
  view;
  /**
   * Emits an event each time {@link SectionPlane.pos} changes.
   *
   * @event
   */
  onPos;
  /**
   * Emits an event each time {@link SectionPlane.dir} changes.
   *
   * @event
   */
  onDir;
  /**
   * Emits an event each time {@link SectionPlane.active} changes.
   *
   * @event
   */
  onActive;
  #state;
  /**
   * @private
   *
   */
  constructor(view, sectionPlaneParams = {}) {
    super(view, sectionPlaneParams);
    this.view = view;
    this.#state = {
      active: sectionPlaneParams.active !== false,
      pos: new Float64Array(sectionPlaneParams.pos || [0, 0, 0]),
      dir: new Float32Array(sectionPlaneParams.pos || [0, 0, -1]),
      dist: 0
    };
    this.onPos = new EventEmitter(new import_strongly_typed_events7.EventDispatcher());
    this.onDir = new EventEmitter(new import_strongly_typed_events7.EventDispatcher());
    this.onActive = new EventEmitter(new import_strongly_typed_events7.EventDispatcher());
  }
  /**
   * Gets if this SectionPlane is active or not.
   *
   * Default value is ````true````.
   *
   * @returns Returns ````true```` if active.
   */
  get active() {
    return this.#state.active;
  }
  /**
   * Sets if this SectionPlane is active or not.
   *
   * Default value is ````true````.
   *
   * @param value Set ````true```` to activate else ````false```` to deactivate.
   */
  set active(value) {
    if (this.#state.active === value) {
      return;
    }
    this.#state.active = value;
    this.view.redraw();
    this.onActive.dispatch(this, this.#state.active);
  }
  /**
   * Gets the World-space position of this SectionPlane's plane.
   *
   * Default value is ````[0, 0, 0]````.
   *
   * @returns  Current position.
   */
  get pos() {
    return this.#state.pos;
  }
  /**
   * Sets the World-space position of this SectionPlane's plane.
   *
   * Default value is ````[0, 0, 0]````.
   *
   * @param value New position.
   */
  set pos(value) {
    this.#state.pos.set(value);
    this.#state.dist = -dotVec3(this.#state.pos, this.#state.dir);
    this.onPos.dispatch(this, this.#state.pos);
  }
  /**
   * Gets the direction of this SectionPlane's plane.
   *
   * Default value is ````[0, 0, -1]````.
   *
   * @returns value Current direction.
   */
  get dir() {
    return this.#state.dir;
  }
  /**
   * Sets the direction of this SectionPlane's plane.
   *
   * Default value is ````[0, 0, -1]````.
   *
   * @param value New direction.
   */
  set dir(value) {
    this.#state.dir.set(value);
    this.#state.dist = -dotVec3(this.#state.pos, this.#state.dir);
    this.view.redraw();
    this.onDir.dispatch(this, this.#state.dir);
  }
  /**
   * Gets this SectionPlane's distance to the origin of the World-space coordinate system.
   *
   * This is the dot product of {@link SectionPlane.pos} and {@link SectionPlane.dir} and is automatically re-calculated
   * each time either of two properties are updated.
   *
   * @returns Distance to the origin of the World-space coordinate system.
   */
  get dist() {
    return this.#state.dist;
  }
  /**
   * Inverts the direction of {@link SectionPlane.dir}.
   */
  flipDir() {
    const dir = this.#state.dir;
    dir[0] *= -1;
    dir[1] *= -1;
    dir[2] *= -1;
    this.#state.dist = -dotVec3(this.#state.pos, this.#state.dir);
    this.onDir.dispatch(this, this.#state.dir);
    this.view.redraw();
  }
  /**
   * COnfigures this SectionPlane.
   *
   * @param sectionPlaneParams
   */
  fromParams(sectionPlaneParams) {
    if (sectionPlaneParams.dir) {
      this.dir = sectionPlaneParams.dir;
    }
    if (sectionPlaneParams.pos) {
      this.pos = sectionPlaneParams.pos;
    }
    if (sectionPlaneParams.active !== void 0) {
      this.active = sectionPlaneParams.active;
    }
  }
  /**
   * Gets the current configuration of this SectionPlane.
   */
  toParams() {
    return {
      id: this.id,
      dir: Array.from(this.#state.dir),
      pos: Array.from(this.#state.pos),
      active: this.#state.active
    };
  }
  /**
   * Destroys this SectionPlane.
   */
  destroy() {
    this.onPos.clear();
    this.onActive.clear;
    this.onDir.clear();
    super.destroy();
  }
};

// ../sdk/src/viewer/Metriqs.ts
var import_strongly_typed_events8 = __toESM(require_dist8());
var unitsInfo = {
  [MetersUnit]: {
    abbrev: "m"
  },
  [CentimetersUnit]: {
    abbrev: "cm"
  },
  [MillimetersUnit]: {
    abbrev: "mm"
  },
  [YardsUnit]: {
    abbrev: "yd"
  },
  [FeetUnit]: {
    abbrev: "ft"
  },
  [InchesUnit]: {
    abbrev: "in"
  }
};
var Metrics = class extends Component {
  #units;
  #scale;
  #origin;
  /**
   * Emits an event each time {@link Metrics.units} changes.
   *
   * @event
   */
  onUnits;
  /**
   * Emits an event each time {@link Metrics.scale} changes.
   *
   * @event
   */
  onScale;
  /**
   * Emits an event each time {@link Metrics.origin} changes.
   *
   * @event
   */
  onOrigin;
  /**
   * @private
   */
  constructor(view, cfg = {
    units: MetersUnit,
    scale: 1,
    origin: [1, 1, 1]
  }) {
    super(view, cfg);
    this.onUnits = new EventEmitter(new import_strongly_typed_events8.EventDispatcher());
    this.onScale = new EventEmitter(new import_strongly_typed_events8.EventDispatcher());
    this.onOrigin = new EventEmitter(new import_strongly_typed_events8.EventDispatcher());
    this.#units = MetersUnit;
    this.#scale = 1;
    this.#origin = createVec3([0, 0, 0]);
    this.units = cfg.units;
    this.scale = cfg.scale;
    this.origin = cfg.origin;
  }
  /**
   * Gets info about the supported Real-space unit types.
   *
   * With {@link constants} indicating each unit type, the info will be:
   *
   * ````javascript
   * {
   *     [MetersUnit]: {
   *         abbrev: "m"
   *     },
   *     [CentimetersUnit]: {
   *         abbrev: "cm"
   *     },
   *     [MillimetersUnit]: {
   *         abbrev: "mm"
   *     },
   *     [YardsUnit]: {
   *         abbrev: "yd"
   *     },
   *     [FeetUnit]: {
   *         abbrev: "ft"
   *     },
   *     [InchesUnit]: {
   *         abbrev: "in"
   *     }
   * }
   * ````
   *
   * @type {*}
   */
  get unitsInfo() {
    return unitsInfo;
  }
  /**
   * Gets the {@link View}'s Real-space unit type.
   */
  get units() {
    return this.#units;
  }
  /**
   * Sets the {@link View}'s Real-space unit type.
   *
   * Accepted values are {@link constants!MetersUnit}, {@link constants!CentimetersUnit}, {@link constants!MillimetersUnit}, {@link constants!YardsUnit}, {@link constants!FeetUnit} and {@link constants!InchesUnit}.
   */
  set units(value) {
    if (!value) {
      value = MetersUnit;
    }
    const info = unitsInfo[value];
    if (!info) {
      this.error("Unsupported value for 'units': " + value + " defaulting to MetersUnit");
      value = MetersUnit;
    }
    this.#units = value;
    this.onUnits.dispatch(this, this.#units);
  }
  /**
   * Gets the number of Real-space units represented by each unit of the {@link View}'s World-space coordinate system.
   */
  get scale() {
    return this.#scale;
  }
  /**
   * Sets the number of Real-space units represented by each unit of the {@link View}'s World-space coordinate system.
   *
   * For example, if {@link Metrics.units} is {@link constants!MetersUnit}, and there are ten meters per World-space coordinate system unit, then ````scale```` would have a value of ````10.0````.
   */
  set scale(value) {
    value = value || 1;
    if (value <= 0) {
      this.error("scale value should be larger than zero");
      return;
    }
    this.#scale = value;
    this.onScale.dispatch(this, this.#scale);
  }
  /**
   * Gets the 3D Real-space origin, in Real-space units, at which this {@link View}'s World-space coordinate origin ````[0,0,0]```` sits.
   */
  get origin() {
    return this.#origin;
  }
  /**
   * Sets the Real-space 3D origin, in Real-space units, at which this {@link View}'s World-space coordinate origin ````[0,0,0]```` sits.
   */
  set origin(value) {
    if (!value) {
      this.#origin[0] = 0;
      this.#origin[1] = 0;
      this.#origin[2] = 0;
      return;
    }
    this.#origin[0] = value[0];
    this.#origin[1] = value[1];
    this.#origin[2] = value[2];
    this.onOrigin.dispatch(this, this.#origin);
  }
  /**
   * Converts a 3D position from World-space to Real-space.
   *
   * This is equivalent to ````realPos = #origin + (worldPos * #scale)````.
   *
   * @param worldPos World-space 3D position, in World coordinate system units.
   * @param [realPos] Destination for Real-space 3D position.
   * @returns  Real-space 3D position, in units indicated by {@link Metrics#units}.
   */
  worldToRealPos(worldPos, realPos = createVec3()) {
    realPos[0] = this.#origin[0] + this.#scale * worldPos[0];
    realPos[1] = this.#origin[1] + this.#scale * worldPos[1];
    realPos[2] = this.#origin[2] + this.#scale * worldPos[2];
    return realPos;
  }
  /**
   * Converts a 3D position from Real-space to World-space.
   *
   * This is equivalent to ````worldPos = (worldPos - #origin) / #scale````.
   *
   * @param realPos Real-space 3D position.
   * @param [worldPos] Destination for World-space 3D position.
   * @returns  World-space 3D position.
   */
  realToWorldPos(realPos, worldPos = createVec3()) {
    worldPos[0] = (realPos[0] - this.#origin[0]) / this.#scale;
    worldPos[1] = (realPos[1] - this.#origin[1]) / this.#scale;
    worldPos[2] = (realPos[2] - this.#origin[2]) / this.#scale;
    return worldPos;
  }
  /**
   * @private
   */
  destroy() {
    super.destroy();
    this.onUnits.clear();
    this.onScale.clear();
    this.onOrigin.clear();
  }
};

// ../sdk/src/viewer/SAO.ts
var SAO = class extends Component {
  /**
   * The View to which this SAO belongs.
   */
  view;
  #state;
  /** @private */
  constructor(view, saoParams) {
    super(view, saoParams);
    this.view = view;
    this.#state = {
      renderModes: [QualityRender],
      kernelRadius: saoParams.kernelRadius || 100,
      intensity: saoParams.intensity !== void 0 ? saoParams.intensity : 0.15,
      bias: saoParams.bias !== void 0 ? saoParams.bias : 0.5,
      scale: saoParams.scale !== void 0 ? saoParams.scale : 1,
      minResolution: saoParams.minResolution !== void 0 ? saoParams.minResolution : 0,
      numSamples: saoParams.numSamples !== void 0 ? saoParams.numSamples : 10,
      blur: !!saoParams.blur,
      blendCutoff: saoParams.blendCutoff !== void 0 ? saoParams.blendCutoff : 0.3,
      blendFactor: saoParams.blendFactor !== void 0 ? saoParams.blendFactor : 1
    };
  }
  /**
   * Sets which rendering modes in which to apply SAO.
   *
   * The {@link View} will apply SAO whenever {@link View.renderMode} has been set one of these values.
   *
   * Default value is [{@link constants!QualityRender | QualityRender}].
   */
  set renderModes(value) {
    this.#state.renderModes = value;
    this.view.redraw();
  }
  /**
   * Gets which rendering modes in which to apply SAO.
   *
   * The {@link View} will apply SAO whenever {@link View.renderMode} has been set one of these values.
   *
   * Default value is [{@link constants!QualityRender | QualityRender}].
   */
  get renderModes() {
    return this.#state.renderModes;
  }
  /**
   * Gets whether SAO is supported by this browser and GPU.
   *
   * Even when enabled, SAO will only work if supported.
   */
  get supported() {
    return this.view.viewer.renderer.getSAOSupported();
  }
  /**
   * Returns true if SAO is currently possible, where it is supported, enabled, and the current view state is compatible.
   * Called internally by renderers logic.
   * @private
   */
  get possible() {
    if (!this.supported) {
      return false;
    }
    const projectionType = this.view.camera.projectionType;
    if (projectionType === CustomProjectionType) {
      return false;
    }
    if (projectionType === FrustumProjectionType) {
      return false;
    }
    return true;
  }
  /**
   * Gets the maximum area that SAO takes into account when checking for possible occlusion for each fragment.
   *
   * Default value is ````100.0````.
   */
  get kernelRadius() {
    return this.#state.kernelRadius;
  }
  /**
   * Sets the maximum area that SAO takes into account when checking for possible occlusion for each fragment.
   *
   * Default value is ````100.0````.
   */
  set kernelRadius(value) {
    if (value === void 0 || value === null) {
      value = 100;
    }
    if (this.#state.kernelRadius === value) {
      return;
    }
    this.#state.kernelRadius = value;
    this.view.redraw();
  }
  /**
   * Gets the degree of darkening (ambient obscurance) produced by the SAO effect.
   *
   * Default value is ````0.15````.
   */
  get intensity() {
    return this.#state.intensity;
  }
  /**
   * Sets the degree of darkening (ambient obscurance) produced by the SAO effect.
   *
   * Default value is ````0.15````.
   */
  set intensity(value) {
    if (value === void 0 || value === null) {
      value = 0.15;
    }
    if (this.#state.intensity === value) {
      return;
    }
    this.#state.intensity = value;
    this.view.redraw();
  }
  /**
   * Gets the SAO bias.
   *
   * Default value is ````0.5````.
   */
  get bias() {
    return this.#state.bias;
  }
  /**
   * Sets the SAO bias.
   *
   * Default value is ````0.5````.
   */
  set bias(value) {
    if (value === void 0 || value === null) {
      value = 0.5;
    }
    if (this.#state.bias === value) {
      return;
    }
    this.#state.bias = value;
    this.view.redraw();
  }
  /**
   * Gets the SAO occlusion scale.
   *
   * Default value is ````1.0````.
   */
  get scale() {
    return this.#state.scale;
  }
  /**
   * Sets the SAO occlusion scale.
   *
   * Default value is ````1.0````.
   */
  set scale(value) {
    if (value === void 0 || value === null) {
      value = 1;
    }
    if (this.#state.scale === value) {
      return;
    }
    this.#state.scale = value;
    this.view.redraw();
  }
  /**
   * Gets the SAO minimum resolution.
   *
   * Default value is ````0.0````.
   */
  get minResolution() {
    return this.#state.minResolution;
  }
  /**
   * Sets the SAO minimum resolution.
   *
   * Default value is ````0.0````.
   */
  set minResolution(value) {
    if (value === void 0 || value === null) {
      value = 0;
    }
    if (this.#state.minResolution === value) {
      return;
    }
    this.#state.minResolution = value;
    this.view.redraw();
  }
  /**
   * Gets the number of SAO samples.
   *
   * Default value is ````10````.
   */
  get numSamples() {
    return this.#state.numSamples;
  }
  /**
   * Sets the number of SAO samples.
   *
   * Default value is ````10````.
   *
   * Update this sparingly, since it causes a shader recompile.
   */
  set numSamples(value) {
    if (value === void 0 || value === null) {
      value = 10;
    }
    if (this.#state.numSamples === value) {
      return;
    }
    this.#state.numSamples = value;
    this.view.redraw();
  }
  /**
   * Gets whether Guassian blur is enabled.
   *
   * Default value is ````true````.
   */
  get blur() {
    return this.#state.blur;
  }
  /**
   * Sets whether Guassian blur is enabled.
   *
   * Default value is ````true````.
   */
  set blur(value) {
    value = value !== false;
    if (this.#state.blur === value) {
      return;
    }
    this.#state.blur = value;
    this.view.redraw();
  }
  /**
   * Gets the SAO blend cutoff.
   *
   * Default value is ````0.3````.
   *
   * Normally you don't need to alter this.
   */
  get blendCutoff() {
    return this.#state.blendCutoff;
  }
  /**
   * Sets the SAO blend cutoff.
   *
   * Default value is ````0.3````.
   *
   * Normally you don't need to alter this.
   */
  set blendCutoff(value) {
    if (value === void 0 || value === null) {
      value = 0.3;
    }
    if (this.#state.blendCutoff === value) {
      return;
    }
    this.#state.blendCutoff = value;
    this.view.redraw();
  }
  /**
   * Gets the SAO blend scale.
   *
   * Default value is ````1.0````.
   *
   * Normally you don't need to alter this.
   */
  get blendFactor() {
    return this.#state.blendFactor;
  }
  /**
   * Sets the SAO blend factor.
   *
   * Default value is ````1.0````.
   *
   * Normally you don't need to alter this.
   */
  set blendFactor(value) {
    if (value === void 0 || value === null) {
      value = 1;
    }
    if (this.#state.blendFactor === value) {
      return;
    }
    this.#state.blendFactor = value;
    this.view.redraw();
  }
  /**
   * Gets if SAO is currently applied.
   *
   * This is `true` when {@link View.renderMode | View.renderMode} is
   * in {@link SAO.renderModes | SAO.renderModes}.
   */
  get applied() {
    for (let i = 0, len = this.#state.renderModes.length; i < len; i++) {
      if (this.view.renderMode === this.#state.renderModes[i]) {
        return true;
      }
    }
    return false;
  }
  /**
   * Gets the current configuration of this SAO.
   */
  toParams() {
    return {
      renderModes: this.renderModes,
      intensity: this.intensity,
      minResolution: this.minResolution,
      blendFactor: this.blendFactor,
      numSamples: this.numSamples,
      bias: this.bias,
      scale: this.scale,
      blur: this.blur,
      blendCutoff: this.blendCutoff,
      kernelRadius: this.kernelRadius
    };
  }
  /**
   * Configures this SAO.
   *
   * @param saoParams
   */
  fromParams(saoParams) {
    this.renderModes = saoParams.renderModes;
    this.intensity = saoParams.intensity;
    this.minResolution = saoParams.minResolution;
    this.blendFactor = saoParams.blendFactor;
    this.numSamples = saoParams.numSamples;
    this.bias = saoParams.bias;
    this.scale = saoParams.scale;
    this.blur = saoParams.blur;
    this.blendCutoff = saoParams.blendCutoff;
    this.kernelRadius = saoParams.kernelRadius;
  }
  /**
   * @private
   */
  destroy() {
    super.destroy();
  }
};

// ../sdk/src/viewer/Texturing.ts
var Texturing = class extends Component {
  /**
   * The View to which this Texturing belongs.
   */
  view;
  /**
   * @private
   */
  #state;
  /**
   * @private
   */
  constructor(view, options = {}) {
    super(view, options);
    this.view = view;
    this.#state = {
      renderModes: options.renderModes || [QualityRender],
      enabled: options.enabled !== false
    };
  }
  /**
   * Sets which rendering modes in which to render textures.
   *
   * Accepted modes are {@link constants!QualityRender} and {@link constants!FastRender}.
   *
   * Default value is [{@link constants!QualityRender}].
   */
  set renderModes(value) {
    this.#state.renderModes = value;
    this.view.redraw();
  }
  /**
   * Gets which rendering modes in which to render textures.
   *
   * Accepted modes are {@link constants!QualityRender} and {@link constants!FastRender}.
   *
   * Default value is [{@link constants!QualityRender}].
   */
  get renderModes() {
    return this.#state.renderModes;
  }
  /**
   * Sets if textures on {@link ViewObject | ViewObjects} are visible.
   *
   * Default is ````true````.
   */
  set enabled(value) {
    if (this.#state.enabled === value) {
      return;
    }
    this.#state.enabled = value;
    this.view.redraw();
  }
  /**
   * Gets if textures on {@link ViewObject | ViewObjects} are visible.
   *
   * Default is ````true````.
   */
  get enabled() {
    return this.#state.enabled;
  }
  /**
   * Gets if textures are currently applied.
   *
   * This is `true` when {@link Texturing.enabled | Texturing.enabled} is `true`
   * and {@link View.renderMode | View.renderMode} is
   * in {@link Texturing.renderModes | Texturing.renderModes}.
   */
  get applied() {
    if (!this.#state.enabled) {
      return false;
    }
    for (let i = 0, len = this.#state.renderModes.length; i < len; i++) {
      if (this.view.renderMode === this.#state.renderModes[i]) {
        return true;
      }
    }
    return false;
  }
  /**
   * @private
   */
  destroy() {
    super.destroy();
  }
};

// ../sdk/src/viewer/LinesMaterial.ts
var LinesMaterial = class extends Component {
  /**
   * The View to which this LinesMaterial belongs.
   */
  view;
  #state;
  /**
   * @private
   */
  constructor(view, options = { lineWidth: 1 }) {
    super(view, options);
    this.view = view;
    this.#state = {
      lineWidth: options.lineWidth !== void 0 && options.lineWidth !== null ? options.lineWidth : 1
    };
  }
  /**
   * Sets line width.
   *
   * Default value is ````1```` pixels.
   */
  set lineWidth(value) {
    this.#state.lineWidth = value || 1;
    this.view.redraw();
  }
  /**
   * Gets the line width.
   *
   * Default value is ````1```` pixels.
   */
  get lineWidth() {
    return this.#state.lineWidth;
  }
};

// ../sdk/src/viewer/ViewLayer.ts
var import_strongly_typed_events9 = __toESM(require_dist8());
var ViewLayer = class extends Component {
  /**
   * Map of the all {@link ViewObject | ViewObjects} in this ViewLayer.
   *
   * These are the ViewObjects for which {@link scene!SceneObject.layerId | SceneObject.layerId} has the same value as the {@link ViewLayer.id | ViewLayer.id}.
   *
   * Each {@link ViewObject} is mapped here by {@link ViewObject.id}.
   *
   * The ViewLayer automatically ensures that there is a {@link ViewObject} here for
   * each {@link scene!RendererObject} in the {@link Viewer | Viewer}
   */
  objects;
  /**
   * Map of the currently visible {@link ViewObject | ViewObjects} in this ViewLayer.
   *
   * A ViewObject is visible when {@link ViewObject.visible} is true.
   *
   * Each {@link ViewObject} is mapped here by {@link ViewObject.id}.
   */
  visibleObjects;
  /**
   * Map of currently x-rayed {@link ViewObject | ViewObjects} in this ViewLayer.
   *
   * A ViewObject is x-rayed when {@link ViewObject.xrayed} is true.
   *
   * Each {@link ViewObject} is mapped here by {@link ViewObject.id}.
   */
  xrayedObjects;
  /**
   * Map of currently highlighted {@link ViewObject | ViewObjects} in this ViewLayer.
   *
   * A ViewObject is highlighted when {@link ViewObject.highlighted} is true.
   *
   * Each {@link ViewObject} is mapped here by {@link ViewObject.id}.
   */
  highlightedObjects;
  /**
   * Map of currently selected {@link ViewObject | ViewObjects} in this ViewLayer.
   *
   * A ViewObject is selected when {@link ViewObject.selected} is true.
   *
   * Each {@link ViewObject} is mapped here by {@link ViewObject.id}.
   */
  selectedObjects;
  /**
   * Map of currently colorized {@link ViewObject | ViewObjects} in this ViewLayer.
   *
   * Each {@link ViewObject} is mapped here by {@link ViewObject.id}.
   */
  colorizedObjects;
  /**
   * Map of {@link ViewObject | ViewObjects} in this ViewLayer whose opacity has been updated.
   *
   * Each {@link ViewObject} is mapped here by {@link ViewObject.id}.
   */
  opacityObjects;
  /**
   * When true, View destroys this ViewLayer as soon as there are no ViewObjects
   * that need it. When false, View retains it.
   * @private
   */
  autoDestroy;
  /**
   * Emits an event each time a {@link ViewObject} is created in this ViewLayer.
   *
   * @event
   */
  onObjectCreated;
  /**
   * Emits an event each time a {@link ViewObject} is destroyed in this ViewLayer.
   *
   * @event
   */
  onObjectDestroyed;
  /**
   * Emits an event each time the visibility of a {@link ViewObject} changes.
   *
   * ViewObjects are shown and hidden with {@link View.setObjectsVisible}, {@link ViewLayer.setObjectsVisible} or {@link ViewObject.visible}.
   *
   * @event
   */
  onObjectVisibility;
  #renderModes;
  #numObjects;
  #objectIds;
  #numVisibleObjects;
  #visibleObjectIds;
  #numXRayedObjects;
  #xrayedObjectIds;
  #numHighlightedObjects;
  #highlightedObjectIds;
  #numSelectedObjects;
  #selectedObjectIds;
  #numColorizedObjects;
  #colorizedObjectIds;
  #numOpacityObjects;
  #opacityObjectIds;
  gammaOutput;
  constructor(options) {
    super(options.view, options);
    this.id = options.id;
    this.viewer = options.viewer;
    this.view = options.view;
    this.objects = {};
    this.visibleObjects = {};
    this.xrayedObjects = {};
    this.highlightedObjects = {};
    this.selectedObjects = {};
    this.colorizedObjects = {};
    this.opacityObjects = {};
    this.autoDestroy = options.autoDestroy !== false;
    this.#numObjects = 0;
    this.#numVisibleObjects = 0;
    this.#numXRayedObjects = 0;
    this.#numHighlightedObjects = 0;
    this.#numSelectedObjects = 0;
    this.#numColorizedObjects = 0;
    this.#numOpacityObjects = 0;
    this.#renderModes = [];
    this.onObjectCreated = new EventEmitter(new import_strongly_typed_events9.EventDispatcher());
    this.onObjectDestroyed = new EventEmitter(new import_strongly_typed_events9.EventDispatcher());
    this.onObjectVisibility = new EventEmitter(new import_strongly_typed_events9.EventDispatcher());
    this.#initViewObjects();
  }
  /**
   * Gets the gamma factor.
   */
  get gammaFactor() {
    return 1;
  }
  /**
   * Sets which rendering modes in which to render the {@link ViewObject | ViewObjects} in this ViewLayer.
   *
   * Default value is [].
   */
  set renderModes(value) {
    this.#renderModes = value;
    this.view.redraw();
  }
  /**
   * Gets which rendering modes in which to render the {@link ViewObject | ViewObjects} in this ViewLayer.
   *
   * Default value is [].
   */
  get renderModes() {
    return this.#renderModes;
  }
  /**
   * Gets the number of {@link ViewObject | ViewObjects} in this ViewLayer.
   */
  get numObjects() {
    return this.#numObjects;
  }
  /**
   * Gets the IDs of the {@link ViewObject | ViewObjects} in this ViewLayer.
   */
  get objectIds() {
    if (!this.#objectIds) {
      this.#objectIds = Object.keys(this.objects);
    }
    return this.#objectIds;
  }
  /**
   * Gets the number of visible {@link ViewObject | ViewObjects} in this ViewLayer.
   */
  get numVisibleObjects() {
    return this.#numVisibleObjects;
  }
  /**
   * Gets the IDs of the visible {@link ViewObject | ViewObjects} in this ViewLayer.
   */
  get visibleObjectIds() {
    if (!this.#visibleObjectIds) {
      this.#visibleObjectIds = Object.keys(this.visibleObjects);
    }
    return this.#visibleObjectIds;
  }
  /**
   * Gets the number of X-rayed {@link ViewObject | ViewObjects} in this ViewLayer.
   */
  get numXRayedObjects() {
    return this.#numXRayedObjects;
  }
  /**
   * Gets the IDs of the X-rayed {@link ViewObject | ViewObjects} in this ViewLayer.
   */
  get xrayedObjectIds() {
    if (!this.#xrayedObjectIds) {
      this.#xrayedObjectIds = Object.keys(this.xrayedObjects);
    }
    return this.#xrayedObjectIds;
  }
  /**
   * Gets the number of highlighted {@link ViewObject | ViewObjects} in this ViewLayer.
   */
  get numHighlightedObjects() {
    return this.#numHighlightedObjects;
  }
  /**
   * Gets the IDs of the highlighted {@link ViewObject | ViewObjects} in this ViewLayer.
   */
  get highlightedObjectIds() {
    if (!this.#highlightedObjectIds) {
      this.#highlightedObjectIds = Object.keys(this.highlightedObjects);
    }
    return this.#highlightedObjectIds;
  }
  /**
   * Gets the number of selected {@link ViewObject | ViewObjects} in this ViewLayer.
   */
  get numSelectedObjects() {
    return this.#numSelectedObjects;
  }
  /**
   * Gets the IDs of the selected {@link ViewObject | ViewObjects} in this ViewLayer.
   */
  get selectedObjectIds() {
    if (!this.#selectedObjectIds) {
      this.#selectedObjectIds = Object.keys(this.selectedObjects);
    }
    return this.#selectedObjectIds;
  }
  /**
   * Gets the number of colorized {@link ViewObject | ViewObjects} in this ViewLayer.
   */
  get numColorizedObjects() {
    return this.#numColorizedObjects;
  }
  /**
   * Gets the IDs of the colorized {@link ViewObject | ViewObjects} in this ViewLayer.
   */
  get colorizedObjectIds() {
    if (!this.#colorizedObjectIds) {
      this.#colorizedObjectIds = Object.keys(this.colorizedObjects);
    }
    return this.#colorizedObjectIds;
  }
  /**
   * Gets the IDs of the {@link ViewObject | ViewObjects} in this ViewLayer that have updated opacities.
   */
  get opacityObjectIds() {
    if (!this.#opacityObjectIds) {
      this.#opacityObjectIds = Object.keys(this.opacityObjects);
    }
    return this.#opacityObjectIds;
  }
  /**
   * Gets the number of {@link ViewObject | ViewObjects} in this ViewLayer that have updated opacities.
   */
  get numOpacityObjects() {
    return this.#numOpacityObjects;
  }
  /**
   * @private
   */
  registerViewObject(viewObject) {
    this.objects[viewObject.id] = viewObject;
    this.#numObjects++;
    this.#objectIds = null;
    this.onObjectCreated.dispatch(this, viewObject);
  }
  /**
   * @private
   */
  deregisterViewObject(viewObject) {
    delete this.objects[viewObject.id];
    delete this.visibleObjects[viewObject.id];
    delete this.xrayedObjects[viewObject.id];
    delete this.highlightedObjects[viewObject.id];
    delete this.selectedObjects[viewObject.id];
    delete this.colorizedObjects[viewObject.id];
    delete this.opacityObjects[viewObject.id];
    this.#numObjects--;
    this.#objectIds = null;
    this.onObjectDestroyed.dispatch(this, viewObject);
  }
  /**
   * @private
   */
  redraw() {
    this.viewer.renderer.setImageDirty(this.view.viewIndex);
  }
  /**
   * @private
   */
  objectVisibilityUpdated(viewObject, visible, notify = true) {
    if (visible) {
      this.visibleObjects[viewObject.id] = viewObject;
      this.#numVisibleObjects++;
    } else {
      delete this.visibleObjects[viewObject.id];
      this.#numVisibleObjects--;
    }
    this.#visibleObjectIds = null;
    if (notify) {
      this.onObjectVisibility.dispatch(this, viewObject);
    }
    this.view.objectVisibilityUpdated(viewObject, visible, notify);
  }
  /**
   * @private
   */
  objectXRayedUpdated(viewObject, xrayed) {
    if (xrayed) {
      this.xrayedObjects[viewObject.id] = viewObject;
      this.#numXRayedObjects++;
    } else {
      delete this.xrayedObjects[viewObject.id];
      this.#numXRayedObjects--;
    }
    this.#xrayedObjectIds = null;
    this.view.objectXRayedUpdated(viewObject, xrayed);
  }
  /**
   * @private
   */
  objectHighlightedUpdated(viewObject, highlighted) {
    if (highlighted) {
      this.highlightedObjects[viewObject.id] = viewObject;
      this.#numHighlightedObjects++;
    } else {
      delete this.highlightedObjects[viewObject.id];
      this.#numHighlightedObjects--;
    }
    this.#highlightedObjectIds = null;
    this.view.objectHighlightedUpdated(viewObject, highlighted);
  }
  /**
   * @private
   */
  objectSelectedUpdated(viewObject, selected) {
    if (selected) {
      this.selectedObjects[viewObject.id] = viewObject;
      this.#numSelectedObjects++;
    } else {
      delete this.selectedObjects[viewObject.id];
      this.#numSelectedObjects--;
    }
    this.#selectedObjectIds = null;
    this.view.objectSelectedUpdated(viewObject, selected);
  }
  /**
   * @private
   */
  objectColorizeUpdated(viewObject, colorized) {
    if (colorized) {
      this.colorizedObjects[viewObject.id] = viewObject;
      this.#numColorizedObjects++;
    } else {
      delete this.colorizedObjects[viewObject.id];
      this.#numColorizedObjects--;
    }
    this.#colorizedObjectIds = null;
    this.view.objectColorizeUpdated(viewObject, colorized);
  }
  /**
   * @private
   */
  objectOpacityUpdated(viewObject, opacityUpdated) {
    if (opacityUpdated) {
      this.opacityObjects[viewObject.id] = viewObject;
      this.#numOpacityObjects++;
    } else {
      delete this.opacityObjects[viewObject.id];
      this.#numOpacityObjects--;
    }
    this.#opacityObjectIds = null;
    this.view.objectOpacityUpdated(viewObject, opacityUpdated);
  }
  /**
   * Updates the visibility of the given {@link ViewObject | ViewObjects} in this ViewLayer.
   *
   * - Updates {@link ViewObject.visible} on the Objects with the given IDs.
   * - Updates {@link ViewLayer.visibleObjects} and {@link ViewLayer.numVisibleObjects}.
   *
   * @param {String[]} objectIds Array of {@link ViewObject.id} values.
   * @param visible Whether or not to cull.
   * @returns True if any {@link ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */
  setObjectsVisible(objectIds, visible) {
    return this.withObjects(objectIds, (viewObject) => {
      const changed = viewObject.visible !== visible;
      viewObject.visible = visible;
      if (changed) {
        this.onObjectVisibility.dispatch(this, viewObject);
      }
      return changed;
    });
  }
  /**
   * Updates the collidability of the given {@link ViewObject | ViewObjects} in this ViewLayer.
   *
   * Updates {@link ViewObject.collidable} on the Objects with the given IDs.
   *
   * @param {String[]} objectIds Array of {@link ViewObject.id} values.
   * @param collidable Whether or not to cull.
   * @returns True if any {@link ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */
  setObjectsCollidable(objectIds, collidable) {
    return this.withObjects(objectIds, (viewObject) => {
      const changed = viewObject.collidable !== collidable;
      viewObject.collidable = collidable;
      return changed;
    });
  }
  /**
   * Updates the culled status of the given {@link ViewObject | ViewObjects} in this ViewLayer.
   *
   * Updates {@link ViewObject.culled} on the Objects with the given IDs.
   *
   * @param {String[]} objectIds Array of {@link ViewObject.id} values.
   * @param culled Whether or not to cull.
   * @returns True if any {@link ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */
  setObjectsCulled(objectIds, culled) {
    return this.withObjects(objectIds, (viewObject) => {
      const changed = viewObject.culled !== culled;
      viewObject.culled = culled;
      return changed;
    });
  }
  /**
   * Selects or deselects the given {@link ViewObject | ViewObjects} in this ViewLayer.
   *
   * - Updates {@link ViewObject.selected} on the Objects with the given IDs.
   * - Updates {@link ViewLayer.selectedObjects} and {@link ViewLayer.numSelectedObjects}.
   *
   * @param  objectIds One or more {@link ViewObject.id} values.
   * @param selected Whether or not to select.
   * @returns True if any {@link ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */
  setObjectsSelected(objectIds, selected) {
    return this.withObjects(objectIds, (viewObject) => {
      const changed = viewObject.selected !== selected;
      viewObject.selected = selected;
      return changed;
    });
  }
  /**
   * Highlights or un-highlights the given {@link ViewObject | ViewObjects} in this ViewLayer.
   *
   * - Updates {@link ViewObject.highlighted} on the Objects with the given IDs.
   * - Updates {@link ViewLayer.highlightedObjects} and {@link ViewLayer.numHighlightedObjects}.
   *
   * @param  objectIds One or more {@link ViewObject.id} values.
   * @param highlighted Whether or not to highlight.
   * @returns True if any {@link ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */
  setObjectsHighlighted(objectIds, highlighted) {
    return this.withObjects(objectIds, (viewObject) => {
      const changed = viewObject.highlighted !== highlighted;
      viewObject.highlighted = highlighted;
      return changed;
    });
  }
  /**
   * Applies or removes X-ray rendering for the given {@link ViewObject | ViewObjects} in this ViewLayer.
   *
   * - Updates {@link ViewObject.xrayed} on the Objects with the given IDs.
   * - Updates {@link ViewLayer.xrayedObjects} and {@link ViewLayer.numXRayedObjects}.
   *
   * @param  objectIds One or more {@link ViewObject.id} values.
   * @param xrayed Whether or not to xray.
   * @returns True if any {@link ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */
  setObjectsXRayed(objectIds, xrayed) {
    return this.withObjects(objectIds, (viewObject) => {
      const changed = viewObject.xrayed !== xrayed;
      if (changed) {
        viewObject.xrayed = xrayed;
      }
      return changed;
    });
  }
  /**
   * Colorizes the given {@link ViewObject | ViewObjects} in this ViewLayer.
   *
   * - Updates {@link ViewObject.colorize} on the Objects with the given IDs.
   * - Updates {@link ViewLayer.colorizedObjects} and {@link ViewLayer.numColorizedObjects}.
   *
   * @param  objectIds One or more {@link ViewObject.id} values.
   * @param colorize - RGB colorize factors in range ````[0..1,0..1,0..1]````.
   * @returns True if any {@link ViewObject | ViewObjects} changed opacity, else false if all updates were redundant and not applied.
   */
  setObjectsColorized(objectIds, colorize) {
    return this.withObjects(objectIds, (viewObject) => {
      viewObject.colorize = colorize;
    });
  }
  /**
   * Sets the opacity of the given {@link ViewObject | ViewObjects} in this ViewLayer.
   *
   * - Updates {@link ViewObject.opacity} on the Objects with the given IDs.
   * - Updates {@link ViewLayer.opacityObjects} and {@link ViewLayer.numOpacityObjects}.
   *
   * @param  objectIds - One or more {@link ViewObject.id} values.
   * @param opacity - Opacity factor in range ````[0..1]````.
   * @returns True if any {@link ViewObject | ViewObjects} changed opacity, else false if all updates were redundant and not applied.
   */
  setObjectsOpacity(objectIds, opacity) {
    return this.withObjects(objectIds, (viewObject) => {
      const changed = viewObject.opacity !== opacity;
      if (changed) {
        viewObject.opacity = opacity;
      }
      return changed;
    });
  }
  /**
   * Sets the pickability of the given {@link ViewObject | ViewObjects} in this ViewLayer.
   *
   * - Updates {@link ViewObject.pickable} on the Objects with the given IDs.
   * - Enables or disables the ability to pick the given Objects with {@link View.pick}.
   *
   * @param {String[]} objectIds Array of {@link ViewObject.id} values.
   * @param pickable Whether or not to set pickable.
   * @returns True if any {@link ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */
  setObjectsPickable(objectIds, pickable) {
    return this.withObjects(objectIds, (viewObject) => {
      const changed = viewObject.pickable !== pickable;
      if (changed) {
        viewObject.pickable = pickable;
      }
      return changed;
    });
  }
  /**
   * Sets the clippability of the given {@link ViewObject | ViewObjects} in this ViewLayer.
   *
   * - Updates {@link ViewObject.clippable} on the Objects with the given IDs.
   * - Enables or disables the ability to pick the given Objects with {@link View.pick}.
   *
   * @param {String[]} objectIds Array of {@link ViewObject.id} values.
   * @param clippable Whether or not to set clippable.
   * @returns True if any {@link ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */
  setObjectsClippable(objectIds, clippable) {
    return this.withObjects(objectIds, (viewObject) => {
      const changed = viewObject.clippable !== clippable;
      if (changed) {
        viewObject.clippable = clippable;
      }
      return changed;
    });
  }
  /**
   * Iterates with a callback over the given {@link ViewObject | ViewObjects} in this ViewLayer.
   *
   * @param  objectIds One or more {@link ViewObject.id} values.
   * @param callback Callback to execute on each {@link ViewObject}.
   * @returns True if any {@link ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */
  withObjects(objectIds, callback) {
    let changed = false;
    for (let i = 0, len = objectIds.length; i < len; i++) {
      const id = objectIds[i];
      let viewObject = this.objects[id];
      if (viewObject) {
        changed = callback(viewObject) || changed;
      }
    }
    return changed;
  }
  #initViewObjects() {
    const models = this.viewer.scene.models;
    for (const id in models) {
      const model = models[id];
      this.#createViewObjects(model);
    }
    this.viewer.scene.onModelCreated.subscribe((scene, model) => {
      this.#createViewObjects(model);
    });
  }
  #createViewObjects(model) {
    const sceneObjects = model.objects;
    for (let id in sceneObjects) {
      const sceneObject = sceneObjects[id];
      const rendererViewObject = this.viewer.renderer.rendererObjects[id];
      if (sceneObject.layerId == this.id) {
        if (!this.objects[id]) {
          const viewObject = new ViewObject(this, sceneObject, rendererViewObject);
          this.objects[viewObject.id] = viewObject;
          this.#numObjects++;
          this.#objectIds = null;
          this.onObjectCreated.dispatch(this, viewObject);
        }
      }
    }
  }
  #destroyViewObjectsForModel(model) {
    const viewerObjects = model.objects;
    for (let id in viewerObjects) {
      const viewerObject = viewerObjects[id];
      const viewObject = this.objects[viewerObject.id];
      if (viewObject) {
        viewObject._destroy();
        this.#numObjects--;
        this.#objectIds = null;
        this.onObjectDestroyed.dispatch(this, viewObject);
      }
    }
  }
  /**
   * Configures this ViewLayer.
   *
   * @param viewLayerParams
   */
  fromParams(viewLayerParams) {
    if (viewLayerParams.autoDestroy) {
      this.autoDestroy = viewLayerParams.autoDestroy;
    }
  }
  /**
   * Gets the current configuration of this ViewLayer.
   */
  toParams() {
    return {
      id: this.id,
      autoDestroy: this.autoDestroy
    };
  }
  /**
   * Destroys this ViewLayer.
   *
   * Causes {@link Viewer | Viewer} to fire a "viewDestroyed" event.
   */
  destroy() {
    this.#destroyViewObjects();
    this.onObjectCreated.clear();
    this.onObjectDestroyed.clear();
    this.onObjectVisibility.clear();
    super.destroy();
  }
  #destroyViewObjects() {
    const objects = this.objects;
    for (let id in objects) {
      const viewObject = objects[id];
      this.deregisterViewObject(viewObject);
      this.onObjectDestroyed.dispatch(this, viewObject);
    }
  }
};

// ../sdk/src/viewer/EmphasisMaterial.ts
var EmphasisMaterial = class extends Component {
  /**
   * The View to which this EmphasisMaterial belongs.
   */
  view;
  #state;
  /**
   * @private
   */
  constructor(view, options = {}) {
    super(view, options);
    this.view = view;
    this.#state = {
      fill: !!options.fill,
      fillColor: new Float32Array(options.fillColor || [0.4, 0.4, 0.4]),
      fillAlpha: options.fillAlpha !== void 0 && options.fillAlpha !== null ? options.fillAlpha : 0.2,
      edges: options.edges !== false,
      edgeColor: new Float32Array(options.edgeColor || [0.2, 0.2, 0.2]),
      edgeAlpha: options.edgeAlpha !== void 0 && options.edgeAlpha !== null ? options.edgeAlpha : 0.5,
      edgeWidth: options.edgeWidth !== void 0 && options.edgeWidth !== null ? options.edgeWidth : 1,
      backfaces: !!options.backfaces,
      glowThrough: !!options.glowThrough
    };
  }
  /**
   * Sets if the surfaces of emphasized {@link ViewObject | ViewObjects} are filled with color.
   *
   * Default is ````true````.
   */
  set fill(value) {
    if (this.#state.fill === value) {
      return;
    }
    this.#state.fill = value;
    this.view.redraw();
  }
  /**
   * Gets if the surfaces of emphasized {@link ViewObject | ViewObjects} are filled with color.
   *
   * Default is ````true````.
   */
  get fill() {
    return this.#state.fill;
  }
  /**
   * Sets the RGB surface fill color for the surfaces of emphasized {@link ViewObject | ViewObjects}.
   *
   * Default is ````[0.4, 0.4, 0.4]````.
   */
  set fillColor(value) {
    const fillColor = this.#state.fillColor;
    if (fillColor[0] === value[0] && fillColor[1] === value[1] && fillColor[2] === value[2]) {
      return;
    }
    fillColor[0] = 0.4;
    fillColor[1] = 0.4;
    fillColor[2] = 0.4;
    this.view.redraw();
  }
  /**
   * Gets the RGB surface fill color for the surfaces of emphasized {@link ViewObject | ViewObjects}.
   *
   * Default is ````[0.4, 0.4, 0.4]````.
   */
  get fillColor() {
    return this.#state.fillColor;
  }
  /**
   * Sets the transparency of the surfaces of emphasized {@link ViewObject | ViewObjects}.
   *
   * A value of ````0.0```` indicates fully transparent, ````1.0```` is fully opaque.
   *
   * Default is ````0.2````.
   */
  set fillAlpha(value) {
    if (this.#state.fillAlpha === value) {
      return;
    }
    this.#state.fillAlpha = value;
    this.view.redraw();
  }
  /**
   * Gets the transparency of the surfaces of emphasized {@link ViewObject | ViewObjects}.
   *
   * A value of ````0.0```` indicates fully transparent, ````1.0```` is fully opaque.
   *
   * Default is ````0.2````.
   */
  get fillAlpha() {
    return this.#state.fillAlpha;
  }
  /**
   * Sets if the edges on emphasized {@link ViewObject | ViewObjects} are visible.
   *
   * Default is ````true````.
   */
  set edges(value) {
    if (this.#state.edges === value) {
      return;
    }
    this.#state.edges = value;
    this.view.redraw();
  }
  /**
   * Gets if the edges on emphasized {@link ViewObject | ViewObjects} are visible.
   *
   * Default is ````true````.
   */
  get edges() {
    return this.#state.edges;
  }
  /**
   * Sets the RGB color of the edges of emphasized {@link ViewObject | ViewObjects}.
   *
   * Default is ```` [0.2, 0.2, 0.2]````.
   */
  set edgeColor(value) {
    let edgeColor = this.#state.edgeColor;
    if (edgeColor[0] === value[0] && edgeColor[1] === value[1] && edgeColor[2] === value[2]) {
      return;
    }
    edgeColor[0] = 0.2;
    edgeColor[1] = 0.2;
    edgeColor[2] = 0.2;
    this.view.redraw();
  }
  /**
   * Gets the RGB color of the edges of emphasized {@link ViewObject | ViewObjects}.
   *
   * Default is ```` [0.2, 0.2, 0.2]````.
   */
  get edgeColor() {
    return this.#state.edgeColor;
  }
  /**
   * Sets the transparency of the edges of emphasized {@link ViewObject | ViewObjects}.
   *
   * A value of ````0.0```` indicates fully transparent, ````1.0```` is fully opaque.
   *
   * Default is ````0.2````.
   */
  set edgeAlpha(value) {
    if (this.#state.edgeAlpha === value) {
      return;
    }
    this.#state.edgeAlpha = value;
    this.view.redraw();
  }
  /**
   * Gets the transparency of the edges of emphasized {@link ViewObject | ViewObjects}.
   *
   * A value of ````0.0```` indicates fully transparent, ````1.0```` is fully opaque.
   *
   * Default is ````0.2````.
   */
  get edgeAlpha() {
    return this.#state.edgeAlpha;
  }
  /**
   * Sets the width of the edges of emphasized {@link ViewObject | ViewObjects}.
   *
   * Default value is ````1.0```` pixels.
   */
  set edgeWidth(value) {
    this.#state.edgeWidth = value;
    this.view.redraw();
  }
  /**
   * Gets the width of the edges of emphasized {@link ViewObject | ViewObjects}.
   *
   * This is not supported by WebGL implementations based on DirectX [2019].
   *
   * Default value is ````1.0```` pixels.
   */
  get edgeWidth() {
    return this.#state.edgeWidth;
  }
  /**
   * Sets whether to render backfaces of emphasized {@link ViewObject | ViewObjects} when {@link EmphasisMaterial.fill} is ````true````.
   *
   * Default is ````false````.
   */
  set backfaces(value) {
    if (this.#state.backfaces === value) {
      return;
    }
    this.#state.backfaces = value;
    this.view.redraw();
  }
  /**
   * Gets whether to render backfaces of emphasized {@link ViewObject | ViewObjects} when {@link EmphasisMaterial.fill} is ````true````.
   *
   * Default is ````false````.
   */
  get backfaces() {
    return this.#state.backfaces;
  }
  /**
   * Sets whether to render emphasized objects over the top of other objects, as if they were "glowing through".
   *
   * Default is ````true````.
   *
   * Note: updating this property will not affect the appearance of objects that are already emphasized.
   *
   * @type {Boolean}
   */
  set glowThrough(value) {
    value = value !== false;
    if (this.#state.glowThrough === value) {
      return;
    }
    this.#state.glowThrough = value;
    this.view.redraw();
  }
  /**
   * Sets whether to render emphasized objects over the top of other objects, as if they were "glowing through".
   *
   * Default is ````true````.
   *
   * @type {Boolean}
   */
  get glowThrough() {
    return this.#state.glowThrough;
  }
  /**
   * @private
   */
  get hash() {
    return "";
  }
  /**
   * Configures this EmphasisMaterial.
   * @param emphasisMaterialParams
   */
  fromParams(emphasisMaterialParams) {
    if (emphasisMaterialParams.fillColor !== void 0) {
      this.fillColor = emphasisMaterialParams.fillColor;
    }
    if (emphasisMaterialParams.edgeColor !== void 0) {
      this.edgeColor = emphasisMaterialParams.edgeColor;
    }
    if (emphasisMaterialParams.edgeWidth !== void 0) {
      this.edgeWidth = emphasisMaterialParams.edgeWidth;
    }
    if (emphasisMaterialParams.edgeAlpha !== void 0) {
      this.edgeAlpha = emphasisMaterialParams.edgeAlpha;
    }
    if (emphasisMaterialParams.edges !== void 0) {
      this.edges = emphasisMaterialParams.edges;
    }
    if (emphasisMaterialParams.fillAlpha !== void 0) {
      this.fillAlpha = emphasisMaterialParams.fillAlpha;
    }
    if (emphasisMaterialParams.fill !== void 0) {
      this.fill = emphasisMaterialParams.fill;
    }
    if (emphasisMaterialParams.backfaces !== void 0) {
      this.backfaces = emphasisMaterialParams.backfaces;
    }
    if (emphasisMaterialParams.glowThrough !== void 0) {
      this.glowThrough = emphasisMaterialParams.glowThrough;
    }
  }
  /**
   * Gets the current configuration of this EmphasisMaterial.
   */
  toParams() {
    return {
      fillColor: Array.from(this.#state.fillColor),
      backfaces: this.#state.backfaces,
      edgeColor: Array.from(this.#state.edgeColor),
      edgeWidth: this.#state.edgeWidth,
      edgeAlpha: this.#state.edgeAlpha,
      edges: this.#state.edges,
      fillAlpha: this.#state.fillAlpha,
      fill: this.#state.fill,
      glowThrough: this.#state.glowThrough
    };
  }
  /**
   * @private
   */
  destroy() {
    super.destroy();
  }
};

// ../sdk/src/viewer/Edges.ts
var Edges = class extends Component {
  /**
   * The View to which this Edges belongs.
   */
  view;
  /**
   * @private
   */
  #state;
  /**
   * @private
   */
  constructor(view, options = {}) {
    super(view, options);
    this.view = view;
    this.#state = {
      renderModes: options.renderModes || [QualityRender],
      edgeColor: new Float32Array(options.edgeColor || [0.2, 0.2, 0.2]),
      edgeAlpha: options.edgeAlpha !== void 0 && options.edgeAlpha !== null ? options.edgeAlpha : 0.5,
      edgeWidth: options.edgeWidth !== void 0 && options.edgeWidth !== null ? options.edgeWidth : 1
    };
  }
  /**
   * Sets which rendering modes in which to show edges on {@link ViewObject | ViewObjects}.
   *
   * The {@link View} will show edges whenever {@link View.renderMode} has been set one of these values.
   *
   * Default value is [{@link constants!QualityRender | QualityRender}].
   */
  set renderModes(value) {
    this.#state.renderModes = value;
    this.view.redraw();
  }
  /**
   * Gets which rendering modes in which to show edges on {@link ViewObject | ViewObjects}.
   *
   * The {@link View} will show edges whenever {@link View.renderMode} has been set one of these values.
   *
   * Default value is [{@link constants!QualityRender | QualityRender}].
   */
  get renderModes() {
    return this.#state.renderModes;
  }
  /**
   * Sets RGB edge color for {@link ViewObject | ViewObjects}.
   *
   * Default value is ````[0.2, 0.2, 0.2]````.
   */
  set edgeColor(value) {
    let edgeColor = this.#state.edgeColor;
    if (value && edgeColor[0] === value[0] && edgeColor[1] === value[1] && edgeColor[2] === value[2]) {
      return;
    }
    edgeColor[0] = 0.2;
    edgeColor[1] = 0.2;
    edgeColor[2] = 0.2;
    this.view.redraw();
  }
  /**
   * Gets RGB edge color for {@link ViewObject | ViewObjects}.
   *
   * Default value is ````[0.2, 0.2, 0.2]````.
   */
  get edgeColor() {
    return this.#state.edgeColor;
  }
  /**
   * Sets edge transparency for {@link ViewObject | ViewObjects}.
   *
   * A value of ````0.0```` indicates fully transparent, ````1.0```` is fully opaque.
   *
   * Default value is ````1.0````.
   */
  set edgeAlpha(value) {
    if (this.#state.edgeAlpha === value) {
      return;
    }
    this.#state.edgeAlpha = value;
    this.view.redraw();
  }
  /**
   * Gets edge transparency for {@link ViewObject | ViewObjects}.
   *
   * A value of ````0.0```` indicates fully transparent, ````1.0```` is fully opaque.
   *
   * Default value is ````1.0````.
   */
  get edgeAlpha() {
    return this.#state.edgeAlpha;
  }
  /**
   * Sets edge width for {@link ViewObject | ViewObjects}.
   *
   * Default value is ````1.0```` pixels.
   */
  set edgeWidth(value) {
    if (this.#state.edgeWidth === value) {
      return;
    }
    this.#state.edgeWidth = value;
    this.view.redraw();
  }
  /**
   * Gets edge width for {@link ViewObject | ViewObjects}.
   *
   * This is not supported by WebGL implementations based on DirectX [2019].
   *
   * Default value is ````1.0```` pixels.
   */
  get edgeWidth() {
    return this.#state.edgeWidth;
  }
  /**
   * Gets if edges are currently applied.
   *
   * This is `true` when {@link View.renderMode | View.renderMode} is
   * in {@link Edges.renderModes | Edges.renderModes}.
   */
  get applied() {
    for (let i = 0, len = this.#state.renderModes.length; i < len; i++) {
      if (this.view.renderMode === this.#state.renderModes[i]) {
        return true;
      }
    }
    return false;
  }
  /**
   * Gets the current configuration of this Edges effect.
   */
  toParams() {
    return {
      renderModes: this.renderModes,
      edgeColor: Array.from(this.edgeColor),
      edgeWidth: this.edgeWidth,
      edgeAlpha: this.edgeAlpha
    };
  }
  /**
   * Configures this Edges effect.
   *
   * @param edgesParams
   */
  fromParams(edgesParams) {
    this.renderModes = edgesParams.renderModes;
    this.edgeColor = Array.from(edgesParams.edgeColor);
    this.edgeWidth = edgesParams.edgeWidth;
    this.edgeAlpha = edgesParams.edgeAlpha;
  }
  /**
   * @private
   */
  destroy() {
    super.destroy();
  }
};

// ../sdk/src/viewer/PointsMaterial.ts
var PointsMaterial = class extends Component {
  /**
   * The View to which this PointsMaterial belongs.
   */
  view;
  #state;
  /**
   * @private
   */
  constructor(view, options = {}) {
    super(view, options);
    this.view = view;
    this.#state = {
      pointSize: options.pointSize !== void 0 && options.pointSize !== null ? options.pointSize : 1,
      roundPoints: options.roundPoints !== false,
      perspectivePoints: options.perspectivePoints !== false,
      minPerspectivePointSize: options.minPerspectivePointSize !== void 0 && options.minPerspectivePointSize !== null ? options.minPerspectivePointSize : 1,
      maxPerspectivePointSize: options.maxPerspectivePointSize !== void 0 && options.maxPerspectivePointSize !== null ? options.maxPerspectivePointSize : 6,
      filterIntensity: !!options.filterIntensity,
      minIntensity: options.minIntensity !== void 0 && options.minIntensity !== null ? options.minIntensity : 0,
      maxIntensity: options.maxIntensity !== void 0 && options.maxIntensity !== null ? options.maxIntensity : 1
    };
  }
  /**
   * Sets point size.
   *
   * Default value is ````2.0```` pixels.
   */
  set pointSize(value) {
    this.#state.pointSize = value;
    this.view.redraw();
  }
  /**
   * Gets point size.
   *
   * Default value is ````2.0```` pixels.
   */
  get pointSize() {
    return this.#state.pointSize;
  }
  /**
   * Sets if points are round or square.
   *
   * Default is ````true```` to set points round.
   */
  set roundPoints(value) {
    if (this.#state.roundPoints === value) {
      return;
    }
    this.#state.roundPoints = value;
    this.view.rebuild();
  }
  /**
   * Gets if points are round or square.
   *
   * Default is ````true```` to set points round.
   */
  get roundPoints() {
    return this.#state.roundPoints;
  }
  /**
   * Sets if rendered point size reduces with distance when {@link Camera.projection} is set to ````PerspectiveProjectionType````.
   *
   * Default is ````true````.
   */
  set perspectivePoints(value) {
    if (this.#state.perspectivePoints === value) {
      return;
    }
    this.#state.perspectivePoints = value;
    this.view.rebuild();
  }
  /**
   * Gets if rendered point size reduces with distance when {@link Camera.projection} is set to PerspectiveProjectionType.
   *
   * Default is ````false````.
   */
  get perspectivePoints() {
    return this.#state.perspectivePoints;
  }
  /**
   * Sets the minimum rendered size of points when {@link PointsMaterial.perspectivePoints} is ````true````.
   *
   * Default value is ````1.0```` pixels.
   */
  set minPerspectivePointSize(value) {
    if (this.#state.minPerspectivePointSize === value) {
      return;
    }
    this.#state.minPerspectivePointSize = value;
    this.view.rebuild();
  }
  /**
   * Gets the minimum rendered size of points when {@link PointsMaterial.perspectivePoints} is ````true````.
   *
   * Default value is ````1.0```` pixels.
   *
   * @type {Number}
   */
  get minPerspectivePointSize() {
    return this.#state.minPerspectivePointSize;
  }
  /**
   * Sets the maximum rendered size of points when {@link PointsMaterial.perspectivePoints} is ````true````.
   *
   * Default value is ````6```` pixels.
   */
  set maxPerspectivePointSize(value) {
    if (this.#state.maxPerspectivePointSize === value) {
      return;
    }
    this.#state.maxPerspectivePointSize = value;
    this.view.rebuild();
  }
  /**
   * Gets the maximum rendered size of points when {@link PointsMaterial.perspectivePoints} is ````true````.
   *
   * Default value is ````6```` pixels.
   */
  get maxPerspectivePointSize() {
    return this.#state.maxPerspectivePointSize;
  }
  /**
   * Sets whether points are made invisible when their intensity lies outside {@link PointsMaterial.minIntensity}
   * and {@link PointsMaterial.maxIntensity}.
   *
   * Default is ````false````.
   */
  set filterIntensity(value) {
    if (this.#state.filterIntensity === value) {
      return;
    }
    this.#state.filterIntensity = value;
    this.view.rebuild();
  }
  /**
   * Gets whether points are made invisible when their intensity lies outside {@link PointsMaterial.minIntensity}
   * and {@link PointsMaterial.maxIntensity}.
   *
   * Default is ````false````.
   */
  get filterIntensity() {
    return this.#state.filterIntensity;
  }
  /**
   * Sets the minimum intensity of rendered points when {@link PointsMaterial.filterIntensity} is ````true````.
   *
   * Default value is ````0````.
   */
  set minIntensity(value) {
    if (this.#state.minIntensity === value) {
      return;
    }
    this.#state.minIntensity = value;
    this.view.redraw();
  }
  /**
   * Gets the minimum intensity of rendered points when {@link PointsMaterial.filterIntensity} is ````true````.
   *
   * Default value is ````0````.
   */
  get minIntensity() {
    return this.#state.minIntensity;
  }
  /**
   * Sets the maximum intensity of rendered points when {@link PointsMaterial.filterIntensity} is ````true````.
   *
   * Default value is ````1````.
   */
  set maxIntensity(value) {
    if (this.#state.maxIntensity === value) {
      return;
    }
    this.#state.maxIntensity = value;
    this.view.redraw();
  }
  /**
   * Gets the maximum intensity of rendered points when {@link PointsMaterial.filterIntensity} is ````true````.
   *
   * Default value is ````1````.
   */
  get maxIntensity() {
    return this.#state.maxIntensity;
  }
  /**
   * @private
   */
  get hash() {
    const state = this.#state;
    return `${state.pointSize};
        ${state.roundPoints};
        ${state.perspectivePoints};
        ${state.minPerspectivePointSize};
        ${state.maxPerspectivePointSize};
        ${state.filterIntensity}`;
  }
  /**
   * Configures this PointsMaterial.
   *
   * @param pointsMaterialParams
   */
  fromParams(pointsMaterialParams) {
    if (pointsMaterialParams.pointSize !== void 0) {
      this.pointSize = pointsMaterialParams.pointSize;
    }
    if (pointsMaterialParams.roundPoints !== void 0) {
      this.roundPoints = pointsMaterialParams.roundPoints;
    }
    if (pointsMaterialParams.perspectivePoints !== void 0) {
      this.perspectivePoints = pointsMaterialParams.perspectivePoints;
    }
    if (pointsMaterialParams.minPerspectivePointSize !== void 0) {
      this.minPerspectivePointSize = pointsMaterialParams.minPerspectivePointSize;
    }
    if (pointsMaterialParams.maxPerspectivePointSize !== void 0) {
      this.maxPerspectivePointSize = pointsMaterialParams.maxPerspectivePointSize;
    }
    if (pointsMaterialParams.filterIntensity !== void 0) {
      this.filterIntensity = pointsMaterialParams.filterIntensity;
    }
  }
  /**
   * Gets the current configuration of this PointsMaterial.
   */
  toParams() {
    return {
      pointSize: this.pointSize,
      roundPoints: this.roundPoints,
      perspectivePoints: this.perspectivePoints,
      minPerspectivePointSize: this.minPerspectivePointSize,
      maxPerspectivePointSize: this.maxPerspectivePointSize,
      filterIntensity: this.filterIntensity,
      minIntensity: this.minIntensity,
      maxIntensity: this.maxIntensity
    };
  }
  /**
   * @private
   */
  destroy() {
    super.destroy();
  }
};

// ../sdk/src/viewer/Camera.ts
var import_strongly_typed_events14 = __toESM(require_dist8());

// ../sdk/src/viewer/PerspectiveProjection.ts
var import_strongly_typed_events10 = __toESM(require_dist8());
var PerspectiveProjection = class extends Component {
  /**
   * The Camera this PerspectiveProjection belongs to.
   */
  camera;
  /**
   * Emits an event each time {@link PerspectiveProjection.projMatrix | PerspectiveProjection.projMatrix} updates.
   *
   * @event
   */
  onProjMatrix;
  /**
   * The type of this projection.
   */
  static type = PerspectiveProjectionType;
  #state;
  #inverseMatrixDirty;
  #transposedProjMatrixDirty;
  #onViewBoundary;
  /**
   * @private
   */
  constructor(camera, cfg = {}) {
    super(camera, cfg);
    this.camera = camera;
    this.#state = {
      near: cfg.near || 0.1,
      far: cfg.far || 1e4,
      fov: cfg.fov || 60,
      fovAxis: cfg.fovAxis || "min",
      projMatrix: createMat4(),
      inverseProjMatrix: createMat4(),
      transposedProjMatrix: createMat4()
    };
    this.#inverseMatrixDirty = true;
    this.#transposedProjMatrixDirty = true;
    this.#onViewBoundary = this.camera.view.onBoundary.subscribe(() => {
      this.setDirty();
    });
    this.onProjMatrix = new EventEmitter(new import_strongly_typed_events10.EventDispatcher());
  }
  /**
   * Gets the PerspectiveProjection's field-of-view angle (FOV).
   *
   * Default value is ````60.0````.
   *
   * @returns {Number} Current field-of-view.
   */
  get fov() {
    return this.#state.fov;
  }
  /**
   * Sets the PerspectiveProjection's field-of-view angle (FOV).
   *
   * Default value is ````60.0````.
   *
   * @param value New field-of-view.
   */
  set fov(value) {
    if (value === this.#state.fov) {
      return;
    }
    this.#state.fov = value;
    this.setDirty();
  }
  /**
   * Gets the PerspectiveProjection's FOV axis.
   *
   * Options are ````"x"````, ````"y"```` or ````"min"````, to use the minimum axis.
   *
   * Default value is ````"min"````.
   *
   * @returns {String} The current FOV axis value.
   */
  get fovAxis() {
    return this.#state.fovAxis;
  }
  /**
   * Sets the PerspectiveProjection's FOV axis.
   *
   * Options are ````"x"````, ````"y"```` or ````"min"````, to use the minimum axis.
   *
   * Default value ````"min"````.
   *
   * @param value New FOV axis value.
   */
  set fovAxis(value) {
    value = value || "min";
    if (this.#state.fovAxis === value) {
      return;
    }
    if (value !== "x" && value !== "y" && value !== "min") {
      this.error("Unsupported value for 'fovAxis': " + value + " - defaulting to 'min'");
      value = "min";
    }
    this.#state.fovAxis = value;
    this.setDirty();
  }
  /**
   * Gets the position of the PerspectiveProjection's near plane on the positive View-space Z-axis.
   *
   * Default value is ````0.1````.
   *
   * @returns The PerspectiveProjection's near plane position.
   */
  get near() {
    return this.#state.near;
  }
  /**
   * Sets the position of the PerspectiveProjection's near plane on the positive View-space Z-axis.
   *
   * Default value is ````0.1````.
   *
   * @param value New PerspectiveProjection near plane position.
   */
  set near(value) {
    if (this.#state.near === value) {
      return;
    }
    this.#state.near = value;
    this.setDirty();
  }
  /**
   * Gets the position of this PerspectiveProjection's far plane on the positive View-space Z-axis.
   *
   * @return {Number} The PerspectiveProjection's far plane position.
   */
  get far() {
    return this.#state.far;
  }
  /**
   * Sets the position of this PerspectiveProjection's far plane on the positive View-space Z-axis.
   *
   * @param value New PerspectiveProjection far plane position.
   */
  set far(value) {
    if (this.#state.far === value) {
      return;
    }
    this.#state.far = value;
    this.setDirty();
  }
  /**
   * Gets the PerspectiveProjection's projection transform matrix.
   *
   * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
   *
   * @returns  The PerspectiveProjection's projection matrix.
   */
  get projMatrix() {
    if (this.dirty) {
      this.cleanIfDirty();
    }
    return this.#state.projMatrix;
  }
  /**
   * Gets the inverse of {@link PerspectiveProjection.projMatrix | PerspectiveProjection.projMatrix}.
   *
   * @returns  The inverse of {@link PerspectiveProjection.projMatrix | PerspectiveProjection.projMatrix}.
   */
  get inverseProjMatrix() {
    if (this.dirty) {
      this.cleanIfDirty();
    }
    if (this.#inverseMatrixDirty) {
      inverseMat4(this.#state.projMatrix, this.#state.inverseProjMatrix);
      this.#inverseMatrixDirty = false;
    }
    return this.#state.inverseProjMatrix;
  }
  /**
   * Gets the transpose of {@link PerspectiveProjection.projMatrix | PerspectiveProjection.projMatrix}.
   *
   * @returns  The transpose of {@link PerspectiveProjection.projMatrix | PerspectiveProjection.projMatrix}.
   */
  get transposedProjMatrix() {
    if (this.dirty) {
      this.cleanIfDirty();
    }
    if (this.#transposedProjMatrixDirty) {
      transposeMat4(this.#state.projMatrix, this.#state.transposedProjMatrix);
      this.#transposedProjMatrixDirty = false;
    }
    return this.#state.transposedProjMatrix;
  }
  /**
   * @private
   */
  clean() {
    const WIDTH_INDEX = 2;
    const HEIGHT_INDEX = 3;
    const boundary = this.camera.view.boundary;
    const aspect = boundary[WIDTH_INDEX] / boundary[HEIGHT_INDEX];
    const fovAxis = this.#state.fovAxis;
    let fov = this.#state.fov;
    if (fovAxis === "x" || fovAxis === "min" && aspect < 1 || fovAxis === "max" && aspect > 1) {
      fov = fov / aspect;
    }
    fov = Math.min(fov, 120);
    perspectiveMat4(fov * (Math.PI / 180), aspect, this.#state.near, this.#state.far, this.#state.projMatrix);
    this.#inverseMatrixDirty = true;
    this.#transposedProjMatrixDirty = true;
    this.camera.view.redraw();
    this.onProjMatrix.dispatch(this, this.#state.projMatrix);
  }
  /**
   * Un-projects the given View-space coordinates and Screen-space depth, using this PerspectiveProjection projection.
   *
   * @param canvasPos Inputs 2D View-space coordinates.
   * @param screenZ Inputs Screen-space Z coordinate.
   * @param screenPos Outputs 3D Screen/Clip-space coordinates.
   * @param viewPos Outputs un-projected 3D View-space coordinates.
   * @param worldPos Outputs un-projected 3D World-space coordinates.
   */
  unproject(canvasPos2, screenZ, screenPos2, viewPos2, worldPos) {
    const htmlElement = this.camera.view.htmlElement;
    const halfViewWidth = htmlElement.offsetWidth / 2;
    const halfViewHeight = htmlElement.offsetHeight / 2;
    screenPos2[0] = (canvasPos2[0] - halfViewWidth) / halfViewWidth;
    screenPos2[1] = (canvasPos2[1] - halfViewHeight) / halfViewHeight;
    screenPos2[2] = screenZ;
    screenPos2[3] = 1;
    mulMat4v4(this.inverseProjMatrix, screenPos2, viewPos2);
    mulVec3Scalar(viewPos2, 1 / viewPos2[3]);
    viewPos2[3] = 1;
    viewPos2[1] *= -1;
    mulMat4v4(this.camera.inverseViewMatrix, viewPos2, worldPos);
    return worldPos;
  }
  /**
   * Sets the state of this PerspectiveParams from the given parameters.
   * @param perspectiveProjectionParams
   */
  fromParams(perspectiveProjectionParams) {
    if (perspectiveProjectionParams.far !== void 0) {
      this.far = perspectiveProjectionParams.far;
    }
    if (perspectiveProjectionParams.near !== void 0) {
      this.near = perspectiveProjectionParams.near;
    }
    if (perspectiveProjectionParams.fov !== void 0) {
      this.fov = perspectiveProjectionParams.fov;
    }
    if (perspectiveProjectionParams.fovAxis !== void 0) {
      this.fovAxis = perspectiveProjectionParams.fovAxis;
    }
  }
  /**
   * Gets this PerspectiveProjection as JSON.
   */
  toParams() {
    return {
      far: this.far,
      near: this.near,
      fov: this.fov,
      fovAxis: this.fovAxis
    };
  }
  /** @private
   *
   */
  destroy() {
    super.destroy();
    this.camera.view.onBoundary.unsubscribe(this.#onViewBoundary);
    this.onProjMatrix.clear();
  }
};

// ../sdk/src/viewer/OrthoProjection.ts
var import_strongly_typed_events11 = __toESM(require_dist8());
var OrthoProjection = class extends Component {
  /**
   * The Camera this OrthoProjection belongs to.
   */
  camera;
  /**
   * Emits an event each time {@link OrthoProjection.projMatrix | OrthoProjection.projMatrix} updates.
   *
   * @event
   */
  onProjMatrix;
  /**
   * The type of this projection.
   */
  static type = OrthoProjectionType;
  #state;
  #inverseMatrixDirty;
  #transposedProjMatrixDirty;
  #onViewBoundary;
  /**
   * @private
   */
  constructor(camera, cfg = {}) {
    super(camera, cfg);
    this.camera = camera;
    this.#state = {
      near: cfg.near || 0.1,
      far: cfg.far || 2e3,
      scale: cfg.scale || 1,
      projMatrix: createMat4(),
      inverseProjMatrix: createMat4(),
      transposedProjMatrix: createMat4()
    };
    this.onProjMatrix = new EventEmitter(new import_strongly_typed_events11.EventDispatcher());
    this.#inverseMatrixDirty = true;
    this.#transposedProjMatrixDirty = true;
    this.#onViewBoundary = this.camera.view.onBoundary.subscribe(() => {
      this.setDirty();
    });
  }
  /**
   * Gets scale factor for this OrthoProjection's extents on X and Y axis.
   *
   * Clamps to minimum value of ````0.01```.
   *
   * Default value is ````1.0````
   *
   * returns New OrthoProjection scale value.
   */
  get scale() {
    return this.#state.scale;
  }
  /**
   * Sets scale factor for this OrthoProjection's extents on X and Y axis.
   *
   * Clamps to minimum value of ````0.01```.
   *
   * Default value is ````1.0````
   * @param value New scale value.
   */
  set scale(value) {
    if (value <= 0) {
      value = 0.01;
    }
    this.#state.scale = value;
    this.setDirty();
  }
  /**
   * Gets the position of the OrthoProjection's near plane on the positive View-space Z-axis.
   *
   * Default value is ````0.1````.
   *
   * returns New OrthoProjection near plane position.
   */
  get near() {
    return this.#state.near;
  }
  /**
   * Sets the position of the OrthoProjection's near plane on the positive View-space Z-axis.
   *
   * Default value is ````0.1````.
   *
   * @param value New OrthoProjection near plane position.
   */
  set near(value) {
    if (this.#state.near === value) {
      return;
    }
    this.#state.near = value;
    this.setDirty();
  }
  /**
   * Gets the position of the OrthoProjection's far plane on the positive View-space Z-axis.
   *
   * Default value is ````10000.0````.
   *
   * returns New far ortho plane position.
   */
  get far() {
    return this.#state.far;
  }
  /**
   * Sets the position of the OrthoProjection's far plane on the positive View-space Z-axis.
   *
   * Default value is ````2000.0````.
   *
   * @param value New far ortho plane position.
   */
  set far(value) {
    if (this.#state.far === value) {
      return;
    }
    this.#state.far = value;
    this.setDirty();
  }
  /**
   * Gets the OrthoProjection's projection transform matrix.
   *
   * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
   *
   * @returns  The OrthoProjection's projection matrix.
   */
  get projMatrix() {
    if (this.dirty) {
      this.cleanIfDirty();
    }
    return this.#state.projMatrix;
  }
  /**
   * Gets the inverse of {@link OrthoProjection.projMatrix | OrthoProjection.projMatrix}.
   *
   * @returns  The inverse of {@link OrthoProjection.projMatrix | OrthoProjection.projMatrix}.
   */
  get inverseProjMatrix() {
    if (this.dirty) {
      this.cleanIfDirty();
    }
    if (this.#inverseMatrixDirty) {
      inverseMat4(this.#state.projMatrix, this.#state.inverseProjMatrix);
      this.#inverseMatrixDirty = false;
    }
    return this.#state.inverseProjMatrix;
  }
  /**
   * Gets the transpose of {@link OrthoProjection.projMatrix | OrthoProjection.projMatrix}.
   *
   * @returns  The transpose of {@link OrthoProjection.projMatrix | OrthoProjection.projMatrix}.
   */
  get transposedProjMatrix() {
    if (this.dirty) {
      this.cleanIfDirty();
    }
    if (this.#transposedProjMatrixDirty) {
      transposeMat4(this.#state.projMatrix, this.#state.transposedProjMatrix);
      this.#transposedProjMatrixDirty = false;
    }
    return this.#state.transposedProjMatrix;
  }
  /**
   * @private
   */
  clean() {
    const WIDTH_INDEX = 2;
    const HEIGHT_INDEX = 3;
    const view = this.camera.view;
    const scale3 = this.#state.scale;
    const halfSize = 0.5 * scale3;
    const boundary = view.boundary;
    const boundaryWidth = boundary[WIDTH_INDEX];
    const boundaryHeight = boundary[HEIGHT_INDEX];
    const aspect = boundaryWidth / boundaryHeight;
    let left;
    let right;
    let top;
    let bottom;
    if (boundaryWidth > boundaryHeight) {
      left = -halfSize;
      right = halfSize;
      top = halfSize / aspect;
      bottom = -halfSize / aspect;
    } else {
      left = -halfSize * aspect;
      right = halfSize * aspect;
      top = halfSize;
      bottom = -halfSize;
    }
    orthoMat4c(left, right, bottom, top, this.#state.near, this.#state.far, this.#state.projMatrix);
    this.#inverseMatrixDirty = true;
    this.#transposedProjMatrixDirty = true;
    this.camera.view.redraw();
    this.onProjMatrix.dispatch(this, this.#state.projMatrix);
  }
  /**
   * Un-projects the given View-space coordinates, using this OrthoProjection projection.
   *
   * @param canvasPos Inputs 2D View-space coordinates.
   * @param screenZ Inputs Screen-space Z coordinate.
   * @param screenPos Outputs 3D Screen/Clip-space coordinates.
   * @param viewPos Outputs un-projected 3D View-space coordinates.
   * @param worldPos Outputs un-projected 3D World-space coordinates.
   */
  unproject(canvasPos2, screenZ, screenPos2, viewPos2, worldPos) {
    const canvas2 = this.camera.view.htmlElement;
    const halfViewWidth = canvas2.offsetWidth / 2;
    const halfViewHeight = canvas2.offsetHeight / 2;
    screenPos2[0] = (canvasPos2[0] - halfViewWidth) / halfViewWidth;
    screenPos2[1] = (canvasPos2[1] - halfViewHeight) / halfViewHeight;
    screenPos2[2] = screenZ;
    screenPos2[3] = 1;
    mulMat4v4(this.inverseProjMatrix, screenPos2, viewPos2);
    mulVec3Scalar(viewPos2, 1 / viewPos2[3]);
    viewPos2[3] = 1;
    viewPos2[1] *= -1;
    mulMat4v4(this.camera.inverseViewMatrix, viewPos2, worldPos);
    return worldPos;
  }
  /**
   * Configures this OrthoProjection.
   *
   * @param orthoProjectionParams
   */
  fromParams(orthoProjectionParams) {
    if (orthoProjectionParams.far !== void 0) {
      this.far = orthoProjectionParams.far;
    }
    if (orthoProjectionParams.near !== void 0) {
      this.near = orthoProjectionParams.near;
    }
    if (orthoProjectionParams.scale !== void 0) {
      this.scale = orthoProjectionParams.scale;
    }
  }
  /**
   * Gets the current configuration of this OrthoProjection.
   */
  toParams() {
    return {
      far: this.far,
      near: this.near,
      scale: this.scale
    };
  }
  /** @private
   *
   */
  destroy() {
    super.destroy();
    this.camera.view.onBoundary.unsubscribe(this.#onViewBoundary);
    this.onProjMatrix.clear();
  }
};

// ../sdk/src/viewer/FrustumProjection.ts
var import_strongly_typed_events12 = __toESM(require_dist8());
var FrustumProjection = class extends Component {
  /**
   * The type of this projection.
   */
  static type = FrustumProjectionType;
  /**
   * The Camera this FrustumProjection belongs to.
   */
  camera;
  /**
   * Emits an event each time {@link FrustumProjection.projMatrix} updates.
   *
   * @event
   */
  onProjMatrix;
  #state;
  #inverseMatrixDirty;
  #transposedProjMatrixDirty;
  /**
   * @private
   */
  constructor(camera, cfg = {}) {
    super(camera, cfg);
    this.camera = camera;
    this.#state = {
      projMatrix: createMat4(),
      inverseProjMatrix: createMat4(),
      transposedProjMatrix: createMat4(),
      near: 0.1,
      far: 1e4,
      left: cfg.left !== void 0 && cfg.left !== null ? cfg.left : -1,
      right: cfg.right !== void 0 && cfg.right !== null ? cfg.right : 1,
      bottom: cfg.bottom !== void 0 && cfg.bottom !== null ? cfg.bottom : -1,
      top: cfg.top !== void 0 && cfg.top !== null ? cfg.top : 1
    };
    this.onProjMatrix = new EventEmitter(new import_strongly_typed_events12.EventDispatcher());
    this.#inverseMatrixDirty = true;
    this.#transposedProjMatrixDirty = true;
  }
  /**
   * Gets the position of the FrustumProjection's left plane on the View-space X-axis.
   *
   * @return {Number} Left frustum plane position.
   */
  get left() {
    return this.#state.left;
  }
  /**
   * Sets the position of the FrustumProjection's left plane on the View-space X-axis.
   *
   * @param value New left frustum plane position.
   */
  set left(value) {
    this.#state.left = value;
    this.setDirty();
  }
  /**
   * Gets the position of the FrustumProjection's right plane on the View-space X-axis.
   *
   * @return {Number} Right frustum plane position.
   */
  get right() {
    return this.#state.right;
  }
  /**
   * Sets the position of the FrustumProjection's right plane on the View-space X-axis.
   *
   * @param value New right frustum plane position.
   */
  set right(value) {
    this.#state.right = value;
    this.setDirty();
  }
  /**
   * Gets the position of the FrustumProjection's top plane on the View-space Y-axis.
   *
   * @return {Number} Top frustum plane position.
   */
  get top() {
    return this.#state.top;
  }
  /**
   * Sets the position of the FrustumProjection's top plane on the View-space Y-axis.
   *
   * @param value New top frustum plane position.
   */
  set top(value) {
    this.#state.top = value;
    this.setDirty();
  }
  /**
   * Gets the position of the FrustumProjection's bottom plane on the View-space Y-axis.
   *
   * @return {Number} Bottom frustum plane position.
   */
  get bottom() {
    return this.#state.bottom;
  }
  /**
   * Sets the position of the FrustumProjection's bottom plane on the View-space Y-axis.
   *
   * @param value New bottom frustum plane position.
   */
  set bottom(value) {
    this.#state.bottom = value;
    this.setDirty();
  }
  /**
   * Gets the position of the FrustumProjection's near plane on the positive View-space Z-axis.
   *
   * Default value is ````0.1````.
   *
   * @return {Number} Near frustum plane position.
   */
  get near() {
    return this.#state.near;
  }
  /**
   * Sets the position of the FrustumProjection's near plane on the positive View-space Z-axis.
   *
   * Default value is ````0.1````.
   *
   * @param value New FrustumProjection near plane position.
   */
  set near(value) {
    this.#state.near = value;
    this.setDirty();
  }
  /**
   * Gets the position of the FrustumProjection's far plane on the positive View-space Z-axis.
   *
   * Default value is ````10000.0````.
   *
   * @return {Number} Far frustum plane position.
   */
  get far() {
    return this.#state.far;
  }
  /**
   * Sets the position of the FrustumProjection's far plane on the positive View-space Z-axis.
   *
   * Default value is ````10000.0````.
   *
   * @param value New far frustum plane position.
   */
  set far(value) {
    this.#state.far = value;
    this.setDirty();
  }
  /**
   * Gets the FrustumProjection's projection transform matrix.
   *
   * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
   *
   * @returns The FrustumProjection's projection matrix
   */
  get projMatrix() {
    if (this.dirty) {
      this.cleanIfDirty();
    }
    return this.#state.projMatrix;
  }
  /**
   * Gets the inverse of {@link FrustumProjection.projMatrix}.
   *
   * @returns  The inverse orthographic projection projMatrix.
   */
  get inverseProjMatrix() {
    if (this.dirty) {
      this.cleanIfDirty();
    }
    if (this.#inverseMatrixDirty) {
      inverseMat4(this.#state.projMatrix, this.#state.inverseProjMatrix);
      this.#inverseMatrixDirty = false;
    }
    return this.#state.inverseProjMatrix;
  }
  /**
   * Gets the transpose of {@link FrustumProjection.projMatrix}.
   *
   * @returns The transpose of {@link FrustumProjection.projMatrix}.
   */
  get transposedProjMatrix() {
    if (this.dirty) {
      this.cleanIfDirty();
    }
    if (this.#transposedProjMatrixDirty) {
      transposeMat4(this.#state.projMatrix, this.#state.transposedProjMatrix);
      this.#transposedProjMatrixDirty = false;
    }
    return this.#state.transposedProjMatrix;
  }
  /**
   * @private
   */
  clean() {
    frustumMat4(this.#state.left, this.#state.right, this.#state.bottom, this.#state.top, this.#state.near, this.#state.far, this.#state.projMatrix);
    this.#inverseMatrixDirty = true;
    this.#transposedProjMatrixDirty = true;
    this.camera.view.redraw();
    this.onProjMatrix.dispatch(this, this.#state.projMatrix);
  }
  /**
   * Un-projects the given View-space coordinates, using this FrustumProjection projection.
   *
   * @param canvasPos Inputs 2D View-space coordinates.
   * @param screenZ Inputs Screen-space Z coordinate.
   * @param screenPos Outputs 3D Screen/Clip-space coordinates.
   * @param viewPos Outputs un-projected 3D View-space coordinates.
   * @param worldPos Outputs un-projected 3D World-space coordinates.
   */
  unproject(canvasPos2, screenZ, screenPos2, viewPos2, worldPos) {
    const htmlElement = this.camera.view.htmlElement;
    const halfViewWidth = htmlElement.offsetWidth / 2;
    const halfViewHeight = htmlElement.offsetHeight / 2;
    screenPos2[0] = (canvasPos2[0] - halfViewWidth) / halfViewWidth;
    screenPos2[1] = (canvasPos2[1] - halfViewHeight) / halfViewHeight;
    screenPos2[2] = screenZ;
    screenPos2[3] = 1;
    mulMat4v4(this.inverseProjMatrix, screenPos2, viewPos2);
    mulVec3Scalar(viewPos2, 1 / viewPos2[3]);
    viewPos2[3] = 1;
    viewPos2[1] *= -1;
    mulMat4v4(this.camera.inverseViewMatrix, viewPos2, worldPos);
    return worldPos;
  }
  /**
   * Configures this FrustumProjection.
   *
   * @param frustumProjectionParams
   */
  fromParams(frustumProjectionParams) {
    if (frustumProjectionParams.far !== void 0) {
      this.far = frustumProjectionParams.far;
    }
    if (frustumProjectionParams.near !== void 0) {
      this.near = frustumProjectionParams.near;
    }
    if (frustumProjectionParams.top !== void 0) {
      this.top = frustumProjectionParams.top;
    }
    if (frustumProjectionParams.bottom !== void 0) {
      this.bottom = frustumProjectionParams.bottom;
    }
    if (frustumProjectionParams.right !== void 0) {
      this.right = frustumProjectionParams.right;
    }
    if (frustumProjectionParams.left !== void 0) {
      this.left = frustumProjectionParams.left;
    }
  }
  /**
   * Gets the current configuration of this FrustumProjection.
   */
  toParams() {
    return {
      far: this.far,
      near: this.near,
      top: this.top,
      bottom: this.bottom,
      right: this.right,
      left: this.left
    };
  }
  /** @private
   *
   */
  destroy() {
    super.destroy();
    this.onProjMatrix.clear();
  }
};

// ../sdk/src/viewer/CustomProjection.ts
var import_strongly_typed_events13 = __toESM(require_dist8());
var CustomProjection = class extends Component {
  /**
   * The Camera this CustomProjection belongs to.
   */
  camera;
  /**
   * Emits an event each time {@link CustomProjection.projMatrix} updates.
   *
   * @event
   */
  onProjMatrix;
  /**
   * The type of this projection.
   */
  static type = CustomProjectionType;
  #state;
  #inverseProjMatrixDirty;
  #transposedProjMatrixDirty;
  /**
   * @private
   */
  constructor(camera, cfg = {}) {
    super(camera, cfg);
    this.camera = camera;
    this.#state = {
      projMatrix: createMat4(cfg.projMatrix || identityMat4()),
      inverseProjMatrix: createMat4(),
      transposedProjMatrix: createMat4()
    };
    this.onProjMatrix = new EventEmitter(new import_strongly_typed_events13.EventDispatcher());
    this.#inverseProjMatrixDirty = true;
    this.#transposedProjMatrixDirty = false;
  }
  /**
   * Gets the CustomProjection's projection transform matrix.
   *
   * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
   *
   * @return  New value for the CustomProjection's matrix.
   */
  get projMatrix() {
    return this.#state.projMatrix;
  }
  /**
   * Sets the CustomProjection's projection transform matrix.
   *
   * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
   *
   * @param projMatrix New value for the CustomProjection's matrix.
   */
  set projMatrix(projMatrix) {
    this.#state.projMatrix.set(projMatrix);
    this.#inverseProjMatrixDirty = true;
    this.#transposedProjMatrixDirty = true;
    this.setDirty();
    this.camera.view.redraw();
    this.onProjMatrix.dispatch(this, this.#state.projMatrix);
  }
  /**
   * Gets the inverse of {@link CustomProjection.projMatrix}.
   *
   * @returns The inverse of {@link CustomProjection.projMatrix}.
   */
  get inverseProjMatrix() {
    if (this.dirty) {
      this.cleanIfDirty();
    }
    if (this.#inverseProjMatrixDirty) {
      inverseMat4(this.#state.projMatrix, this.#state.inverseProjMatrix);
      this.#inverseProjMatrixDirty = false;
    }
    return this.#state.inverseProjMatrix;
  }
  /**
   * Gets the transpose of {@link CustomProjection.projMatrix}.
   *
   * @returns The transpose of {@link CustomProjection.projMatrix}.
   */
  get transposedProjMatrix() {
    if (this.dirty) {
      this.cleanIfDirty();
    }
    if (this.#transposedProjMatrixDirty) {
      transposeMat4(this.#state.projMatrix, this.#state.transposedProjMatrix);
      this.#transposedProjMatrixDirty = false;
    }
    return this.#state.transposedProjMatrix;
  }
  /**
   * Un-projects the given View-space coordinates, using this CustomProjection.
   *
   * @param canvasPos Inputs 2D View-space coordinates.
   * @param screenZ Inputs Screen-space Z coordinate.
   * @param screenPos Outputs 3D Screen/Clip-space coordinates.
   * @param viewPos Outputs un-projected 3D View-space coordinates.
   * @param worldPos Outputs un-projected 3D World-space coordinates.
   */
  unproject(canvasPos2, screenZ, screenPos2, viewPos2, worldPos) {
    const htmlElement = this.camera.view.htmlElement;
    const halfViewWidth = htmlElement.offsetWidth / 2;
    const halfViewHeight = htmlElement.offsetHeight / 2;
    screenPos2[0] = (canvasPos2[0] - halfViewWidth) / halfViewWidth;
    screenPos2[1] = (canvasPos2[1] - halfViewHeight) / halfViewHeight;
    screenPos2[2] = screenZ;
    screenPos2[3] = 1;
    mulMat4v4(this.inverseProjMatrix, screenPos2, viewPos2);
    mulVec3Scalar(viewPos2, 1 / viewPos2[3]);
    viewPos2[3] = 1;
    viewPos2[1] *= -1;
    mulMat4v4(this.camera.inverseViewMatrix, viewPos2, worldPos);
    return worldPos;
  }
  /**
   * Configures this CustomProjection.
   * @param customProjectionParams
   */
  fromParams(customProjectionParams) {
    if (customProjectionParams.projMatrix) {
      this.projMatrix = customProjectionParams.projMatrix;
    }
  }
  /**
   * Gets the current configuration of this CustomProjection.
   */
  toParams() {
    return {
      projMatrix: Array.from(this.projMatrix)
    };
  }
  /** @private
   *
   */
  destroy() {
    super.destroy();
    this.onProjMatrix.clear();
  }
};

// ../sdk/src/viewer/Camera.ts
var tempVec32 = createVec3();
var tempVec3b6 = createVec3();
var tempVec3c4 = createVec3();
var tempVec3d2 = createVec3();
var tempVec3e2 = createVec3();
var tempVec3f = createVec3();
var tempMat2 = createMat4();
var tempMatb = createMat4();
var eyeLookVec = createVec3();
var eyeLookVecNorm = createVec3();
var eyeLookOffset = createVec3();
var offsetEye = createVec3();
var Camera = class extends Component {
  /**
   * The View to which this Camera belongs.
   *
   * @property view
   * @type {View}
   *
   */
  view;
  /**
   * The perspective projection.
   *
   * The Camera uses this while {@link Camera.projectionType} equals {@link PerspectiveProjectionType}.
   */
  perspectiveProjection;
  /**
   * The orthographic projection.
   *
   * The Camera uses this while {@link Camera.projectionType} equals {@link constants!OrthoProjectionType}.
   */
  orthoProjection;
  /**
   * The frustum projection.
   *
   * The Camera uses this while {@link Camera.projectionType} equals {@link constants!FrustumProjectionType}.
   */
  frustumProjection;
  /**
   * The custom projection.
   *
   * The Camera uses this while {@link Camera.projectionType} equals {@link constants!CustomProjectionType}.
   */
  customProjection;
  /**
   * Emits an event each time {@link Camera.projectionType} updates.
   *
   * ````javascript
   * myView.camera.onProjectionType.subscribe((camera, projType) => { ... });
   * ````
   *
   * @event
   */
  onProjectionType;
  /**
   * Emits an event each time {@link Camera.viewMatrix} updates.
   *
   * ````javascript
   * myView.camera.onViewMatrix.subscribe((camera, viewMatrix) => { ... });
   * ````
   *
   * @event
   */
  onViewMatrix;
  /**
   * Emits an event each time {@link Camera.projMatrix} updates.
   *
   * ````javascript
   * myView.camera.onProjMatrix.subscribe((camera, projMatrix) => { ... });
   * ````
   *
   * @event
   */
  onProjMatrix;
  /**
   * Emits an event each time {@link Camera.worldAxis} updates.
   *
   * ````javascript
   * myView.camera.onWorldAxis.subscribe((camera, worldAxis) => { ... });
   * ````
   *
   * @event
   */
  onWorldAxis;
  /**
   * Emits an event each time {@link Camera.frustum} updates.
   *
   * ````javascript
   * myView.camera.onFrustum.subscribe((camera, frustum) => { ... });
   * ````
   *
   * @event
   */
  onFrustum;
  #state;
  /**
   * The viewing frustum.
   */
  #frustum;
  #activeProjection;
  /**
   * @private
   */
  constructor(view, cfg = {}) {
    super(view, cfg);
    this.onProjectionType = new EventEmitter(new import_strongly_typed_events14.EventDispatcher());
    this.onViewMatrix = new EventEmitter(new import_strongly_typed_events14.EventDispatcher());
    this.onProjMatrix = new EventEmitter(new import_strongly_typed_events14.EventDispatcher());
    this.onWorldAxis = new EventEmitter(new import_strongly_typed_events14.EventDispatcher());
    this.onFrustum = new EventEmitter(new import_strongly_typed_events14.EventDispatcher());
    this.view = view;
    this.#state = {
      eye: createVec3(cfg.eye || [0, 0, 10]),
      look: createVec3(cfg.look || [0, 0, 0]),
      up: createVec3(cfg.up || [0, 1, 0]),
      worldUp: createVec3([0, 1, 0]),
      worldRight: createVec3([1, 0, 0]),
      worldForward: createVec3([0, 0, -1]),
      worldAxis: new Float32Array(cfg.worldAxis || [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      gimbalLock: cfg.gimbalLock !== false,
      constrainPitch: cfg.constrainPitch === true,
      projectionType: cfg.projectionType || PerspectiveProjectionType,
      deviceMatrix: cfg.deviceMatrix ? createMat4(cfg.deviceMatrix) : identityMat4(),
      hasDeviceMatrix: !!cfg.deviceMatrix,
      viewMatrix: createMat4(),
      viewNormalMatrix: createMat4(),
      inverseViewMatrix: createMat4()
    };
    this.#frustum = new Frustum3();
    this.perspectiveProjection = new PerspectiveProjection(this);
    this.orthoProjection = new OrthoProjection(this);
    this.frustumProjection = new FrustumProjection(this);
    this.customProjection = new CustomProjection(this);
    this.#activeProjection = this.perspectiveProjection;
    this.perspectiveProjection.onProjMatrix.subscribe(() => {
      if (this.#state.projectionType === PerspectiveProjectionType) {
        this.onProjMatrix.dispatch(this, this.perspectiveProjection.projMatrix);
      }
    });
    this.orthoProjection.onProjMatrix.subscribe(() => {
      if (this.#state.projectionType === OrthoProjectionType) {
        this.onProjMatrix.dispatch(this, this.orthoProjection.projMatrix);
      }
    });
    this.frustumProjection.onProjMatrix.subscribe(() => {
      if (this.#state.projectionType === FrustumProjectionType) {
        this.onProjMatrix.dispatch(this, this.frustumProjection.projMatrix);
      }
    });
    this.customProjection.onProjMatrix.subscribe(() => {
      if (this.#state.projectionType === CustomProjectionType) {
        this.onProjMatrix.dispatch(this, this.customProjection.projMatrix);
      }
    });
  }
  /**
   * Gets the currently active projection for this Camera.
   *
   * The currently active project is selected with {@link Camera.projectionType}.
   *
   * @returns {PerspectiveProjection|OrthoProjection|FrustumProjection|CustomProjection} The currently active projection is active.
   */
  get projection() {
    return this.#activeProjection;
  }
  /**
   * Gets the position of the Camera's eye.
   *
   * Default vale is ````[0,0,10]````.
   *
   * @type {Number[]} New eye position.
   */
  get eye() {
    return this.#state.eye;
  }
  /**
   * Sets the position of the Camera's eye.
   *
   * Default value is ````[0,0,10]````.
   *
   * @type {Number[]} New eye position.
   */
  set eye(eye) {
    this.#state.eye.set(eye);
    this.setDirty();
  }
  /**
   * Gets the position of this Camera's point-of-interest.
   *
   * Default value is ````[0,0,0]````.
   *
   * @returns {Number[]} Camera look position.
   */
  get look() {
    return this.#state.look;
  }
  /**
   * Sets the position of this Camera's point-of-interest.
   *
   * Default value is ````[0,0,0]````.
   *
   * @param look Camera look position.
   */
  set look(look) {
    this.#state.look.set(look);
    this.setDirty();
  }
  /**
   * Gets the direction of this Camera's {@link Camera.up | Camera.up} vector.
   *
   * @returns {Number[]} Direction of "up".
   */
  get up() {
    return this.#state.up;
  }
  /**
   * Sets the direction of this Camera's {@link Camera.up | Camera.up} vector.
   *
   * @param up Direction of "up".
   */
  set up(up) {
    this.#state.up.set(up);
    this.setDirty();
  }
  /**
   * Gets the direction of World-space "up".
   *
   * This is set by {@link Camera.worldAxis}.
   *
   * Default value is ````[0,1,0]````.
   *
   * @returns {Number[]} The "up" vector.
   */
  get worldUp() {
    return this.#state.worldUp;
  }
  /**
   * Gets the direction of World-space "right".
   *
   * This is set by {@link Camera.worldAxis}.
   *
   * Default value is ````[1,0,0]````.
   *
   * @returns {Number[]} The "up" vector.
   */
  get worldRight() {
    return this.#state.worldRight;
  }
  /**
   * Gets the direction of World-space "forwards".
   *
   * This is set by {@link Camera.worldAxis}.
   *
   * Default value is ````[0,0,1]````.
   *
   * @returns {Number[]} The "up" vector.
   */
  get worldForward() {
    return this.#state.worldForward;
  }
  /**
   * Gets whether to prevent camera from being pitched upside down.
   *
   * The camera is upside down when the angle between {@link Camera.up | Camera.up} and {@link Camera.worldUp} is less than one degree.
   *
   * Default value is ````false````.
   *
   * @returns {Boolean} ````true```` if pitch rotation is currently constrained.
   */
  get constrainPitch() {
    return this.#state.constrainPitch;
  }
  /**
   * Sets whether to prevent camera from being pitched upside down.
   *
   * The camera is upside down when the angle between {@link Camera.up | Camera.up} and {@link Camera.worldUp} is less than one degree.
   *
   * Default value is ````false````.
   *
   * @param value Set ````true```` to contrain pitch rotation.
   */
  set constrainPitch(value) {
    this.#state.constrainPitch = value;
  }
  /**
   * Gets whether to lock yaw rotation to pivot about the World-space "up" axis.
   *
   * @returns {Boolean} Returns ````true```` if gimbal is locked.
   */
  get gimbalLock() {
    return this.#state.gimbalLock;
  }
  /**
   * Sets whether to lock yaw rotation to pivot about the World-space "up" axis.
   *
   * @param {Boolean} gimbalLock Set true to lock gimbal.
   */
  set gimbalLock(value) {
    this.#state.gimbalLock = value;
  }
  /**
   * Gets the up, right and forward axis of the World coordinate system.
   *
   * Has format: ````[rightX, rightY, rightZ, upX, upY, upZ, forwardX, forwardY, forwardZ]````
   *
   * Default axis is ````[1, 0, 0, 0, 1, 0, 0, 0, 1]````
   *
   * @returns {Number[]} The current World coordinate axis.
   */
  get worldAxis() {
    return this.#state.worldAxis;
  }
  /**
   * Sets the up, right and forward axis of the World coordinate system.
   *
   * Has format: ````[rightX, rightY, rightZ, upX, upY, upZ, forwardX, forwardY, forwardZ]````
   *
   * Default axis is ````[1, 0, 0, 0, 1, 0, 0, 0, 1]````
   *
   * @param axis The new Wworld coordinate axis.
   */
  set worldAxis(axis) {
    const state = this.#state;
    state.worldAxis.set(axis);
    state.worldRight[0] = state.worldAxis[0];
    state.worldRight[1] = state.worldAxis[1];
    state.worldRight[2] = state.worldAxis[2];
    state.worldUp[0] = state.worldAxis[3];
    state.worldUp[1] = state.worldAxis[4];
    state.worldUp[2] = state.worldAxis[5];
    state.worldForward[0] = state.worldAxis[6];
    state.worldForward[1] = state.worldAxis[7];
    state.worldForward[2] = state.worldAxis[8];
    this.onWorldAxis.dispatch(this, state.worldAxis);
  }
  /**
   * Gets an optional matrix to premultiply into {@link Camera.projMatrix} matrix.
   *
   * @returns {Number[]} The matrix.
   */
  get deviceMatrix() {
    return this.#state.deviceMatrix;
  }
  /**
   * Sets an optional matrix to premultiply into {@link Camera.projMatrix} matrix.
   *
   * This is intended to be used for stereo rendering with WebVR etc.
   *
   * @param matrix The matrix.
   */
  set deviceMatrix(matrix) {
    this.#state.deviceMatrix.set(matrix || [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
    this.#state.hasDeviceMatrix = !!matrix;
    this.setDirty();
  }
  /**
   * Gets if the World-space X-axis is "up".
   * @returns {boolean}
   */
  get xUp() {
    return this.#state.worldUp[0] > this.#state.worldUp[1] && this.#state.worldUp[0] > this.#state.worldUp[2];
  }
  /**
   * Gets if the World-space Y-axis is "up".
   * @returns {boolean}
   */
  get yUp() {
    return this.#state.worldUp[1] > this.#state.worldUp[0] && this.#state.worldUp[1] > this.#state.worldUp[2];
  }
  /**
   * Gets if the World-space Z-axis is "up".
   * @returns {boolean}
   */
  get zUp() {
    return this.#state.worldUp[2] > this.#state.worldUp[0] && this.#state.worldUp[2] > this.#state.worldUp[1];
  }
  /**
   * Gets distance from {@link Camera.look | Camera.look} to {@link Camera.eye | Camera.eye}.
   *
   * @returns {Number} The distance.
   */
  get eyeLookDist() {
    return lenVec3(subVec3(this.#state.look, this.#state.eye, tempVec32));
  }
  /**
   * Gets the Camera's viewing transformation matrix.
   *
   * @returns {Number[]} The viewing transform matrix.
   */
  get viewMatrix() {
    if (this.dirty) {
      this.cleanIfDirty();
    }
    return this.#state.viewMatrix;
  }
  /**
   * Gets the inverse of the Camera's viewing transform matrix.
   *
   * @returns {Number[]} The inverse viewing transform matrix.
   */
  get inverseViewMatrix() {
    if (this.dirty) {
      this.cleanIfDirty();
    }
    return this.#state.inverseViewMatrix;
  }
  /**
   * Gets the Camera's projection transformation projMatrix.
   *
   * @returns {Number[]} The projection matrix.
   */
  get projMatrix() {
    return this.#activeProjection.projMatrix;
  }
  /**
   * Gets the Camera's 3D World-space viewing frustum.
   *
   * @returns {Frustum3} The frustum.
   */
  get frustum() {
    if (this.dirty) {
      this.cleanIfDirty();
    }
    return this.#frustum;
  }
  /**
   * Gets the active projection type.
   *
   * Possible values are ````PerspectiveProjectionType````, ````OrthoProjectionType````, ````"frustum"```` and ````"customProjection"````.
   *
   * Default value is ````PerspectiveProjectionType````.
   *
   * @returns {number} Identifies the active projection type.
   */
  get projectionType() {
    return this.#state.projectionType;
  }
  /**
   * Sets the active projection type.
   *
   * Accepted values are ````PerspectiveProjectionType````, ````OrthoProjectionType````, ````"frustum"```` and ````"customProjection"````.
   *
   * Default value is ````PerspectiveProjectionType````.
   *
   * @param value Identifies the active projection type.
   */
  set projectionType(value) {
    value = value || PerspectiveProjectionType;
    if (this.#state.projectionType === value) {
      return;
    }
    if (value === PerspectiveProjectionType) {
      this.#activeProjection = this.perspectiveProjection;
    } else if (value === OrthoProjectionType) {
      this.#activeProjection = this.orthoProjection;
    } else if (value === FrustumProjectionType) {
      this.#activeProjection = this.frustumProjection;
    } else if (value === CustomProjectionType) {
      this.#activeProjection = this.customProjection;
    } else {
      this.error("Unsupported value for 'projection': " + value + " defaulting to PerspectiveProjectionType");
      this.#activeProjection = this.perspectiveProjection;
      value = PerspectiveProjectionType;
    }
    this.#activeProjection.clean();
    this.#state.projectionType = value;
    this.clean();
    this.onProjectionType.dispatch(this, this.#state.projectionType);
    this.onProjMatrix.dispatch(this, this.#activeProjection.projMatrix);
  }
  setDirty() {
    super.setDirty();
    this.view.redraw();
  }
  clean() {
    const state = this.#state;
    let eye;
    if (this.projectionType === OrthoProjectionType) {
      subVec3(this.#state.eye, this.#state.look, eyeLookVec);
      normalizeVec3(eyeLookVec, eyeLookVecNorm);
      mulVec3Scalar(eyeLookVecNorm, 1e3, eyeLookOffset);
      addVec3(this.#state.look, eyeLookOffset, offsetEye);
      eye = offsetEye;
    } else {
      eye = this.#state.eye;
    }
    if (state.hasDeviceMatrix) {
      lookAtMat4v(eye, this.#state.look, this.#state.up, tempMatb);
      mulMat4(state.deviceMatrix, tempMatb, state.viewMatrix);
    } else {
      lookAtMat4v(eye, this.#state.look, this.#state.up, state.viewMatrix);
    }
    inverseMat4(this.#state.viewMatrix, this.#state.inverseViewMatrix);
    transposeMat4(this.#state.inverseViewMatrix, this.#state.viewNormalMatrix);
    this.view.redraw();
    setFrustum3(this.#state.viewMatrix, this.#activeProjection.projMatrix, this.#frustum);
    this.onViewMatrix.dispatch(this, this.#state.viewMatrix);
    this.onFrustum.dispatch(this, this.#frustum);
  }
  /**
   * Rotates {@link Camera.eye | Camera.eye} about {@link Camera.look | Camera.look}, around the {@link Camera.up | Camera.up} vector
   *
   * @param angleInc Angle of rotation in degrees
   */
  orbitYaw(angleInc) {
    let lookEyeVec = subVec3(this.#state.eye, this.#state.look, tempVec32);
    rotationMat4v(angleInc * 0.0174532925, this.#state.gimbalLock ? this.#state.worldUp : this.#state.up, tempMat2);
    lookEyeVec = transformPoint3(tempMat2, lookEyeVec, tempVec3b6);
    this.eye = addVec3(this.#state.look, lookEyeVec, tempVec3c4);
    this.up = transformPoint3(tempMat2, this.#state.up, tempVec3d2);
  }
  /**
   * Rotates {@link Camera.eye | Camera.eye} about {@link Camera.look | Camera.look} around the right axis (orthogonal to {@link Camera.up | Camera.up} and "look").
   *
   * @param angleInc Angle of rotation in degrees
   */
  orbitPitch(angleInc) {
    if (this.#state.constrainPitch) {
      angleInc = dotVec3(this.#state.up, this.#state.worldUp) / DEGTORAD;
      if (angleInc < 1) {
        return;
      }
    }
    let eye2 = subVec3(this.#state.eye, this.#state.look, tempVec32);
    const left = cross3Vec3(normalizeVec3(eye2, tempVec3b6), normalizeVec3(this.#state.up, tempVec3c4));
    rotationMat4v(angleInc * 0.0174532925, left, tempMat2);
    eye2 = transformPoint3(tempMat2, eye2, tempVec3d2);
    this.up = transformPoint3(tempMat2, this.#state.up, tempVec3e2);
    this.eye = addVec3(eye2, this.#state.look, tempVec3f);
  }
  /**
   * Rotates {@link Camera.look | Camera.look} about {@link Camera.eye | Camera.eye}, around the {@link Camera.up | Camera.up} vector.
   *
   * @param angleInc Angle of rotation in degrees
   */
  yaw(angleInc) {
    let look2 = subVec3(this.#state.look, this.#state.eye, tempVec32);
    rotationMat4v(angleInc * 0.0174532925, this.#state.gimbalLock ? this.#state.worldUp : this.#state.up, tempMat2);
    look2 = transformPoint3(tempMat2, look2, tempVec3b6);
    this.look = addVec3(look2, this.#state.eye, tempVec3c4);
    if (this.#state.gimbalLock) {
      this.up = transformPoint3(tempMat2, this.#state.up, tempVec3d2);
    }
  }
  /**
       * Rotates {@link Camera.look | Camera.look} about {@link Camera.eye | Camera.eye}, around the right axis (orthogonal to {@link Camera.up | Camera.up} and "look").
  
       * @param angleInc Angle of rotation in degrees
       */
  pitch(angleInc) {
    if (this.#state.constrainPitch) {
      angleInc = dotVec3(this.#state.up, this.#state.worldUp) / DEGTORAD;
      if (angleInc < 1) {
        return;
      }
    }
    let look2 = subVec3(this.#state.look, this.#state.eye, tempVec32);
    const left = cross3Vec3(normalizeVec3(look2, tempVec3b6), normalizeVec3(this.#state.up, tempVec3c4));
    rotationMat4v(angleInc * 0.0174532925, left, tempMat2);
    this.up = transformPoint3(tempMat2, this.#state.up, tempVec3f);
    look2 = transformPoint3(tempMat2, look2, tempVec3d2);
    this.look = addVec3(look2, this.#state.eye, tempVec3e2);
  }
  /**
   * Pans the Camera along its local X, Y and Z axis.
   *
   * @param pan The pan vector
   */
  pan(pan) {
    const eye2 = subVec3(this.#state.eye, this.#state.look, tempVec32);
    const vec = [0, 0, 0];
    let v;
    if (pan[0] !== 0) {
      const left = cross3Vec3(normalizeVec3(eye2, []), normalizeVec3(this.#state.up, tempVec3b6));
      v = mulVec3Scalar(left, pan[0]);
      vec[0] += v[0];
      vec[1] += v[1];
      vec[2] += v[2];
    }
    if (pan[1] !== 0) {
      v = mulVec3Scalar(normalizeVec3(this.#state.up, tempVec3c4), pan[1]);
      vec[0] += v[0];
      vec[1] += v[1];
      vec[2] += v[2];
    }
    if (pan[2] !== 0) {
      v = mulVec3Scalar(normalizeVec3(eye2, tempVec3d2), pan[2]);
      vec[0] += v[0];
      vec[1] += v[1];
      vec[2] += v[2];
    }
    this.eye = addVec3(this.#state.eye, vec, tempVec3e2);
    this.look = addVec3(this.#state.look, vec, tempVec3f);
  }
  /**
   * Increments/decrements the Camera's zoom factor, which is the distance between {@link Camera.eye | Camera.eye} and {@link Camera.look | Camera.look}.
   *
   * @param delta Zoom factor increment.
   */
  zoom(delta) {
    const vec = subVec3(this.#state.eye, this.#state.look, tempVec32);
    const lenLook = Math.abs(lenVec3(vec));
    const newLenLook = Math.abs(lenLook + delta);
    if (newLenLook < 0.5) {
      return;
    }
    const dir = normalizeVec3(vec, tempVec3c4);
    this.eye = addVec3(this.#state.look, mulVec3Scalar(dir, newLenLook), tempVec3d2);
  }
  /**
   * Gets the configuration of this Camera.
   */
  toParams() {
    return {
      eye: Array.from(this.#state.eye),
      look: Array.from(this.#state.look),
      up: Array.from(this.#state.up),
      worldAxis: Array.from(this.#state.worldAxis),
      gimbalLock: this.gimbalLock,
      constrainPitch: this.constrainPitch,
      projectionType: this.projectionType,
      perspectiveProjection: this.perspectiveProjection.toParams(),
      orthoProjection: this.orthoProjection.toParams(),
      frustumProjection: this.frustumProjection.toParams(),
      customProjection: this.customProjection.toParams()
    };
  }
  /**
   * Configures this Camera.
   * @param cameraParams
   */
  fromParams(cameraParams) {
    if (cameraParams.eye) {
      this.eye = cameraParams.eye;
    }
    if (cameraParams.look) {
      this.look = cameraParams.look;
    }
    if (cameraParams.up) {
      this.up = cameraParams.up;
    }
    if (cameraParams.constrainPitch !== void 0) {
      this.constrainPitch = cameraParams.constrainPitch;
    }
    if (cameraParams.gimbalLock !== void 0) {
      this.gimbalLock = cameraParams.gimbalLock;
    }
    if (cameraParams.perspectiveProjection) {
      this.perspectiveProjection.fromParams(cameraParams.perspectiveProjection);
    }
    if (cameraParams.orthoProjection) {
      this.orthoProjection.fromParams(cameraParams.orthoProjection);
    }
    if (cameraParams.frustumProjection) {
      this.frustumProjection.fromParams(cameraParams.frustumProjection);
    }
    if (cameraParams.projectionType !== void 0) {
      this.projectionType = cameraParams.projectionType;
    }
    if (cameraParams.worldAxis) {
      this.worldAxis = cameraParams.worldAxis;
    }
  }
  /**
   * @private
   */
  destroy() {
    super.destroy();
    this.onProjectionType.clear();
    this.onViewMatrix.clear();
    this.onProjMatrix.clear();
    this.onWorldAxis.clear();
  }
};

// ../sdk/src/viewer/AmbientLight.ts
var AmbientLight = class extends Component {
  /**
   * The View to which this AmbientLight belongs.
   */
  view;
  #state;
  /**
   * @param view Owner component. When destroyed, the owner will destroy this AmbientLight as well.
   * @param cfg AmbientLight configuration
   */
  constructor(view, cfg = {}) {
    super(view, cfg);
    this.view = view;
    this.#state = {
      type: "ambient",
      color: new Float32Array(cfg.color || [0.7, 0.7, 0.7]),
      intensity: cfg.intensity !== void 0 && cfg.intensity !== null ? cfg.intensity : 1
    };
    this.view.registerLight(this);
  }
  /**
   * Sets the RGB color of this AmbientLight.
   *
   * Default value is ````[0.7, 0.7, 0.7]````.
   *
   * @param color The AmbientLight's RGB color.
   */
  set color(color2) {
    this.#state.color.set(color2);
    this.view.redraw();
  }
  /**
   * Gets the RGB color of this AmbientLight.
   *
   * Default value is ````[0.7, 0.7, 0.7]````.
   */
  get color() {
    return this.#state.color;
  }
  /**
   * Sets the intensity of this AmbientLight.
   *
   * Default value is ````1.0```` for maximum intensity.
   *
   * @param intensity The AmbientLight's intensity.
   */
  set intensity(intensity) {
    this.#state.intensity = intensity !== void 0 ? intensity : 1;
    this.view.redraw();
  }
  /**
   * Gets the intensity of this AmbientLight.
   *
   * Default value is ````1.0```` for maximum intensity.
   *
   * @returns {Number} The AmbientLight's intensity.
   */
  get intensity() {
    return this.#state.intensity;
  }
  /**
   * Configures this AmbientLight.
   * @param ambientLightParams
   */
  fromParams(ambientLightParams) {
    if (ambientLightParams.color) {
      this.color = ambientLightParams.color;
    }
    if (ambientLightParams.intensity !== void 0) {
      this.intensity = ambientLightParams.intensity;
    }
  }
  /**
   * Gets the current configuration of this AmbientLight.
   */
  toParams() {
    return {
      id: this.id,
      color: Array.from(this.color),
      intensity: this.intensity
    };
  }
  /**
   * Destroys this AmbientLight.
   */
  destroy() {
    super.destroy();
    this.view.deregisterLight(this);
  }
};

// ../sdk/src/viewer/DirLight.ts
var DirLight = class extends Component {
  /**
   * The View to which this DirLight belongs.
   */
  view;
  #state;
  /**
   * @param view View that owns this DirLight. When destroyed, the View will destroy this DirLight as well.
   * @param options The DirLight configuration
   * @param [options.id] Optional ID, unique among all components in the parent {@link scene!Scene | Scene}, generated automatically when omitted.
   * @param [options.dir=[1.0, 1.0, 1.0]]  A unit vector indicating the direction that the light is shining,  given in either World or View space, depending on the value of the ````space```` parameter.
   * @param [options.color=[0.7, 0.7, 0.8 ]] The color of this DirLight.
   * @param [options.intensity=1.0] The intensity of this DirLight, as a factor in range ````[0..1]````.
   * @param [options.space="view"] The coordinate system the DirLight is defined in - ````"view"```` or ````"space"````.
   */
  constructor(view, options = {}) {
    super(view, options);
    this.view = view;
    this.#state = {
      type: "dir",
      dir: new Float32Array(options.dir || [1, 1, 1]),
      color: new Float32Array(options.color || [0.7, 0.7, 0.8]),
      intensity: options.intensity !== void 0 && options.intensity !== null ? options.intensity : 1,
      space: options.space || "view"
    };
    this.view.registerLight(this);
  }
  /**
   * Gets the direction in which the DirLight is shining.
   *
   * Default value is ````[1.0, 1.0, 1.0]````.
   *
   * @returns {Number[]} The direction vector.
   */
  get dir() {
    return this.#state.dir;
  }
  /**
   * The coordinate system the DirLight is defined in - ````"view"```` or ````"space"````.
   */
  get space() {
    return this.#state.space;
  }
  /**
   * Sets the direction in which the DirLight is shining.
   *
   * Default value is ````[1.0, 1.0, 1.0]````.
   *
   * @param value The direction vector.
   */
  set dir(value) {
    this.#state.dir.set(value);
    this.view.redraw();
  }
  /**
   * Gets the RGB color of this DirLight.
   *
   * Default value is ````[0.7, 0.7, 0.8]````.
   *
   * @returns {Number[]} The DirLight's RGB color.
   */
  get color() {
    return this.#state.color;
  }
  /**
   * Sets the RGB color of this DirLight.
   *
   * Default value is ````[0.7, 0.7, 0.8]````.
   *
   * @param color The DirLight's RGB color.
   */
  set color(color2) {
    this.#state.color.set(color2);
    this.view.redraw();
  }
  /**
   * Gets the intensity of this DirLight.
   *
   * Default value is ````1.0```` for maximum intensity.
   *
   * @returns {Number} The DirLight's intensity.
   */
  get intensity() {
    return this.#state.intensity;
  }
  /**
   * Sets the intensity of this DirLight.
   *
   * Default intensity is ````1.0```` for maximum intensity.
   *
   * @param intensity The DirLight's intensity
   */
  set intensity(intensity) {
    this.#state.intensity = intensity;
    this.view.redraw();
  }
  /**
   * Configures this DirLight.
   *
   * Ignores {@link DirLightParams.space | DirLightParams.space}, because
   * {@link DirLight.space | DirLight.space} is not dynamically updatable.
   *
   * @param dirLightParams
   */
  fromParams(dirLightParams) {
    if (dirLightParams.dir) {
      this.dir = dirLightParams.dir;
    }
    if (dirLightParams.color) {
      this.color = dirLightParams.color;
    }
    if (dirLightParams.intensity !== void 0) {
      this.intensity = dirLightParams.intensity;
    }
  }
  /**
   * Gets this DirLight's current configuration.
   */
  toParams() {
    return {
      id: this.id,
      dir: Array.from(this.dir),
      color: Array.from(this.color),
      intensity: this.intensity,
      space: this.space
    };
  }
  /**
   * Destroys this DirLight.
   */
  destroy() {
    super.destroy();
    this.view.deregisterLight(this);
    this.view.redraw();
  }
};

// ../sdk/src/viewer/SnapshotResult.ts
var SnapshotResult = class {
  constructor() {
    this.reset();
  }
  /**
   * @private
   */
  reset() {
  }
};

// ../sdk/src/viewer/ResolutionScale.ts
var ResolutionScale = class extends Component {
  /**
   * The View to which this ResolutionScale belongs.
   */
  view;
  /**
   * @private
   */
  #state;
  /**
   * @private
   */
  constructor(view, options = {}) {
    super(view, options);
    this.view = view;
    this.#state = {
      renderModes: options.renderModes || [FastRender],
      resolutionScale: options.resolutionScale || 1
    };
  }
  /**
   * Sets which rendering modes in which to apply ResolutionScale.
   *
   * Default value is [{@link constants!FastRender | FastRender}].
   */
  set renderModes(value) {
    this.#state.renderModes = value;
    this.view.redraw();
  }
  /**
   * Gets which rendering modes in which to apply ResolutionScale.
   *
   * Default value is [{@link constants!FastRender | FastRender}].
   */
  get renderModes() {
    return this.#state.renderModes;
  }
  /**
   * Sets the scale when ResolutionScale is applied.
   *
   * Default is ````1.0````.
   */
  set resolutionScale(value) {
    if (this.#state.resolutionScale === value) {
      return;
    }
    this.#state.resolutionScale = value;
    this.view.redraw();
  }
  /**
   * Gets the scale when ResolutionScale is applied.
   *
   * Default is ````1.0````.
   */
  get resolutionScale() {
    return this.#state.resolutionScale;
  }
  /**
   * Gets if resolution scaling is currently applied.
   *
   * This is `true` when {@link View.renderMode | View.renderMode} is
   * in {@link ResolutionScale.renderModes | ResolutionScale.renderModes}.
   */
  get applied() {
    for (let i = 0, len = this.#state.renderModes.length; i < len; i++) {
      if (this.view.renderMode === this.#state.renderModes[i]) {
        return true;
      }
    }
    return false;
  }
  /**
   * Configures this ResolutionScale.
   *
   * @param resolutionScaleParams
   */
  fromParams(resolutionScaleParams) {
    if (resolutionScaleParams.renderModes !== void 0) {
      this.renderModes = resolutionScaleParams.renderModes;
    }
    if (resolutionScaleParams.resolutionScale !== void 0) {
      this.resolutionScale = resolutionScaleParams.resolutionScale;
    }
  }
  /**
   * Gets the current configuration of this ResolutionScale.
   */
  toParams() {
    return {
      renderModes: this.renderModes,
      resolutionScale: this.resolutionScale
    };
  }
  /**
   * @private
   */
  destroy() {
    super.destroy();
  }
};

// ../sdk/src/viewer/View.ts
var View = class extends Component {
  /**
   * The index of this View in {@link Viewer.viewList}.
   * @private
   */
  viewIndex;
  /**
   * Manages the Camera for this View.
   */
  camera;
  /**
   * The HTML canvas.
   */
  htmlElement;
  /**
   * Indicates if this View is transparent.
   */
  transparent;
  /**
   * Boundary of the canvas in absolute browser window coordinates.
   * Format is ````[xmin, ymin, xwidth, ywidth]````.
   */
  boundary;
  /**
   * Configures Scalable Ambient Obscurance (SAO) for this View.
   */
  sao;
  /**
   * Configures when textures are rendered for this View.
   */
  texturing;
  /**
   * Configures the appearance of edges belonging to {@link ViewObject} in this View.
   */
  edges;
  /**
   * Manages measurement units, origin and scale for this View.
   */
  metrics;
  /**
   * Configures the X-rayed appearance of {@link ViewObject | ViewObjects} in this View.
   */
  xrayMaterial;
  /**
   * Configures the highlighted appearance of {@link ViewObject | ViewObjects} in this View.
   */
  highlightMaterial;
  /**
   * Configures the appearance of {@link ViewObject | ViewObjects} in this View.
   */
  selectedMaterial;
  /**
   * Configures resolution scaling for this View.
   */
  resolutionScale;
  /**
   * Configures the appearance of point primitives belonging to {@link ViewObject | ViewObjects} in this View .
   */
  pointsMaterial;
  /**
   * Configures the appearance of lines belonging to {@link ViewObject | ViewObjects} in this View.
   */
  linesMaterial;
  /**
   * Map of the all {@link ViewObject | ViewObjects} in this View.
   *
   * Each {@link ViewObject} is mapped here by {@link ViewObject.id}.
   *
   * The View automatically ensures that there is a {@link ViewObject} here for
   * each {@link RendererObject} in the {@link Viewer | Viewer}
   */
  objects;
  /**
   * Map of the currently visible {@link ViewObject | ViewObjects} in this View.
   *
   * A ViewObject is visible when {@link ViewObject.visible} is true.
   *
   * Each {@link ViewObject} is mapped here by {@link ViewObject.id}.
   */
  visibleObjects;
  /**
   * Map of currently x-rayed {@link ViewObject | ViewObjects} in this View.
   *
   * A ViewObject is x-rayed when {@link ViewObject.xrayed} is true.
   *
   * Each {@link ViewObject} is mapped here by {@link ViewObject.id}.
   */
  xrayedObjects;
  /**
   * Map of currently highlighted {@link ViewObject | ViewObjects} in this View.
   *
   * A ViewObject is highlighted when {@link ViewObject.highlighted} is true.
   *
   * Each {@link ViewObject} is mapped here by {@link ViewObject.id}.
   */
  highlightedObjects;
  /**
   * Map of currently selected {@link ViewObject | ViewObjects} in this View.
   *
   * A ViewObject is selected when {@link ViewObject.selected} is true.
   *
   * Each {@link ViewObject} is mapped here by {@link ViewObject.id}.
   */
  selectedObjects;
  /**
   * Map of currently colorized {@link ViewObject | ViewObjects} in this View.
   *
   * Each {@link ViewObject} is mapped here by {@link ViewObject.id}.
   */
  colorizedObjects;
  /**
   * Map of {@link ViewObject | ViewObjects} in this View whose opacity has been updated.
   *
   * Each {@link ViewObject} is mapped here by {@link ViewObject.id}.
   */
  opacityObjects;
  /**
   * Map of {@link SectionPlane}s in this View.
   *
   * Each {@link SectionPlane} is mapped here by {@link SectionPlane.id}.
   */
  sectionPlanes;
  /**
   * List of {@link SectionPlane}s in this View.
   */
  sectionPlanesList = [];
  /**
   * Map of light sources in this View.
   */
  lights;
  /**
   * List of light sources in this View.
   */
  lightsList = [];
  gammaOutput;
  /**
   * Map of the all {@link ViewLayer}s in this View.
   *
   * Each {@link ViewLayer} is mapped here by {@link ViewLayer.id}.
   */
  layers;
  /**
   * Emits an event each time the canvas boundary changes.
   *
   * @event
   */
  onBoundary;
  /**
   * Emits an event each time a {@link ViewObject} is created in this View.
   *
   * @event
   */
  onObjectCreated;
  /**
   * Emits an event each time a {@link ViewObject} is destroyed in this View.
   *
   * @event
   */
  onObjectDestroyed;
  /**
   * Emits an event each time the visibility of a {@link ViewObject} changes in this View.
   *
   * ViewObjects are shown and hidden with {@link View.setObjectsVisible}, {@link ViewLayer.setObjectsVisible} or {@link ViewObject.visible}.
   *
   * @event
   */
  onObjectVisibility;
  /**
   * Emits an event each time the X-ray state of a {@link ViewObject} changes in this View.
   *
   * ViewObjects are X-rayed with {@link View.setObjectsXRayed}, {@link ViewLayer.setObjectsXRayed} or {@link ViewObject.xrayed}.
   *
   * @event
   */
  onObjectXRayed;
  /**
   * Emits an event each time a {@link ViewLayer} is created in this View.
   *
   * Layers are created explicitly with {@link View.createLayer}, or implicitly with {@link scene!SceneModel.createObject | SceneModel.createObject} and {@link scene!SceneObjectParams.layerId | SceneObjectParams.layerId}.
   *
   * @event
   */
  onLayerCreated;
  /**
   * Emits an event each time a {@link ViewLayer} in this View is destroyed.
   *
   * ViewLayers are destroyed explicitly with {@link ViewLayer.destroy}, or implicitly when they become empty and {@link View.autoLayers} is false.
   *
   * @event
   */
  onLayerDestroyed;
  /**
   * Emits an event each time a {@link SectionPlane} is created in this View.
   *
   * @event
   */
  onSectionPlaneCreated;
  /**
   * Emits an event each time a {@link SectionPlane} in this View is destroyed.
   *
   * @event
   */
  onSectionPlaneDestroyed;
  /**
   * Emits an event each time a snapshot is initiated with {@link View.getSnapshot}.
   *
   * @event
   */
  onSnapshotStarted;
  /**
   * Emits an event each time a snapshot is completed with {@link View.getSnapshot}.
   *
   * @event
   */
  onSnapshotFinished;
  #onTick;
  #renderMode = QualityRender;
  #autoLayers;
  #backgroundColor;
  #backgroundColorFromAmbientLight;
  #numObjects;
  #objectIds;
  #numVisibleObjects;
  #visibleObjectIds;
  #numXRayedObjects;
  #xrayedObjectIds;
  #numHighlightedObjects;
  #highlightedObjectIds;
  #numSelectedObjects;
  #selectedObjectIds;
  #numColorizedObjects;
  #colorizedObjectIds;
  #numOpacityObjects;
  #opacityObjectIds;
  #lightsHash = null;
  #sectionPlanesHash = null;
  #snapshotBegun;
  #autoCanvas;
  /**
   * @private
   */
  constructor(viewer, viewParams) {
    super(null, viewParams);
    this.viewer = viewer;
    let canvas2;
    if (viewParams.htmlElement || viewParams.elementId) {
      canvas2 = // Canvas is actually a generic HTMLElement, but we think of it as a canvas
      viewParams.htmlElement || document.getElementById(viewParams.elementId);
      if (!(canvas2 instanceof HTMLElement)) {
        console.error("Mandatory View config expected: valid HTMLElement");
      }
      this.#autoCanvas = false;
    }
    if (!canvas2) {
      canvas2 = document.createElement("canvas");
      canvas2.style.position = "absolute";
      canvas2.style.zIndex = "100000";
      canvas2.style.width = "600px";
      canvas2.style.height = "500px";
      canvas2.style.position = "absolute";
      canvas2.style.background = "white";
      canvas2.style.border = "0";
      document.body.appendChild(canvas2);
      this.#autoCanvas = true;
    }
    this.htmlElement = canvas2;
    this.viewIndex = 0;
    this.objects = {};
    this.visibleObjects = {};
    this.xrayedObjects = {};
    this.highlightedObjects = {};
    this.selectedObjects = {};
    this.colorizedObjects = {};
    this.opacityObjects = {};
    this.sectionPlanes = {};
    this.sectionPlanesList = [];
    this.lights = {};
    this.lightsList = [];
    this.layers = {};
    this.#numObjects = 0;
    this.#objectIds = null;
    this.#numVisibleObjects = 0;
    this.#visibleObjectIds = null;
    this.#numXRayedObjects = 0;
    this.#xrayedObjectIds = null;
    this.#numHighlightedObjects = 0;
    this.#highlightedObjectIds = null;
    this.#numSelectedObjects = 0;
    this.#selectedObjectIds = null;
    this.#numColorizedObjects = 0;
    this.#colorizedObjectIds = null;
    this.#numOpacityObjects = 0;
    this.#opacityObjectIds = null;
    this.gammaOutput = true;
    this.#snapshotBegun = false;
    this.#sectionPlanesHash = null;
    this.#lightsHash = null;
    this.onBoundary = new EventEmitter(
      new import_strongly_typed_events15.EventDispatcher()
    );
    this.#backgroundColor = createVec3([
      viewParams.backgroundColor ? viewParams.backgroundColor[0] : 1,
      viewParams.backgroundColor ? viewParams.backgroundColor[1] : 1,
      viewParams.backgroundColor ? viewParams.backgroundColor[2] : 1
    ]);
    this.#backgroundColorFromAmbientLight = !!viewParams.backgroundColorFromAmbientLight;
    this.transparent = !!viewParams.transparent;
    this.boundary = [
      this.htmlElement.offsetLeft,
      this.htmlElement.offsetTop,
      this.htmlElement.clientWidth,
      this.htmlElement.clientHeight
    ];
    let lastWindowWidth = 0;
    let lastWindowHeight = 0;
    let lastViewWidth = 0;
    let lastViewHeight = 0;
    let lastViewOffsetLeft = 0;
    let lastViewOffsetTop = 0;
    let lastParent = null;
    let lastResolutionScale = null;
    this.#onTick = this.viewer.onTick.subscribe(() => {
      const htmlElement = this.htmlElement;
      const newResolutionScale = this.resolutionScale.resolutionScale !== lastResolutionScale;
      const newWindowSize = window.innerWidth !== lastWindowWidth || window.innerHeight !== lastWindowHeight;
      const newViewSize = htmlElement.clientWidth !== lastViewWidth || htmlElement.clientHeight !== lastViewHeight;
      const newViewPos = htmlElement.offsetLeft !== lastViewOffsetLeft || htmlElement.offsetTop !== lastViewOffsetTop;
      const parent = htmlElement.parentElement;
      const newParent = parent !== lastParent;
      if (newResolutionScale || newWindowSize || newViewSize || newViewPos || newParent) {
        if (newResolutionScale || newViewSize || newViewPos) {
          const newWidth = htmlElement.clientWidth;
          const newHeight = htmlElement.clientHeight;
          if (newResolutionScale || newViewSize) {
          }
          const boundary = this.boundary;
          boundary[0] = htmlElement.offsetLeft;
          boundary[1] = htmlElement.offsetTop;
          boundary[2] = newWidth;
          boundary[3] = newHeight;
          if (!newResolutionScale || newViewSize) {
            this.onBoundary.dispatch(this, boundary);
          }
          lastViewWidth = newWidth;
          lastViewHeight = newHeight;
        }
        if (newResolutionScale) {
        }
        if (newWindowSize) {
          lastWindowWidth = window.innerWidth;
          lastWindowHeight = window.innerHeight;
        }
        if (newViewPos) {
          lastViewOffsetLeft = htmlElement.offsetLeft;
          lastViewOffsetTop = htmlElement.offsetTop;
        }
        lastParent = parent;
      }
    });
    this.camera = new Camera(this);
    this.sao = new SAO(this, viewParams.sao || {});
    this.texturing = new Texturing(this, {});
    this.metrics = new Metrics(this, {
      units: viewParams.units,
      scale: viewParams.scale,
      origin: viewParams.origin
    });
    this.xrayMaterial = new EmphasisMaterial(this, viewParams.xrayMaterial || {
      fill: true,
      fillColor: [0.9, 0.7, 0.6],
      fillAlpha: 0.4,
      edges: true,
      edgeColor: [0.5, 0.4, 0.4],
      edgeAlpha: 1,
      edgeWidth: 1
    });
    this.highlightMaterial = new EmphasisMaterial(this, viewParams.highlightMaterial || {
      fill: true,
      fillColor: [1, 1, 0],
      fillAlpha: 0.5,
      edges: true,
      edgeColor: [0.5, 0.4, 0.4],
      edgeAlpha: 1,
      edgeWidth: 1
    });
    this.selectedMaterial = new EmphasisMaterial(this, viewParams.selectedMaterial || {
      fill: true,
      fillColor: [0, 1, 0],
      fillAlpha: 0.5,
      edges: true,
      edgeColor: [0.4, 0.5, 0.4],
      edgeAlpha: 1,
      edgeWidth: 1
    });
    this.edges = new Edges(this, viewParams.edges || {
      edgeColor: [0, 0, 0],
      edgeAlpha: 1,
      edgeWidth: 1,
      renderModes: [QualityRender]
    });
    this.resolutionScale = new ResolutionScale(this, viewParams.resolutionScale || {
      renderModes: [FastRender],
      resolutionScale: 1
    });
    this.pointsMaterial = new PointsMaterial(this, viewParams.pointsMaterial || {
      pointSize: 1,
      roundPoints: true,
      perspectivePoints: true,
      minPerspectivePointSize: 1,
      maxPerspectivePointSize: 6,
      filterIntensity: false,
      minIntensity: 0,
      maxIntensity: 1
    });
    this.linesMaterial = new LinesMaterial(this, {
      lineWidth: 1
    });
    this.lights = {};
    this.#autoLayers = viewParams.autoLayers !== false;
    this.onObjectCreated = new EventEmitter(
      new import_strongly_typed_events15.EventDispatcher()
    );
    this.onObjectDestroyed = new EventEmitter(
      new import_strongly_typed_events15.EventDispatcher()
    );
    this.onObjectVisibility = new EventEmitter(
      new import_strongly_typed_events15.EventDispatcher()
    );
    this.onObjectXRayed = new EventEmitter(
      new import_strongly_typed_events15.EventDispatcher()
    );
    this.onLayerCreated = new EventEmitter(
      new import_strongly_typed_events15.EventDispatcher()
    );
    this.onLayerDestroyed = new EventEmitter(
      new import_strongly_typed_events15.EventDispatcher()
    );
    this.onSectionPlaneCreated = new EventEmitter(
      new import_strongly_typed_events15.EventDispatcher()
    );
    this.onSectionPlaneDestroyed = new EventEmitter(
      new import_strongly_typed_events15.EventDispatcher()
    );
    this.onSnapshotStarted = new EventEmitter(
      new import_strongly_typed_events15.EventDispatcher()
    );
    this.onSnapshotFinished = new EventEmitter(
      new import_strongly_typed_events15.EventDispatcher()
    );
    new AmbientLight(this, {
      color: [1, 1, 1],
      intensity: 1
    });
    new DirLight(this, {
      dir: [0.8, -0.5, -0.5],
      color: [0.8, 0.8, 1],
      intensity: 1,
      space: "world"
    });
    new DirLight(this, {
      dir: [-0.8, -1, 0.5],
      color: [1, 1, 0.9],
      intensity: 1,
      space: "world"
    });
    new DirLight(this, {
      dir: [-0.8, -1, -0.5],
      color: [0, 0, 1],
      intensity: 1,
      space: "world"
    });
  }
  /**
   * @private
   */
  initViewObjects() {
    this.#createViewObjectsForScene();
    this.viewer.scene.onModelCreated.subscribe(
      (scene, sceneModel) => {
        this.#createViewObjectsForSceneModel(sceneModel);
      }
    );
    this.viewer.scene.onModelDestroyed.subscribe(
      (scene, sceneModel) => {
        this.#destroyViewObjectsForSceneModel(sceneModel);
      }
    );
  }
  #createViewObjectsForScene() {
    for (const id in this.viewer.scene.models) {
      this.#createViewObjectsForSceneModel(this.viewer.scene.models[id]);
    }
  }
  #createViewObjectsForSceneModel(sceneModel) {
    const sceneObjects = sceneModel.objects;
    for (let id in sceneObjects) {
      if (!this.objects[id]) {
        const sceneObject = sceneObjects[id];
        const layerId = sceneObject.layerId || "default";
        let viewLayer = this.layers[layerId];
        if (!viewLayer) {
          if (!this.#autoLayers) {
            continue;
          }
          viewLayer = new ViewLayer({
            id: layerId,
            view: this,
            viewer: this.viewer
          });
          this.layers[layerId] = viewLayer;
          viewLayer.onDestroyed.one(() => {
            delete this.layers[viewLayer.id];
            this.onLayerDestroyed.dispatch(this, viewLayer);
          });
          this.onLayerCreated.dispatch(this, viewLayer);
        }
        const rendererObjects = this.viewer.renderer.rendererObjects;
        const rendererObject = rendererObjects[id];
        const viewObject = new ViewObject(viewLayer, sceneObject, rendererObject);
        viewLayer.registerViewObject(viewObject);
        this.registerViewObject(viewObject);
        this.onObjectCreated.dispatch(this, viewObject);
      }
    }
  }
  /**
   * Sets wether this View will automatically create {@link ViewLayer | ViewLayers} on-demand
   * as {@link RendererObject | ViewerObjects} are created.
   *
   * When ````true```` (default), the View will automatically create {@link ViewLayer | ViewLayers} as needed for each new
   * {@link RendererObject.layerId} encountered, including a "default" ViewLayer for ViewerObjects that have no
   * layerId. This "default" ViewLayer ensures that a ViewObject is created in the View for every SceneObject that is created.
   *
   * If you set this ````false````, however, then the View will only create {@link ViewObject | ViewObjects} for
   * {@link scene!SceneObject | SceneObjects} that have a {@link scene!SceneObject.layerId} that matches the ID of a
   * {@link ViewLayer} that you have explicitly created previously with {@link View.createLayer}.
   *
   * Setting this parameter false enables Views to contain only the ViewObjects that they actually need to show, i.e. to represent only
   * ViewerObjects that they need to view. This enables a View to avoid wastefully creating and maintaining ViewObjects for ViewerObjects
   * that it never needs to show.
   *
   * Default value is `true``.
   *
   * @param autoLayers The new value for atuoLayers
   */
  set autoLayers(autoLayers) {
    if (this.#autoLayers === autoLayers) {
      return;
    }
    this.#autoLayers = autoLayers;
    if (autoLayers) {
      this.#createViewObjectsForScene();
    }
  }
  /**
   * Gets wether this View will automatically create {@link ViewLayer | ViewLayers} on-demand
   * as {@link RendererObject | ViewerObjects} are created.
   */
  get autoLayers() {
    return this.#autoLayers;
  }
  /**
   * Sets which rendering mode this View is in.
   *
   * Default value is {@link constants!QualityRender | QualityRender}.
   *
   * Setting a View's rendering mode will activate whatever effects (eg. SAO, edges, canas scaling) are configured to
   * be active in that mode, while deactivating all other effects.
   */
  set renderMode(renderMode) {
    this.#renderMode = renderMode;
    this.redraw();
  }
  /**
   * Gets which rendering mode this View is in.
   *
   * Default value is {@link constants!QualityRender | QualityRender}.
   */
  get renderMode() {
    return this.#renderMode;
  }
  /**
   *
   */
  get aabb() {
    return this.viewer.scene.aabb;
  }
  /**
   * Gets the canvas clear color.
   *
   * Default value is ````[1, 1, 1]````.
   */
  get backgroundColor() {
    return this.#backgroundColor;
  }
  /**
   * Sets the canvas clear color.
   *
   * Default value is ````[1, 1, 1]````.
   */
  set backgroundColor(value) {
    if (value) {
      this.#backgroundColor[0] = value[0];
      this.#backgroundColor[1] = value[1];
      this.#backgroundColor[2] = value[2];
    } else {
      this.#backgroundColor[0] = 1;
      this.#backgroundColor[1] = 1;
      this.#backgroundColor[2] = 1;
    }
    this.redraw();
  }
  /**
   * Gets whether the canvas clear color will be derived from {@link AmbientLight} or {@link View#backgroundColor}
   * when {@link View#transparent} is ```true```.
   *
   * When {@link View#transparent} is ```true``` and this is ````true````, then the canvas clear color will
   * be taken from the ambient light color.
   *
   * When {@link View#transparent} is ```true``` and this is ````false````, then the canvas clear color will
   * be taken from {@link View#backgroundColor}.
   *
   * Default value is ````true````.
   */
  get backgroundColorFromAmbientLight() {
    return this.#backgroundColorFromAmbientLight;
  }
  /**
   * Sets if the canvas background color is derived from an {@link AmbientLight}.
   *
   * This only has effect when the canvas is not transparent. When not enabled, the background color
   * will be the canvas element's HTML/CSS background color.
   *
   * Default value is ````true````.
   */
  set backgroundColorFromAmbientLight(backgroundColorFromAmbientLight) {
    this.#backgroundColorFromAmbientLight = backgroundColorFromAmbientLight !== false;
  }
  /**
   * Gets the gamma factor.
   */
  get gammaFactor() {
    return 1;
  }
  /**
   * Gets the number of {@link ViewObject | ViewObjects} in this View.
   */
  get numObjects() {
    return this.#numObjects;
  }
  /**
   * Gets the IDs of the {@link ViewObject | ViewObjects} in this View.
   */
  get objectIds() {
    if (!this.#objectIds) {
      this.#objectIds = Object.keys(this.objects);
    }
    return this.#objectIds;
  }
  /**
   * Gets the number of visible {@link ViewObject | ViewObjects} in this View.
   */
  get numVisibleObjects() {
    return this.#numVisibleObjects;
  }
  /**
   * Gets the IDs of the visible {@link ViewObject | ViewObjects} in this View.
   */
  get visibleObjectIds() {
    if (!this.#visibleObjectIds) {
      this.#visibleObjectIds = Object.keys(this.visibleObjects);
    }
    return this.#visibleObjectIds;
  }
  /**
   * Gets the number of X-rayed {@link ViewObject | ViewObjects} in this View.
   */
  get numXRayedObjects() {
    return this.#numXRayedObjects;
  }
  /**
   * Gets the IDs of the X-rayed {@link ViewObject | ViewObjects} in this View.
   */
  get xrayedObjectIds() {
    if (!this.#xrayedObjectIds) {
      this.#xrayedObjectIds = Object.keys(this.xrayedObjects);
    }
    return this.#xrayedObjectIds;
  }
  /**
   * Gets the number of highlighted {@link ViewObject | ViewObjects} in this View.
   */
  get numHighlightedObjects() {
    return this.#numHighlightedObjects;
  }
  /**
   * Gets the IDs of the highlighted {@link ViewObject | ViewObjects} in this View.
   */
  get highlightedObjectIds() {
    if (!this.#highlightedObjectIds) {
      this.#highlightedObjectIds = Object.keys(this.highlightedObjects);
    }
    return this.#highlightedObjectIds;
  }
  /**
   * Gets the number of selected {@link ViewObject | ViewObjects} in this View.
   */
  get numSelectedObjects() {
    return this.#numSelectedObjects;
  }
  /**
   * Gets the IDs of the selected {@link ViewObject | ViewObjects} in this View.
   */
  get selectedObjectIds() {
    if (!this.#selectedObjectIds) {
      this.#selectedObjectIds = Object.keys(this.selectedObjects);
    }
    return this.#selectedObjectIds;
  }
  /**
   * Gets the number of colorized {@link ViewObject | ViewObjects} in this View.
   */
  get numColorizedObjects() {
    return this.#numColorizedObjects;
  }
  /**
   * Gets the IDs of the colorized {@link ViewObject | ViewObjects} in this View.
   */
  get colorizedObjectIds() {
    if (!this.#colorizedObjectIds) {
      this.#colorizedObjectIds = Object.keys(this.colorizedObjects);
    }
    return this.#colorizedObjectIds;
  }
  /**
   * Gets the IDs of the {@link ViewObject | ViewObjects} in this View that have updated opacities.
   */
  get opacityObjectIds() {
    if (!this.#opacityObjectIds) {
      this.#opacityObjectIds = Object.keys(this.opacityObjects);
    }
    return this.#opacityObjectIds;
  }
  /**
   * Gets the number of {@link ViewObject | ViewObjects} in this View that have updated opacities.
   */
  get numOpacityObjects() {
    return this.#numOpacityObjects;
  }
  /**
   * @private
   */
  registerViewObject(viewObject) {
    this.objects[viewObject.id] = viewObject;
    this.#numObjects++;
    this.#objectIds = null;
  }
  /**
   * @private
   */
  deregisterViewObject(viewObject) {
    delete this.objects[viewObject.id];
    delete this.visibleObjects[viewObject.id];
    delete this.xrayedObjects[viewObject.id];
    delete this.highlightedObjects[viewObject.id];
    delete this.selectedObjects[viewObject.id];
    delete this.colorizedObjects[viewObject.id];
    delete this.opacityObjects[viewObject.id];
    this.#numObjects--;
    this.#objectIds = null;
  }
  /**
   * @private
   */
  objectVisibilityUpdated(viewObject, visible, notify = true) {
    if (visible) {
      this.visibleObjects[viewObject.id] = viewObject;
      this.#numVisibleObjects++;
    } else {
      delete this.visibleObjects[viewObject.id];
      this.#numVisibleObjects--;
    }
    this.#visibleObjectIds = null;
    if (notify) {
      this.onObjectVisibility.dispatch(this, viewObject);
    }
  }
  /**
   * @private
   */
  objectXRayedUpdated(viewObject, xrayed, notify = true) {
    if (xrayed) {
      this.xrayedObjects[viewObject.id] = viewObject;
      this.#numXRayedObjects++;
    } else {
      delete this.xrayedObjects[viewObject.id];
      this.#numXRayedObjects--;
    }
    this.#xrayedObjectIds = null;
    if (notify) {
      this.onObjectXRayed.dispatch(this, viewObject);
    }
  }
  /**
   * @private
   */
  objectHighlightedUpdated(viewObject, highlighted) {
    if (highlighted) {
      this.highlightedObjects[viewObject.id] = viewObject;
      this.#numHighlightedObjects++;
    } else {
      delete this.highlightedObjects[viewObject.id];
      this.#numHighlightedObjects--;
    }
    this.#highlightedObjectIds = null;
  }
  /**
   * @private
   */
  objectSelectedUpdated(viewObject, selected) {
    if (selected) {
      this.selectedObjects[viewObject.id] = viewObject;
      this.#numSelectedObjects++;
    } else {
      delete this.selectedObjects[viewObject.id];
      this.#numSelectedObjects--;
    }
    this.#selectedObjectIds = null;
  }
  /**
   * @private
   */
  objectColorizeUpdated(viewObject, colorized) {
    if (colorized) {
      this.colorizedObjects[viewObject.id] = viewObject;
      this.#numColorizedObjects++;
    } else {
      delete this.colorizedObjects[viewObject.id];
      this.#numColorizedObjects--;
    }
    this.#colorizedObjectIds = null;
  }
  /**
   * @private
   */
  objectOpacityUpdated(viewObject, opacityUpdated) {
    if (opacityUpdated) {
      this.opacityObjects[viewObject.id] = viewObject;
      this.#numOpacityObjects++;
    } else {
      delete this.opacityObjects[viewObject.id];
      this.#numOpacityObjects--;
    }
    this.#opacityObjectIds = null;
  }
  /**
   * Creates a {@link SectionPlane} in this View.
   *
   * @param sectionPlaneParams
   */
  createSectionPlane(sectionPlaneParams) {
    let id = sectionPlaneParams.id || createUUID2();
    if (this.sectionPlanes[id]) {
      this.error(
        `SectionPlane with ID "${id}" already exists - will randomly-generate ID`
      );
      id = createUUID2();
    }
    const sectionPlane = new SectionPlane(this, sectionPlaneParams);
    this.#registerSectionPlane(sectionPlane);
    sectionPlane.onDestroyed.one(() => {
      this.#deregisterSectionPlane(sectionPlane);
    });
    return sectionPlane;
  }
  /**
   * Destroys the {@link SectionPlane | SectionPlanes} in this View.
   */
  clearSectionPlanes() {
    const objectIds = Object.keys(this.sectionPlanes);
    for (let i = 0, len = objectIds.length; i < len; i++) {
      this.sectionPlanes[objectIds[i]].destroy();
    }
    this.sectionPlanesList.length = 0;
    this.#sectionPlanesHash = null;
  }
  /**
   * @private
   */
  getSectionPlanesHash() {
    if (this.#sectionPlanesHash) {
      return this.#sectionPlanesHash;
    }
    if (this.sectionPlanesList.length === 0) {
      return this.#sectionPlanesHash = ";";
    }
    let sectionPlane;
    const hashParts = [];
    for (let i = 0, len = this.sectionPlanesList.length; i < len; i++) {
      sectionPlane = this.sectionPlanesList[i];
      hashParts.push("cp");
    }
    hashParts.push(";");
    this.#sectionPlanesHash = hashParts.join("");
    return this.#sectionPlanesHash;
  }
  /**
   * @private
   */
  registerLight(light) {
    this.lightsList.push(light);
    this.lights[light.id] = light;
    this.#lightsHash = null;
    this.rebuild();
  }
  /**
   * @private
   */
  deregisterLight(light) {
    for (let i = 0, len = this.lightsList.length; i < len; i++) {
      if (this.lightsList[i].id === light.id) {
        this.lightsList.splice(i, 1);
        this.#lightsHash = null;
        delete this.lights[light.id];
        this.rebuild();
        return;
      }
    }
  }
  /**
   * Destroys the {@link DirLight | DirLights}, {@link PointLight | PointLights} and {@link AmbientLight | AmbientLights} in this View.
   */
  clearLights() {
    const lightIds = Object.keys(this.lights);
    for (let i = 0, len = lightIds.length; i < len; i++) {
      this.lights[lightIds[i]].destroy();
    }
  }
  /**
   * @private
   */
  getLightsHash() {
    if (this.#lightsHash) {
      return this.#lightsHash;
    }
    if (this.lightsList.length === 0) {
      return this.#lightsHash = ";";
    }
    const hashParts = [];
    const lights = this.lightsList;
    for (let i = 0, len = lights.length; i < len; i++) {
      const light = lights[i];
      hashParts.push("/");
      hashParts.push(light instanceof DirLight ? "d" : "p");
      hashParts.push(light.space === "world" ? "w" : "v");
      if (light.castsShadow) {
        hashParts.push("sh");
      }
    }
    hashParts.push(";");
    this.#lightsHash = hashParts.join("");
    return this.#lightsHash;
  }
  /**
   * @private
   */
  rebuild() {
    this.viewer.renderer.setNeedsRebuild(this.viewIndex);
  }
  /**
   * @private
   */
  redraw() {
    this.viewer.renderer.setImageDirty(this.viewIndex);
  }
  /**
   * @private
   */
  getAmbientColorAndIntensity() {
    return [0.5, 0.5, 0.5, 1];
  }
  /**
   * Updates the visibility of the given {@link ViewObject | ViewObjects} in this View.
   *
   * - Updates {@link ViewObject.visible} on the Objects with the given IDs.
   * - Updates {@link View.visibleObjects} and {@link View.numVisibleObjects}.
   *
   * @param {string[]} objectIds Array of {@link ViewObject.id} values.
   * @param visible Whether or not to cull.
   * @returns True if any {@link ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */
  setObjectsVisible(objectIds, visible) {
    return this.withObjects(objectIds, (viewObject) => {
      const changed = viewObject.visible !== visible;
      viewObject.visible = visible;
      return changed;
    });
  }
  /**
   * Updates the collidability of the given {@link ViewObject | ViewObjects} in this View.
   *
   * Updates {@link ViewObject.collidable} on the Objects with the given IDs.
   *
   * @param {string[]} objectIds Array of {@link ViewObject.id} values.
   * @param collidable Whether or not to cull.
   * @returns True if any {@link ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */
  setObjectsCollidable(objectIds, collidable) {
    return this.withObjects(objectIds, (viewObject) => {
      const changed = viewObject.collidable !== collidable;
      viewObject.collidable = collidable;
      return changed;
    });
  }
  /**
   * Updates the culled status of the given {@link ViewObject | ViewObjects} in this View.
   *
   * Updates {@link ViewObject.culled} on the Objects with the given IDs.
   *
   * @param {string[]} objectIds Array of {@link ViewObject.id} values.
   * @param culled Whether or not to cull.
   * @returns True if any {@link ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */
  setObjectsCulled(objectIds, culled) {
    return this.withObjects(objectIds, (viewObject) => {
      const changed = viewObject.culled !== culled;
      viewObject.culled = culled;
      return changed;
    });
  }
  /**
   * Selects or deselects the given {@link ViewObject | ViewObjects} in this View.
   *
   * - Updates {@link ViewObject.selected} on the Objects with the given IDs.
   * - Updates {@link View.selectedObjects} and {@link View.numSelectedObjects}.
   *
   * @param  objectIds One or more {@link ViewObject.id} values.
   * @param selected Whether or not to select.
   * @returns True if any {@link ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */
  setObjectsSelected(objectIds, selected) {
    return this.withObjects(objectIds, (viewObject) => {
      const changed = viewObject.selected !== selected;
      viewObject.selected = selected;
      return changed;
    });
  }
  /**
   * Highlights or un-highlights the given {@link ViewObject | ViewObjects} in this View.
   *
   * - Updates {@link ViewObject.highlighted} on the Objects with the given IDs.
   * - Updates {@link View.highlightedObjects} and {@link View.numHighlightedObjects}.
   *
   * @param  objectIds One or more {@link ViewObject.id} values.
   * @param highlighted Whether or not to highlight.
   * @returns True if any {@link ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */
  setObjectsHighlighted(objectIds, highlighted) {
    return this.withObjects(objectIds, (viewObject) => {
      const changed = viewObject.highlighted !== highlighted;
      viewObject.highlighted = highlighted;
      return changed;
    });
  }
  /**
   * Applies or removes X-ray rendering for the given {@link ViewObject | ViewObjects} in this View.
   *
   * - Updates {@link ViewObject.xrayed} on the Objects with the given IDs.
   * - Updates {@link View.xrayedObjects} and {@link View.numXRayedObjects}.
   *
   * @param  objectIds One or more {@link ViewObject.id} values.
   * @param xrayed Whether or not to xray.
   * @returns True if any {@link ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */
  setObjectsXRayed(objectIds, xrayed) {
    return this.withObjects(objectIds, (viewObject) => {
      const changed = viewObject.xrayed !== xrayed;
      if (changed) {
        viewObject.xrayed = xrayed;
      }
      return changed;
    });
  }
  /**
   * Colorizes the given {@link ViewObject | ViewObjects} in this View.
   *
   * - Updates {@link ViewObject.colorize} on the Objects with the given IDs.
   * - Updates {@link View.colorizedObjects} and {@link View.numColorizedObjects}.
   *
   * @param  objectIds One or more {@link ViewObject.id} values.
   * @param colorize - RGB colorize factors in range ````[0..1,0..1,0..1]````.
   * @returns True if any {@link ViewObject | ViewObjects} changed opacity, else false if all updates were redundant and not applied.
   */
  setObjectsColorized(objectIds, colorize) {
    return this.withObjects(objectIds, (viewObject) => {
      viewObject.colorize = colorize;
    });
  }
  /**
   * Sets the opacity of the given {@link ViewObject | ViewObjects} in this View.
   *
   * - Updates {@link ViewObject.opacity} on the Objects with the given IDs.
   * - Updates {@link View.opacityObjects} and {@link View.numOpacityObjects}.
   *
   * @param  objectIds - One or more {@link ViewObject.id} values.
   * @param opacity - Opacity factor in range ````[0..1]````.
   * @returns True if any {@link ViewObject | ViewObjects} changed opacity, else false if all updates were redundant and not applied.
   */
  setObjectsOpacity(objectIds, opacity) {
    return this.withObjects(objectIds, (viewObject) => {
      const changed = viewObject.opacity !== opacity;
      if (changed) {
        viewObject.opacity = opacity;
      }
      return changed;
    });
  }
  /**
   * Sets the pickability of the given {@link ViewObject | ViewObjects} in this View.
   *
   * - Updates {@link ViewObject.pickable} on the Objects with the given IDs.
   * - Enables or disables the ability to pick the given Objects with {@link View.pick}.
   *
   * @param {string[]} objectIds Array of {@link ViewObject.id} values.
   * @param pickable Whether or not to set pickable.
   * @returns True if any {@link ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */
  setObjectsPickable(objectIds, pickable) {
    return this.withObjects(objectIds, (viewObject) => {
      const changed = viewObject.pickable !== pickable;
      if (changed) {
        viewObject.pickable = pickable;
      }
      return changed;
    });
  }
  /**
   * Sets the clippability of the given {@link ViewObject | ViewObjects} in this View.
   *
   * - Updates {@link ViewObject.clippable} on the Objects with the given IDs.
   * - Enables or disables the ability to clip the given Objects with {@link SectionPlane}.
   *
   * @param objectIds Array of {@link ViewObject.id} values.
   * @param clippable Whether or not to set clippable.
   * @returns True if any {@link ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */
  setObjectsClippable(objectIds, clippable) {
    return this.withObjects(objectIds, (viewObject) => {
      const changed = viewObject.clippable !== clippable;
      if (changed) {
        viewObject.clippable = clippable;
      }
      return changed;
    });
  }
  /**
   * Iterates with a callback over the given {@link ViewObject | ViewObjects} in this View.
   *
   * @param objectIds One or more {@link ViewObject.id} values.
   * @param callback Callback to execute on each {@link ViewObject}.
   * @returns True if any {@link ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */
  withObjects(objectIds, callback) {
    let changed = false;
    for (let i = 0, len = objectIds.length; i < len; i++) {
      const id = objectIds[i];
      let viewObject = this.objects[id];
      if (viewObject) {
        changed = callback(viewObject) || changed;
      }
    }
    return changed;
  }
  /**
   * Creates a {@link ViewLayer} in this View.
   *
   * The ViewLayer is then registered in {@link View.layers}.
   *
   * Since the ViewLayer is created explicitly by this method, the ViewLayer will persist until {@link ViewLayer.destroy}
   * is called, or the {@link View} itself is destroyed. If a ViewLayer with the given ID already exists, then the method
   * returns that existing ViewLayer. The method will also ensure that the existing ViewLayer likewise persists.
   *
   * @param viewLayerParams
   * @returns The new ViewLayer
   */
  createLayer(viewLayerParams) {
    let viewLayer = this.layers[viewLayerParams.id];
    if (!viewLayer) {
      viewLayer = new ViewLayer({
        // Automatically creates ViewObjects
        id: viewLayerParams.id,
        view: this,
        viewer: this.viewer
      });
      this.layers[viewLayerParams.id] = viewLayer;
      this.onLayerCreated.dispatch(this, viewLayer);
      viewLayer.onDestroyed.one(() => {
        delete this.layers[viewLayer.id];
        this.onLayerDestroyed.dispatch(this, viewLayer);
      });
    }
    viewLayer.autoDestroy = viewLayerParams.autoDestroy || false;
    return viewLayer;
  }
  /**
   * Attempts to pick a ViewObject in this View.
   *
   * @param pickParams Picking parameters.
   * @param pickResult Picking results, when caller wants to manage them externally.
   * @throws {@link core!SDKError | SDKError}
   * * No View is currently attached to this Renderer.
   * * Can't find a View attached to this Renderer with the given handle.
   * * Illegal picking parameters given.
   * @returns {@link PickResult}
   * * Picking attempt completed.
   */
  pick(pickParams, pickResult) {
    return this.viewer.renderer.pick(this.viewIndex, pickParams, pickResult);
  }
  /**
   * Enter snapshot mode.
   *
   * Switches rendering to a hidden snapshot canvas.
   *
   * Exit snapshot mode using {@link Viewer#endSnapshot}.
   */
  beginSnapshot() {
    if (this.#snapshotBegun) {
      return;
    }
    this.viewer.renderer.beginSnapshot(this.viewIndex);
    this.#snapshotBegun = true;
  }
  /**
   * Captures a snapshot image of this View.
   *
   * @param snapshotParams
   * @param snapshotResult
   */
  getSnapshot(snapshotParams, snapshotResult) {
    return new SnapshotResult();
  }
  #registerSectionPlane(sectionPlane) {
    this.sectionPlanesList.push(sectionPlane);
    this.sectionPlanes[sectionPlane.id] = sectionPlane;
    this.#sectionPlanesHash = null;
    this.rebuild();
    this.onSectionPlaneCreated.dispatch(this, sectionPlane);
  }
  #deregisterSectionPlane(sectionPlane) {
    for (let i = 0, len = this.sectionPlanesList.length; i < len; i++) {
      if (this.sectionPlanesList[i].id === sectionPlane.id) {
        this.sectionPlanesList.splice(i, 1);
        this.#sectionPlanesHash = null;
        delete this.sectionPlanes[sectionPlane.id];
        this.rebuild();
        this.onSectionPlaneDestroyed.dispatch(this, sectionPlane);
        return;
      }
    }
  }
  getNumAllocatedSectionPlanes() {
    return this.sectionPlanesList.length;
  }
  /**
   * Sets the state of this View.
   * @param viewParams
   */
  fromParams(viewParams) {
    if (viewParams.camera) {
      this.camera.fromParams(viewParams.camera);
    }
    this.autoLayers = viewParams.autoLayers;
    if (viewParams.layers) {
      for (let viewLayerParams of viewParams.layers) {
        const existingViewLayer = this.layers[viewLayerParams.id];
        if (!existingViewLayer) {
          this.createLayer(viewLayerParams);
        }
      }
    }
    if (viewParams.sectionPlanes) {
      for (let sectionPlaneParams of viewParams.sectionPlanes) {
        const existingSectionPlane = this.sectionPlanes[sectionPlaneParams.id];
        if (existingSectionPlane) {
          existingSectionPlane.fromParams(sectionPlaneParams);
        } else {
          this.createSectionPlane(sectionPlaneParams);
        }
      }
    }
    if (viewParams.sao) {
      this.sao.fromParams(viewParams.sao);
    }
    if (viewParams.edges) {
      this.edges.fromParams(viewParams.edges);
    }
    if (viewParams.highlightMaterial) {
      this.highlightMaterial.fromParams(viewParams.highlightMaterial);
    }
    if (viewParams.selectedMaterial) {
      this.selectedMaterial.fromParams(viewParams.selectedMaterial);
    }
    if (viewParams.xrayMaterial) {
      this.xrayMaterial.fromParams(viewParams.xrayMaterial);
    }
    if (viewParams.pointsMaterial) {
      this.pointsMaterial.fromParams(viewParams.pointsMaterial);
    }
  }
  /**
   * Gets this View as JSON.
   */
  toParams() {
    return {
      id: this.id,
      camera: this.camera.toParams(),
      autoLayers: this.autoLayers,
      layers: Object.values(this.layers).map((viewLayer) => viewLayer.toParams()),
      sectionPlanes: Object.values(this.sectionPlanes).map((sectionPlane) => sectionPlane.toParams()),
      lights: Object.values(this.lights).map((light) => light.toParams()),
      sao: this.sao.toParams(),
      edges: this.edges.toParams(),
      highlightMaterial: this.highlightMaterial.toParams(),
      selectedMaterial: this.selectedMaterial.toParams(),
      xrayMaterial: this.xrayMaterial.toParams(),
      pointsMaterial: this.pointsMaterial.toParams(),
      resolutionScale: this.resolutionScale.toParams(),
      renderMode: this.renderMode
    };
  }
  /**
   * Destroys this View.
   *
   * Causes {@link Viewer | Viewer} to fire a "viewDestroyed" event.
   */
  destroy() {
    this.viewer.onTick.unsubscribe(this.#onTick);
    this.#destroyViewLayers();
    this.#destroyViewObjects();
    this.onObjectCreated.clear();
    this.onObjectDestroyed.clear();
    this.onObjectVisibility.clear();
    this.onObjectXRayed.clear();
    this.onLayerCreated.clear();
    this.onLayerDestroyed.clear();
    this.onSectionPlaneCreated.clear();
    this.onSectionPlaneDestroyed.clear();
    super.destroy();
  }
  #destroyViewObjectsForSceneModel(sceneModel) {
    const objects = sceneModel.objects;
    for (let id in objects) {
      const object = objects[id];
      const layerId = object.layerId || "default";
      let viewLayer = this.layers[layerId];
      const viewObject = this.objects[object.id];
      this.deregisterViewObject(viewObject);
      if (viewLayer) {
        viewLayer.deregisterViewObject(viewObject);
        if (viewLayer.autoDestroy && viewLayer.numObjects === 0) {
          viewLayer.destroy();
        }
      }
      this.onObjectDestroyed.dispatch(this, viewObject);
    }
  }
  #destroyViewLayers() {
    const layers = this.layers;
    for (let id in layers) {
      const viewLayer = layers[id];
      viewLayer.destroy();
    }
  }
  #destroyViewObjects() {
    const objects = this.objects;
    for (let id in objects) {
      const object = objects[id];
      const sceneObject = object.sceneObject;
      const layerId = sceneObject.layerId || "default";
      let viewLayer = this.layers[layerId];
      const viewObject = this.objects[object.id];
      this.deregisterViewObject(viewObject);
      if (viewLayer) {
        viewLayer.deregisterViewObject(viewObject);
        if (viewLayer.autoDestroy && viewLayer.numObjects === 0) {
          viewLayer.destroy();
        }
      }
      this.onObjectDestroyed.dispatch(this, viewObject);
    }
  }
};

// ../sdk/src/viewer/stats.ts
var stats = {
  build: {
    version: "0.8"
  },
  client: {
    browser: navigator && navigator.userAgent ? navigator.userAgent : "n/a"
  },
  components: {
    viewers: 0,
    views: 0,
    scenes: 0,
    models: 0,
    meshes: 0,
    objects: 0
  },
  memory: {
    meshes: 0,
    positions: 0,
    colors: 0,
    normals: 0,
    uvs: 0,
    indices: 0,
    textures: 0,
    transforms: 0,
    materials: 0,
    programs: 0
  },
  frame: {
    frameCount: 0,
    fps: 0,
    tasksRun: 0,
    tasksScheduled: 0,
    tasksBudget: 0
  }
};

// ../sdk/src/viewer/scheduler.ts
var tickEvent = {
  viewerId: "",
  time: 0,
  startTime: 0,
  prevTime: 0,
  deltaTime: 0
};
var Scheduler = class {
  viewers;
  #viewersRenderInfo = {};
  // @ts-ignore
  #viewerIDMap = new Map2();
  // Ensures unique viewer IDs
  #taskQueue = new Queue();
  // Task queue, which is pumped on each frame; tasks are pushed to it with calls to xeokit.schedule
  #taskBudget = 10;
  // Millisecs we're allowed to spend on tasks in each frame
  #lastTime = 0;
  #elapsedTime = 0;
  /**
   * @private
   */
  constructor() {
    this.viewers = {};
    const frame = () => {
      const time = Date.now();
      if (this.#lastTime > 0) {
        this.#elapsedTime = time - this.#lastTime;
      }
      this.#runTasks(time);
      this.#fireTickEvents(time);
      this.#renderViewers();
      this.#lastTime = time;
      requestAnimationFrame(frame);
    };
    requestAnimationFrame(frame);
  }
  #runTasks(time) {
    const tasksRun = this.#runTasksUntil(time + this.#taskBudget);
    const tasksScheduled = this.getNumTasks();
    stats.frame.tasksRun = tasksRun;
    stats.frame.tasksScheduled = tasksScheduled;
    stats.frame.tasksBudget = this.#taskBudget;
  }
  #runTasksUntil(until = -1) {
    let time = (/* @__PURE__ */ new Date()).getTime();
    let tasksRun = 0;
    while (this.#taskQueue.length > 0 && (until < 0 || time < until)) {
      const callback = this.#taskQueue.shift();
      const scope = this.#taskQueue.shift();
      if (scope) {
        callback.call(scope);
      } else {
        callback();
      }
      time = (/* @__PURE__ */ new Date()).getTime();
      tasksRun++;
    }
    return tasksRun;
  }
  #fireTickEvents(time) {
    tickEvent.time = time;
    for (let id in scheduler.viewers) {
      if (this.viewers.hasOwnProperty(id)) {
        const viewer = this.viewers[id];
        tickEvent.viewerId = id;
        tickEvent.startTime = viewer.startTime;
        tickEvent.deltaTime = tickEvent.prevTime != null ? tickEvent.time - tickEvent.prevTime : 0;
        viewer.onTick.dispatch(viewer, tickEvent);
      }
    }
    tickEvent.prevTime = time;
  }
  #renderViewers() {
    for (let id in this.viewers) {
      if (this.viewers.hasOwnProperty(id)) {
        const viewer = this.viewers[id];
        let renderInfo = this.#viewersRenderInfo[id];
        if (!renderInfo) {
          renderInfo = this.#viewersRenderInfo[id] = {};
        }
        viewer.render({});
      }
    }
  }
  registerViewer(viewer) {
    if (viewer.id) {
      if (this.viewers[viewer.id]) {
        console.error(`[ERROR] Viewer ${inQuotes(viewer.id)} already exists`);
        return;
      }
    } else {
      viewer.id = this.#viewerIDMap.addItem({});
    }
    this.viewers[viewer.id] = viewer;
    this.#viewersRenderInfo[viewer.id] = {
      // ticksPerOcclusionTest: ticksPerOcclusionTest,
      // ticksPerRender: ticksPerRender,
      // renderCountdown: ticksPerRender
    };
    stats.components.viewers++;
  }
  deregisterViewer(viewer) {
    if (!this.viewers[viewer.id]) {
      return;
    }
    this.#viewerIDMap.removeItem(viewer.id);
    delete this.viewers[viewer.id];
    delete this.#viewersRenderInfo[viewer.id];
    stats.components.viewers--;
  }
  scheduleTask(callback, scope) {
    this.#taskQueue.push(callback);
    this.#taskQueue.push(scope);
  }
  getNumTasks() {
    return this.#taskQueue.length;
  }
};
var scheduler = new Scheduler();

// ../sdk/src/viewer/Viewer.ts
var Viewer = class extends Component {
  /**
   * Indicates the capabilities of this Viewer.
   */
  capabilities;
  /**
   * Emits an event each time a message is logged.
   *
   * @event
   */
  onLog;
  /**
   * Emits an event each time a Viewer "tick" occurs (~10-60 times per second).
   *
   * @event
   */
  onTick;
  /**
   * Emits an event each time a {@link View} is created.
   *
   * @event
   */
  onViewCreated;
  /**
   * Emits an event each time a {@link View} is destroyed.
   *
   * @event
   */
  onViewDestroyed;
  /**
   * The Viewer's scene representation.
   *
   * The {@link scene!SceneModel | SceneModels} is the container of {@link scene!SceneModel | SceneModels}
   * and {@link scene!SceneObject | SceneObjects}, which contain the geometry and materials for models currently
   * loaded in the Viewer.
   */
  scene;
  /**
   * Map of all the Views in this Viewer.
   *
   * Each {@link View} is mapped here against {@link View.id | View.id}.
   *
   * Each {@link View} is an independently configurable view of the Viewer's models, with its own
   * canvas, camera position, section planes, lights, and object visual states.
   */
  views;
  /**
   * List of all the Views in this Viewer.
   *
   * Each {@link View} is an independently configurable view of the Viewer's models, with its own canvas, camera position, section planes, lights, and object visual states.
   *
   * @internal
   */
  viewList;
  /**
   *  The number of {@link View | Views} belonging to this Viewer.
   *
   *  The maxiumum number of Views that a Viewer can have is determined by the {@link Renderer} implementation it was
   *  configured with, which is provided in {@link Capabilities.maxViews}.
   */
  numViews;
  /**
   * The time that this Viewer was created.
   * This is the number of milliseconds since the epoch, which is defined as the midnight at the beginning of January 1, 1970, UTC.
   */
  startTime = (/* @__PURE__ */ new Date()).getTime();
  /**
   * The Renderer that this Viewer was configured with via the Viewer's constructor.
   * Th Renderer is only used by the Viewer, and is not intended to for users to use directly. It's provided via this property
   * in order to verify which Render implementation the Viewer is configured with.
   */
  renderer;
  #tickifiedFunctions;
  /**
   * Creates a Viewer.
   *
   * @param params - Viewer configuration.
   * @param params.scene - Contains model representations. A Scene can be attached to a maximum of one Viewer - don't share a Scene between multiple Viewers.
   * @param params.renderer - Manages rendering of models.
   * @param params.id - ID for this Viewer, automatically generated by default.
   * @param params.units - The measurement unit type. Accepted values are ````"meters"````, ````"metres"````, , ````"centimeters"````, ````"centimetres"````, ````"millimeters"````,  ````"millimetres"````, ````"yards"````, ````"feet"```` and ````"inches"````.
   * @param params.scale - The number of Real-space units in each World-space coordinate system unit.
   * @param params.origin - The Real-space 3D origin, in current measurement units, at which the World-space coordinate origin ````[0,0,0]```` sits.
   * @param params.localeService - Locale-based translation service.
   * @throws SDKError
   *   The given Renderer is already attached to some other Viewer.
   */
  constructor(params2) {
    super(null, {});
    this.id = params2.id || createUUID2();
    if (params2.renderer.viewer !== void 0) {
      throw new SDKError(`Failed to create Viewer - the given Renderer is currently attached to another Viewer`);
    }
    this.onLog = new EventEmitter(new import_strongly_typed_events16.EventDispatcher());
    this.onTick = new EventEmitter(new import_strongly_typed_events16.EventDispatcher());
    this.onViewCreated = new EventEmitter(new import_strongly_typed_events16.EventDispatcher());
    this.onViewDestroyed = new EventEmitter(new import_strongly_typed_events16.EventDispatcher());
    this.viewList = [];
    this.numViews = 0;
    this.views = {};
    this.destroyed = false;
    this.capabilities = {
      maxViews: 1,
      headless: false,
      astcSupported: false,
      etc1Supported: false,
      etc2Supported: false,
      dxtSupported: false,
      bptcSupported: false,
      pvrtcSupported: false
    };
    this.scene = params2.scene || new Scene();
    params2.renderer.attachViewer(this);
    params2.renderer.getCapabilities(this.capabilities);
    this.renderer = params2.renderer;
    this.#tickifiedFunctions = {};
    this.scene.onModelCreated.subscribe((scene, sceneModel) => {
      this.renderer.attachSceneModel(sceneModel);
    });
    this.scene.onModelDestroyed.subscribe((scene, sceneModel) => {
      this.renderer.detachSceneModel(sceneModel);
    });
    scheduler.registerViewer(this);
  }
  /**
   * This method will "tickify" the provided `cb` function.
   *
   * This means, the function will be wrapped so:
   *
   * - it runs time-aligned to scene ticks
   * - it runs maximum once per scene-tick
   *
   * @param {Function} cb The function to tickify
   * @returns {Function}
   */
  tickify(cb2) {
    let cbString = cb2.toString();
    if (cbString in this.#tickifiedFunctions) {
      return this.#tickifiedFunctions[cbString].wrapperFunc;
    }
    let alreadyRun = 0;
    let needToRun = 0;
    let lastArgs;
    const wrapperFunc = function(...args) {
      lastArgs = args;
      needToRun++;
    };
    const tickSubId = this.onTick.sub(() => {
      const tmp = needToRun;
      if (tmp > alreadyRun) {
        alreadyRun = tmp;
        cb2(...lastArgs);
      }
    });
    this.#tickifiedFunctions[cbString] = { tickSubId, wrapperFunc };
    return wrapperFunc;
  }
  /**
   * Creates a new {@link View} within this Viewer.
   *
   * * The maximum number of views you're allowed to create is provided in {@link Capabilities.maxViews}. This
   * will be determined by the {@link Renderer} implementation the Viewer is configured with.
   * * To destroy the View after use, call {@link View.destroy}.
   * * You must add a View to the Viewer before you can create or load content into the Viewer's Viewer.
   *
   * ### Usage
   *
   * ````javascript
   * const view1 = myViewer.createView({
   *      id: "myView",
   *      elementId: "myView1"
   *  });
   *
   * if (view1 instanceof SDKError) {
   *      console.log(view1.message);
   * } else {
   *      view1.camera.eye = [-3.933, 2.855, 27.018];
   *      view1.camera.look = [4.400, 3.724, 8.899];
   *      view1.camera.up = [-0.018, 0.999, 0.039];
   *
   *      //...
   * }
   * ````
   *
   * @param viewParams View configuration.
   * @returns *{@link View | View}*
   * * On success.
   * @returns *{@link core!SDKError | SDKError}*
   * * If View already exists with the given ID.
   * * Attempted to create too many Views - see {@link Capabilities.maxViews | Capabilities.maxViews}.
   */
  createView(viewParams) {
    if (this.viewList.length >= this.capabilities.maxViews) {
      return new SDKError(`Attempted to create too many Views with View.createView() - maximum of ${this.capabilities.maxViews} is allowed`);
    }
    let viewId = viewParams.id || createUUID2();
    if (this.views[viewId]) {
      return new SDKError(`View with ID "${viewId}" already exists in this Viewer`);
    }
    if (viewParams.elementId) {
      const htmlElement = document.getElementById(viewParams.elementId);
      if (!(htmlElement instanceof HTMLElement)) {
        return new SDKError("viewParams.htmlElement is not an HTMLElement");
      }
    }
    if (viewParams.htmlElement) {
      if (!(viewParams.htmlElement instanceof HTMLElement)) {
        return new SDKError("viewParams.elementId does not reference an HTMLElement");
      }
    }
    const view = new View(this, apply({ id: viewId }, viewParams));
    const result = this.renderer.attachView(view);
    if (result instanceof SDKError) {
      this.error(`Failed to create View (id = "${view.viewId}"): ${result.message}`);
      return result;
    }
    this.#registerView(view);
    view.onDestroyed.one(() => {
      this.#deregisterView(view);
      this.renderer.detachView(view);
      this.onViewDestroyed.dispatch(this, view);
    });
    for (let id in this.scene.models) {
      this.renderer.attachSceneModel(this.scene.models[id]);
    }
    view.initViewObjects();
    this.onViewCreated.dispatch(this, view);
    return view;
  }
  /**
   * Trigger redraw of all {@link View | Views} belonging to this Viewer.
   *
   * @private
   */
  redraw() {
    for (let viewId in this.views) {
      this.views[viewId].redraw();
    }
  }
  /**
   * Logs a console debugging message for this Viewer.
   *
   * The console message will have this format: *````[LOG] [<component type> <component id>: <message>````*
   *
   * @private
   * @param message - The message to log
   */
  log(message) {
    window.console.log(`[LOG] ${this.#prefixMessageWithID(message)}`);
  }
  /**
   * Logs a warning for this Viewer to the JavaScript console.
   *
   * The console message will have this format: *````[WARN] [<component type> =<component id>: <message>````*
   *
   * @private
   * @param message - The warning message to log
   */
  warn(message) {
    window.console.warn(`[WARN] ${this.#prefixMessageWithID(message)}`);
  }
  /**
   * Logs an error for this Viewer to the JavaScript console.
   *
   * The console message will have this format: *````[ERROR] [<component type> =<component id>: <message>````*
   *
   * @private
   * @param message The error message to log
   */
  error(message) {
    window.console.error(`[ERROR] ${this.#prefixMessageWithID(message)}`);
  }
  /**
   * Clears this Viewer.
   *
   * Destroys all existing {@link View | Views} and resets all properties to their default values.
   */
  clear() {
    for (let viewId in this.views) {
      const view = this.views[viewId];
      view.destroy();
    }
  }
  /**
   * @private
   * @param params
   */
  render(params2) {
    for (let viewIndex = 0; viewIndex < this.viewList.length; viewIndex++) {
      this.renderer.render(viewIndex, { force: false });
    }
  }
  #prefixMessageWithID(message) {
    return `[${this.constructor.name} "${inQuotes(this.id)}"]: ${message}`;
  }
  #registerView(view) {
    if (this.views[view.id]) {
      return;
    }
    this.views[view.id] = view;
    for (let viewIndex = 0; ; viewIndex++) {
      if (!this.viewList[viewIndex]) {
        this.viewList[viewIndex] = view;
        this.numViews++;
        view.viewIndex = viewIndex;
        return;
      }
    }
  }
  #deregisterView(view) {
    if (!this.views[view.id]) {
      return;
    }
    delete this.views[view.id];
    delete this.viewList[view.viewIndex];
    this.numViews--;
  }
  /**
   * Configures this Viewer.
   *
   * @param viewerParams
   */
  fromParams(viewerParams) {
    if (viewerParams.views) {
      for (let viewParams of viewerParams.views) {
        if (viewParams.id !== void 0) {
          const existingView = this.views[viewParams.id];
          if (existingView) {
            existingView.fromParams(viewParams);
          } else {
            this.createView(viewParams);
          }
        } else {
          this.createView(viewParams);
        }
      }
    }
  }
  /**
   * Gets the current configuration of this Viewer.
   */
  toParams() {
    return {
      views: this.viewList.map((el) => el.toParams())
    };
  }
  /**
   * Destroys this Viewer.
   */
  destroy() {
    if (this.destroyed) {
      return;
    }
    this.renderer.detachViewer();
    scheduler.deregisterViewer(this);
    for (let id in this.views) {
      this.views[id].destroy();
    }
    this.onLog.clear();
    this.onTick.clear();
    this.onViewCreated.clear();
    this.onViewDestroyed.clear();
    super.destroy();
  }
};

// ../sdk/src/viewer/PointLight.ts
var PointLight = class extends Component {
  /**
   * The View to which this PointLight belongs.
   */
  view;
  #state;
  /**
   * @param view View that owns this PointLight. When destroyed, the View will destroy this PointLight as well.
   * @param cfg The PointLight configuration
   */
  constructor(view, cfg = {}) {
    super(view, cfg);
    this.view = view;
    this.#state = {
      type: "point",
      pos: new Float64Array(cfg.pos || [1, 1, 1]),
      color: new Float32Array(cfg.color || [0.7, 0.7, 0.8]),
      intensity: 1,
      // @ts-ignore
      attenuation: new Float32Array([cfg.constantAttenuation, cfg.linearAttenuation, cfg.quadraticAttenuation]),
      space: cfg.space || "view"
    };
    this.view.registerLight(this);
  }
  /**
   * The coordinate system the PointLight is defined in - ````"view"```` or ````"space"````.
   */
  get space() {
    return this.#state.space;
  }
  /**
   * Gets the position of this PointLight.
   *
   * This will be either World- or View-space, depending on the value of {@link PointLight.space}.
   *
   * Default value is ````[1.0, 1.0, 1.0]````.
   *
   * @returns {Number[]} The position.
   */
  get pos() {
    return this.#state.pos;
  }
  /**
   * Sets the position of this PointLight.
   *
   * This will be either World- or View-space, depending on the value of {@link PointLight.space}.
   *
   * Default value is ````[1.0, 1.0, 1.0]````.
   *
   * @param pos The position.
   */
  set pos(pos) {
    this.#state.pos.set(pos || [1, 1, 1]);
    this.view.redraw();
  }
  /**
   * Gets the RGB color of this PointLight.
   *
   * Default value is ````[0.7, 0.7, 0.8]````.
   *
   * @returns {Number[]} The PointLight's RGB color.
   */
  get color() {
    return this.#state.color;
  }
  /**
   * Sets the RGB color of this PointLight.
   *
   * Default value is ````[0.7, 0.7, 0.8]````.
   *
   * @param color The PointLight's RGB color.
   */
  set color(color2) {
    this.#state.color.set(color2 || [0.7, 0.7, 0.8]);
    this.view.redraw();
  }
  /**
   * Gets the intensity of this PointLight.
   *
   * Default value is ````1.0```` for maximum intensity.
   *
   * @returns {Number} The PointLight's intensity.
   */
  get intensity() {
    return this.#state.intensity;
  }
  /**
   * Sets the intensity of this PointLight.
   *
   * Default intensity is ````1.0```` for maximum intensity.
   *
   * @param intensity The PointLight's intensity
   */
  set intensity(intensity) {
    if (intensity === this.#state.intensity) {
      return;
    }
    this.#state.intensity = intensity;
    this.view.redraw();
  }
  /**
   * Gets the constant attenuation factor for this PointLight.
   *
   * Default value is ````0````.
   *
   * @returns {Number} The constant attenuation factor.
   */
  get constantAttenuation() {
    return this.#state.attenuation[0];
  }
  /**
   * Sets the constant attenuation factor for this PointLight.
   *
   * Default value is ````0````.
   *
   * @param value The constant attenuation factor.
   */
  set constantAttenuation(value) {
    this.#state.attenuation[0] = value;
    this.view.redraw();
  }
  /**
   * Gets the linear attenuation factor for this PointLight.
   *
   * Default value is ````0````.
   *
   * @returns {Number} The linear attenuation factor.
   */
  get linearAttenuation() {
    return this.#state.attenuation[1];
  }
  /**
   * Sets the linear attenuation factor for this PointLight.
   *
   * Default value is ````0````.
   *
   * @param value The linear attenuation factor.
   */
  set linearAttenuation(value) {
    this.#state.attenuation[1] = value;
    this.view.redraw();
  }
  /**
   * Gets the quadratic attenuation factor for this PointLight.
   *
   * Default value is ````0````.
   *
   * @returns {Number} The quadratic attenuation factor.
   */
  get quadraticAttenuation() {
    return this.#state.attenuation[2];
  }
  /**
   * Sets the quadratic attenuation factor for this PointLight.
   *
   * Default value is ````0````.
   *
   * @param value The quadratic attenuation factor.
   */
  set quadraticAttenuation(value) {
    this.#state.attenuation[2] = value;
    this.view.redraw();
  }
  /**
   * Configures this PointLight.
   *
   * Ignores {@link PointLightParams.space | PointLightParams.space}, because
   * {@link PointLight.space | PointLight.space} is not dynamically updatable.
   *
   * @param pointLightParams
   */
  fromParams(pointLightParams) {
    if (pointLightParams.pos) {
      this.pos = pointLightParams.pos;
    }
    if (pointLightParams.color) {
      this.color = pointLightParams.color;
    }
    if (pointLightParams.intensity !== void 0) {
      this.intensity = pointLightParams.intensity;
    }
  }
  /**
   * Gets the current configuration of this PointLight.
   */
  toParams() {
    return {
      id: this.id,
      color: Array.from(this.color),
      pos: Array.from(this.pos),
      quadraticAttenuation: this.quadraticAttenuation,
      linearAttenuation: this.linearAttenuation,
      constantAttenuation: this.constantAttenuation,
      intensity: this.intensity,
      space: this.space
    };
  }
  /**
   * Destroys this PointLight.
   */
  destroy() {
    super.destroy();
    this.view.deregisterLight(this);
    this.view.redraw();
  }
};

// ../sdk/src/viewer/PickResult.ts
var PickResult = class {
  #viewObject;
  #gotCanvasPos;
  #gotSnappedCanvasPos;
  #gotOrigin;
  #gotDirection;
  #gotIndices;
  #gotLocalPos;
  #gotWorldPos;
  #gotViewPos;
  #gotWorldNormal;
  #gotUV;
  #snappedToVertex;
  #snappedToEdge;
  #canvasPos;
  #snappedCanvasPos;
  #origin;
  #direction;
  #indices;
  #localPos;
  #worldPos;
  #viewPos;
  #worldNormal;
  #uv;
  constructor() {
    this.#viewObject = null;
    this.#canvasPos = new Int16Array([0, 0]);
    this.#origin = new Float64Array([0, 0, 0]);
    this.#direction = new Float64Array([0, 0, 0]);
    this.#indices = new Int32Array(3);
    this.#localPos = new Float64Array([0, 0, 0]);
    this.#worldPos = new Float64Array([0, 0, 0]);
    this.#viewPos = new Float64Array([0, 0, 0]);
    this.#worldNormal = new Float64Array([0, 0, 0]);
    this.#uv = new Float64Array([0, 0]);
    this.#gotOrigin = false;
    this.#gotDirection = false;
    this.#gotIndices = false;
    this.#gotCanvasPos = false;
    this.#gotSnappedCanvasPos = false;
    this.#gotLocalPos = false;
    this.#gotWorldPos = false;
    this.#gotViewPos = false;
    this.#gotWorldNormal = false;
    this.#gotUV = false;
    this.#snappedToVertex = false;
    this.#snappedToEdge = false;
    this.reset();
  }
  /**
   * The picked {@link ViewObject}.
   */
  get viewObject() {
    return this.#viewObject;
  }
  /**
   * @private
   */
  set viewObject(value) {
    this.#viewObject = value;
  }
  /**
   * Canvas coordinates when picking with a 2D pointer.
   */
  get canvasPos() {
    return this.#gotCanvasPos ? this.#canvasPos : void 0;
  }
  /**
   * @private
   */
  set canvasPos(value) {
    if (value) {
      this.#canvasPos[0] = value[0];
      this.#canvasPos[1] = value[1];
      this.#gotCanvasPos = true;
    } else {
      this.#gotCanvasPos = false;
    }
  }
  /**
   * World-space 3D ray origin when raypicked.
   */
  get origin() {
    return this.#gotOrigin ? this.#origin : null;
  }
  /**
   * @private
   */
  set origin(value) {
    if (value) {
      this.#origin[0] = value[0];
      this.#origin[1] = value[1];
      this.#origin[2] = value[2];
      this.#gotOrigin = true;
    } else {
      this.#gotOrigin = false;
    }
  }
  /**
   * World-space 3D ray direction when raypicked.
   */
  get direction() {
    return this.#gotDirection ? this.#direction : null;
  }
  /**
   * @private
   */
  set direction(value) {
    if (value) {
      this.#direction[0] = value[0];
      this.#direction[1] = value[1];
      this.#direction[2] = value[2];
      this.#gotDirection = true;
    } else {
      this.#gotDirection = false;
    }
  }
  /**
   * Picked triangle's vertex indices.
   * Only defined when an object and triangle was picked.
   */
  get indices() {
    return this.#viewObject !== null && this.#gotIndices ? this.#indices : null;
  }
  /**
   * @private
   */
  set indices(value) {
    if (value) {
      this.#indices[0] = value[0];
      this.#indices[1] = value[1];
      this.#indices[2] = value[2];
      this.#gotIndices = true;
    } else {
      this.#gotIndices = false;
    }
  }
  /**
   * Picked Local-space point on surface.
   * Only defined when an object and a point on its surface was picked.
   */
  get localPos() {
    return this.#viewObject !== null && this.#gotLocalPos ? this.#localPos : null;
  }
  /**
   * @private
   */
  set localPos(value) {
    if (value) {
      this.#localPos[0] = value[0];
      this.#localPos[1] = value[1];
      this.#localPos[2] = value[2];
      this.#gotLocalPos = true;
    } else {
      this.#gotLocalPos = false;
    }
  }
  /**
   * Picked World-space point on surface.
   * Only defined when an object and a point on its surface was picked.
   */
  get worldPos() {
    return this.#viewObject && this.#gotWorldPos ? this.#worldPos : null;
  }
  /**
   * @private
   */
  set worldPos(value) {
    if (value) {
      this.#worldPos[0] = value[0];
      this.#worldPos[1] = value[1];
      this.#worldPos[2] = value[2];
      this.#gotWorldPos = true;
    } else {
      this.#gotWorldPos = false;
    }
  }
  /**
   * Picked View-space point on surface.
   * Only defined when an object and a point on its surface was picked.
   */
  get viewPos() {
    return this.#viewObject && this.#gotViewPos ? this.#viewPos : null;
  }
  /**
   * @private
   */
  set viewPos(value) {
    if (value) {
      this.#viewPos[0] = value[0];
      this.#viewPos[1] = value[1];
      this.#viewPos[2] = value[2];
      this.#gotViewPos = true;
    } else {
      this.#gotViewPos = false;
    }
  }
  /**
   * Normal vector at picked position on surface.
   * Only defined when an object and a point on its surface was picked.
   */
  get worldNormal() {
    return this.#viewObject !== null && this.#gotWorldNormal ? this.#worldNormal : null;
  }
  /**
   * @private
   */
  set worldNormal(value) {
    if (value) {
      this.#worldNormal[0] = value[0];
      this.#worldNormal[1] = value[1];
      this.#worldNormal[2] = value[2];
      this.#gotWorldNormal = true;
    } else {
      this.#gotWorldNormal = false;
    }
  }
  /**
   * UV coordinates at picked position on surface.
   * Only defined when an object and a point on its surface was picked.
   */
  get uv() {
    return this.#viewObject !== null && this.#gotUV ? this.#uv : null;
  }
  /**
   * @private
   */
  set uv(value) {
    if (value) {
      this.#uv[0] = value[0];
      this.#uv[1] = value[1];
      this.#gotUV = true;
    } else {
      this.#gotUV = false;
    }
  }
  /**
   * Returns `true` if picking has snapped to the canvas coordinates of the nearest vertex.
   * When this is `true`, then {@link PickResult.snappedCanvasPos} will contain the canvas coordinates of the nearest position on teh nearest vertex.
   */
  get snappedToVertex() {
    return this.#viewObject !== null && this.#snappedToVertex;
  }
  /**
   * @private
   */
  set snappedToVertex(value) {
    this.#snappedToVertex = value;
  }
  /**
   * Returns `true` if picking has snapped to the canvas coordinates of the nearest edge.
   * When this is `true`, then {@link PickResult.snappedCanvasPos} will contain the canvas coordinates of the nearest position on teh nearest edge.
   */
  get snappedToEdge() {
    return this.#viewObject !== null && this.#snappedToEdge;
  }
  set snappedToEdge(value) {
    this.#snappedToEdge = value;
  }
  /**
   * Snapped canvas coordinates when picking with a 2D pointer.
   * This has a value when {@link PickResult.snappedToEdge} or {@link PickResult.snappedToVertex} is `true`, otherwise will be `null`.
   */
  get snappedCanvasPos() {
    return this.#gotSnappedCanvasPos ? this.#snappedCanvasPos : void 0;
  }
  /**
   * @private
   */
  set snappedCanvasPos(value) {
    if (value) {
      this.#snappedCanvasPos[0] = value[0];
      this.#snappedCanvasPos[1] = value[1];
      this.#gotSnappedCanvasPos = true;
    } else {
      this.#gotSnappedCanvasPos = false;
    }
  }
  /**
   * @private
   */
  reset() {
    this.#viewObject = null;
    this.#gotCanvasPos = false;
    this.#gotSnappedCanvasPos = false;
    this.#gotOrigin = false;
    this.#gotDirection = false;
    this.#gotIndices = false;
    this.#gotLocalPos = false;
    this.#gotWorldPos = false;
    this.#gotViewPos = false;
    this.#gotWorldNormal = false;
    this.#gotUV = false;
    this.#snappedToVertex = false;
    this.#snappedToEdge = false;
  }
};

// ../sdk/src/webglrenderer/index.ts
var webglrenderer_exports = {};
__export(webglrenderer_exports, {
  WebGLRenderer: () => WebGLRenderer
});

// ../sdk/src/ktx2/index.ts
var ktx2_exports = {};
__export(ktx2_exports, {
  KTX2TextureTranscoder: () => KTX2TextureTranscoder
});

// ../sdk/src/ktx2/KTX2TextureTranscoder.ts
var KTX2TransferSRGB = 2;
var KTX2_ALPHA_PREMULTIPLIED = 1;
var activeTranscoders = 0;
var BasisFormat = {
  ETC1S: 0,
  UASTC_4x4: 1
};
var TranscoderFormat = {
  ETC1: 0,
  ETC2: 1,
  BC1: 2,
  BC3: 3,
  BC4: 4,
  BC5: 5,
  BC7_M6_OPAQUE_ONLY: 6,
  BC7_M5: 7,
  PVRTC1_4_RGB: 8,
  PVRTC1_4_RGBA: 9,
  ASTC_4x4: 10,
  ATC_RGB: 11,
  ATC_RGBA_INTERPOLATED_ALPHA: 12,
  RGBA32: 13,
  RGB565: 14,
  BGR565: 15,
  RGBA4444: 16
};
var EngineFormat = {
  RGBAFormat,
  RGBA_ASTC_4x4_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT5_Format,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format
};
var KTX2TextureTranscoder = class {
  #transcoderPath;
  #transcoderBinary;
  #transcoderPending;
  #workerPool;
  #workerSourceURL;
  #workerConfig;
  #supportedFileTypes;
  #withCredentials;
  /**
   * Creates a new KTX2TextureTranscoder.
   *
   * @param {String} [params.transcoderPath="https://cdn.jsdelivr.net/npm/@xeokit/sdk/dist/basis/"] Path to the Basis
   * transcoder module that internally does the heavy lifting for our KTX2TextureTranscoder. If we omit this configuration,
   * then our KTX2TextureTranscoder will load it from ````https://cdn.jsdelivr.net/npm/@xeokit/sdk/dist/basis/```` by
   * default. Therefore, make sure your application is connected to the internet if you wish to use the default transcoder path.
   * @param {Number} [params.workerLimit] The maximum number of Workers to use for transcoding.
   */
  constructor(params2) {
    this.#transcoderPath = params2.transcoderPath || "https://cdn.jsdelivr.net/npm/@xeokit/sdk/dist/basis/";
    this.#transcoderBinary = null;
    this.#transcoderPending = null;
    this.#workerPool = new WorkerPool();
    this.#workerSourceURL = "";
    if (params2.workerLimit) {
      this.#workerPool.setWorkerLimit(params2.workerLimit);
    }
    this.#workerConfig = null;
    this.#withCredentials = false;
    this.#supportedFileTypes = ["xgf2"];
  }
  /**
   * Initializes this transcoder.
   *
   * @param capabilities A set of flags indicating the capabilities of this TextureTranscoder.
   */
  init(capabilities) {
    this.#workerConfig = {
      astcSupported: capabilities.astcSupported,
      etc1Supported: capabilities.etc1Supported,
      etc2Supported: capabilities.etc2Supported,
      dxtSupported: capabilities.dxtSupported,
      bptcSupported: capabilities.bptcSupported,
      pvrtcSupported: capabilities.pvrtcSupported
    };
  }
  /**
   * Transcodes texture data from transcoded buffers.
   *
   * @param {ArrayBuffer[]} buffers Transcoded input texture data. Given as an array of buffers so that we can support multi-image textures, such as cube maps.
   * @param {*} config Transcoding options.
   * @returns {Promise<TextureCompressedParams>} Transcoded output texture data.
   */
  transcode(buffers, config2 = {}) {
    return new Promise((resolve2, reject) => {
      const taskConfig = config2;
      this.#initTranscoder().then(() => {
        return this.#workerPool.postMessage({
          type: "transcode",
          buffers,
          taskConfig
        }, buffers);
      }).then((e) => {
        const transcodeResult = e.data;
        const { mipmaps, width, height, format, type, error, dfdTransferFn, dfdFlags } = transcodeResult;
        if (type === "error") {
          return reject(error);
        }
        resolve2({
          mipmaps,
          props: {
            format,
            minFilter: mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter,
            magFilter: mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter,
            encoding: dfdTransferFn === KTX2TransferSRGB ? sRGBEncoding : LinearEncoding,
            premultiplyAlpha: !!(dfdFlags & KTX2_ALPHA_PREMULTIPLIED)
          }
        });
      });
    });
  }
  /**
   * Destroys this KTX2TextureTranscoder
   */
  destroy() {
    URL.revokeObjectURL(this.#workerSourceURL);
    this.#workerPool.destroy();
    activeTranscoders--;
  }
  #initTranscoder() {
    if (!this.#transcoderPending) {
      const jsLoader = new FileLoader();
      jsLoader.setPath(this.#transcoderPath);
      jsLoader.setWithCredentials(this.#withCredentials);
      const jsContent = jsLoader.loadAsync("basis_transcoder.js");
      const binaryLoader = new FileLoader();
      binaryLoader.setPath(this.#transcoderPath);
      binaryLoader.setResponseType("arraybuffer");
      binaryLoader.setWithCredentials(this.#withCredentials);
      const binaryContent = binaryLoader.loadAsync("basis_transcoder.wasm");
      this.#transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent2, binaryContent2]) => {
        const fn = BasisWorker.toString();
        const body = [
          "/* constants */",
          "let _EngineFormat = " + JSON.stringify(EngineFormat),
          "let _TranscoderFormat = " + JSON.stringify(TranscoderFormat),
          "let _BasisFormat = " + JSON.stringify(BasisFormat),
          "/* basis_transcoder.js */",
          jsContent2,
          "/* worker */",
          fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))
        ].join("\n");
        this.#workerSourceURL = URL.createObjectURL(new Blob([body]));
        this.#transcoderBinary = binaryContent2;
        this.#workerPool.setWorkerCreator(() => {
          const worker = new Worker(this.#workerSourceURL);
          const transcoderBinary = this.#transcoderBinary.slice(0);
          worker.postMessage({
            type: "init",
            config: this.#workerConfig,
            transcoderBinary
          }, [transcoderBinary]);
          return worker;
        });
      });
      if (activeTranscoders > 0) {
        console.warn("KTX2TextureTranscoder: Multiple active KTX2TextureTranscoder may cause performance issues. Use a single KTX2TextureTranscoder instance, or call .dispose() on old instances.");
      }
      activeTranscoders++;
    }
    return this.#transcoderPending;
  }
};
var BasisWorker = function() {
  let config2;
  let transcoderPending;
  let BasisModule;
  const EngineFormat2 = _EngineFormat;
  const TranscoderFormat2 = _TranscoderFormat;
  const BasisFormat2 = _BasisFormat;
  self.addEventListener("message", function(e) {
    const message = e.data;
    switch (message.type) {
      case "init":
        config2 = message.config;
        init(message.transcoderBinary);
        break;
      case "transcode":
        transcoderPending.then(() => {
          try {
            const {
              width,
              height,
              hasAlpha,
              mipmaps,
              format,
              dfdTransferFn,
              dfdFlags
            } = transcode(message.buffers[0]);
            const buffers = [];
            for (let i = 0; i < mipmaps.length; ++i) {
              buffers.push(mipmaps[i].data.buffer);
            }
            self.postMessage({
              type: "transcode",
              id: message.id,
              width,
              height,
              hasAlpha,
              mipmaps,
              format,
              dfdTransferFn,
              dfdFlags
              // @ts-ignore
            }, buffers);
          } catch (error) {
            console.error(`[BasisWorker]: ${error}`);
            self.postMessage({ type: "error", id: message.id, error: error.message });
          }
        });
        break;
    }
  });
  function init(wasmBinary) {
    transcoderPending = new Promise((resolve2) => {
      BasisModule = {
        wasmBinary,
        onRuntimeInitialized: resolve2
      };
      BASIS(BasisModule);
    }).then(() => {
      BasisModule.initializeBasis();
      if (BasisModule.KTX2File === void 0) {
        console.warn("KTX2TextureTranscoder: Please update Basis Universal transcoder.");
      }
    });
  }
  function transcode(buffer) {
    const ktx2File = new BasisModule.KTX2File(new Uint8Array(buffer));
    function cleanup() {
      ktx2File.close();
      ktx2File.delete();
    }
    if (!ktx2File.isValid()) {
      cleanup();
      throw new Error("KTX2TextureTranscoder: Invalid or unsupported .ktx2 file");
    }
    const basisFormat = ktx2File.isUASTC() ? BasisFormat2.UASTC_4x4 : BasisFormat2.ETC1S;
    const width = ktx2File.getWidth();
    const height = ktx2File.getHeight();
    const levels = ktx2File.getLevels();
    const hasAlpha = ktx2File.getHasAlpha();
    const dfdTransferFn = ktx2File.getDFDTransferFunc();
    const dfdFlags = ktx2File.getDFDFlags();
    const { transcoderFormat, engineFormat } = getTranscoderFormat(basisFormat, width, height, hasAlpha);
    if (!width || !height || !levels) {
      cleanup();
      throw new Error("KTX2TextureTranscoder: Invalid texture");
    }
    if (!ktx2File.startTranscoding()) {
      cleanup();
      throw new Error("KTX2TextureTranscoder: .startTranscoding failed");
    }
    const mipmaps = [];
    for (let mip = 0; mip < levels; mip++) {
      const levelInfo = ktx2File.getImageLevelInfo(mip, 0, 0);
      const mipWidth = levelInfo.origWidth;
      const mipHeight = levelInfo.origHeight;
      const dst = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(mip, 0, 0, transcoderFormat));
      const status = ktx2File.transcodeImage(dst, mip, 0, 0, transcoderFormat, 0, -1, -1);
      if (!status) {
        cleanup();
        throw new Error("KTX2TextureTranscoder: .transcodeImage failed.");
      }
      mipmaps.push({ data: dst, width: mipWidth, height: mipHeight });
    }
    cleanup();
    return { width, height, hasAlpha, mipmaps, format: engineFormat, dfdTransferFn, dfdFlags };
  }
  const FORMAT_OPTIONS = [{
    if: "astcSupported",
    basisFormat: [BasisFormat2.UASTC_4x4],
    transcoderFormat: [TranscoderFormat2.ASTC_4x4, TranscoderFormat2.ASTC_4x4],
    engineFormat: [EngineFormat2.RGBA_ASTC_4x4_Format, EngineFormat2.RGBA_ASTC_4x4_Format],
    priorityETC1S: Infinity,
    priorityUASTC: 1,
    needsPowerOfTwo: false
  }, {
    if: "bptcSupported",
    basisFormat: [BasisFormat2.ETC1S, BasisFormat2.UASTC_4x4],
    transcoderFormat: [TranscoderFormat2.BC7_M5, TranscoderFormat2.BC7_M5],
    engineFormat: [EngineFormat2.RGBA_BPTC_Format, EngineFormat2.RGBA_BPTC_Format],
    priorityETC1S: 3,
    priorityUASTC: 2,
    needsPowerOfTwo: false
  }, {
    if: "dxtSupported",
    basisFormat: [BasisFormat2.ETC1S, BasisFormat2.UASTC_4x4],
    transcoderFormat: [TranscoderFormat2.BC1, TranscoderFormat2.BC3],
    engineFormat: [EngineFormat2.RGB_S3TC_DXT1_Format, EngineFormat2.RGBA_S3TC_DXT5_Format],
    priorityETC1S: 4,
    priorityUASTC: 5,
    needsPowerOfTwo: false
  }, {
    if: "etc2Supported",
    basisFormat: [BasisFormat2.ETC1S, BasisFormat2.UASTC_4x4],
    transcoderFormat: [TranscoderFormat2.ETC1, TranscoderFormat2.ETC2],
    engineFormat: [EngineFormat2.RGB_ETC2_Format, EngineFormat2.RGBA_ETC2_EAC_Format],
    priorityETC1S: 1,
    priorityUASTC: 3,
    needsPowerOfTwo: false
  }, {
    if: "etc1Supported",
    basisFormat: [BasisFormat2.ETC1S, BasisFormat2.UASTC_4x4],
    transcoderFormat: [TranscoderFormat2.ETC1],
    engineFormat: [EngineFormat2.RGB_ETC1_Format],
    priorityETC1S: 2,
    priorityUASTC: 4,
    needsPowerOfTwo: false
  }, {
    if: "pvrtcSupported",
    basisFormat: [BasisFormat2.ETC1S, BasisFormat2.UASTC_4x4],
    transcoderFormat: [TranscoderFormat2.PVRTC1_4_RGB, TranscoderFormat2.PVRTC1_4_RGBA],
    engineFormat: [EngineFormat2.RGB_PVRTC_4BPPV1_Format, EngineFormat2.RGBA_PVRTC_4BPPV1_Format],
    priorityETC1S: 5,
    priorityUASTC: 6,
    needsPowerOfTwo: true
  }];
  const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function(a2, b4) {
    return a2.priorityETC1S - b4.priorityETC1S;
  });
  const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function(a2, b4) {
    return a2.priorityUASTC - b4.priorityUASTC;
  });
  function getTranscoderFormat(basisFormat, width, height, hasAlpha) {
    let transcoderFormat;
    let engineFormat;
    const options = basisFormat === BasisFormat2.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;
    for (let i = 0; i < options.length; i++) {
      const opt = options[i];
      if (!config2[opt.if])
        continue;
      if (!opt.basisFormat.includes(basisFormat))
        continue;
      if (hasAlpha && opt.transcoderFormat.length < 2)
        continue;
      if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height)))
        continue;
      transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];
      engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];
      return {
        transcoderFormat,
        engineFormat
      };
    }
    console.warn("KTX2TextureTranscoder: No suitable compressed texture format found. Decoding to RGBA32.");
    transcoderFormat = TranscoderFormat2.RGBA32;
    engineFormat = EngineFormat2.RGBAFormat;
    return {
      transcoderFormat,
      engineFormat
    };
  }
  function isPowerOfTwo(value) {
    if (value <= 2)
      return true;
    return (value & value - 1) === 0 && value !== 0;
  }
};

// ../sdk/src/webglutils/WebGLArrayBuf.ts
var WebGLArrayBuf = class {
  /**
   * WebGL2 rendering context.
   */
  gl;
  /**
   * The ArrayBuffer's item type.
   */
  itemType;
  /**
   * Byte size of each item.
   */
  itemByteSize;
  /**
   * The ArrayBuffer type.
   */
  type;
  /**
   * Allocated yet?
   */
  allocated;
  /**
   * A GLenum specifying the intended usage pattern of the data store for optimization purposes. Possible values:
   *
   * * gl.STATIC_DRAW : The contents are intended to be specified once by the application, and used many times as the source for WebGL drawing and image specification commands.
   * * gl.DYNAMIC_DRAW : The contents are intended to be respecified repeatedly by the application, and used many times as the source for WebGL drawing and image specification commands.
   * * gl.STREAM_DRAW : The contents are intended to be specified once by the application, and used at most a few times as the source for WebGL drawing and image specification commands.
   * * gl.STATIC_READ : The contents are intended to be specified once by reading data from WebGL, and queried many times by the application.
   * * gl.DYNAMIC_READ : The contents are intended to be respecified repeatedly by reading data from WebGL, and queried many times by the application.
   * * gl.STREAM_READ : The contents are intended to be specified once by reading data from WebGL, and queried at most a few times by the application
   * * gl.STATIC_COPY : The contents are intended to be specified once by reading data from WebGL, and used many times as the source for WebGL drawing and image specification commands.
   * * gl.DYNAMIC_COPY : The contents are intended to be respecified repeatedly by reading data from WebGL, and used many times as the source for WebGL drawing and image specification commands.
   * * gl.STREAM_COPY : The contents are intended to be specified once by reading data from WebGL, and used at most a few times as the source for WebGL drawing and image specification commands.
   */
  usage;
  /**
   * The ArrayBuffer type.
   */
  length;
  /**
   *
   */
  dataLength;
  /**
   * Number of items in the ArrayBuffer.
   */
  numItems;
  /**
   * Size of each item.
   */
  itemSize;
  /**
   * True when ArrayBuffer values are normalized.
   */
  normalized;
  /**
   * The ArrayBuffer stride.
   */
  stride;
  /**
   *
   */
  offset;
  /**
   * Hand to a WebGLBuffer.
   */
  handle;
  /**
   * Creates a WebGL ArrayBuffer.
   */
  constructor(gl, type, data, numItems, itemSize, usage, normalized, stride, offset) {
    this.gl = gl;
    this.type = type;
    this.allocated = false;
    switch (data.constructor) {
      case Uint8Array:
        this.itemType = gl.UNSIGNED_BYTE;
        this.itemByteSize = 1;
        break;
      case Int8Array:
        this.itemType = gl.BYTE;
        this.itemByteSize = 1;
        break;
      case Uint16Array:
        this.itemType = gl.UNSIGNED_SHORT;
        this.itemByteSize = 2;
        break;
      case Int16Array:
        this.itemType = gl.SHORT;
        this.itemByteSize = 2;
        break;
      case Uint32Array:
        this.itemType = gl.UNSIGNED_INT;
        this.itemByteSize = 4;
        break;
      case Int32Array:
        this.itemType = gl.INT;
        this.itemByteSize = 4;
        break;
      default:
        this.itemType = gl.FLOAT;
        this.itemByteSize = 4;
    }
    this.usage = usage;
    this.length = 0;
    this.dataLength = numItems;
    this.numItems = 0;
    this.itemSize = itemSize;
    this.normalized = !!normalized;
    this.stride = stride || 0;
    this.offset = offset || 0;
    this._allocate(data);
  }
  _allocate(data) {
    this.allocated = false;
    this.handle = this.gl.createBuffer();
    if (!this.handle) {
      throw new Error("Failed to allocate WebGL ArrayBuffer");
    }
    if (this.handle) {
      this.gl.bindBuffer(this.type, this.handle);
      this.gl.bufferData(this.type, data.length > this.dataLength ? data.slice(0, this.dataLength) : data, this.usage);
      this.gl.bindBuffer(this.type, null);
      this.length = data.length;
      this.numItems = this.length / this.itemSize;
      this.allocated = true;
    }
  }
  /**
   * Updates the contents of this ArrayBuffer.
   * @param data
   * @param offset
   */
  setData(data, offset) {
    if (!this.allocated) {
      return;
    }
    if (data.length + (offset || 0) > this.length) {
      this.destroy();
      this._allocate(data);
    } else {
      this.gl.bindBuffer(this.type, this.handle);
      if (offset || offset === 0) {
        this.gl.bufferSubData(this.type, offset * this.itemByteSize, data);
      } else {
        this.gl.bufferData(this.type, data, this.usage);
      }
      this.gl.bindBuffer(this.type, null);
    }
  }
  /**
   * Binds this ArrayBuffer to the WebGL rendering context.
   */
  bind() {
    if (!this.allocated) {
      return;
    }
    this.gl.bindBuffer(this.type, this.handle);
  }
  /**
   * Unbinds this ArrayBuffer from the WebGL rendering context.
   */
  unbind() {
    if (!this.allocated) {
      return;
    }
    this.gl.bindBuffer(this.type, null);
  }
  /**
   * Destroys this ArrayBuffer.
   */
  destroy() {
    if (!this.allocated) {
      return;
    }
    this.gl.deleteBuffer(this.handle);
    this.allocated = false;
  }
};

// ../sdk/src/webglutils/WebGLAttribute.ts
var WebGLAttribute = class {
  gl;
  location;
  /**
   * Creates a new vertex attribute.
   * @param gl
   * @param location
   */
  constructor(gl, location) {
    this.gl = gl;
    this.location = location;
  }
  /**
   * Binds an array buffer to this vertex attribute.
   * @param arrayBuf
   */
  bindArrayBuffer(arrayBuf) {
    if (!arrayBuf) {
      return;
    }
    arrayBuf.bind();
    this.gl.enableVertexAttribArray(this.location);
    this.gl.vertexAttribPointer(this.location, arrayBuf.itemSize, arrayBuf.itemType, arrayBuf.normalized, arrayBuf.stride, arrayBuf.offset);
  }
};

// ../sdk/src/webglutils/WebGLShader.ts
var WebGLShader = class {
  /**
   * Compilation errors, if any.
   */
  errors;
  /**
   * True when this shader was successfully allocated.
   */
  allocated;
  /**
   * True when this shader was successfully compiled.
   */
  compiled;
  /**
   * Handle to GPU-resident WebGL2 shader.
   */
  handle;
  /**
   * Creates a new shader.
   * @param gl
   * @param type
   * @param source
   */
  constructor(gl, type, source) {
    this.allocated = false;
    this.compiled = false;
    this.handle = gl.createShader(type);
    if (!this.handle) {
      this.errors = [
        "Failed to allocate"
      ];
      return;
    }
    this.allocated = true;
    gl.shaderSource(this.handle, source);
    gl.compileShader(this.handle);
    this.compiled = gl.getShaderParameter(this.handle, gl.COMPILE_STATUS);
    if (!this.compiled) {
      if (!gl.isContextLost()) {
        const lines = source.split("\n");
        const numberedLines = [];
        for (let i = 0; i < lines.length; i++) {
          numberedLines.push(i + 1 + ": " + lines[i] + "\n");
        }
        this.errors = [];
        this.errors.push("");
        this.errors.push(gl.getShaderInfoLog(this.handle) || "");
        this.errors = this.errors.concat(numberedLines.join(""));
      }
    }
  }
  /**
   * Destroys this shader.
   */
  destroy() {
  }
};

// ../sdk/src/webglutils/WebGLSampler.ts
var WebGLSampler = class {
  location;
  gl;
  /**
   * Creates a new sampler.
   * @param gl
   * @param location
   */
  constructor(gl, location) {
    this.gl = gl;
    this.location = location;
  }
  /**
   * Binds a texture to this sampler.
   * @param texture
   * @param unit
   */
  bindTexture(texture, unit) {
    if (texture.bind(unit)) {
      this.gl.uniform1i(this.location, unit);
      return true;
    }
    return false;
  }
};

// ../sdk/src/webglutils/WebGLProgram.ts
var ids = new Map2({}, "");
var WebGLProgram = class {
  /**
   * Unique ID of this program.
   */
  id;
  /**
   * The vertex shader.
   */
  vertexShader;
  /**
   * The fragment shader.
   */
  fragmentShader;
  /**
   * Map of all attributes in this program.
   */
  attributes;
  /**
   * Map of all samplers in this program.
   */
  samplers;
  /**
   * Map of all uniforms in this program.
   */
  uniforms;
  /**
   * List of compilation errors for this program, if any.
   */
  errors;
  /**
   * Flag set true when program has been validated.
   */
  validated;
  /**
   * Flag set true when this program has been successfully linked.
   */
  linked;
  /**
   * Flag set true when this program has been successfully conpiled.
   */
  compiled;
  /**
   * Flag set true when this program has been successfully allocated.
   */
  allocated;
  /**
   * The WebGL2 rendering context.
   */
  gl;
  /**
   * The source code from which the shaders are built.
   */
  source;
  /**
   * Handle to the WebGL program itself, which resides on the GPU.
   */
  handle;
  /**
   * Creates a new program.
   * @param gl
   * @param shaderSource
   */
  constructor(gl, shaderSource) {
    this.id = ids.addItem({});
    this.source = shaderSource;
    this.gl = gl;
    this.allocated = false;
    this.compiled = false;
    this.linked = false;
    this.validated = false;
    this.errors = void 0;
    this.uniforms = {};
    this.samplers = {};
    this.attributes = {};
    this.vertexShader = new WebGLShader(gl, gl.VERTEX_SHADER, this.source.vertex);
    this.fragmentShader = new WebGLShader(gl, gl.FRAGMENT_SHADER, this.source.fragment);
    if (!this.vertexShader.allocated) {
      this.errors = ["Vertex shader failed to allocate"].concat(this.vertexShader.errors);
      logErrors(this.errors);
      return;
    }
    if (!this.fragmentShader.allocated) {
      this.errors = ["Fragment shader failed to allocate"].concat(this.fragmentShader.errors);
      logErrors(this.errors);
      return;
    }
    this.allocated = true;
    if (!this.vertexShader.compiled) {
      this.errors = ["Vertex shader failed to compile"].concat(this.vertexShader.errors);
      logErrors(this.errors);
      return;
    }
    if (!this.fragmentShader.compiled) {
      this.errors = ["Fragment shader failed to compile"].concat(this.fragmentShader.errors);
      logErrors(this.errors);
      return;
    }
    this.compiled = true;
    this.handle = gl.createProgram();
    if (!this.handle) {
      this.errors = ["Failed to allocate program"];
      return;
    }
    gl.attachShader(this.handle, this.vertexShader.handle);
    gl.attachShader(this.handle, this.fragmentShader.handle);
    gl.linkProgram(this.handle);
    this.linked = gl.getProgramParameter(this.handle, gl.LINK_STATUS);
    this.validated = true;
    if (!this.linked || !this.validated) {
      this.errors = [];
      this.errors.push("");
      this.errors.push(gl.getProgramInfoLog(this.handle));
      this.errors.push("\nVertex shader:\n");
      this.errors = this.errors.concat(this.source.vertex);
      this.errors.push("\nFragment shader:\n");
      this.errors = this.errors.concat(this.source.fragment);
      logErrors(this.errors);
      return;
    }
    const numUniforms = gl.getProgramParameter(this.handle, gl.ACTIVE_UNIFORMS);
    for (let i = 0; i < numUniforms; ++i) {
      const u = gl.getActiveUniform(this.handle, i);
      if (u) {
        let uName = u.name;
        if (uName[uName.length - 1] === "\0") {
          uName = uName.substr(0, uName.length - 1);
        }
        const location = gl.getUniformLocation(this.handle, uName);
        if (u.type === gl.SAMPLER_2D || u.type === gl.SAMPLER_CUBE || u.type === 35682 || u.type === 36306) {
          this.samplers[uName] = new WebGLSampler(gl, location);
        } else {
          this.uniforms[uName] = location;
        }
      }
    }
    const numAttribs = gl.getProgramParameter(this.handle, gl.ACTIVE_ATTRIBUTES);
    for (let i = 0; i < numAttribs; i++) {
      const a2 = gl.getActiveAttrib(this.handle, i);
      if (a2) {
        const location = gl.getAttribLocation(this.handle, a2.name);
        this.attributes[a2.name] = new WebGLAttribute(gl, location);
      }
    }
    this.allocated = true;
  }
  /**
   * Binds this program.
   */
  bind() {
    if (!this.allocated) {
      return;
    }
    this.gl.useProgram(this.handle);
  }
  /**
   * Gets the location of the given uniform within this program.
   * @param name
   */
  getLocation(name12) {
    return this.uniforms[name12];
  }
  /**
   * Gets an attribute within this program.
   * @param name
   */
  getAttribute(name12) {
    return this.attributes[name12];
  }
  /**
   * Gets a sampler within this program.
   * @param name
   */
  getSampler(name12) {
    return this.samplers[name12];
  }
  /**
   * Binds a texture to this program.
   * @param name
   * @param texture
   * @param unit
   */
  bindTexture(name12, texture, unit) {
    if (!this.allocated) {
      return false;
    }
    const sampler = this.samplers[name12];
    if (sampler) {
      return sampler.bindTexture(texture, unit);
    } else {
      return false;
    }
  }
  /**
   * Destroys this program.
   */
  destroy() {
    if (!this.allocated) {
      return;
    }
    ids.removeItem(this.id);
    this.gl.deleteProgram(this.handle);
    this.gl.deleteShader(this.vertexShader.handle);
    this.gl.deleteShader(this.fragmentShader.handle);
    this.attributes = {};
    this.uniforms = {};
    this.samplers = {};
    this.allocated = false;
  }
};
function logErrors(errors) {
  console.error(errors.join("\n"));
}

// ../sdk/src/webglutils/WebGLRenderBuffer.ts
var WebGLRenderBuffer = class {
  #gl;
  allocated;
  canvas;
  #buffer;
  bound;
  size;
  #imageDataCache;
  #texture;
  #depthTexture;
  #hasDepthTexture;
  constructor(canvas2, gl, options) {
    this.#gl = gl;
    this.allocated = false;
    this.canvas = canvas2;
    this.#buffer = null;
    this.bound = false;
    this.size = options.size;
    this.#hasDepthTexture = !!options.depthTexture;
  }
  /**
   * Sets the size of this render buffer.
   * @param size
   */
  setSize(size) {
    this.size = size;
  }
  webglContextRestored(gl) {
    this.#gl = gl;
    this.#buffer = null;
    this.allocated = false;
    this.bound = false;
  }
  /**
   * Binds this render buffer.
   */
  bind(...internalformats) {
    this.touch(...internalformats);
    if (this.bound) {
      return;
    }
    const gl = this.#gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.#buffer.framebuf);
    this.bound = true;
  }
  /**
   * Create and specify a WebGL texture image.
   *
   * @param { number } width
   * @param { number } height
   * @param { GLenum } [internalformat=null]
   *
   * @returns { WebGLTexture }
   */
  createTexture(width, height, internalformat = null) {
    const gl = this.#gl;
    const colorTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, colorTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    if (internalformat) {
      gl.texStorage2D(gl.TEXTURE_2D, 1, internalformat, width, height);
    } else {
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    }
    return colorTexture;
  }
  /**
   *
   * @param {number[]} [internalformats=[]]
   * @returns
   */
  touch(...internalformats) {
    let width;
    let height;
    const gl = this.#gl;
    if (this.size) {
      width = this.size[0];
      height = this.size[1];
    } else {
      width = gl.drawingBufferWidth;
      height = gl.drawingBufferHeight;
    }
    if (this.#buffer) {
      if (this.#buffer.width === width && this.#buffer.height === height) {
        return;
      } else {
        this.#buffer.textures.forEach((texture) => gl.deleteTexture(texture));
        gl.deleteFramebuffer(this.#buffer.framebuf);
        gl.deleteRenderbuffer(this.#buffer.renderbuf);
      }
    }
    const colorTextures = [];
    if (internalformats.length > 0) {
      colorTextures.push(...internalformats.map((internalformat) => this.createTexture(width, height, internalformat)));
    } else {
      colorTextures.push(this.createTexture(width, height));
    }
    let depthTexture;
    if (this.#hasDepthTexture) {
      depthTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, depthTexture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT32F, width, height, 0, gl.DEPTH_COMPONENT, gl.FLOAT, null);
    }
    const renderbuf = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuf);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT32F, width, height);
    const framebuf = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuf);
    for (let i = 0; i < colorTextures.length; i++) {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, colorTextures[i], 0);
    }
    if (internalformats.length > 0) {
      gl.drawBuffers(colorTextures.map((_, i) => gl.COLOR_ATTACHMENT0 + i));
    }
    if (this.#hasDepthTexture) {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture, 0);
    } else {
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuf);
    }
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuf);
    if (!gl.isFramebuffer(framebuf)) {
      throw "Invalid framebuffer";
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    switch (status) {
      case gl.FRAMEBUFFER_COMPLETE:
        break;
      case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        throw "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
      case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        throw "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
      case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        throw "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
      case gl.FRAMEBUFFER_UNSUPPORTED:
        throw "Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED";
      default:
        throw "Incomplete framebuffer: " + status;
    }
    this.#buffer = {
      framebuf,
      renderbuf,
      texture: colorTextures[0],
      textures: colorTextures,
      depthTexture,
      width,
      height
    };
    this.bound = false;
  }
  /**
   * Clears this render buffer.
   */
  clear() {
    if (!this.bound) {
      throw "Render buffer not bound";
    }
    const gl = this.#gl;
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  }
  /**
   * Reads a pixel from this render buffer.
   * @param pickX
   * @param pickY
   */
  read(pickX, pickY, glFormat = null, glType = null, arrayType = Uint8Array, arrayMultiplier = 4, colorBufferIndex = 0) {
    const x = pickX;
    const y = this.#buffer.height ? this.#buffer.height - pickY - 1 : this.#gl.drawingBufferHeight - pickY;
    const pix = new arrayType(arrayMultiplier);
    const gl = this.#gl;
    gl.readBuffer(gl.COLOR_ATTACHMENT0 + colorBufferIndex);
    gl.readPixels(x, y, 1, 1, glFormat || gl.RGBA, glType || gl.UNSIGNED_BYTE, pix, 0);
    return pix;
  }
  readArray(glFormat = null, glType = null, arrayType = Uint8Array, arrayMultiplier = 4, colorBufferIndex = 0) {
    const pix = new arrayType(this.#buffer.width * this.#buffer.height * arrayMultiplier);
    const gl = this.#gl;
    gl.readBuffer(gl.COLOR_ATTACHMENT0 + colorBufferIndex);
    gl.readPixels(0, 0, this.#buffer.width, this.#buffer.height, glFormat || gl.RGBA, glType || gl.UNSIGNED_BYTE, pix, 0);
    return pix;
  }
  /**
   * Returns an HTMLCanvas containing the contents of the RenderBuffer as an image.
   *
   * - The HTMLCanvas has a CanvasRenderingContext2D.
   * - Expects the caller to draw more things on the HTMLCanvas (annotations etc).
   *
   * @returns {HTMLCanvasElement}
   */
  readImageAsCanvas() {
    const gl = this.#gl;
    const imageDataCache = this._getImageDataCache();
    const canvas2 = imageDataCache.canvas;
    return canvas2;
  }
  /**
   * Redas an image from this render buffer.
   * @param params
   */
  readImage(params2) {
    const gl = this.#gl;
    const imageDataCache = this._getImageDataCache();
    const pixelData = imageDataCache.pixelData;
    const canvas2 = imageDataCache.canvas;
    const imageData = imageDataCache.imageData;
    const context = imageDataCache.context;
    const { width, height } = this.#buffer;
    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixelData);
    imageData.data.set(pixelData);
    context.putImageData(imageData, 0, 0);
    context.save();
    context.globalCompositeOperation = "copy";
    context.scale(1, -1);
    context.drawImage(canvas2, 0, -height, width, height);
    context.restore();
    let format = params2.format || "png";
    if (format !== "jpeg" && format !== "png" && format !== "bmp") {
      console.error("Unsupported image format: '" + format + "' - supported types are 'jpeg', 'bmp' and 'png' - defaulting to 'png'");
      format = "png";
    }
    return canvas2.toDataURL(`image/${format}`);
  }
  _getImageDataCache(type = Uint8Array, multiplier = 4) {
    const bufferWidth = this.#buffer.width;
    const bufferHeight = this.#buffer.height;
    let imageDataCache = this.#imageDataCache;
    if (imageDataCache) {
      if (imageDataCache.width !== bufferWidth || imageDataCache.height !== bufferHeight) {
        this.#imageDataCache = null;
        imageDataCache = null;
      }
    }
    if (!imageDataCache) {
      const canvas2 = document.createElement("canvas");
      const context = canvas2.getContext("2d");
      canvas2.width = bufferWidth;
      canvas2.height = bufferHeight;
      imageDataCache = {
        pixelData: new type(bufferWidth * bufferHeight * multiplier),
        canvas: canvas2,
        context,
        imageData: context.createImageData(bufferWidth, bufferHeight),
        width: bufferWidth,
        height: bufferHeight
      };
      this.#imageDataCache = imageDataCache;
    }
    imageDataCache.context.resetTransform();
    return imageDataCache;
  }
  unbind() {
    const gl = this.#gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    this.bound = false;
  }
  getTexture() {
    return this.#texture || (this.#texture = {
      bind: (unit) => {
        if (this.#buffer && this.#buffer.texture) {
          this.#gl.activeTexture(this.#gl["TEXTURE" + unit]);
          this.#gl.bindTexture(this.#gl.TEXTURE_2D, this.#buffer.texture);
          return true;
        }
        return false;
      },
      unbind: (unit) => {
        if (this.#buffer && this.#buffer.texture) {
          this.#gl.activeTexture(this.#gl["TEXTURE" + unit]);
          this.#gl.bindTexture(this.#gl.TEXTURE_2D, null);
        }
      }
    });
  }
  hasDepthTexture() {
    return this.#hasDepthTexture;
  }
  /**
   * Gets the depth texture component of this render buffer, if any.
   */
  getDepthTexture() {
    if (!this.#hasDepthTexture) {
      return null;
    }
    return this.#depthTexture || (this.#depthTexture = {
      bind: (unit) => {
        if (this.#buffer && this.#buffer.depthTexture) {
          this.#gl.activeTexture(this.#gl["TEXTURE" + unit]);
          this.#gl.bindTexture(this.#gl.TEXTURE_2D, this.#buffer.depthTexture);
          return true;
        }
        return false;
      },
      unbind: (unit) => {
        if (this.#buffer && this.#buffer.depthTexture) {
          this.#gl.activeTexture(this.#gl["TEXTURE" + unit]);
          this.#gl.bindTexture(this.#gl.TEXTURE_2D, null);
        }
      }
    });
  }
  destroy() {
    if (this.allocated) {
      const gl = this.#gl;
      this.#buffer.textures.forEach((texture) => gl.deleteTexture(texture));
      gl.deleteTexture(this.#buffer.depthTexture);
      gl.deleteFramebuffer(this.#buffer.framebuf);
      gl.deleteRenderbuffer(this.#buffer.renderbuf);
      this.allocated = false;
      this.#buffer = null;
      this.bound = false;
    }
    this.#imageDataCache = null;
    this.#texture = null;
    this.#depthTexture = null;
  }
};

// ../sdk/src/webglutils/getWebGLExtension.ts
function getWebGLExtension(gl, name12) {
  if (gl._cachedExtensions === void 0) {
    gl._cachedExtensions = {};
  }
  if (gl._cachedExtensions[name12] !== void 0) {
    return gl._cachedExtensions[name12];
  }
  let extension;
  switch (name12) {
    case "WEBGL_depth_texture":
      extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
      break;
    case "EXT_texture_filter_anisotropic":
      extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
      break;
    case "WEBGL_compressed_texture_s3tc":
      extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
      break;
    case "WEBGL_compressed_texture_pvrtc":
      extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
      break;
    default:
      extension = gl.getExtension(name12);
  }
  gl._cachedExtensions[name12] = extension;
  return extension;
}

// ../sdk/src/webglutils/convertWebGLConstant.ts
function convertWebGLConstant(gl, constantVal, encoding) {
  let extension;
  const p = constantVal;
  if (p === UnsignedByteType)
    return gl.UNSIGNED_BYTE;
  if (p === UnsignedShort4444Type)
    return gl.UNSIGNED_SHORT_4_4_4_4;
  if (p === UnsignedShort5551Type)
    return gl.UNSIGNED_SHORT_5_5_5_1;
  if (p === ByteType)
    return gl.BYTE;
  if (p === ShortType)
    return gl.SHORT;
  if (p === UnsignedShortType)
    return gl.UNSIGNED_SHORT;
  if (p === IntType)
    return gl.INT;
  if (p === UnsignedIntType)
    return gl.UNSIGNED_INT;
  if (p === FloatType)
    return gl.FLOAT;
  if (p === HalfFloatType) {
    return gl.HALF_FLOAT;
  }
  if (p === AlphaFormat)
    return gl.ALPHA;
  if (p === RGBAFormat)
    return gl.RGBA;
  if (p === LuminanceFormat)
    return gl.LUMINANCE;
  if (p === LuminanceAlphaFormat)
    return gl.LUMINANCE_ALPHA;
  if (p === DepthFormat)
    return gl.DEPTH_COMPONENT;
  if (p === DepthStencilFormat)
    return gl.DEPTH_STENCIL;
  if (p === RedFormat)
    return gl.RED;
  if (p === RGBFormat) {
    return gl.RGBA;
  }
  if (p === RedIntegerFormat)
    return gl.RED_INTEGER;
  if (p === RGFormat)
    return gl.RG;
  if (p === RGIntegerFormat)
    return gl.RG_INTEGER;
  if (p === RGBAIntegerFormat)
    return gl.RGBA_INTEGER;
  if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
    if (encoding === sRGBEncoding) {
      const extension2 = getWebGLExtension(gl, "WEBGL_compressed_texture_s3tc_srgb");
      if (extension2 !== null) {
        if (p === RGB_S3TC_DXT1_Format)
          return extension2.COMPRESSED_SRGB_S3TC_DXT1_EXT;
        if (p === RGBA_S3TC_DXT1_Format)
          return extension2.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
        if (p === RGBA_S3TC_DXT3_Format)
          return extension2.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
        if (p === RGBA_S3TC_DXT5_Format)
          return extension2.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
      } else {
        return null;
      }
    } else {
      extension = getWebGLExtension(gl, "WEBGL_compressed_texture_s3tc");
      if (extension !== null) {
        if (p === RGB_S3TC_DXT1_Format)
          return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (p === RGBA_S3TC_DXT1_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (p === RGBA_S3TC_DXT3_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (p === RGBA_S3TC_DXT5_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else {
        return null;
      }
    }
  }
  if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
    const extension2 = getWebGLExtension(gl, "WEBGL_compressed_texture_pvrtc");
    if (extension2 !== null) {
      if (p === RGB_PVRTC_4BPPV1_Format)
        return extension2.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
      if (p === RGB_PVRTC_2BPPV1_Format)
        return extension2.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
      if (p === RGBA_PVRTC_4BPPV1_Format)
        return extension2.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
      if (p === RGBA_PVRTC_2BPPV1_Format)
        return extension2.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
    } else {
      return null;
    }
  }
  if (p === RGB_ETC1_Format) {
    const extension2 = getWebGLExtension(gl, "WEBGL_compressed_texture_etc1");
    if (extension2 !== null) {
      return extension2.COMPRESSED_RGB_ETC1_WEBGL;
    } else {
      return null;
    }
  }
  if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
    const extension2 = getWebGLExtension(gl, "WEBGL_compressed_texture_etc");
    if (extension2 !== null) {
      if (p === RGB_ETC2_Format)
        return encoding === sRGBEncoding ? extension2.COMPRESSED_SRGB8_ETC2 : extension2.COMPRESSED_RGB8_ETC2;
      if (p === RGBA_ETC2_EAC_Format)
        return encoding === sRGBEncoding ? extension2.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension2.COMPRESSED_RGBA8_ETC2_EAC;
    } else {
      return null;
    }
  }
  if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
    const extension2 = getWebGLExtension(gl, "WEBGL_compressed_texture_astc");
    if (extension2 !== null) {
      if (p === RGBA_ASTC_4x4_Format)
        return encoding === sRGBEncoding ? extension2.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension2.COMPRESSED_RGBA_ASTC_4x4_KHR;
      if (p === RGBA_ASTC_5x4_Format)
        return encoding === sRGBEncoding ? extension2.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension2.COMPRESSED_RGBA_ASTC_5x4_KHR;
      if (p === RGBA_ASTC_5x5_Format)
        return encoding === sRGBEncoding ? extension2.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension2.COMPRESSED_RGBA_ASTC_5x5_KHR;
      if (p === RGBA_ASTC_6x5_Format)
        return encoding === sRGBEncoding ? extension2.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension2.COMPRESSED_RGBA_ASTC_6x5_KHR;
      if (p === RGBA_ASTC_6x6_Format)
        return encoding === sRGBEncoding ? extension2.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension2.COMPRESSED_RGBA_ASTC_6x6_KHR;
      if (p === RGBA_ASTC_8x5_Format)
        return encoding === sRGBEncoding ? extension2.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension2.COMPRESSED_RGBA_ASTC_8x5_KHR;
      if (p === RGBA_ASTC_8x6_Format)
        return encoding === sRGBEncoding ? extension2.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension2.COMPRESSED_RGBA_ASTC_8x6_KHR;
      if (p === RGBA_ASTC_8x8_Format)
        return encoding === sRGBEncoding ? extension2.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension2.COMPRESSED_RGBA_ASTC_8x8_KHR;
      if (p === RGBA_ASTC_10x5_Format)
        return encoding === sRGBEncoding ? extension2.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension2.COMPRESSED_RGBA_ASTC_10x5_KHR;
      if (p === RGBA_ASTC_10x6_Format)
        return encoding === sRGBEncoding ? extension2.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension2.COMPRESSED_RGBA_ASTC_10x6_KHR;
      if (p === RGBA_ASTC_10x8_Format)
        return encoding === sRGBEncoding ? extension2.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension2.COMPRESSED_RGBA_ASTC_10x8_KHR;
      if (p === RGBA_ASTC_10x10_Format)
        return encoding === sRGBEncoding ? extension2.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension2.COMPRESSED_RGBA_ASTC_10x10_KHR;
      if (p === RGBA_ASTC_12x10_Format)
        return encoding === sRGBEncoding ? extension2.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension2.COMPRESSED_RGBA_ASTC_12x10_KHR;
      if (p === RGBA_ASTC_12x12_Format)
        return encoding === sRGBEncoding ? extension2.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension2.COMPRESSED_RGBA_ASTC_12x12_KHR;
    } else {
      return null;
    }
  }
  if (p === RGBA_BPTC_Format) {
    const extension2 = getWebGLExtension(gl, "EXT_texture_compression_bptc");
    if (extension2 !== null) {
      if (p === RGBA_BPTC_Format) {
        return encoding === sRGBEncoding ? extension2.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension2.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      }
    } else {
      return null;
    }
  }
  if (p === UnsignedInt248Type) {
    return gl.UNSIGNED_INT_24_8;
  }
  if (p === RepeatWrapping) {
    return gl.REPEAT;
  }
  if (p === ClampToEdgeWrapping) {
    return gl.CLAMP_TO_EDGE;
  }
  if (p === NearestMipMapNearestFilter) {
    return gl.NEAREST_MIPMAP_LINEAR;
  }
  if (p === NearestMipMapLinearFilter) {
    return gl.NEAREST_MIPMAP_LINEAR;
  }
  if (p === LinearMipMapNearestFilter) {
    return gl.LINEAR_MIPMAP_NEAREST;
  }
  if (p === LinearMipMapLinearFilter) {
    return gl.LINEAR_MIPMAP_LINEAR;
  }
  if (p === NearestFilter) {
    return gl.NEAREST;
  }
  if (p === LinearFilter) {
    return gl.LINEAR;
  }
  return null;
}

// ../sdk/src/webglutils/WebGLTexture.ts
var color = new Uint8Array([0, 0, 0, 1]);
var WebGLTexture = class {
  gl;
  target;
  format;
  type;
  internalFormat;
  premultiplyAlpha;
  flipY;
  unpackAlignment;
  wrapS;
  wrapT;
  wrapR;
  texture;
  allocated;
  minFilter;
  magFilter;
  encoding;
  constructor(params2) {
    this.gl = params2.gl;
    this.target = params2.target || params2.gl.TEXTURE_2D;
    this.format = params2.format || RGBAFormat;
    this.type = params2.type || UnsignedByteType;
    this.internalFormat = -1;
    this.premultiplyAlpha = !!params2.premultiplyAlpha;
    this.flipY = !!params2.flipY;
    this.unpackAlignment = 4;
    this.wrapS = params2.wrapS || RepeatWrapping;
    this.wrapT = params2.wrapT || RepeatWrapping;
    this.wrapR = params2.wrapR || RepeatWrapping;
    this.texture = params2.gl.createTexture();
    if (params2.preloadColor) {
      this.setPreloadColor(params2.preloadColor);
    }
    this.allocated = true;
  }
  setPreloadColor(value) {
    if (!value) {
      color[0] = 0;
      color[1] = 0;
      color[2] = 0;
      color[3] = 255;
    } else {
      color[0] = Math.floor(value[0] * 255);
      color[1] = Math.floor(value[1] * 255);
      color[2] = Math.floor(value[2] * 255);
      color[3] = Math.floor((value[3] !== void 0 ? value[3] : 1) * 255);
    }
    const gl = this.gl;
    gl.bindTexture(this.target, this.texture);
    if (this.target === gl.TEXTURE_CUBE_MAP) {
      const faces2 = [
        gl.TEXTURE_CUBE_MAP_POSITIVE_X,
        gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
        gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
        gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
        gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
        gl.TEXTURE_CUBE_MAP_NEGATIVE_Z
      ];
      for (let i = 0, len = faces2.length; i < len; i++) {
        gl.texImage2D(faces2[i], 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, color);
      }
    } else {
      gl.texImage2D(this.target, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, color);
    }
    gl.bindTexture(this.target, null);
  }
  setTarget(target) {
    this.target = target || this.gl.TEXTURE_2D;
  }
  setImage(image, props = {}) {
    const gl = this.gl;
    if (props.format !== void 0) {
      this.format = props.format;
    }
    if (props.internalFormat !== void 0) {
      this.internalFormat = props.internalFormat;
    }
    if (props.encoding !== void 0) {
      this.encoding = props.encoding;
    }
    if (props.type !== void 0) {
      this.type = props.type;
    }
    if (props.flipY !== void 0) {
      this.flipY = props.flipY;
    }
    if (props.premultiplyAlpha !== void 0) {
      this.premultiplyAlpha = props.premultiplyAlpha;
    }
    if (props.unpackAlignment !== void 0) {
      this.unpackAlignment = props.unpackAlignment;
    }
    if (props.minFilter !== void 0) {
      this.minFilter = props.minFilter;
    }
    if (props.magFilter !== void 0) {
      this.magFilter = props.magFilter;
    }
    if (props.wrapS !== void 0) {
      this.wrapS = props.wrapS;
    }
    if (props.wrapT !== void 0) {
      this.wrapT = props.wrapT;
    }
    if (props.wrapR !== void 0) {
      this.wrapR = props.wrapR;
    }
    let generateMipMap = false;
    gl.bindTexture(this.target, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, this.flipY);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, this.unpackAlignment);
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
    const minFilter = convertWebGLConstant(gl, this.minFilter);
    gl.texParameteri(this.target, gl.TEXTURE_MIN_FILTER, minFilter);
    if (minFilter === gl.NEAREST_MIPMAP_NEAREST || minFilter === gl.LINEAR_MIPMAP_NEAREST || minFilter === gl.NEAREST_MIPMAP_LINEAR || minFilter === gl.LINEAR_MIPMAP_LINEAR) {
      generateMipMap = true;
    }
    const magFilter = convertWebGLConstant(gl, this.magFilter);
    if (magFilter) {
      gl.texParameteri(this.target, gl.TEXTURE_MAG_FILTER, magFilter);
    }
    const wrapS = convertWebGLConstant(gl, this.wrapS);
    if (wrapS) {
      gl.texParameteri(this.target, gl.TEXTURE_WRAP_S, wrapS);
    }
    const wrapT = convertWebGLConstant(gl, this.wrapT);
    if (wrapT) {
      gl.texParameteri(this.target, gl.TEXTURE_WRAP_T, wrapT);
    }
    const glFormat = convertWebGLConstant(gl, this.format, this.encoding);
    const glType = convertWebGLConstant(gl, this.type);
    const glInternalFormat = getInternalFormat(gl, this.internalFormat, glFormat, glType, this.encoding, false);
    if (this.target === gl.TEXTURE_CUBE_MAP) {
      if (isArray(image)) {
        const images = image;
        const faces2 = [
          gl.TEXTURE_CUBE_MAP_POSITIVE_X,
          gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
          gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
          gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
          gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
          gl.TEXTURE_CUBE_MAP_NEGATIVE_Z
        ];
        for (let i = 0, len = faces2.length; i < len; i++) {
          gl.texImage2D(faces2[i], 0, glInternalFormat, glFormat, glType, images[i]);
        }
      }
    } else {
      gl.texImage2D(gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
    }
    gl.bindTexture(this.target, null);
  }
  setCompressedData(params2) {
    const gl = this.gl;
    const mipmaps = params2.mipmaps || [];
    const levels = mipmaps.length;
    const props = params2.props;
    if (props.format !== void 0) {
      this.format = props.format;
    }
    if (props.internalFormat !== void 0) {
      this.internalFormat = props.internalFormat;
    }
    if (props.encoding !== void 0) {
      this.encoding = props.encoding;
    }
    if (props.type !== void 0) {
      this.type = props.type;
    }
    if (props.flipY !== void 0) {
      this.flipY = props.flipY;
    }
    if (props.premultiplyAlpha !== void 0) {
      this.premultiplyAlpha = props.premultiplyAlpha;
    }
    if (props.unpackAlignment !== void 0) {
      this.unpackAlignment = props.unpackAlignment;
    }
    if (props.minFilter !== void 0) {
      this.minFilter = props.minFilter;
    }
    if (props.magFilter !== void 0) {
      this.magFilter = props.magFilter;
    }
    if (props.wrapS !== void 0) {
      this.wrapS = props.wrapS;
    }
    if (props.wrapT !== void 0) {
      this.wrapT = props.wrapT;
    }
    if (props.wrapR !== void 0) {
      this.wrapR = props.wrapR;
    }
    gl.activeTexture(gl.TEXTURE0 + 0);
    gl.bindTexture(this.target, this.texture);
    let supportsMips = mipmaps.length > 1;
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, this.flipY);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, this.unpackAlignment);
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
    const wrapS = convertWebGLConstant(gl, this.wrapS);
    if (wrapS) {
      gl.texParameteri(this.target, gl.TEXTURE_WRAP_S, wrapS);
    }
    const wrapT = convertWebGLConstant(gl, this.wrapT);
    if (wrapT) {
      gl.texParameteri(this.target, gl.TEXTURE_WRAP_T, wrapT);
    }
    if (this.type === gl.TEXTURE_3D || this.type === gl.TEXTURE_2D_ARRAY) {
      const wrapR = convertWebGLConstant(gl, this.wrapR);
      if (wrapR) {
        gl.texParameteri(this.target, gl.TEXTURE_WRAP_R, wrapR);
      }
      gl.texParameteri(this.type, gl.TEXTURE_WRAP_R, wrapR);
    }
    if (supportsMips) {
      gl.texParameteri(this.target, gl.TEXTURE_MIN_FILTER, filterFallback(gl, this.minFilter));
      gl.texParameteri(this.target, gl.TEXTURE_MAG_FILTER, filterFallback(gl, this.magFilter));
    } else {
      gl.texParameteri(this.target, gl.TEXTURE_MIN_FILTER, convertWebGLConstant(gl, this.minFilter));
      gl.texParameteri(this.target, gl.TEXTURE_MAG_FILTER, convertWebGLConstant(gl, this.magFilter));
    }
    const glFormat = convertWebGLConstant(gl, this.format, this.encoding);
    const glType = convertWebGLConstant(gl, this.type);
    const glInternalFormat = getInternalFormat(gl, this.internalFormat, glFormat, glType, this.encoding, false);
    gl.texStorage2D(gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
    for (let i = 0, len = mipmaps.length; i < len; i++) {
      const mipmap = mipmaps[i];
      if (this.format !== RGBAFormat) {
        if (glFormat !== null) {
          gl.compressedTexSubImage2D(gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
        } else {
          console.warn("Attempt to load unsupported compressed texture format in .setCompressedData()");
        }
      } else {
        gl.texSubImage2D(gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
      }
    }
    gl.bindTexture(this.target, null);
  }
  setProps(props) {
    const gl = this.gl;
    gl.bindTexture(this.target, this.texture);
    this._uploadProps(props);
    gl.bindTexture(this.target, null);
  }
  _uploadProps(props) {
    const gl = this.gl;
    if (props.format !== void 0) {
      this.format = props.format;
    }
    if (props.internalFormat !== void 0) {
      this.internalFormat = props.internalFormat;
    }
    if (props.encoding !== void 0) {
      this.encoding = props.encoding;
    }
    if (props.type !== void 0) {
      this.type = props.type;
    }
    if (props.minFilter !== void 0) {
      const minFilter = convertWebGLConstant(gl, props.minFilter);
      if (minFilter) {
        this.minFilter = props.minFilter;
        gl.texParameteri(this.target, gl.TEXTURE_MIN_FILTER, minFilter);
        if (minFilter === gl.NEAREST_MIPMAP_NEAREST || minFilter === gl.LINEAR_MIPMAP_NEAREST || minFilter === gl.NEAREST_MIPMAP_LINEAR || minFilter === gl.LINEAR_MIPMAP_LINEAR) {
          gl.generateMipmap(this.target);
        }
      }
    }
    if (props.magFilter !== void 0) {
      const magFilter = convertWebGLConstant(gl, props.magFilter);
      if (magFilter) {
        this.magFilter = props.magFilter;
        gl.texParameteri(this.target, gl.TEXTURE_MAG_FILTER, magFilter);
      }
    }
    if (props.wrapS !== void 0) {
      const wrapS = convertWebGLConstant(gl, props.wrapS);
      if (wrapS) {
        this.wrapS = props.wrapS;
        gl.texParameteri(this.target, gl.TEXTURE_WRAP_S, wrapS);
      }
    }
    if (props.wrapT !== void 0) {
      const wrapT = convertWebGLConstant(gl, props.wrapT);
      if (wrapT) {
        this.wrapT = props.wrapT;
        gl.texParameteri(this.target, gl.TEXTURE_WRAP_T, wrapT);
      }
    }
  }
  bind(unit) {
    if (!this.allocated) {
      return false;
    }
    if (this.texture) {
      const gl = this.gl;
      gl.activeTexture(gl[`TEXTURE${unit}`]);
      gl.bindTexture(this.target, this.texture);
      return true;
    }
    return false;
  }
  unbind(unit) {
    if (!this.allocated) {
      return;
    }
    if (this.texture) {
      const gl = this.gl;
      gl.activeTexture(gl[`TEXTURE${unit}`]);
      gl.bindTexture(this.target, null);
    }
  }
  destroy() {
    if (!this.allocated) {
      return;
    }
    if (this.texture) {
      this.gl.deleteTexture(this.texture);
      this.texture = null;
    }
  }
};
function getInternalFormat(gl, internalFormatName, glFormat, glType, encoding, isVideoTexture = false) {
  if (internalFormatName !== null) {
    if (gl[internalFormatName] !== void 0) {
      return gl[internalFormatName];
    }
    console.warn("Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
  }
  let internalFormat = glFormat;
  if (glFormat === gl.RED) {
    if (glType === gl.FLOAT)
      internalFormat = gl.R32F;
    if (glType === gl.HALF_FLOAT)
      internalFormat = gl.R16F;
    if (glType === gl.UNSIGNED_BYTE)
      internalFormat = gl.R8;
  }
  if (glFormat === gl.RG) {
    if (glType === gl.FLOAT)
      internalFormat = gl.RG32F;
    if (glType === gl.HALF_FLOAT)
      internalFormat = gl.RG16F;
    if (glType === gl.UNSIGNED_BYTE)
      internalFormat = gl.RG8;
  }
  if (glFormat === gl.RGBA) {
    if (glType === gl.FLOAT)
      internalFormat = gl.RGBA32F;
    if (glType === gl.HALF_FLOAT)
      internalFormat = gl.RGBA16F;
    if (glType === gl.UNSIGNED_BYTE)
      internalFormat = encoding === sRGBEncoding && isVideoTexture === false ? gl.SRGB8_ALPHA8 : gl.RGBA8;
    if (glType === gl.UNSIGNED_SHORT_4_4_4_4)
      internalFormat = gl.RGBA4;
    if (glType === gl.UNSIGNED_SHORT_5_5_5_1)
      internalFormat = gl.RGB5_A1;
  }
  if (internalFormat === gl.R16F || internalFormat === gl.R32F || internalFormat === gl.RG16F || internalFormat === gl.RG32F || internalFormat === gl.RGBA16F || internalFormat === gl.RGBA32F) {
    getWebGLExtension(gl, "EXT_color_buffer_float");
  }
  return internalFormat;
}
function filterFallback(gl, f) {
  if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
    return gl.NEAREST;
  }
  return gl.LINEAR;
}

// ../sdk/src/webglutils/canvas2image.ts
var Canvas2Image = function() {
  const oCanvas = document.createElement("canvas"), sc = String.fromCharCode, strDownloadMime = "image/octet-stream", bReplaceDownloadMime = false;
  if (!oCanvas.getContext) {
    return {
      saveAsBMP: function() {
      },
      saveAsPNG: function() {
      },
      saveAsJPEG: function() {
      }
    };
  }
  const bHasImageData = !!oCanvas.getContext("2d").getImageData, bHasDataURL = !!oCanvas.toDataURL, bHasBase64 = !!window.btoa;
  const readCanvasData = function(oCanvas2) {
    const iWidth = parseInt(oCanvas2.width), iHeight = parseInt(oCanvas2.height);
    return oCanvas2.getContext("2d").getImageData(0, 0, iWidth, iHeight);
  };
  const encodeData = function(data) {
    let i, aData, strData = "";
    if (typeof data == "string") {
      strData = data;
    } else {
      aData = data;
      for (i = 0; i < aData.length; i++) {
        strData += sc(aData[i]);
      }
    }
    return btoa(strData);
  };
  const createBMP = function(oData) {
    let strHeader = "";
    const iWidth = oData.width;
    const iHeight = oData.height;
    strHeader += "BM";
    let iFileSize = iWidth * iHeight * 4 + 54;
    strHeader += sc(iFileSize % 256);
    iFileSize = Math.floor(iFileSize / 256);
    strHeader += sc(iFileSize % 256);
    iFileSize = Math.floor(iFileSize / 256);
    strHeader += sc(iFileSize % 256);
    iFileSize = Math.floor(iFileSize / 256);
    strHeader += sc(iFileSize % 256);
    strHeader += sc(0, 0, 0, 0, 54, 0, 0, 0);
    strHeader += sc(40, 0, 0, 0);
    let iImageWidth = iWidth;
    strHeader += sc(iImageWidth % 256);
    iImageWidth = Math.floor(iImageWidth / 256);
    strHeader += sc(iImageWidth % 256);
    iImageWidth = Math.floor(iImageWidth / 256);
    strHeader += sc(iImageWidth % 256);
    iImageWidth = Math.floor(iImageWidth / 256);
    strHeader += sc(iImageWidth % 256);
    let iImageHeight = iHeight;
    strHeader += sc(iImageHeight % 256);
    iImageHeight = Math.floor(iImageHeight / 256);
    strHeader += sc(iImageHeight % 256);
    iImageHeight = Math.floor(iImageHeight / 256);
    strHeader += sc(iImageHeight % 256);
    iImageHeight = Math.floor(iImageHeight / 256);
    strHeader += sc(iImageHeight % 256);
    strHeader += sc(1, 0, 32, 0);
    strHeader += sc(0, 0, 0, 0);
    let iDataSize = iWidth * iHeight * 4;
    strHeader += sc(iDataSize % 256);
    iDataSize = Math.floor(iDataSize / 256);
    strHeader += sc(iDataSize % 256);
    iDataSize = Math.floor(iDataSize / 256);
    strHeader += sc(iDataSize % 256);
    iDataSize = Math.floor(iDataSize / 256);
    strHeader += sc(iDataSize % 256);
    strHeader += sc(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const aImgData = oData.data;
    let strPixelData = "";
    let c2;
    let x;
    let y = iHeight;
    let iOffsetX;
    let iOffsetY;
    let strPixelRow;
    do {
      iOffsetY = iWidth * (y - 1) * 4;
      strPixelRow = "";
      for (x = 0; x < iWidth; x++) {
        iOffsetX = 4 * x;
        strPixelRow += sc(
          aImgData[iOffsetY + iOffsetX + 2],
          // B
          aImgData[iOffsetY + iOffsetX + 1],
          // G
          aImgData[iOffsetY + iOffsetX],
          // R
          aImgData[iOffsetY + iOffsetX + 3]
          // A
        );
      }
      strPixelData += strPixelRow;
    } while (--y);
    return encodeData(strHeader + strPixelData);
  };
  const saveFile = function(strData) {
    if (!window.open(strData)) {
      document.location.href = strData;
    }
  };
  const makeDataURI = function(strData, strMime) {
    return "data:" + strMime + ";base64," + strData;
  };
  const makeImageObject = function(strSource) {
    const oImgElement = document.createElement("img");
    oImgElement.src = strSource;
    return oImgElement;
  };
  const scaleCanvas = function(oCanvas2, iWidth, iHeight, flipy) {
    if (iWidth && iHeight) {
      const oSaveCanvas = document.createElement("canvas");
      oSaveCanvas.width = iWidth;
      oSaveCanvas.height = iHeight;
      oSaveCanvas.style.width = iWidth + "px";
      oSaveCanvas.style.height = iHeight + "px";
      const oSaveCtx = oSaveCanvas.getContext("2d");
      if (flipy) {
        oSaveCtx.save();
        oSaveCtx.scale(1, -1);
        oSaveCtx.imageSmoothingEnabled = true;
        oSaveCtx.drawImage(oCanvas2, 0, 0, oCanvas2.width, oCanvas2.height, 0, 0, iWidth, -iHeight);
        oSaveCtx.restore();
      } else {
        oSaveCtx.imageSmoothingEnabled = true;
        oSaveCtx.drawImage(oCanvas2, 0, 0, oCanvas2.width, oCanvas2.height, 0, 0, iWidth, iHeight);
      }
      return oSaveCanvas;
    }
    return oCanvas2;
  };
  return {
    saveAsPNG: function(oCanvas2, bReturnImg, iWidth, iHeight, flipy) {
      if (!bHasDataURL)
        return false;
      const oScaledCanvas = scaleCanvas(oCanvas2, iWidth, iHeight, flipy);
      const strMime = "image/png";
      const strData = oScaledCanvas.toDataURL(strMime);
      if (bReturnImg) {
        return makeImageObject(strData);
      } else {
        saveFile(bReplaceDownloadMime ? strData.replace(strMime, strDownloadMime) : strData);
      }
      return true;
    },
    saveAsJPEG: function(oCanvas2, bReturnImg, iWidth, iHeight, flipy) {
      if (!bHasDataURL)
        return false;
      const oScaledCanvas = scaleCanvas(oCanvas2, iWidth, iHeight, flipy);
      const strMime = "image/jpeg";
      const strData = oScaledCanvas.toDataURL(strMime);
      if (strData.indexOf(strMime) != 5)
        return false;
      if (bReturnImg) {
        return makeImageObject(strData);
      } else {
        saveFile(bReplaceDownloadMime ? strData.replace(strMime, strDownloadMime) : strData);
      }
      return true;
    },
    saveAsBMP: function(oCanvas2, bReturnImg, iWidth, iHeight, flipy) {
      if (!(bHasDataURL && bHasImageData && bHasBase64))
        return false;
      const oScaledCanvas = scaleCanvas(oCanvas2, iWidth, iHeight, flipy);
      const strMime = "image/bmp";
      const oData = readCanvasData(oScaledCanvas), strImgData = createBMP(oData);
      if (bReturnImg) {
        return makeImageObject(makeDataURI(strImgData, strMime));
      } else {
        saveFile(makeDataURI(strImgData, strMime));
      }
      return true;
    }
  };
}();

// ../sdk/src/webglutils/WEBGL_INFO.ts
var WEBGL_INFO = {
  WEBGL: false,
  SUPPORTED_EXTENSIONS: {}
};
var canvas = document.createElement("canvas");
if (canvas) {
  const gl = canvas.getContext("webgl2", { antialias: true });
  WEBGL_INFO.WEBGL = !!gl;
  if (WEBGL_INFO.WEBGL) {
    WEBGL_INFO.ANTIALIAS = gl.getContextAttributes().antialias;
    if (gl.getShaderPrecisionFormat) {
      if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
        WEBGL_INFO.FS_MAX_FLOAT_PRECISION = "highp";
      } else {
        if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
          WEBGL_INFO.FS_MAX_FLOAT_PRECISION = "mediump";
        } else {
          WEBGL_INFO.FS_MAX_FLOAT_PRECISION = "lowp";
        }
      }
    } else {
      WEBGL_INFO.FS_MAX_FLOAT_PRECISION = "mediump";
    }
    WEBGL_INFO.DEPTH_BUFFER_BITS = gl.getParameter(gl.DEPTH_BITS);
    WEBGL_INFO.MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    WEBGL_INFO.MAX_CUBE_MAP_SIZE = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
    WEBGL_INFO.MAX_RENDERBUFFER_SIZE = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
    WEBGL_INFO.MAX_TEXTURE_UNITS = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    WEBGL_INFO.MAX_TEXTURE_IMAGE_UNITS = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    WEBGL_INFO.MAX_VERTEX_ATTRIBS = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
    WEBGL_INFO.MAX_VERTEX_UNIFORM_VECTORS = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
    WEBGL_INFO.MAX_FRAGMENT_UNIFORM_VECTORS = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
    WEBGL_INFO.MAX_VARYING_VECTORS = gl.getParameter(gl.MAX_VARYING_VECTORS);
    gl.getSupportedExtensions().forEach(function(ext) {
      WEBGL_INFO.SUPPORTED_EXTENSIONS[ext] = true;
    });
    WEBGL_INFO.depthTexturesSupported = WEBGL_INFO.SUPPORTED_EXTENSIONS["WEBGL_depth_texture"];
  }
}

// ../sdk/src/webglrenderer/RenderContext.ts
var RenderContext = class {
  /**
   * The Viewer.
   */
  viewer;
  /**
   * @private
   */
  rendererSets;
  /**
   * The View we are rendering.
   */
  view;
  /**
   * The WebGL rendering context.
   */
  gl;
  viewMatrixDataTexture;
  /**
   * Whether to render a quality representation for triangle surfaces.
   *
   * When ````false````, we'll render them with a fast vertex-shaded Gouraud-shaded representation, which
   * is great for zillions of objects.
   *
   * When ````true````, we'll render them at a better visual quality, using smooth, per-fragment shading
   * and a more realistic lighting model.
   */
  pbrEnabled;
  /**
   * Whether backfaces are currently enabled during the current frame.
   */
  backfaces;
  /**
   * The vertex winding order for what we currently consider to be a backface during current
   * frame: true == "cw", false == "ccw".
   */
  frontface;
  /**
   * The next available texture unit to bind a {@link WebGLAbstractTexture} to.
   */
  textureUnit;
  /**
   * Statistic that counts how many times ````gl.bindTexture()```` has been called so far within the current frame.
   */
  bindTexture;
  /**
   * Indicates which pass the renderers is currently rendering.
   */
  renderPass;
  /**
   * The 4x4 viewing transform matrix the renderers is currently using when rendering castsShadows.
   *
   * This sets the viewpoint to look from the point of view of each {@link DirLight}
   * or {@link PointLight} that casts a shadow.
   */
  shadowViewMatrix;
  /**
   * The 4x4 viewing projection matrix the renderers is currently using when rendering shadows.
   */
  shadowProjMatrix;
  /**
   * The 4x4 viewing transform matrix the renderers is currently using when rendering a ray-pick.
   *
   * This sets the viewpoint to look along the ray given to {@link scene!Scene/pick:method"}}Scene#pick(){{/crossLink}}
   * when picking with a ray.
   */
  pickViewMatrix;
  /**
   * The 4x4 orthographic projection transform matrix the renderers is currently using when rendering a ray-pick.
   */
  pickProjMatrix;
  /**
   * Distance to the near clipping plane when rendering depth fragments for GPU-accelerated 3D picking.
   */
  pickZNear;
  /**
   * Distance to the far clipping plane when rendering depth fragments for GPU-accelerated 3D picking.
   */
  pickZFar;
  /**
   * Whether or not the renderers is currently picking invisible objects.
   */
  pickInvisible;
  /** The current line width.
   */
  lineWidth;
  /**
   * ID of the last {@link WebGLProgram} that was bound during the current frame.
   */
  lastProgramId;
  /**
   * The occlusion rendering texture.
   */
  saoOcclusionTexture;
  pickClipPos;
  webglRenderer;
  constructor(viewer, gl, webglRenderer) {
    this.viewer = viewer;
    this.view = null;
    this.gl = gl;
    this.webglRenderer = webglRenderer;
    this.reset();
  }
  /**
   * Called by the renderers before each frame.
   */
  reset() {
    this.lastProgramId = -1;
    this.pbrEnabled = false;
    this.backfaces = false;
    this.frontface = true;
    this.textureUnit = 0;
    this.shadowViewMatrix = null;
    this.shadowProjMatrix = null;
    this.pickViewMatrix = null;
    this.pickProjMatrix = null;
    this.pickZNear = 0.01;
    this.pickZFar = 5e3;
    this.pickInvisible = false;
    this.lineWidth = 1;
    this.saoOcclusionTexture = null;
  }
  /**
   * Gets the next available texture unit for this render
   */
  get nextTextureUnit() {
    const textureUnit = this.textureUnit;
    this.textureUnit = (this.textureUnit + 1) % WEBGL_INFO.MAX_TEXTURE_UNITS;
    return textureUnit;
  }
};

// ../sdk/src/webglrenderer/WebGLRendererGeometry.ts
var WebGLRendererGeometry = class {
  constructor() {
  }
};

// ../sdk/src/webglrenderer/WebGLRendererTexture.ts
var WebGLRendererTexture = class {
  texture;
  texture2D;
  constructor(texture, texture2D) {
    this.texture = texture;
    this.texture2D = texture2D;
  }
  destroy() {
    if (this.texture2D) {
      this.texture2D.destroy();
    }
  }
};

// ../sdk/src/webglrenderer/SCENE_OBJECT_FLAGS.ts
var SCENE_OBJECT_FLAGS = {
  VISIBLE: 1,
  CULLED: 1 << 2,
  PICKABLE: 1 << 3,
  CLIPPABLE: 1 << 4,
  COLLIDABLE: 1 << 5,
  CAST_SHADOW: 1 << 6,
  RECEIVE_SHADOW: 1 << 7,
  XRAYED: 1 << 8,
  HIGHLIGHTED: 1 << 9,
  SELECTED: 1 << 10,
  BACKFACES: 1 << 11,
  TRANSPARENT: 1 << 12
};

// ../sdk/src/webglrenderer/WebGLRendererObject.ts
var tempIntRGB = new Uint16Array([0, 0, 0]);
var WebGLRendererObject = class {
  id;
  rendererModel;
  layerId;
  rendererMeshes;
  #flags;
  #aabb;
  #offsetAABB;
  #offset;
  #colorizeUpdated;
  #opacityUpdated;
  /**
   * @private
   * @param params
   */
  constructor(params2) {
    this.id = params2.id;
    this.rendererModel = params2.rendererModel;
    this.rendererMeshes = params2.rendererMeshes || [];
    this.#flags = [0, 0, 0, 0];
    this.#aabb = params2.aabb;
    this.#offsetAABB = createAABB3(params2.aabb);
    this.#offset = createVec3();
    this.#colorizeUpdated = false;
    this.#opacityUpdated = false;
    for (let i = 0, len = this.rendererMeshes.length; i < len; i++) {
      this.rendererMeshes[i].setRendererObject(this);
    }
  }
  get aabb() {
    return this.#offsetAABB;
  }
  setVisible(viewIndex, visible) {
    if (!!(this.#flags[viewIndex] & SCENE_OBJECT_FLAGS.VISIBLE) === visible) {
      return;
    }
    this.#flags[viewIndex] = visible ? this.#flags[viewIndex] | SCENE_OBJECT_FLAGS.VISIBLE : this.#flags[viewIndex] & ~SCENE_OBJECT_FLAGS.VISIBLE;
    for (let i = 0, len = this.rendererMeshes.length; i < len; i++) {
      this.rendererMeshes[i].setVisible(viewIndex, this.#flags[viewIndex]);
    }
  }
  setHighlighted(viewIndex, highlighted) {
    if (!!(this.#flags[viewIndex] & SCENE_OBJECT_FLAGS.HIGHLIGHTED) === highlighted) {
      return;
    }
    this.#flags[viewIndex] = highlighted ? this.#flags[viewIndex] | SCENE_OBJECT_FLAGS.HIGHLIGHTED : this.#flags[viewIndex] & ~SCENE_OBJECT_FLAGS.HIGHLIGHTED;
    for (let i = 0, len = this.rendererMeshes.length; i < len; i++) {
      this.rendererMeshes[i].setHighlighted(viewIndex, this.#flags[viewIndex]);
    }
  }
  setXRayed(viewIndex, xrayed) {
    if (!!(this.#flags[viewIndex] & SCENE_OBJECT_FLAGS.XRAYED) === xrayed) {
      return;
    }
    this.#flags[viewIndex] = xrayed ? this.#flags[viewIndex] | SCENE_OBJECT_FLAGS.XRAYED : this.#flags[viewIndex] & ~SCENE_OBJECT_FLAGS.XRAYED;
    for (let i = 0, len = this.rendererMeshes.length; i < len; i++) {
      this.rendererMeshes[i].setXRayed(viewIndex, this.#flags[viewIndex]);
    }
  }
  setSelected(viewIndex, selected) {
    if (!!(this.#flags[viewIndex] & SCENE_OBJECT_FLAGS.SELECTED) === selected) {
      return;
    }
    this.#flags[viewIndex] = selected ? this.#flags[viewIndex] | SCENE_OBJECT_FLAGS.SELECTED : this.#flags[viewIndex] & ~SCENE_OBJECT_FLAGS.SELECTED;
    for (let i = 0, len = this.rendererMeshes.length; i < len; i++) {
      this.rendererMeshes[i].setSelected(viewIndex, this.#flags[viewIndex]);
    }
  }
  setCulled(viewIndex, culled) {
    if (!!(this.#flags[viewIndex] & SCENE_OBJECT_FLAGS.CULLED) === culled) {
      return;
    }
    this.#flags[viewIndex] = culled ? this.#flags[viewIndex] | SCENE_OBJECT_FLAGS.CULLED : this.#flags[viewIndex] & ~SCENE_OBJECT_FLAGS.CULLED;
    for (let i = 0, len = this.rendererMeshes.length; i < len; i++) {
      this.rendererMeshes[i].setCulled(viewIndex, this.#flags[viewIndex]);
    }
  }
  setClippable(viewIndex, clippable) {
    if (!!(this.#flags[viewIndex] & SCENE_OBJECT_FLAGS.CLIPPABLE) === clippable) {
      return;
    }
    this.#flags[viewIndex] = clippable ? this.#flags[viewIndex] | SCENE_OBJECT_FLAGS.CLIPPABLE : this.#flags[viewIndex] & ~SCENE_OBJECT_FLAGS.CLIPPABLE;
    for (let i = 0, len = this.rendererMeshes.length; i < len; i++) {
      this.rendererMeshes[i].setClippable(viewIndex, this.#flags[viewIndex]);
    }
  }
  setCollidable(viewIndex, collidable) {
    if (!!(this.#flags[viewIndex] & SCENE_OBJECT_FLAGS.COLLIDABLE) === collidable) {
      return;
    }
    this.#flags[viewIndex] = collidable ? this.#flags[viewIndex] | SCENE_OBJECT_FLAGS.COLLIDABLE : this.#flags[viewIndex] & ~SCENE_OBJECT_FLAGS.COLLIDABLE;
    for (let i = 0, len = this.rendererMeshes.length; i < len; i++) {
      this.rendererMeshes[i].setCollidable(viewIndex, this.#flags[viewIndex]);
    }
  }
  setPickable(viewIndex, pickable) {
    if (!!(this.#flags[viewIndex] & SCENE_OBJECT_FLAGS.PICKABLE) === pickable) {
      return;
    }
    this.#flags[viewIndex] = pickable ? this.#flags[viewIndex] | SCENE_OBJECT_FLAGS.PICKABLE : this.#flags[viewIndex] & ~SCENE_OBJECT_FLAGS.PICKABLE;
    for (let i = 0, len = this.rendererMeshes.length; i < len; i++) {
      this.rendererMeshes[i].setPickable(viewIndex, this.#flags[viewIndex]);
    }
  }
  setColorize(viewIndex, color2) {
    if (color2) {
      tempIntRGB[0] = Math.floor(color2[0] * 255);
      tempIntRGB[1] = Math.floor(color2[1] * 255);
      tempIntRGB[2] = Math.floor(color2[2] * 255);
      for (let i = 0, len = this.rendererMeshes.length; i < len; i++) {
        this.rendererMeshes[i].setColorize(viewIndex, tempIntRGB);
      }
    } else {
      for (let i = 0, len = this.rendererMeshes.length; i < len; i++) {
        this.rendererMeshes[i].setColorize(viewIndex, null);
      }
    }
  }
  setOpacity(viewIndex, opacity) {
    if (this.rendererMeshes.length === 0) {
      return;
    }
    const lastOpacityQuantized = this.rendererMeshes[0].colorize[3];
    let opacityQuantized = 255;
    if (opacity !== null && opacity !== void 0) {
      if (opacity < 0) {
        opacity = 0;
      } else if (opacity > 1) {
        opacity = 1;
      }
      opacityQuantized = Math.floor(opacity * 255);
      if (lastOpacityQuantized === opacityQuantized) {
        return;
      }
    } else {
      opacityQuantized = 255;
      if (lastOpacityQuantized === opacityQuantized) {
        return;
      }
    }
    for (let i = 0, len = this.rendererMeshes.length; i < len; i++) {
      this.rendererMeshes[i].setOpacity(viewIndex, opacityQuantized, this.#flags[viewIndex]);
    }
  }
  setOffset(viewIndex, offset) {
  }
  initFlags(viewIndex) {
    for (let i = 0, len = this.rendererMeshes.length; i < len; i++) {
      this.rendererMeshes[i].initFlags(viewIndex, this.#flags[viewIndex]);
    }
  }
  commitRendererState(viewIndex) {
    for (let i = 0, len = this.rendererMeshes.length; i < len; i++) {
      this.rendererMeshes[i].commitRendererState(viewIndex);
    }
  }
  destroy() {
    for (let i = 0, len = this.rendererMeshes.length; i < len; i++) {
      this.rendererMeshes[i].destroy();
    }
  }
};

// ../sdk/src/webglrenderer/WebGLRendererMesh.ts
var tempMat4a3 = createMat4();
var tempMat4b2 = createMat4();
var WebGLRendererMesh = class {
  id;
  color;
  rendererGeometry;
  rendererTextureSet;
  matrix;
  opacity;
  pickId;
  tileManager;
  tile;
  rendererObject;
  aabb;
  layer;
  meshIndex;
  colorize;
  colorizing;
  transparent;
  attribs;
  constructor(params2) {
    this.rendererObject = null;
    this.tileManager = params2.tileManager;
    this.id = params2.id;
    this.pickId = 0;
    this.attribs = [];
    this.color = [params2.color[0], params2.color[1], params2.color[2], params2.opacity];
    for (let i = 0; i < 4; i++) {
      this.attribs.push({
        colorize: [params2.color[0], params2.color[1], params2.color[2], params2.opacity],
        // [0..255]
        colorizing: false,
        transparent: params2.opacity < 255
      });
    }
    this.layer = params2.layer;
    this.matrix = params2.matrix;
    this.opacity = params2.opacity;
    this.aabb = createAABB3();
    this.rendererTextureSet = params2.rendererTextureSet;
    this.rendererGeometry = params2.rendererGeometry;
    this.meshIndex = params2.meshIndex;
  }
  delegatePickedEntity() {
    throw new Error("Method not implemented.");
  }
  setRendererObject(rendererObject) {
    this.rendererObject = rendererObject;
  }
  setVisible(viewIndex, flags) {
    this.layer.setLayerMeshVisible(viewIndex, this.meshIndex, flags, this.attribs[viewIndex].transparent);
  }
  setMatrix(matrix) {
    const center2 = transformPoint3(matrix, [0, 0, 0]);
    const oldTile = this.tile;
    this.tile = oldTile ? this.tileManager.updateTileCenter(oldTile, center2) : this.tileManager.getTile(center2);
    const tileChanged = !oldTile || oldTile.id !== this.tile.id;
    const tileCenter = this.tile.center;
    const needRTC = tileCenter[0] !== 0 || tileCenter[1] !== 0 || tileCenter[2] !== 0;
    this.layer.setLayerMeshMatrix(this.meshIndex, needRTC ? mulMat4(matrix, translationMat4c(-tileCenter[0], -tileCenter[1], -tileCenter[2], tempMat4a3), tempMat4b2) : matrix);
    if (tileChanged) {
    }
  }
  setColor(color2) {
    const setOpacity = false;
    this.color[0] = color2[0];
    this.color[1] = color2[1];
    this.color[2] = color2[2];
    if (!this.colorizing) {
      for (let viewIndex = 0, len = this.layer.rendererModel.viewer.viewList.length; viewIndex < len; viewIndex++) {
        this.layer.setLayerMeshColor(viewIndex, this.meshIndex, color2, setOpacity);
      }
    }
  }
  setColorize(viewIndex, colorize) {
    const setOpacity = false;
    const attribs = this.attribs[viewIndex];
    const meshColorize = attribs.colorize;
    if (colorize) {
      meshColorize[0] = colorize[0];
      meshColorize[1] = colorize[1];
      meshColorize[2] = colorize[2];
      this.layer.setLayerMeshColor(viewIndex, this.meshIndex, meshColorize, setOpacity);
      attribs.colorizing = true;
    } else {
      this.layer.setLayerMeshColor(viewIndex, this.meshIndex, meshColorize, setOpacity);
      attribs.colorizing = false;
    }
  }
  setOpacity(viewIndex, opacity, flags) {
    const setOpacity = true;
    const attribs = this.attribs[viewIndex];
    const newTransparent = opacity < 255;
    const lastTransparent = attribs.transparent;
    const changingTransparency = lastTransparent !== newTransparent;
    attribs.color[3] = opacity;
    attribs.colorize[3] = opacity;
    attribs.transparent = newTransparent;
    if (this.colorizing) {
      this.layer.setLayerMeshColor(viewIndex, this.meshIndex, attribs.colorize, setOpacity);
    } else {
      this.layer.setLayerMeshColor(viewIndex, this.meshIndex, attribs.color, setOpacity);
    }
    if (changingTransparency) {
      this.layer.setLayerMeshTransparent(viewIndex, this.meshIndex, flags, newTransparent);
    }
  }
  setHighlighted(viewIndex, flags) {
    this.layer.setLayerMeshHighlighted(viewIndex, this.meshIndex, flags, this.attribs[viewIndex].transparent);
  }
  setXRayed(viewIndex, flags) {
    this.layer.setLayerMeshXRayed(viewIndex, this.meshIndex, flags, this.attribs[viewIndex].transparent);
  }
  setSelected(viewIndex, flags) {
    this.layer.setLayerMeshSelected(viewIndex, this.meshIndex, flags, this.attribs[viewIndex].transparent);
  }
  setClippable(viewIndex, flags) {
    this.layer.setLayerMeshClippable(viewIndex, this.meshIndex, flags);
  }
  setCollidable(viewIndex, flags) {
    this.layer.setLayerMeshCollidable(viewIndex, this.meshIndex, flags);
  }
  setPickable(viewIndex, flags) {
    this.layer.setLayerMeshPickable(viewIndex, this.meshIndex, flags, this.attribs[viewIndex].transparent);
  }
  setCulled(viewIndex, flags) {
    this.layer.setLayerMeshCulled(viewIndex, this.meshIndex, flags, this.attribs[viewIndex].transparent);
  }
  canPickTriangle() {
    return false;
  }
  drawPickTriangles(drawFlags, renderContext) {
  }
  pickTriangleSurface(pickResult) {
  }
  canPickWorldPos() {
    return true;
  }
  drawPickNormals(renderContext) {
  }
  initFlags(viewIndex, flags) {
    this.layer.initFlags(viewIndex, this.meshIndex, flags, this.attribs[viewIndex].transparent);
  }
  commitRendererState(viewIndex) {
    this.layer.commitRendererState(viewIndex);
  }
  destroy() {
    if (this.tile && this.tileManager) {
      this.tileManager.putTile(this.tile);
    }
  }
};

// ../sdk/src/webglrenderer/WebGLRendererTextureSet.ts
var WebGLRendererTextureSet = class {
  id;
  colorRendererTexture;
  metallicRoughnessRendererTexture;
  emissiveRendererTexture;
  occlusionRendererTexture;
  constructor(params2) {
    this.id = params2.id;
    this.colorRendererTexture = params2.colorRendererTexture;
    this.metallicRoughnessRendererTexture = params2.metallicRoughnessRendererTexture;
    this.emissiveRendererTexture = params2.emissiveRendererTexture;
    this.occlusionRendererTexture = params2.occlusionRendererTexture;
  }
};

// ../sdk/src/webglrenderer/MeshCounts.ts
var MeshCounts = class {
  numMeshes;
  numVisible;
  numTransparent;
  numXRayed;
  numSelected;
  numHighlighted;
  numClippable;
  numPickable;
  numCulled;
  constructor() {
    this.reset();
  }
  reset() {
    this.numMeshes = 0;
    this.numVisible = 0;
    this.numTransparent = 0;
    this.numXRayed = 0;
    this.numSelected = 0;
    this.numHighlighted = 0;
    this.numClippable = 0;
    this.numPickable = 0;
    this.numCulled = 0;
  }
};

// ../sdk/src/webglrenderer/RenderFlags.ts
var RenderFlags = class {
  /**
   * Set by {@link Drawable#rebuildRenderFlags} to indicate which layers are visible within the {@link Drawable}.
   *
   * This is a list of IDs of visible layers within the {@link Drawable}. The IDs will be whatever the
   * {@link Drawable} uses to identify its layers, usually integers.
   *
   * @property visibleLayers
   * @type {Number[]}
   */
  visibleLayers;
  /**
   * Set by {@link Drawable#rebuildRenderFlags} to indicate which {@link SectionPlane}s are active within each layer of the {@link Drawable}.
   *
   * Layout is as follows:
   *
   * ````[
   *      false, false, true, // Layer 0, SectionPlanes 0, 1, 2
   *      false, true, true,  // Layer 1, SectionPlanes 0, 1, 2
   *      true, false, true   // Layer 2, SectionPlanes 0, 1, 2
   * ]````
   *
   * @property sectionPlanesActivePerLayer
   * @type {Boolean[]}
   */
  sectionPlanesActivePerLayer;
  culled;
  sectioned;
  numLayers;
  numVisibleLayers;
  colorOpaque;
  colorTransparent;
  edgesOpaque;
  edgesTransparent;
  xrayedSilhouetteOpaque;
  xrayedEdgesOpaque;
  xrayedSilhouetteTransparent;
  xrayedEdgesTransparent;
  highlightedSilhouetteOpaque;
  highlightedEdgesOpaque;
  highlightedSilhouetteTransparent;
  highlightedEdgesTransparent;
  selectedSilhouetteOpaque;
  selectedEdgesOpaque;
  selectedSilhouetteTransparent;
  selectedEdgesTransparent;
  /**
   * @private
   */
  constructor() {
    this.visibleLayers = [];
    this.sectionPlanesActivePerLayer = [];
    this.reset();
  }
  /**
   * @private
   */
  reset() {
    this.culled = false;
    this.sectioned = false;
    this.numLayers = 0;
    this.numVisibleLayers = 0;
    this.colorOpaque = false;
    this.colorTransparent = false;
    this.edgesOpaque = false;
    this.edgesTransparent = false;
    this.xrayedSilhouetteOpaque = false;
    this.xrayedEdgesOpaque = false;
    this.xrayedSilhouetteTransparent = false;
    this.xrayedEdgesTransparent = false;
    this.highlightedSilhouetteOpaque = false;
    this.highlightedEdgesOpaque = false;
    this.highlightedSilhouetteTransparent = false;
    this.highlightedEdgesTransparent = false;
    this.selectedSilhouetteOpaque = false;
    this.selectedEdgesOpaque = false;
    this.selectedSilhouetteTransparent = false;
    this.selectedEdgesTransparent = false;
  }
};

// ../sdk/src/webglrenderer/vbo/batching/VBOBatchingBuffer.ts
var VBOBatchingBuffer = class {
  maxVerts;
  maxIndices;
  positions;
  colors;
  uv;
  normals;
  pickColors;
  offsets;
  indices;
  edgeIndices;
  constructor(maxGeometryBatchSize = 4e5) {
    if (maxGeometryBatchSize > 4e5) {
      maxGeometryBatchSize = 4e5;
    }
    this.maxVerts = maxGeometryBatchSize;
    this.maxIndices = maxGeometryBatchSize;
    this.positions = [];
    this.colors = [];
    this.uv = [];
    this.normals = [];
    this.pickColors = [];
    this.offsets = [];
    this.indices = [];
    this.edgeIndices = [];
  }
};

// ../sdk/src/webglrenderer/RENDER_PASSES.ts
var RENDER_PASSES = {
  // Skipped - suppress rendering
  NOT_RENDERED: 0,
  // Draw color, or draw depth or normals for post-effects
  DRAW_OPAQUE: 1,
  DRAW_TRANSPARENT: 2,
  // Accents silhouette rendering - mutually exclusive modes
  SILHOUETTE_HIGHLIGHTED: 3,
  SILHOUETTE_SELECTED: 4,
  SILHOUETTE_XRAYED: 5,
  // Picking
  PICK: 6
};

// ../sdk/src/webglrenderer/vbo/ScratchMemory.ts
var ScratchMemory = class {
  #uint8Arrays;
  #float32Arrays;
  constructor() {
    this.#uint8Arrays = {};
    this.#float32Arrays = {};
  }
  _clear() {
    this.#uint8Arrays = {};
    this.#float32Arrays = {};
  }
  getUInt8Array(len) {
    let uint8Array = this.#uint8Arrays[len];
    if (!uint8Array) {
      uint8Array = new Uint8Array(len);
      this.#uint8Arrays[len] = uint8Array;
    }
    return uint8Array;
  }
  getFloat32Array(len) {
    let float32Array = this.#float32Arrays[len];
    if (!float32Array) {
      float32Array = new Float32Array(len);
      this.#float32Arrays[len] = float32Array;
    }
    return float32Array;
  }
};
var batchingLayerScratchMemory = new ScratchMemory();
var countUsers = 0;
function getScratchMemory() {
  countUsers++;
  return batchingLayerScratchMemory;
}
function putScratchMemory() {
  if (countUsers === 0) {
    return;
  }
  countUsers--;
  if (countUsers === 0) {
    batchingLayerScratchMemory._clear();
  }
}

// ../sdk/src/webglrenderer/vbo/batching/VBOBatchingLayer.ts
var numLayers = 0;
var tempVec3a6 = createVec3();
var tempVec4a4 = createVec4();
var tempVec4b4 = createVec4();
var VBOBatchingLayer = class {
  primitive;
  rendererModel;
  layerIndex;
  meshCounts;
  renderState;
  sortId;
  saoSupported;
  #built;
  #aabb;
  aabbDirty;
  #meshes;
  // A Mesh has multiple SubMeshes
  #layerNumber;
  #deferredAttributesUpdateEnabled;
  #deferredMatricesUpdateEnabled;
  #deferredAttributesUpdateDirty;
  #deferredMatricesUpdateDirty;
  #countAttributesUpdateInFrame;
  #countMatricesUpdateInFrame;
  #onViewerTick;
  #scratchMemory;
  #buffer;
  renderContext;
  #portions;
  #rendererSet;
  constructor(vBOBatchingLayerParams, rendererSet) {
    this.renderContext = vBOBatchingLayerParams.renderContext;
    this.primitive = vBOBatchingLayerParams.primitive;
    this.rendererModel = vBOBatchingLayerParams.rendererModel;
    this.layerIndex = vBOBatchingLayerParams.layerIndex;
    this.sortId = `VBOBatchingLayer-${vBOBatchingLayerParams.primitive}`;
    this.meshCounts = [];
    for (let i = 0, len = this.renderContext.viewer.viewList.length; i < len; i++) {
      this.meshCounts.push(new MeshCounts());
    }
    this.#layerNumber = numLayers++;
    this.#portions = [];
    this.#buffer = new VBOBatchingBuffer();
    this.#scratchMemory = getScratchMemory();
    this.#rendererSet = rendererSet;
    this.#built = false;
    this.#aabb = collapseAABB3();
    this.aabbDirty = true;
    this.renderState = {
      numVertices: 0,
      positionsBuf: null,
      indicesBuf: null,
      offsetsBuf: null,
      colorsBuf: [],
      flagsBufs: [],
      positionsDecompressScale: createVec3(),
      positionsDecompressOffset: createVec3(),
      origin: createVec3(vBOBatchingLayerParams.origin),
      pbrSupported: false
    };
  }
  get hash() {
    return `${this.primitive}`;
  }
  get aabb() {
    if (this.aabbDirty) {
      collapseAABB3(this.#aabb);
      for (let i = 0, len = this.#meshes.length; i < len; i++) {
        expandAABB3(this.#aabb, this.#meshes[i].aabb);
      }
      this.aabbDirty = false;
    }
    return this.#aabb;
  }
  canCreateLayerMesh(sceneGeometry) {
    if (this.#built) {
      throw new SDKError("Already built");
    }
    const numVertices = sceneGeometry.positionsCompressed.length;
    const numIndices = sceneGeometry.indices ? sceneGeometry.indices.length : 0;
    return this.#buffer.positions.length + numVertices < this.#buffer.maxVerts && this.#buffer.indices.length + numIndices < this.#buffer.maxIndices;
  }
  createLayerMesh(layerMeshParams, sceneMesh) {
    if (this.#built) {
      throw new SDKError("Already built");
    }
    const geometry = sceneMesh.geometry;
    const color2 = sceneMesh.color;
    const pickColor = layerMeshParams.pickColor;
    const buffer = this.#buffer;
    const positionsIndex = buffer.positions.length;
    const vertsIndex = positionsIndex / 3;
    const indices = geometry.indices;
    const edgeIndices = geometry.edgeIndices;
    const positionsCompressed = geometry.positionsCompressed;
    const uvCompressed = geometry.uvsCompressed;
    const geometryAABB = geometry.aabb;
    const colorsCompressed = geometry.colorsCompressed;
    const numGeometryVerts = positionsCompressed.length / 3;
    let numLayerVerts = buffer.positions.length / 3;
    let numLayerMeshVerts = 0;
    if (!positionsCompressed) {
      throw "positionsCompressed expected";
    }
    if (indices) {
      for (let i = 0, len = indices.length; i < len; i++) {
        buffer.indices.push(numLayerVerts + indices[i]);
      }
    }
    if (edgeIndices) {
      for (let i = 0, len = edgeIndices.length; i < len; i++) {
        buffer.edgeIndices.push(numLayerVerts + edgeIndices[i]);
      }
    }
    for (let k = 0, lenk = positionsCompressed.length; k < lenk; k += 3) {
      tempVec3a6[0] = positionsCompressed[k];
      tempVec3a6[1] = positionsCompressed[k + 1];
      tempVec3a6[2] = positionsCompressed[k + 2];
      decompressPoint3WithAABB3(tempVec3a6, geometryAABB, tempVec4a4);
      if (sceneMesh.rtcMatrix) {
        tempVec4a4[3] = 1;
        transformPoint4(sceneMesh.rtcMatrix, tempVec4a4, tempVec4b4);
        buffer.positions.push(tempVec4b4[0]);
        buffer.positions.push(tempVec4b4[1]);
        buffer.positions.push(tempVec4b4[2]);
      } else {
        buffer.positions.push(tempVec4a4[0]);
        buffer.positions.push(tempVec4a4[1]);
        buffer.positions.push(tempVec4a4[2]);
      }
    }
    if (colorsCompressed) {
      for (let i = 0, len = colorsCompressed.length; i < len; i++) {
        buffer.colors.push(colorsCompressed[i]);
      }
    }
    if (uvCompressed && uvCompressed.length > 0) {
      for (let i = 0, len = uvCompressed.length; i < len; i++) {
        buffer.uv.push(uvCompressed[i]);
      }
    }
    numLayerVerts += numGeometryVerts;
    numLayerMeshVerts += numGeometryVerts;
    if (color2) {
      const r = color2[0] * 255;
      const g = color2[1] * 255;
      const b4 = color2[2] * 255;
      const a2 = 255;
      for (let i = 0; i < numLayerMeshVerts; i++) {
        buffer.colors.push(r);
        buffer.colors.push(g);
        buffer.colors.push(b4);
        buffer.colors.push(a2);
      }
    }
    for (let i = 0, len = numLayerMeshVerts; i < len; i += 4) {
      buffer.pickColors.push(...pickColor);
    }
    const layerMeshIndex = this.#portions.length / 2;
    this.#portions.push(vertsIndex);
    this.#portions.push(numLayerVerts);
    for (let viewIndex = 0, len = this.meshCounts.length; viewIndex < len; viewIndex++) {
      this.meshCounts[viewIndex].numMeshes++;
      this.rendererModel.meshCounts[viewIndex].numMeshes++;
    }
    return layerMeshIndex;
  }
  /**
   * Builds batch VBOs from appended geometries.
   * No more portions can then be created.
   */
  build() {
    if (this.#built) {
      throw new SDKError("Already built");
    }
    const renderState = this.renderState;
    const gl = this.renderContext.gl;
    const buffer = this.#buffer;
    const numViews = this.meshCounts.length;
    if (buffer.positions.length > 0) {
      const positions = new Float32Array(buffer.positions);
      positions3ToAABB3(positions, this.#aabb, null);
      const quantizedPositions = quantizePositions3(positions, this.#aabb);
      renderState.positionsBuf = new WebGLArrayBuf(gl, gl.ARRAY_BUFFER, quantizedPositions, buffer.positions.length, 3, gl.STATIC_DRAW);
      renderState.positionsDecompressOffset.set([this.#aabb[0], this.#aabb[1], this.#aabb[2]]);
      renderState.positionsDecompressScale.set([
        (this.#aabb[3] - this.#aabb[0]) / 65535,
        (this.#aabb[4] - this.#aabb[1]) / 65535,
        (this.#aabb[5] - this.#aabb[2]) / 65535
      ]);
    }
    if (buffer.colors.length > 0) {
      const colors = new Uint8Array(buffer.colors);
      let normalized = false;
      for (let viewIndex = 0; viewIndex < numViews; viewIndex++) {
        renderState.colorsBuf[viewIndex] = new WebGLArrayBuf(gl, gl.ARRAY_BUFFER, colors, buffer.colors.length, 4, gl.STATIC_DRAW, normalized);
      }
    }
    if (buffer.positions.length > 0) {
      const flagsLength = buffer.positions.length / 3;
      const flags = new Float32Array(flagsLength);
      let notNormalized = false;
      for (let viewIndex = 0; viewIndex < numViews; viewIndex++) {
        renderState.flagsBufs[viewIndex] = new WebGLArrayBuf(gl, gl.ARRAY_BUFFER, flags, flags.length, 1, gl.DYNAMIC_DRAW, notNormalized);
      }
    }
    if (buffer.pickColors.length > 0) {
      const pickColors = new Uint8Array(buffer.pickColors);
      let normalized = false;
      renderState.pickColorsBuf = new WebGLArrayBuf(gl, gl.ARRAY_BUFFER, pickColors, buffer.pickColors.length, 4, gl.STATIC_DRAW, normalized);
    }
    if (buffer.indices.length > 0) {
      const indices = new Uint32Array(buffer.indices);
      renderState.indicesBuf = new WebGLArrayBuf(gl, gl.ELEMENT_ARRAY_BUFFER, indices, buffer.indices.length, 1, gl.STATIC_DRAW);
    }
    if (buffer.edgeIndices.length > 0) {
      const edgeIndices = new Uint32Array(buffer.edgeIndices);
      renderState.edgeIndicesBuf = new WebGLArrayBuf(gl, gl.ELEMENT_ARRAY_BUFFER, edgeIndices, buffer.edgeIndices.length, 1, gl.STATIC_DRAW);
    }
    if (buffer.uv.length > 0) {
      if (!renderState.uvDecodeMatrix) {
        const bounds = getUVBounds(buffer.uv);
        const result = compressUVs(buffer.uv, bounds.min, bounds.max);
        const uv = result.quantized;
        let notNormalized = false;
        renderState.uvDecodeMatrix = createMat3(result.decompressMatrix);
        renderState.uvBuf = new WebGLArrayBuf(gl, gl.ARRAY_BUFFER, uv, uv.length, 2, gl.STATIC_DRAW, notNormalized);
      } else {
        let notNormalized = false;
        renderState.uvBuf = new WebGLArrayBuf(gl, gl.ARRAY_BUFFER, buffer.uv, buffer.uv.length, 2, gl.STATIC_DRAW, notNormalized);
      }
    }
    this.saoSupported = this.primitive === SolidPrimitive || this.primitive === SurfacePrimitive || this.primitive === TrianglesPrimitive;
    renderState.pbrSupported = !!renderState.metallicRoughnessBuf && !!renderState.uvBuf && !!renderState.normalsBuf && !!renderState.textureSet && !!renderState.textureSet.colorTexture && !!renderState.textureSet.metallicRoughnessTexture;
    renderState.colorTextureSupported = !!renderState.uvBuf && !!renderState.textureSet && !!renderState.textureSet.colorTexture;
    this.#buffer = null;
    this.#built = true;
  }
  initFlags(viewIndex, layerMeshIndex, flags, meshTransparent) {
    const layerMeshCounts = this.meshCounts[viewIndex];
    const modelMeshCounts = this.rendererModel.meshCounts[viewIndex];
    if (flags & SCENE_OBJECT_FLAGS.VISIBLE) {
      layerMeshCounts.numVisible++;
      modelMeshCounts.numVisible++;
    }
    if (flags & SCENE_OBJECT_FLAGS.HIGHLIGHTED) {
      layerMeshCounts.numHighlighted++;
      modelMeshCounts.numHighlighted++;
    }
    if (flags & SCENE_OBJECT_FLAGS.XRAYED) {
      layerMeshCounts.numXRayed++;
      modelMeshCounts.numXRayed++;
    }
    if (flags & SCENE_OBJECT_FLAGS.SELECTED) {
      layerMeshCounts.numSelected++;
      modelMeshCounts.numSelected++;
    }
    if (flags & SCENE_OBJECT_FLAGS.CLIPPABLE) {
      layerMeshCounts.numClippable++;
      modelMeshCounts.numClippable++;
    }
    if (flags & SCENE_OBJECT_FLAGS.PICKABLE) {
      layerMeshCounts.numPickable++;
      modelMeshCounts.numPickable++;
    }
    if (flags & SCENE_OBJECT_FLAGS.CULLED) {
      layerMeshCounts.numCulled++;
      modelMeshCounts.numCulled++;
    }
    if (meshTransparent) {
      layerMeshCounts.numTransparent++;
      modelMeshCounts.numTransparent++;
    }
    this.setLayerMeshFlags(viewIndex, layerMeshIndex, flags, meshTransparent);
  }
  setLayerMeshVisible(viewIndex, layerMeshIndex, flags, transparent) {
    if (!this.#built) {
      throw new SDKError("Not built");
    }
    if (flags & SCENE_OBJECT_FLAGS.VISIBLE) {
      this.meshCounts[viewIndex].numVisible++;
      this.rendererModel.meshCounts[viewIndex].numVisible++;
    } else {
      this.meshCounts[viewIndex].numVisible--;
      this.rendererModel.meshCounts[viewIndex].numVisible--;
    }
    this.setLayerMeshFlags(viewIndex, layerMeshIndex, flags, transparent);
  }
  setLayerMeshHighlighted(viewIndex, layerMeshIndex, flags, transparent) {
    if (!this.#built) {
      throw new SDKError("Not built");
    }
    if (flags & SCENE_OBJECT_FLAGS.HIGHLIGHTED) {
      this.meshCounts[viewIndex].numHighlighted++;
      this.rendererModel.meshCounts[viewIndex].numHighlighted++;
    } else {
      this.meshCounts[viewIndex].numHighlighted--;
      this.rendererModel.meshCounts[viewIndex].numHighlighted--;
    }
    this.setLayerMeshFlags(viewIndex, layerMeshIndex, flags, transparent);
  }
  setLayerMeshXRayed(viewIndex, layerMeshIndex, flags, transparent) {
    if (!this.#built) {
      throw new SDKError("Not built");
    }
    if (flags & SCENE_OBJECT_FLAGS.XRAYED) {
      this.meshCounts[viewIndex].numXRayed++;
      this.rendererModel.meshCounts[viewIndex].numXRayed++;
    } else {
      this.meshCounts[viewIndex].numXRayed--;
      this.rendererModel.meshCounts[viewIndex].numXRayed--;
    }
    this.setLayerMeshFlags(viewIndex, layerMeshIndex, flags, transparent);
  }
  setLayerMeshSelected(viewIndex, layerMeshIndex, flags, transparent) {
    if (!this.#built) {
      throw new SDKError("Not built");
    }
    if (flags & SCENE_OBJECT_FLAGS.SELECTED) {
      this.meshCounts[viewIndex].numSelected++;
      this.rendererModel.meshCounts[viewIndex].numSelected++;
    } else {
      this.meshCounts[viewIndex].numSelected--;
      this.rendererModel.meshCounts[viewIndex].numSelected--;
    }
    this.setLayerMeshFlags(viewIndex, layerMeshIndex, flags, transparent);
  }
  setLayerMeshClippable(viewIndex, layerMeshIndex, flags) {
    if (!this.#built) {
      throw new SDKError("Not built");
    }
    if (flags & SCENE_OBJECT_FLAGS.CLIPPABLE) {
      this.meshCounts[viewIndex].numClippable++;
      this.rendererModel.meshCounts[viewIndex].numClippable++;
    } else {
      this.meshCounts[viewIndex].numClippable--;
      this.rendererModel.meshCounts[viewIndex].numClippable--;
    }
    this.setLayerMeshFlags(viewIndex, layerMeshIndex, flags);
  }
  setLayerMeshCulled(viewIndex, layerMeshIndex, flags, transparent) {
    if (!this.#built) {
      throw new SDKError("Not built");
    }
    if (flags & SCENE_OBJECT_FLAGS.CULLED) {
      this.meshCounts[viewIndex].numCulled++;
      this.rendererModel.meshCounts[viewIndex].numCulled++;
    } else {
      this.meshCounts[viewIndex].numCulled--;
      this.rendererModel.meshCounts[viewIndex].numCulled--;
    }
    this.setLayerMeshFlags(viewIndex, layerMeshIndex, flags, transparent);
  }
  setLayerMeshCollidable(viewIndex, layerMeshIndex, flags) {
    if (!this.#built) {
      throw new SDKError("Not built");
    }
  }
  setLayerMeshPickable(viewIndex, layerMeshIndex, flags, transparent) {
    if (!this.#built) {
      throw new SDKError("Not built");
    }
    if (flags & SCENE_OBJECT_FLAGS.PICKABLE) {
      this.meshCounts[viewIndex].numPickable++;
      this.rendererModel.meshCounts[viewIndex].numPickable++;
    } else {
      this.meshCounts[viewIndex].numPickable--;
      this.rendererModel.meshCounts[viewIndex].numPickable--;
    }
    this.setLayerMeshFlags(viewIndex, layerMeshIndex, flags, transparent);
  }
  setLayerMeshColor(viewIndex, layerMeshIndex, color2) {
    if (!this.#built) {
      throw new SDKError("Not built");
    }
    const portionsIdx = layerMeshIndex * 2;
    const vertexBase = this.#portions[portionsIdx];
    const numVerts = this.#portions[portionsIdx + 1];
    const firstColor = vertexBase * 4;
    const lenColor = numVerts * 4;
    const tempArray = this.#scratchMemory.getUInt8Array(lenColor);
    const r = color2[0];
    const g = color2[1];
    const b4 = color2[2];
    for (let i = 0; i < lenColor; i += 4) {
      tempArray[i + 0] = r;
      tempArray[i + 1] = g;
      tempArray[i + 2] = b4;
    }
    this.renderState.colorsBuf[viewIndex].setData(tempArray, firstColor);
  }
  setLayerMeshTransparent(viewIndex, layerMeshIndex, flags, transparent) {
    if (transparent) {
      this.meshCounts[viewIndex].numTransparent++;
      this.rendererModel.meshCounts[viewIndex].numTransparent++;
    } else {
      this.meshCounts[viewIndex].numTransparent--;
      this.rendererModel.meshCounts[viewIndex].numTransparent--;
    }
    this.setLayerMeshFlags(viewIndex, layerMeshIndex, flags, transparent);
  }
  setLayerMeshFlags(viewIndex, layerMeshIndex, flags, transparent = false) {
    if (!this.#built) {
      throw new SDKError("Not built");
    }
    const view = this.renderContext.viewer.viewList[viewIndex];
    const portionsIdx = layerMeshIndex * 2;
    const vertexBase = this.#portions[portionsIdx];
    const numVerts = this.#portions[portionsIdx + 1];
    const firstFlag = vertexBase;
    const lenFlags = numVerts - vertexBase;
    const tempArray = this.#scratchMemory.getFloat32Array(lenFlags);
    const visible = !!(flags & SCENE_OBJECT_FLAGS.VISIBLE);
    const xrayed = !!(flags & SCENE_OBJECT_FLAGS.XRAYED);
    const highlighted = !!(flags & SCENE_OBJECT_FLAGS.HIGHLIGHTED);
    const selected = !!(flags & SCENE_OBJECT_FLAGS.SELECTED);
    const pickable = !!(flags & SCENE_OBJECT_FLAGS.PICKABLE);
    const culled = !!(flags & SCENE_OBJECT_FLAGS.CULLED);
    let colorFlag;
    if (!visible || culled || xrayed || highlighted && !view.highlightMaterial.glowThrough || selected && !view.selectedMaterial.glowThrough) {
      colorFlag = RENDER_PASSES.NOT_RENDERED;
    } else {
      if (transparent) {
        colorFlag = RENDER_PASSES.DRAW_TRANSPARENT;
      } else {
        colorFlag = RENDER_PASSES.DRAW_OPAQUE;
      }
    }
    let silhouetteFlag;
    if (!visible || culled) {
      silhouetteFlag = RENDER_PASSES.NOT_RENDERED;
    } else if (selected) {
      silhouetteFlag = RENDER_PASSES.SILHOUETTE_SELECTED;
    } else if (highlighted) {
      silhouetteFlag = RENDER_PASSES.SILHOUETTE_HIGHLIGHTED;
    } else if (xrayed) {
      silhouetteFlag = RENDER_PASSES.SILHOUETTE_XRAYED;
    } else {
      silhouetteFlag = RENDER_PASSES.NOT_RENDERED;
    }
    let pickFlag = visible && !culled && pickable ? RENDER_PASSES.PICK : RENDER_PASSES.NOT_RENDERED;
    const clippableFlag = !!(flags & SCENE_OBJECT_FLAGS.CLIPPABLE) ? 1 : 0;
    for (let i = 0; i < lenFlags; i++) {
      let vertFlag = 0;
      vertFlag |= colorFlag;
      vertFlag |= silhouetteFlag << 4;
      vertFlag |= pickFlag << 8;
      vertFlag |= clippableFlag << 12;
      tempArray[i] = vertFlag;
    }
    this.renderState.flagsBufs[viewIndex].setData(tempArray, firstFlag);
  }
  setLayerMeshMatrix(layerMeshIndex, matrix) {
    if (!this.#built) {
      throw new SDKError("Not built");
    }
  }
  setLayerMeshOffset(viewIndex, layerMeshIndex, offset) {
    if (!this.#built) {
      throw new SDKError("Not built");
    }
  }
  drawColorOpaque() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numCulled === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numVisible === 0 || this.meshCounts[viewIndex].numTransparent === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numXRayed === this.meshCounts[viewIndex].numMeshes) {
      return;
    }
    if (this.#rendererSet.colorRenderer) {
      this.#rendererSet.colorRenderer.renderVBOBatchingLayer(this, RENDER_PASSES.DRAW_OPAQUE);
    }
  }
  drawColorSAOOpaque() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numCulled === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numVisible === 0 || this.meshCounts[viewIndex].numTransparent === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numXRayed === this.meshCounts[viewIndex].numMeshes) {
      return;
    }
    if (this.#rendererSet.colorSAORenderer) {
      this.#rendererSet.colorSAORenderer.renderVBOBatchingLayer(this, RENDER_PASSES.DRAW_OPAQUE);
    }
  }
  drawColorTranslucent() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numCulled === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numVisible === 0 || this.meshCounts[viewIndex].numTransparent === 0 || this.meshCounts[viewIndex].numXRayed === this.meshCounts[viewIndex].numMeshes) {
      return;
    }
    if (this.#rendererSet.colorRenderer) {
      this.#rendererSet.colorRenderer.renderVBOBatchingLayer(this, RENDER_PASSES.DRAW_TRANSPARENT);
    }
  }
  drawDepth() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numCulled === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numVisible === 0 || this.meshCounts[viewIndex].numTransparent === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numXRayed === this.meshCounts[viewIndex].numMeshes) {
      return;
    }
    if (this.#rendererSet.drawDepthRenderer) {
      this.#rendererSet.drawDepthRenderer.renderVBOBatchingLayer(this, RENDER_PASSES.DRAW_OPAQUE);
    }
  }
  drawNormals() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numCulled === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numVisible === 0 || this.meshCounts[viewIndex].numTransparent === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numXRayed === this.meshCounts[viewIndex].numMeshes) {
      return;
    }
  }
  drawSilhouetteXRayed() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numCulled === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numVisible === 0 || this.meshCounts[viewIndex].numXRayed === 0) {
      return;
    }
    if (this.#rendererSet.silhouetteRenderer) {
      this.#rendererSet.silhouetteRenderer.renderVBOBatchingLayer(this, RENDER_PASSES.SILHOUETTE_XRAYED);
    }
  }
  drawSilhouetteHighlighted() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numCulled === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numVisible === 0 || this.meshCounts[viewIndex].numHighlighted === 0) {
      return;
    }
    if (this.#rendererSet.silhouetteRenderer) {
      this.#rendererSet.silhouetteRenderer.renderVBOBatchingLayer(this, RENDER_PASSES.SILHOUETTE_HIGHLIGHTED);
    }
  }
  drawSilhouetteSelected() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numCulled === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numVisible === 0 || this.meshCounts[viewIndex].numSelected === 0) {
      return;
    }
    if (this.#rendererSet.silhouetteRenderer) {
      this.#rendererSet.silhouetteRenderer.renderVBOBatchingLayer(this, RENDER_PASSES.SILHOUETTE_SELECTED);
    }
  }
  drawEdgesColorOpaque() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numCulled === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numVisible === 0) {
      return;
    }
    if (this.#rendererSet.edgesColorRenderer) {
      this.#rendererSet.edgesColorRenderer.renderVBOBatchingLayer(this, RENDER_PASSES.DRAW_OPAQUE);
    }
  }
  drawEdgesColorTranslucent() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numCulled === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numVisible === 0 || this.meshCounts[viewIndex].numTransparent === 0) {
      return;
    }
    if (this.#rendererSet.edgesColorRenderer) {
      this.#rendererSet.edgesColorRenderer.renderVBOBatchingLayer(this, RENDER_PASSES.DRAW_TRANSPARENT);
    }
  }
  drawEdgesHighlighted() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numCulled === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numVisible === 0 || this.meshCounts[viewIndex].numHighlighted === 0) {
      return;
    }
    if (this.#rendererSet.edgesSilhouetteRenderer) {
      this.#rendererSet.edgesSilhouetteRenderer.renderVBOBatchingLayer(this, RENDER_PASSES.SILHOUETTE_HIGHLIGHTED);
    }
  }
  drawEdgesSelected() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numCulled === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numVisible === 0 || this.meshCounts[viewIndex].numSelected === 0) {
      return;
    }
    if (this.#rendererSet.edgesSilhouetteRenderer) {
      this.#rendererSet.edgesSilhouetteRenderer.renderVBOBatchingLayer(this, RENDER_PASSES.SILHOUETTE_SELECTED);
    }
  }
  drawEdgesXRayed() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numCulled === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numVisible === 0 || this.meshCounts[viewIndex].numXRayed === 0) {
      return;
    }
    if (this.#rendererSet.edgesSilhouetteRenderer) {
      this.#rendererSet.edgesSilhouetteRenderer.renderVBOBatchingLayer(this, RENDER_PASSES.SILHOUETTE_XRAYED);
    }
  }
  drawOcclusion() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numCulled === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numVisible === 0) {
      return;
    }
    if (this.#rendererSet.occlusionRenderer) {
      this.#rendererSet.occlusionRenderer.renderVBOBatchingLayer(this, RENDER_PASSES.DRAW_OPAQUE);
    }
  }
  drawShadow() {
    const viewIndex = this.renderContext.view.viewIndex;
  }
  drawPickMesh() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numVisible === 0) {
      return;
    }
    if (this.#rendererSet.pickMeshRenderer) {
      this.#rendererSet.pickMeshRenderer.renderVBOBatchingLayer(this, RENDER_PASSES.PICK);
    }
  }
  drawPickDepths() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numVisible === 0) {
      return;
    }
    if (this.#rendererSet.pickDepthRenderer) {
      this.#rendererSet.pickDepthRenderer.renderVBOBatchingLayer(this, RENDER_PASSES.PICK);
    }
  }
  drawSnapInit() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numCulled === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numVisible === 0) {
      return;
    }
    if (this.#rendererSet.snapInitRenderer) {
      this.#rendererSet.snapInitRenderer.renderVBOBatchingLayer(this, RENDER_PASSES.PICK);
    }
  }
  drawSnap() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numCulled === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numVisible === 0) {
      return;
    }
    if (this.#rendererSet.snapRenderer) {
      this.#rendererSet.snapRenderer.renderVBOBatchingLayer(this, RENDER_PASSES.PICK);
    }
  }
  drawPickNormals() {
  }
  destroy() {
    const renderState = this.renderState;
    if (renderState.positionsBuf) {
      renderState.positionsBuf.destroy();
      renderState.positionsBuf = null;
    }
    if (renderState.offsetsBuf) {
      renderState.offsetsBuf.destroy();
      renderState.offsetsBuf = null;
    }
    for (let viewIndex = 0, len = renderState.colorsBuf.length; viewIndex < len; viewIndex++) {
      if (renderState.colorsBuf[viewIndex]) {
        renderState.colorsBuf[viewIndex].destroy();
        renderState.colorsBuf[viewIndex] = null;
      }
    }
    for (let viewIndex = 0, len = renderState.flagsBufs.length; viewIndex < len; viewIndex++) {
      if (renderState.flagsBufs[viewIndex]) {
        renderState.flagsBufs[viewIndex].destroy();
        renderState.flagsBufs[viewIndex] = null;
      }
    }
    if (renderState.pickColorsBuf) {
      renderState.pickColorsBuf.destroy();
      renderState.pickColorsBuf = null;
    }
    if (renderState.uvBuf) {
      renderState.uvBuf.destroy();
      renderState.uvBuf = null;
    }
    if (renderState.indicesBuf) {
      renderState.indicesBuf.destroy();
      renderState.indicesBuf = null;
    }
    if (renderState.edgeIndicesBuf) {
      renderState.edgeIndicesBuf.destroy();
      renderState.edgeIndicesBuf = null;
    }
    putScratchMemory();
  }
  commitRendererState(viewIndex) {
  }
  isEmpty() {
    return false;
  }
};

// ../sdk/src/webglrenderer/vbo/VBORenderer.ts
var defaultColor = new Float32Array([1, 1, 1, 1]);
function joinSansComments(srcLines) {
  const src = [];
  let line;
  let n;
  for (let i = 0, len = srcLines.length; i < len; i++) {
    line = srcLines[i];
    n = line.indexOf("/");
    if (n > 0) {
      if (line.charAt(n + 1) === "/") {
        line = line.substring(0, n);
      }
    }
    src.push(line);
  }
  return src.join("\n");
}
var VBORenderer = class {
  renderContext;
  hash;
  program;
  errors;
  edges;
  #needRebuild;
  uniforms;
  attributes;
  samplers;
  constructor(renderContext, cfg = { edges: false }) {
    this.renderContext = renderContext;
    this.#needRebuild = true;
    this.edges = cfg.edges;
    this.build();
  }
  get lambertShadingHash() {
    return this.renderContext.view.getLightsHash();
  }
  get slicingHash() {
    return this.renderContext.view.getSectionPlanesHash();
  }
  get pointsHash() {
    const pointsMaterial = this.renderContext.view.pointsMaterial;
    return `${pointsMaterial.roundPoints}-${pointsMaterial.perspectivePoints}`;
  }
  needRebuild() {
    this.#needRebuild = true;
  }
  getValid() {
    if (!this.#needRebuild) {
      return true;
    }
    this.#needRebuild = false;
    return this.hash === this.getHash();
  }
  build() {
    const view = this.renderContext.view;
    const gl = this.renderContext.gl;
    const vertexSrc = [];
    this.buildVertexShader(vertexSrc);
    const fragmentSrc = [];
    this.buildFragmentShader(fragmentSrc);
    this.program = new WebGLProgram(gl, {
      vertex: joinSansComments(vertexSrc),
      fragment: joinSansComments(fragmentSrc)
    });
    if (this.program.errors) {
      this.errors = this.program.errors;
      return;
    }
    const program = this.program;
    this.uniforms = {
      renderPass: program.getLocation("renderPass"),
      gammaFactor: program.getLocation("gammaFactor"),
      sceneModelMatrix: program.getLocation("sceneModelMatrix"),
      viewMatrix: program.getLocation("viewMatrix"),
      projMatrix: program.getLocation("projMatrix"),
      worldMatrix: program.getLocation("worldMatrix"),
      positionsDecompressOffset: program.getLocation("positionsDecompressOffset"),
      positionsDecompressScale: program.getLocation("positionsDecompressScale"),
      snapCameraEyeRTC: program.getLocation("snapCameraEyeRTC"),
      pointSize: program.getLocation("pointSize"),
      intensityRange: program.getLocation("intensityRange"),
      nearPlaneHeight: program.getLocation("nearPlaneHeight"),
      pointCloudIntensityRange: program.getLocation("pointCloudIntensityRange"),
      pickZNear: program.getLocation("pickZNear"),
      pickZFar: program.getLocation("pickZFar"),
      pickClipPos: program.getLocation("pickClipPos"),
      drawingBufferSize: program.getLocation("drawingBufferSize"),
      silhouetteColor: program.getLocation("silhouetteColor"),
      sectionPlanes: [],
      lightColor: [],
      lightDir: [],
      lightPos: [],
      lightAttenuation: [],
      lightAmbient: program.getLocation("lightAmbient"),
      saoParams: program.getLocation("saoParams")
    };
    const lights = view.lightsList;
    for (let i = 0, len = lights.length; i < len; i++) {
      const light = lights[i];
      if (light instanceof DirLight) {
        this.uniforms.lightColor[i] = program.getLocation("lightColor" + i);
        this.uniforms.lightPos[i] = null;
        this.uniforms.lightDir[i] = program.getLocation("lightDir" + i);
        break;
      } else {
        this.uniforms.lightColor[i] = program.getLocation("lightColor" + i);
        this.uniforms.lightPos[i] = program.getLocation("lightPos" + i);
        this.uniforms.lightDir[i] = null;
        this.uniforms.lightAttenuation[i] = program.getLocation("lightAttenuation" + i);
      }
    }
    const uniforms = this.uniforms;
    for (let i = 0, len = view.sectionPlanesList.length; i < len; i++) {
      uniforms.sectionPlanes.push({
        active: program.getLocation("sectionPlaneActive" + i),
        pos: program.getLocation("sectionPlanePos" + i),
        dir: program.getLocation("sectionPlaneDir" + i)
      });
    }
    this.attributes = {
      position: program.getAttribute("position"),
      normal: program.getAttribute("normal"),
      color: program.getAttribute("color"),
      uv: program.getAttribute("uv"),
      intensity: program.getAttribute("intensity"),
      flags: program.getAttribute("flags"),
      pickColor: program.getAttribute("pickColor"),
      modelMatrix: program.getAttribute("modelMatrix"),
      // Instancing
      modelMatrixCol0: program.getAttribute("modelMatrixCol0"),
      modelMatrixCol1: program.getAttribute("modelMatrixCol1"),
      modelMatrixCol2: program.getAttribute("modelMatrixCol2")
    };
    this.hash = this.getHash();
    this.#needRebuild = false;
  }
  vertexHeader(src) {
    src.push("#version 300 es");
    src.push(`// ${this.constructor.name} vertex shader`);
  }
  vertexCommonDefs(src) {
    src.push("in float flags;");
    src.push("uniform int renderPass;");
  }
  vertexBatchingTransformDefs(src) {
    src.push("in vec3 position;");
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 worldMatrix;");
    src.push("uniform vec3 positionsDecompressOffset;");
    src.push("uniform vec3 positionsDecompressScale;");
  }
  vertexInstancingTransformDefs(src) {
    src.push("uniform mat4 viewMatrix;");
    src.push("uniform mat4 projMatrix;");
    src.push("uniform mat4 worldMatrix;");
    src.push("uniform vec3 positionsDecompressOffset;");
    src.push("uniform vec3 positionsDecompressScale;");
    src.push("in vec3 position;");
    src.push("in vec4 modelMatrixCol0;");
    src.push("in vec4 modelMatrixCol1;");
    src.push("in vec4 modelMatrixCol2;");
  }
  vertexPickMeshDefs(src) {
    src.push("in vec4 pickColor;");
    src.push("out vec4 vPickColor;");
    src.push("uniform vec2 drawingBufferSize;");
    src.push("uniform vec2 pickClipPos;");
    src.push("vec4 remapPickClipPos(vec4 clipPos) {");
    src.push("    clipPos.xy /= clipPos.w;");
    src.push("    clipPos.xy = (clipPos.xy - pickClipPos) * drawingBufferSize;");
    src.push("    clipPos.xy *= clipPos.w;");
    src.push("    return clipPos;");
    src.push("}");
  }
  vertexSlicingDefs(src) {
    if (this.renderContext.view.getNumAllocatedSectionPlanes() > 0) {
      src.push("out vec4 vWorldPosition;");
      src.push("out boolean vClippable;");
    }
  }
  vertexDrawMainOpen(src) {
    src.push("void main(void) {");
    src.push(`      int colorFlag = (int(flags) & 0xF);`);
    src.push(`      if (colorFlag != renderPass) {`);
    src.push("          gl_Position = vec4(2.0, 0.0, 0.0, 0.0);");
    src.push("      } else {");
  }
  vertexSilhouetteMainOpen(src) {
    src.push("void main(void) {");
    src.push("      int silhouetteFlag = (int(flags) >> 4 & 0xF);");
    src.push(`      if (silhouetteFlag != renderPass) {`);
    src.push("          gl_Position = vec4(2.0, 0.0, 0.0, 0.0);");
    src.push("      } else {");
  }
  vertexPickMainOpen(src) {
    src.push("void main(void) {");
    src.push(`      int pickFlag = int(flags) >> 8 & 0xF;`);
    src.push(`      if (pickFlag != renderPass) {`);
    src.push("          gl_Position = vec4(2.0, 0.0, 0.0, 0.0);");
    src.push("      } else {");
  }
  vertexMainClose(src) {
    src.push("      }");
    src.push("}");
  }
  vertexSlicingLogic(src) {
    if (this.renderContext.view.getNumAllocatedSectionPlanes() > 0) {
      src.push("      vWorldPosition = worldPosition;");
      src.push("      vClippable = (int(flags) >> 12 & 0xF) == 1;");
    }
  }
  vertexDrawBatchingTransformLogic(src) {
    src.push("          vec4 worldPosition = (vec4(positionsDecompressOffset + (positionsDecompressScale * position), 1.0)); ");
    src.push("          vec4 viewPosition  = viewMatrix * worldPosition; ");
    src.push("          gl_Position = projMatrix * viewPosition;");
  }
  vertexDrawPointsBatchingTransformLogic(src) {
    src.push("          vec4 worldPosition = (vec4(positionsDecompressOffset + (positionsDecompressScale * position), 1.0)); ");
    src.push("          vec4 viewPosition  = viewMatrix * worldPosition; ");
    src.push("          vec4 clipPos = projMatrix * viewPosition;");
    src.push("          gl_Position = clipPos;");
    src.push("          clipPos.xy *= clipPos.w;");
  }
  vertexPickBatchingTransformLogic(src) {
    src.push("          vec4 worldPosition = (vec4(positionsDecompressOffset + (positionsDecompressScale * position), 1.0)); ");
    src.push("          vec4 viewPosition  = viewMatrix * worldPosition; ");
    src.push("          gl_Position = remapPickClipPos(projMatrix * viewPosition);");
  }
  vertexDrawInstancingTransformLogic(src) {
    src.push("          vec4 worldPosition = (vec4(positionsDecompressOffset + (positionsDecompressScale * position), 1.0)); ");
    src.push("          vec4 viewPosition  = viewMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0); ");
    src.push("          gl_Position = projMatrix * viewPosition;");
  }
  vertexPickInstancingTransformLogic(src) {
    src.push("          vec4 worldPosition = (vec4(positionsDecompressOffset + (positionsDecompressScale * position), 1.0)); ");
    src.push("          vec4 viewPosition  = viewMatrix * vec4(dot(worldPosition, modelMatrixCol0), dot(worldPosition, modelMatrixCol1), dot(worldPosition, modelMatrixCol2), 1.0); ");
    src.push("          gl_Position = remapPickClipPos(projMatrix * viewPosition);");
  }
  vertexDrawLambertDefs(src) {
    src.push("          in  vec4 color;");
    src.push("          out vec4 vColor;");
    src.push("          out vec4 vViewPosition;");
  }
  vertexDrawLambertLogic(src) {
    src.push("          vColor = vec4(float(color.r) / 255.0, float(color.g) / 255.0, float(color.b) / 255.0, 1.0);");
    src.push("          vViewPosition = viewPosition;");
  }
  vertexSilhouetteDefs(src) {
    src.push("          uniform vec4 silhouetteColor;");
    src.push("          out vec4 vColor;");
  }
  vertexSilhouetteLogic(src) {
    src.push("          vColor = vec4(silhouetteColor.r, silhouetteColor.g, silhouetteColor.b, 0.5);");
  }
  vertexDrawFlatColorLogic(src) {
    src.push("          vColor = vec4(float(color.r) / 255.0, float(color.g) / 255.0, float(color.b) / 255.0, 1.0);");
  }
  vertexDrawFlatColorDefs(src) {
    src.push("          in vec4 color;");
    src.push("          out vec4 vColor;");
  }
  vertexDrawEdgesColorLogic(src) {
    src.push("          vColor = vec4(float(color.r-200.0) / 255.0, float(color.g-200.0) / 255.0, float(color.b-200.0) / 255.0, 1.0);");
  }
  vertexPickMeshLogic(src) {
    src.push("          vPickColor = vec4(float(pickColor.r) / 255.0, float(pickColor.g) / 255.0, float(pickColor.b) / 255.0, float(pickColor.a) / 255.0);");
  }
  vertexPointsDrawDefs(src) {
    src.push("in vec4 color;");
    src.push("out vec4 vColor;");
  }
  vertexDrawPointsColorsLogic(src) {
    src.push("vColor = vec4(float(color.r) / 255.0, float(color.g) / 255.0, float(color.b) / 255.0, 1.0);");
  }
  vertexPointsGeometryDefs(src) {
    const pointsMaterial = this.renderContext.view.pointsMaterial;
    if (pointsMaterial.perspectivePoints) {
      src.push("uniform float nearPlaneHeight;");
    }
    if (pointsMaterial.filterIntensity) {
      src.push("uniform vec2 intensityRange;");
    }
    src.push("uniform float pointSize;");
  }
  vertexPointsFilterLogicOpenBlock(src) {
    const pointsMaterial = this.renderContext.view.pointsMaterial;
    if (pointsMaterial.filterIntensity) {
      src.push("float intensity = float(color.a) / 255.0;");
      src.push("if (intensity < intensityRange[0] || intensity > intensityRange[1]) {");
      src.push("   gl_Position = vec4(2.0, 0.0, 0.0, 0.0);");
      src.push("} else {");
    }
  }
  vertexPointsFilterLogicCloseBlock(src) {
    const pointsMaterial = this.renderContext.view.pointsMaterial;
    if (pointsMaterial.filterIntensity) {
      src.push("}");
    }
  }
  vertexPointsGeometryLogic(src) {
    const pointsMaterial = this.renderContext.view.pointsMaterial;
    src.push("gl_PointSize = pointSize;");
  }
  fragmentHeader(src) {
    src.push("#version 300 es");
    src.push(`// ${this.constructor.name} fragment shader`);
  }
  fragmentPrecisionDefs(src) {
    src.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
    src.push("precision highp float;");
    src.push("precision highp int;");
    src.push("#else");
    src.push("precision mediump float;");
    src.push("precision mediump int;");
    src.push("#endif");
  }
  fragmentCommonDefs(src) {
    src.push("vec4 color;");
    src.push("out vec4 outColor;");
  }
  fragmentDrawLambertDefs(src) {
    const view = this.renderContext.view;
    src.push("in vec4 vColor;");
    src.push("in vec4 vViewPosition;");
    src.push("uniform vec4 lightAmbient;");
    src.push("uniform mat4 viewMatrix;");
    for (let i = 0, len = view.lightsList.length; i < len; i++) {
      const light = view.lightsList[i];
      if (light instanceof AmbientLight) {
        continue;
      }
      src.push(`uniform vec4 lightColor${i};`);
      if (light instanceof DirLight) {
        src.push(`uniform vec3 lightDir${i};`);
      }
      if (light instanceof PointLight) {
        src.push(`uniform vec3 lightPos${i};`);
      }
    }
  }
  fragmentDrawLambertLogic(src) {
    const view = this.renderContext.view;
    src.push("vec3 reflectedColor = vec3(0.0, 0.0, 0.0);");
    src.push("vec3 viewLightDir = vec3(0.0, 0.0, -1.0);");
    src.push("float lambertian = 1.0;");
    src.push("vec3 xTangent = dFdx( vViewPosition.xyz );");
    src.push("vec3 yTangent = dFdy( vViewPosition.xyz );");
    src.push("vec3 viewNormal = normalize( cross( xTangent, yTangent ) );");
    for (let i = 0, len = view.lightsList.length; i < len; i++) {
      const light = view.lightsList[i];
      if (light instanceof AmbientLight) {
        continue;
      }
      if (light instanceof DirLight) {
        if (light.space === "view") {
          src.push(`viewLightDir = normalize(lightDir${i});`);
        } else {
          src.push(`viewLightDir = normalize((viewMatrix * vec4(lightDir${i}, 0.0)).xyz);`);
        }
      } else if (light instanceof PointLight) {
        if (light.space === "view") {
          src.push(`viewLightDir = -normalize(lightPos${i} - viewPosition.xyz);`);
        } else {
          src.push(`viewLightDir = -normalize((viewMatrix * vec4(lightPos${i}, 0.0)).xyz);`);
        }
      } else {
        continue;
      }
      src.push("lambertian = max(dot(-viewNormal, viewLightDir), 0.0);");
      src.push(`reflectedColor += lambertian * (lightColor${i}.rgb * lightColor${i}.a);`);
    }
    src.push("color = vec4((lightAmbient.rgb * lightAmbient.a * vColor.rgb) + (reflectedColor * vColor.rgb), vColor.a);");
  }
  fragmentDrawSAODefs(src) {
    src.push("uniform sampler2D saoOcclusionTexture;");
    src.push("uniform vec4      saoParams;");
    src.push("const float       saoUnpackDownScale = 255. / 256.;");
    src.push("const vec3        saoPackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );");
    src.push("const vec4        saoUnpackFactors = saoUnpackDownScale / vec4( saoPackFactors, 1. );");
    src.push("float saoUnpackRGBToFloat( const in vec4 v ) {");
    src.push("    return dot( v, saoUnpackFactors );");
    src.push("}");
  }
  fragmentSilhouetteDefs(src) {
    src.push(
      "in vec4 vColor;"
    );
  }
  fragmentDrawFlatColorDefs(src) {
    src.push("in vec4 vColor;");
  }
  fragmentDrawFlatColorLogic(src) {
    src.push("color = vColor;");
  }
  fragmentDrawSAOLogic(src) {
    src.push("   float saoViewportWidth = saoParams[0];");
    src.push("   float saoViewportHeight = saoParams[1];");
    src.push("   float saoBlendCutoff = saoParams[2];");
    src.push("   float saoBlendFactor = saoParams[3];");
    src.push("   vec2  saoUV = vec2(gl_FragCoord.x / saoViewportWidth, gl_FragCoord.y / saoViewportHeight);");
    src.push("   float saoAmbient = smoothstep(saoBlendCutoff, 1.0, saoUnpackRGBToFloat(texture(saoOcclusionTexture, saoUV))) * saoBlendFactor;");
    src.push("   color = vec4(color.rgb * saoAmbient, 1.0);");
  }
  fragmentDrawDepthDefs(src) {
    src.push("in vec2 vHighPrecisionZW;");
  }
  fragmentDrawDepthLogic(src) {
    src.push("float depthFragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;");
    src.push("color = vec4(vec3(1.0 - depthFragCoordZ), 1.0); ");
  }
  fragmentSilhouetteLogic(src) {
    src.push("color = vColor;");
  }
  fragmentPickMeshDefs(src) {
    src.push("in vec4 vPickColor;");
    src.push("out vec4 outColor;");
  }
  fragmentPickMeshLogic(src) {
    src.push("color = vPickColor;");
  }
  fragmentSlicingDefs(src) {
    const numSectionPlanes = this.renderContext.view.getNumAllocatedSectionPlanes();
    if (numSectionPlanes === 0) {
      return;
    }
    src.push("in vec4 vWorldPosition;");
    src.push("in boolean vClippable;");
    for (let i = 0; i < numSectionPlanes; i++) {
      src.push("uniform bool sectionPlaneActive" + i + ";");
      src.push("uniform vec3 sectionPlanePos" + i + ";");
      src.push("uniform vec3 sectionPlaneDir" + i + ";");
    }
  }
  fragmentSlicingLogic(src) {
    const numSectionPlanes = this.renderContext.view.getNumAllocatedSectionPlanes();
    if (numSectionPlanes === 0) {
      return;
    }
    src.push("  if (vClippable) {");
    src.push("    float dist = 0.0;");
    for (let i = 0; i < numSectionPlanes; i++) {
      src.push("    if (sectionPlaneActive" + i + ") {");
      src.push("      dist += clamp(dot(-sectionPlaneDir" + i + ".xyz, vWorldPosition.xyz - sectionPlanePos" + i + ".xyz), 0.0, 1000.0);");
      src.push("    }");
    }
    src.push("    if (dist > 0.0) { discard; }");
    src.push("  }");
  }
  fragmentPointsGeometryLogic(src) {
    if (this.renderContext.view.pointsMaterial.roundPoints) {
      src.push("  vec2 cxy = 2.0 * gl_PointCoord - 1.0;");
      src.push("  float r = dot(cxy, cxy);");
      src.push("  if (r > 1.0) {");
      src.push("       discard;");
      src.push("  }");
    }
  }
  fragmentCommonOutput(src) {
    src.push("outColor = color;");
  }
  bind(renderPass) {
    const view = this.renderContext.view;
    const gl = this.renderContext.gl;
    const uniforms = this.uniforms;
    const renderContext = this.renderContext;
    renderContext.textureUnit = 0;
    if (this.program && !this.getValid()) {
      this.program.destroy();
      this.program = null;
    }
    if (!this.program) {
      this.build();
      if (this.errors) {
        return false;
      }
      renderContext.lastProgramId = -1;
    }
    if (!this.program) {
      return false;
    }
    if (renderContext.lastProgramId === this.program.id) {
      return true;
    }
    this.program.bind();
    renderContext.lastProgramId = this.program.id;
    gl.uniform1i(uniforms.renderPass, renderPass);
    if (uniforms.projMatrix) {
      gl.uniformMatrix4fv(
        uniforms.projMatrix,
        false,
        renderPass === RENDER_PASSES.PICK ? renderContext.pickProjMatrix : view.camera.projMatrix
      );
    }
    if (uniforms.pointSize) {
      gl.uniform1f(uniforms.pointSize, view.pointsMaterial.pointSize);
    }
    if (uniforms.nearPlaneHeight) {
      gl.uniform1f(uniforms.nearPlaneHeight, view.camera.projectionType === OrthoProjectionType ? 1 : gl.drawingBufferHeight / (2 * Math.tan(0.5 * view.camera.perspectiveProjection.fov * Math.PI / 180)));
    }
    if (uniforms.pickZNear) {
      gl.uniform1f(uniforms.pickZNear, renderContext.pickZNear);
      gl.uniform1f(uniforms.pickZFar, renderContext.pickZFar);
    }
    if (uniforms.drawingBufferSize) {
      gl.uniform2f(uniforms.drawingBufferSize, gl.drawingBufferWidth, gl.drawingBufferHeight);
    }
    if (uniforms.pickClipPos) {
      gl.uniform2fv(uniforms.pickClipPos, renderContext.pickClipPos);
    }
    if (uniforms.lightAmbient) {
      gl.uniform4fv(uniforms.lightAmbient, view.getAmbientColorAndIntensity());
    }
    for (let i = 0, len = view.lightsList.length; i < len; i++) {
      const light = view.lightsList[i];
      if (this.uniforms.lightColor[i]) {
        gl.uniform4f(this.uniforms.lightColor[i], light.color[0], light.color[1], light.color[2], light.intensity);
      }
      if (this.uniforms.lightPos[i]) {
        const pointLight = light;
        gl.uniform3fv(this.uniforms.lightPos[i], pointLight.pos);
      }
      if (this.uniforms.lightDir[i]) {
        const dirLight = light;
        gl.uniform3fv(this.uniforms.lightDir[i], dirLight.dir);
      }
    }
    if (this.uniforms.silhouetteColor) {
      if (this.edges) {
        if (renderPass === RENDER_PASSES.SILHOUETTE_XRAYED) {
          const material = view.xrayMaterial;
          const color2 = material.edgeColor;
          gl.uniform4f(this.uniforms.silhouetteColor, color2[0], color2[1], color2[2], material.edgeAlpha);
        } else if (renderPass === RENDER_PASSES.SILHOUETTE_HIGHLIGHTED) {
          const material = view.highlightMaterial;
          const color2 = material.edgeColor;
          gl.uniform4f(this.uniforms.silhouetteColor, color2[0], color2[1], color2[2], material.edgeAlpha);
        } else if (renderPass === RENDER_PASSES.SILHOUETTE_SELECTED) {
          const material = view.selectedMaterial;
          const color2 = material.edgeColor;
          gl.uniform4f(this.uniforms.silhouetteColor, color2[0], color2[1], color2[2], material.edgeAlpha);
        } else {
          gl.uniform4fv(this.uniforms.silhouetteColor, defaultColor);
        }
      } else {
        if (renderPass === RENDER_PASSES.SILHOUETTE_XRAYED) {
          const material = view.xrayMaterial;
          const color2 = material.fillColor;
          gl.uniform4f(this.uniforms.silhouetteColor, color2[0], color2[1], color2[2], material.fillAlpha);
        } else if (renderPass === RENDER_PASSES.SILHOUETTE_HIGHLIGHTED) {
          const material = view.highlightMaterial;
          const color2 = material.fillColor;
          gl.uniform4f(this.uniforms.silhouetteColor, color2[0], color2[1], color2[2], material.fillAlpha);
        } else if (renderPass === RENDER_PASSES.SILHOUETTE_SELECTED) {
          const material = view.selectedMaterial;
          const color2 = material.fillColor;
          gl.uniform4f(this.uniforms.silhouetteColor, color2[0], color2[1], color2[2], material.fillAlpha);
        } else {
          gl.uniform4fv(this.uniforms.silhouetteColor, defaultColor);
        }
      }
    }
    const sao = view.sao;
    const saoEnabled = sao.possible;
    if (saoEnabled) {
      if (this.uniforms.saoParams) {
        gl.uniform4f(this.uniforms.saoParams, gl.drawingBufferWidth, gl.drawingBufferHeight, sao.blendCutoff, sao.blendFactor);
        this.program.bindTexture(
          this.samplers.saoOcclusionTexture,
          renderContext.saoOcclusionTexture,
          renderContext.textureUnit
        );
        renderContext.textureUnit = (renderContext.textureUnit + 1) % WEBGL_INFO.MAX_TEXTURE_UNITS;
      }
    }
    return true;
  }
  renderVBOInstancingLayer(vboInstancinglayer, renderPass) {
  }
  renderVBOBatchingLayer(vboInstancinglayer, renderPass) {
  }
  destroy() {
    if (this.program) {
      this.program.destroy();
    }
    this.program = null;
  }
};

// ../sdk/src/webglrenderer/vbo/batching/VBOBatchingRenderer.ts
var VBOBatchingRenderer = class extends VBORenderer {
  renderVBOBatchingLayer(vboBatchingLayer, renderPass) {
    if (!this.bind(renderPass)) {
      return;
    }
    const attributes = this.attributes;
    const renderState = vboBatchingLayer.renderState;
    const view = this.renderContext.view;
    const viewIndex = view.viewIndex;
    const gl = this.renderContext.gl;
    attributes.position.bindArrayBuffer(renderState.positionsBuf);
    if (attributes.flags) {
      attributes.flags.bindArrayBuffer(renderState.flagsBufs[viewIndex]);
    }
    if (attributes.color) {
      attributes.color.bindArrayBuffer(renderState.colorsBuf[viewIndex]);
    }
    if (attributes.pickColor) {
      attributes.pickColor.bindArrayBuffer(renderState.pickColorsBuf);
    }
    if (attributes.intensity) {
    }
    if (attributes.uv) {
      attributes.uv.bindArrayBuffer(renderState.uvBuf);
    }
    gl.uniform1i(this.uniforms.renderPass, renderPass);
    gl.uniform3fv(this.uniforms.positionsDecompressOffset, renderState.positionsDecompressOffset);
    gl.uniform3fv(this.uniforms.positionsDecompressScale, renderState.positionsDecompressScale);
    gl.uniformMatrix4fv(this.uniforms.worldMatrix, false, vboBatchingLayer.rendererModel.worldMatrix);
    gl.uniformMatrix4fv(
      this.uniforms.viewMatrix,
      false,
      createRTCViewMat(
        renderPass === RENDER_PASSES.PICK ? this.renderContext.pickViewMatrix : this.renderContext.view.camera.viewMatrix,
        renderState.origin
      )
    );
    if (renderState.indicesBuf) {
      renderState.indicesBuf.bind();
    }
    this.drawVBOBatchingLayerPrimitives(vboBatchingLayer, renderPass);
  }
};

// ../sdk/src/webglrenderer/vbo/batching/points/renderers/VBOPointsBatchingDrawColorRenderer.ts
var VBOPointsBatchingDrawColorRenderer = class extends VBOBatchingRenderer {
  getHash() {
    const view = this.renderContext.view;
    const pointsMaterial = view.pointsMaterial;
    return `${pointsMaterial.perspectivePoints}-${pointsMaterial.filterIntensity}-${pointsMaterial.roundPoints}-${view.getSectionPlanesHash()}`;
  }
  buildVertexShader(src) {
    this.vertexHeader(src);
    this.vertexCommonDefs(src);
    this.vertexBatchingTransformDefs(src);
    this.vertexSlicingDefs(src);
    this.vertexPointsGeometryDefs(src);
    this.vertexPointsDrawDefs(src);
    this.vertexDrawMainOpen(src);
    {
      this.vertexPointsFilterLogicOpenBlock(src);
      {
        this.vertexDrawPointsBatchingTransformLogic(src);
        this.vertexSlicingLogic(src);
        this.vertexDrawPointsColorsLogic(src);
        this.vertexPointsGeometryLogic(src);
      }
      this.vertexPointsFilterLogicCloseBlock(src);
    }
    this.vertexMainClose(src);
  }
  buildFragmentShader(src) {
    this.fragmentHeader(src);
    this.fragmentPrecisionDefs(src);
    this.fragmentCommonDefs(src);
    this.fragmentSlicingDefs(src);
    this.fragmentDrawFlatColorDefs(src);
    src.push("void main(void) {");
    {
      this.fragmentPointsGeometryLogic(src);
      this.fragmentSlicingLogic(src);
      this.fragmentDrawFlatColorLogic(src);
      this.fragmentCommonOutput(src);
    }
    src.push("}");
  }
  drawVBOBatchingLayerPrimitives(vboBatchingLayer, renderPass) {
    const gl = this.renderContext.gl;
    gl.drawArrays(gl.POINTS, 0, vboBatchingLayer.renderState.positionsBuf.numItems);
  }
};

// ../sdk/src/webglrenderer/vbo/batching/points/renderers/VBOPointsBatchingPickMeshRenderer.ts
var VBOPointsBatchingPickMeshRenderer = class extends VBOBatchingRenderer {
  getHash() {
    const view = this.renderContext.view;
    const pointsMaterial = view.pointsMaterial;
    return `${pointsMaterial.perspectivePoints}-${pointsMaterial.filterIntensity}-${pointsMaterial.roundPoints}-${view.getSectionPlanesHash()}`;
  }
  buildVertexShader(src) {
    this.vertexHeader(src);
    this.vertexCommonDefs(src);
    this.vertexBatchingTransformDefs(src);
    this.vertexSlicingDefs(src);
    this.vertexPointsGeometryDefs(src);
    this.vertexPointsDrawDefs(src);
    this.vertexPickMainOpen(src);
    {
      this.vertexPointsFilterLogicOpenBlock(src);
      {
        this.vertexDrawPointsBatchingTransformLogic(src);
        this.vertexSlicingLogic(src);
        this.vertexDrawPointsColorsLogic(src);
        this.vertexPointsGeometryLogic(src);
      }
      this.vertexPointsFilterLogicCloseBlock(src);
    }
    this.vertexMainClose(src);
  }
  buildFragmentShader(src) {
    this.fragmentHeader(src);
    this.fragmentPrecisionDefs(src);
    this.fragmentCommonDefs(src);
    this.fragmentSlicingDefs(src);
    this.fragmentDrawFlatColorDefs(src);
    src.push("void main(void) {");
    {
      this.fragmentPointsGeometryLogic(src);
      this.fragmentSlicingLogic(src);
      this.fragmentDrawFlatColorLogic(src);
      this.fragmentCommonOutput(src);
    }
    src.push("}");
  }
  drawVBOBatchingLayerPrimitives(vboBatchingLayer, renderPass) {
    const gl = this.renderContext.gl;
    gl.drawArrays(gl.POINTS, 0, vboBatchingLayer.renderState.positionsBuf.numItems);
  }
};

// ../sdk/src/webglrenderer/vbo/batching/points/renderers/VBOPointsBatchingSilhouetteRenderer.ts
var VBOPointsBatchingSilhouetteRenderer = class extends VBOBatchingRenderer {
  getHash() {
    const view = this.renderContext.view;
    const pointsMaterial = view.pointsMaterial;
    return `${pointsMaterial.perspectivePoints}-${pointsMaterial.filterIntensity}-${pointsMaterial.roundPoints}-${view.getSectionPlanesHash()}`;
  }
  buildVertexShader(src) {
    this.vertexHeader(src);
    this.vertexCommonDefs(src);
    this.vertexBatchingTransformDefs(src);
    this.vertexSlicingDefs(src);
    this.vertexPointsGeometryDefs(src);
    this.vertexSilhouetteDefs(src);
    this.vertexSilhouetteMainOpen(src);
    {
      this.vertexPointsFilterLogicOpenBlock(src);
      {
        this.vertexDrawPointsBatchingTransformLogic(src);
        this.vertexSlicingLogic(src);
        this.vertexDrawPointsColorsLogic(src);
        this.vertexPointsGeometryLogic(src);
      }
      this.vertexPointsFilterLogicCloseBlock(src);
    }
    this.vertexMainClose(src);
  }
  buildFragmentShader(src) {
    this.fragmentHeader(src);
    this.fragmentPrecisionDefs(src);
    this.fragmentCommonDefs(src);
    this.fragmentSlicingDefs(src);
    this.fragmentDrawFlatColorDefs(src);
    src.push("void main(void) {");
    {
      this.fragmentPointsGeometryLogic(src);
      this.fragmentSlicingLogic(src);
      this.fragmentSilhouetteLogic(src);
      this.fragmentCommonOutput(src);
    }
    src.push("}");
  }
  drawVBOBatchingLayerPrimitives(vboBatchingLayer, renderPass) {
    const gl = this.renderContext.gl;
    gl.drawArrays(gl.POINTS, 0, vboBatchingLayer.renderState.positionsBuf.numItems);
  }
};

// ../sdk/src/webglrenderer/vbo/VBORendererSet.ts
var VBORendererSet = class {
  renderContext;
  renderStats;
  #colorRenderer;
  #colorSAORenderer;
  #drawDepthRenderer;
  #silhouetteRenderer;
  #pickMeshRenderer;
  #pickDepthRenderer;
  #occlusionRenderer;
  #snapInitRenderer;
  #snapRenderer;
  #edgesColorRenderer;
  #edgesSilhouetteRenderer;
  constructor(webglRenderer) {
    this.renderContext = webglRenderer.renderContext;
    this.renderStats = webglRenderer.renderStats;
  }
  _compile() {
    if (this.#colorRenderer && !this.#colorRenderer.getValid()) {
      this.#colorRenderer.destroy();
      this.#colorRenderer = null;
    }
    if (this.#colorSAORenderer && !this.#colorSAORenderer.getValid()) {
      this.#colorSAORenderer.destroy();
      this.#colorSAORenderer = null;
    }
    if (this.#drawDepthRenderer && !this.#drawDepthRenderer.getValid()) {
      this.#drawDepthRenderer.destroy();
      this.#drawDepthRenderer = null;
    }
    if (this.#silhouetteRenderer && !this.#silhouetteRenderer.getValid()) {
      this.#silhouetteRenderer.destroy();
      this.#silhouetteRenderer = null;
    }
    if (this.#edgesColorRenderer && !this.#edgesColorRenderer.getValid()) {
      this.#edgesColorRenderer.destroy();
      this.#edgesColorRenderer = null;
    }
    if (this.#pickMeshRenderer && !this.#pickMeshRenderer.getValid()) {
      this.#pickMeshRenderer.destroy();
      this.#pickMeshRenderer = null;
    }
    if (this.#pickDepthRenderer && !this.#pickDepthRenderer.getValid()) {
      this.#pickDepthRenderer.destroy();
      this.#pickDepthRenderer = null;
    }
    if (this.#occlusionRenderer && this.#occlusionRenderer.getValid() === false) {
      this.#occlusionRenderer.destroy();
      this.#occlusionRenderer = null;
    }
    if (this.#snapInitRenderer && !this.#snapInitRenderer.getValid()) {
      this.#snapInitRenderer.destroy();
      this.#snapInitRenderer = null;
    }
    if (this.#snapRenderer && !this.#snapRenderer.getValid()) {
      this.#snapRenderer.destroy();
      this.#snapRenderer = null;
    }
  }
  _eagerCreate() {
  }
  get colorRenderer() {
    if (!this.#colorRenderer) {
      this.#colorRenderer = this.createDrawColorRenderer();
    }
    return this.#colorRenderer;
  }
  get colorSAORenderer() {
    if (!this.#colorSAORenderer) {
      this.#colorSAORenderer = this.createDrawColorSAORenderer();
    }
    return this.#colorSAORenderer;
  }
  get drawDepthRenderer() {
    if (!this.#colorRenderer) {
      this.#colorRenderer = this.createDrawDepthRenderer();
    }
    return this.#colorRenderer;
  }
  get silhouetteRenderer() {
    if (!this.#silhouetteRenderer) {
      this.#silhouetteRenderer = this.createSilhouetteRenderer();
    }
    return this.#silhouetteRenderer;
  }
  get edgesColorRenderer() {
    if (!this.#edgesColorRenderer) {
      this.#edgesColorRenderer = this.createEdgesColorRenderer();
    }
    return this.#edgesColorRenderer;
  }
  get edgesSilhouetteRenderer() {
    if (!this.#edgesSilhouetteRenderer) {
      this.#edgesSilhouetteRenderer = this.createEdgesSilhouetteRenderer();
    }
    return this.#edgesSilhouetteRenderer;
  }
  get pickMeshRenderer() {
    if (!this.#pickMeshRenderer) {
      this.#pickMeshRenderer = this.createPickMeshRenderer();
    }
    return this.#pickMeshRenderer;
  }
  get pickDepthRenderer() {
    if (!this.#pickDepthRenderer) {
      this.#pickDepthRenderer = this.createPickDepthRenderer();
    }
    return this.#pickDepthRenderer;
  }
  get occlusionRenderer() {
    if (!this.#occlusionRenderer) {
      this.#occlusionRenderer = this.createOcclusionRenderer();
    }
    return this.#occlusionRenderer;
  }
  get snapInitRenderer() {
    if (!this.#snapInitRenderer) {
      this.#snapInitRenderer = this.createSnapInitRenderer();
    }
    return this.#snapInitRenderer;
  }
  get snapRenderer() {
    if (!this.#snapRenderer) {
      this.#snapInitRenderer = this.createSnapRenderer();
    }
    return this.#snapRenderer;
  }
  createDrawColorRenderer() {
    return null;
  }
  createDrawColorSAORenderer() {
    return null;
  }
  createDrawDepthRenderer() {
    return null;
  }
  createSilhouetteRenderer() {
    return null;
  }
  createEdgesColorRenderer() {
    return null;
  }
  createEdgesSilhouetteRenderer() {
    return null;
  }
  createPickMeshRenderer() {
    return null;
  }
  createPickDepthRenderer() {
    return null;
  }
  createOcclusionRenderer() {
    return null;
  }
  createSnapInitRenderer() {
    return null;
  }
  createSnapRenderer() {
    return null;
  }
  _destroy() {
    if (this.#colorRenderer) {
      this.#colorRenderer.destroy();
    }
    if (this.#colorSAORenderer) {
      this.#colorSAORenderer.destroy();
    }
    if (this.#drawDepthRenderer) {
      this.#drawDepthRenderer.destroy();
    }
    if (this.#silhouetteRenderer) {
      this.#silhouetteRenderer.destroy();
    }
    if (this.#edgesColorRenderer) {
      this.#edgesColorRenderer.destroy();
    }
    if (this.#edgesSilhouetteRenderer) {
      this.#edgesSilhouetteRenderer.destroy();
    }
    if (this.#pickMeshRenderer) {
      this.#pickMeshRenderer.destroy();
    }
    if (this.#pickDepthRenderer) {
      this.#pickDepthRenderer.destroy();
    }
    if (this.#occlusionRenderer) {
      this.#occlusionRenderer.destroy();
    }
    if (this.#snapInitRenderer) {
      this.#snapInitRenderer.destroy();
    }
    if (this.#snapRenderer) {
      this.#snapRenderer.destroy();
    }
  }
};
var RendererSetFactory = class {
  #rendererSets;
  #createRendererSet;
  constructor(createRendererSet) {
    this.#rendererSets = {};
    this.#createRendererSet = createRendererSet;
  }
  getRenderers(webglRenderer) {
    const viewerId = webglRenderer.viewer.id;
    let rendererSet = this.#rendererSets[viewerId];
    if (!rendererSet) {
      rendererSet = this.#createRendererSet(webglRenderer);
      this.#rendererSets[viewerId] = rendererSet;
      rendererSet._compile();
      rendererSet._eagerCreate();
      webglRenderer.onCompiled.sub(() => {
        rendererSet._compile();
        rendererSet._eagerCreate();
      });
      webglRenderer.onDestroyed.sub(() => {
        delete this.#rendererSets[viewerId];
        rendererSet._destroy();
      });
    }
    return rendererSet;
  }
};

// ../sdk/src/webglrenderer/vbo/batching/points/renderers/rendererFactory.ts
var RendererFactory = class extends VBORendererSet {
  createDrawColorRenderer() {
    return new VBOPointsBatchingDrawColorRenderer(this.renderContext);
  }
  createPickMeshRenderer() {
    return new VBOPointsBatchingPickMeshRenderer(this.renderContext);
  }
  createSilhouetteRenderer() {
    return new VBOPointsBatchingSilhouetteRenderer(this.renderContext);
  }
};
var rendererFactory = new RendererSetFactory((webglRenderer) => {
  return new RendererFactory(webglRenderer);
});

// ../sdk/src/webglrenderer/vbo/batching/points/VBOPointsBatchingLayer.ts
var VBOPointsBatchingLayer = class extends VBOBatchingLayer {
  constructor(layerParams) {
    super(layerParams, rendererFactory.getRenderers(layerParams.renderContext.webglRenderer));
  }
};

// ../sdk/src/webglrenderer/vbo/batching/triangles/renderers/VBOTrianglesBatchingDrawColorRenderer.ts
var VBOTrianglesBatchingDrawColorRenderer = class extends VBOBatchingRenderer {
  getHash() {
    const view = this.renderContext.view;
    return `${view.getLightsHash()}-${view.getSectionPlanesHash()}`;
  }
  buildVertexShader(src) {
    this.vertexHeader(src);
    this.vertexCommonDefs(src);
    this.vertexBatchingTransformDefs(src);
    this.vertexSlicingDefs(src);
    this.vertexDrawLambertDefs(src);
    this.vertexDrawMainOpen(src);
    {
      this.vertexDrawBatchingTransformLogic(src);
      this.vertexDrawLambertLogic(src);
      this.vertexSlicingLogic(src);
    }
    this.vertexMainClose(src);
  }
  buildFragmentShader(src) {
    this.fragmentHeader(src);
    this.fragmentPrecisionDefs(src);
    this.fragmentCommonDefs(src);
    this.fragmentSlicingDefs(src);
    this.fragmentDrawLambertDefs(src);
    src.push("void main(void) {");
    {
      this.fragmentSlicingLogic(src);
      this.fragmentDrawLambertLogic(src);
      this.fragmentCommonOutput(src);
    }
    src.push("}");
  }
  drawVBOBatchingLayerPrimitives(vboBatchingLayer, renderPass) {
    const gl = this.renderContext.gl;
    const renderState = vboBatchingLayer.renderState;
    gl.drawElements(gl.TRIANGLES, renderState.indicesBuf.numItems, renderState.indicesBuf.itemType, 0);
  }
};

// ../sdk/src/webglrenderer/vbo/batching/triangles/renderers/VBOTrianglesBatchingPickMeshRenderer.ts
var VBOTrianglesBatchingPickMeshRenderer = class extends VBOBatchingRenderer {
  getHash() {
    return this.slicingHash;
  }
  buildVertexShader(src) {
    this.vertexHeader(src);
    this.vertexCommonDefs(src);
    this.vertexBatchingTransformDefs(src);
    this.vertexSlicingDefs(src);
    this.vertexPickMeshDefs(src);
    this.vertexPickMainOpen(src);
    {
      this.vertexPickBatchingTransformLogic(src);
      this.vertexPickMeshLogic(src);
      this.vertexSlicingLogic(src);
    }
    this.vertexMainClose(src);
  }
  buildFragmentShader(src) {
    this.fragmentHeader(src);
    this.fragmentPrecisionDefs(src);
    this.fragmentCommonDefs(src);
    this.fragmentSlicingDefs(src);
    this.fragmentPickMeshDefs(src);
    src.push("void main(void) {");
    {
      this.fragmentSlicingLogic(src);
      this.fragmentPickMeshLogic(src);
      this.fragmentCommonOutput(src);
    }
    src.push("}");
  }
  drawVBOBatchingLayerPrimitives(vboBatchingLayer, renderPass) {
    const gl = this.renderContext.gl;
    const renderState = vboBatchingLayer.renderState;
    gl.drawElements(gl.TRIANGLES, renderState.indicesBuf.numItems, renderState.indicesBuf.itemType, 0);
  }
};

// ../sdk/src/webglrenderer/vbo/batching/triangles/renderers/VBOTrianglesBatchingSilhouetteRenderer.ts
var VBOTrianglesBatchingSilhouetteRenderer = class extends VBOBatchingRenderer {
  getHash() {
    return this.slicingHash;
  }
  buildVertexShader(src) {
    this.vertexHeader(src);
    this.vertexCommonDefs(src);
    this.vertexBatchingTransformDefs(src);
    this.vertexSlicingDefs(src);
    this.vertexSilhouetteDefs(src);
    this.vertexSilhouetteMainOpen(src);
    {
      this.vertexDrawBatchingTransformLogic(src);
      this.vertexSilhouetteLogic(src);
      this.vertexSlicingLogic(src);
    }
    this.vertexMainClose(src);
  }
  buildFragmentShader(src) {
    this.fragmentHeader(src);
    this.fragmentPrecisionDefs(src);
    this.fragmentCommonDefs(src);
    this.fragmentSlicingDefs(src);
    this.fragmentSilhouetteDefs(src);
    src.push("void main(void) {");
    {
      this.fragmentSlicingLogic(src);
      this.fragmentSilhouetteLogic(src);
      this.fragmentCommonOutput(src);
    }
    src.push("}");
  }
  drawVBOBatchingLayerPrimitives(vboBatchingLayer, renderPass) {
    const gl = this.renderContext.gl;
    const renderState = vboBatchingLayer.renderState;
    gl.drawElements(gl.TRIANGLES, renderState.indicesBuf.numItems, renderState.indicesBuf.itemType, 0);
  }
};

// ../sdk/src/webglrenderer/vbo/batching/triangles/renderers/VBOTrianglesBatchingEdgesDrawRenderer.ts
var VBOTrianglesBatchingEdgesDrawRenderer = class extends VBOBatchingRenderer {
  constructor(renderContext) {
    super(renderContext, { edges: true });
  }
  getHash() {
    return this.slicingHash;
  }
  buildVertexShader(src) {
    this.vertexHeader(src);
    this.vertexCommonDefs(src);
    this.vertexBatchingTransformDefs(src);
    this.vertexSlicingDefs(src);
    this.vertexDrawFlatColorDefs(src);
    this.vertexDrawMainOpen(src);
    {
      this.vertexDrawBatchingTransformLogic(src);
      this.vertexDrawEdgesColorLogic(src);
      this.vertexSlicingLogic(src);
    }
    this.vertexMainClose(src);
  }
  buildFragmentShader(src) {
    this.fragmentHeader(src);
    this.fragmentPrecisionDefs(src);
    this.fragmentCommonDefs(src);
    this.fragmentSlicingDefs(src);
    this.fragmentDrawFlatColorDefs(src);
    src.push("void main(void) {");
    {
      this.fragmentSlicingLogic(src);
      this.fragmentDrawFlatColorLogic(src);
      this.fragmentCommonOutput(src);
    }
    src.push("}");
  }
  drawVBOBatchingLayerPrimitives(vboBatchingLayer, renderPass) {
    const gl = this.renderContext.gl;
    const renderState = vboBatchingLayer.renderState;
    gl.drawElements(gl.LINES, renderState.edgeIndicesBuf.numItems, renderState.edgeIndicesBuf.itemType, 0);
  }
};

// ../sdk/src/webglrenderer/vbo/batching/triangles/renderers/VBOTrianglesBatchingEdgesSilhouetteRenderer.ts
var VBOTrianglesBatchingEdgesSilhouetteRenderer = class extends VBOBatchingRenderer {
  constructor(renderContext) {
    super(renderContext, { edges: true });
  }
  getHash() {
    return this.slicingHash;
  }
  buildVertexShader(src) {
    this.vertexHeader(src);
    this.vertexCommonDefs(src);
    this.vertexBatchingTransformDefs(src);
    this.vertexSlicingDefs(src);
    this.vertexSilhouetteDefs(src);
    this.vertexSilhouetteMainOpen(src);
    {
      this.vertexDrawBatchingTransformLogic(src);
      this.vertexSilhouetteLogic(src);
      this.vertexSlicingLogic(src);
    }
    this.vertexMainClose(src);
  }
  buildFragmentShader(src) {
    this.fragmentHeader(src);
    this.fragmentPrecisionDefs(src);
    this.fragmentCommonDefs(src);
    this.fragmentSlicingDefs(src);
    this.fragmentSilhouetteDefs(src);
    src.push("void main(void) {");
    {
      this.fragmentSlicingLogic(src);
      this.fragmentSilhouetteLogic(src);
      this.fragmentCommonOutput(src);
    }
    src.push("}");
  }
  drawVBOBatchingLayerPrimitives(vboBatchingLayer, renderPass) {
    const gl = this.renderContext.gl;
    const renderState = vboBatchingLayer.renderState;
    gl.drawElements(gl.LINES, renderState.edgeIndicesBuf.numItems, renderState.edgeIndicesBuf.itemType, 0);
  }
};

// ../sdk/src/webglrenderer/vbo/batching/triangles/renderers/VBOTrianglesBatchingDrawDepthRenderer.ts
var VBOTrianglesBatchingDrawDepthRenderer = class extends VBOBatchingRenderer {
  getHash() {
    return `${this.slicingHash}`;
  }
  buildVertexShader(src) {
    this.vertexHeader(src);
    this.vertexCommonDefs(src);
    this.vertexBatchingTransformDefs(src);
    this.vertexSlicingDefs(src);
    this.vertexDrawMainOpen(src);
    {
      this.vertexDrawBatchingTransformLogic(src);
      this.vertexSlicingLogic(src);
    }
    this.vertexMainClose(src);
  }
  buildFragmentShader(src) {
    this.fragmentHeader(src);
    this.fragmentPrecisionDefs(src);
    this.fragmentCommonDefs(src);
    this.fragmentDrawDepthDefs(src);
    this.fragmentSlicingDefs(src);
    src.push("void main(void) {");
    {
      this.fragmentSlicingLogic(src);
      this.fragmentDrawDepthLogic(src);
      this.fragmentCommonOutput(src);
    }
    src.push("}");
  }
  drawVBOBatchingLayerPrimitives(vboBatchingLayer, renderPass) {
    const gl = this.renderContext.gl;
    const renderState = vboBatchingLayer.renderState;
    gl.drawElements(gl.TRIANGLES, renderState.indicesBuf.numItems, renderState.indicesBuf.itemType, 0);
  }
};

// ../sdk/src/webglrenderer/vbo/batching/triangles/renderers/VBOTrianglesBatchingDrawColorSAORenderer.ts
var VBOTrianglesBatchingDrawColorSAORenderer = class extends VBOBatchingRenderer {
  getHash() {
    const view = this.renderContext.view;
    return `${view.getLightsHash()}-${view.getSectionPlanesHash()}`;
  }
  buildVertexShader(src) {
    this.vertexHeader(src);
    this.vertexCommonDefs(src);
    this.vertexBatchingTransformDefs(src);
    this.vertexSlicingDefs(src);
    this.vertexDrawLambertDefs(src);
    this.vertexDrawMainOpen(src);
    {
      this.vertexDrawBatchingTransformLogic(src);
      this.vertexDrawLambertLogic(src);
      this.vertexSlicingLogic(src);
    }
    this.vertexMainClose(src);
  }
  buildFragmentShader(src) {
    this.fragmentHeader(src);
    this.fragmentPrecisionDefs(src);
    this.fragmentCommonDefs(src);
    this.fragmentSlicingDefs(src);
    this.fragmentDrawLambertDefs(src);
    this.fragmentDrawSAODefs(src);
    src.push("void main(void) {");
    {
      this.fragmentSlicingLogic(src);
      this.fragmentDrawLambertLogic(src);
      this.fragmentDrawSAOLogic(src);
      this.fragmentCommonOutput(src);
    }
    src.push("}");
  }
  drawVBOBatchingLayerPrimitives(vboBatchingLayer, renderPass) {
    const gl = this.renderContext.gl;
    const renderState = vboBatchingLayer.renderState;
    gl.drawElements(gl.TRIANGLES, renderState.indicesBuf.numItems, renderState.indicesBuf.itemType, 0);
  }
};

// ../sdk/src/webglrenderer/vbo/batching/triangles/renderers/rendererFactory.ts
var RendererFactory2 = class extends VBORendererSet {
  createDrawColorRenderer() {
    return new VBOTrianglesBatchingDrawColorRenderer(this.renderContext);
  }
  createDrawColorSAORenderer() {
    return new VBOTrianglesBatchingDrawColorSAORenderer(this.renderContext);
  }
  createDrawDepthRenderer() {
    return new VBOTrianglesBatchingDrawDepthRenderer(this.renderContext);
  }
  createPickMeshRenderer() {
    return new VBOTrianglesBatchingPickMeshRenderer(this.renderContext);
  }
  createSilhouetteRenderer() {
    return new VBOTrianglesBatchingSilhouetteRenderer(this.renderContext);
  }
  createEdgesColorRenderer() {
    return new VBOTrianglesBatchingEdgesDrawRenderer(this.renderContext);
  }
  createEdgesSilhouetteRenderer() {
    return new VBOTrianglesBatchingEdgesSilhouetteRenderer(this.renderContext);
  }
};
var rendererFactory2 = new RendererSetFactory((webglRenderer) => {
  return new RendererFactory2(webglRenderer);
});

// ../sdk/src/webglrenderer/vbo/batching/triangles/VBOTrianglesBatchingLayer.ts
var VBOTrianglesBatchingLayer = class extends VBOBatchingLayer {
  constructor(layerParams) {
    super(layerParams, rendererFactory2.getRenderers(layerParams.renderContext.webglRenderer));
  }
};

// ../sdk/src/webglrenderer/vbo/instancing/VBOInstancingBuffer.ts
var VBOInstancingBuffer = class {
  maxVerts;
  maxIndices;
  positions;
  colors;
  uv;
  normals;
  pickColors;
  offsets;
  indices;
  edgeIndices;
  modelNormalMatrixCol0;
  modelNormalMatrixCol1;
  modelNormalMatrixCol2;
  modelMatrixCol0;
  modelMatrixCol1;
  modelMatrixCol2;
  modelMatrix;
  constructor() {
    this.positions = [];
    this.colors = [];
    this.uv = [];
    this.normals = [];
    this.pickColors = [];
    this.offsets = [];
    this.indices = [];
    this.edgeIndices = [];
    this.modelMatrixCol0 = [];
    this.modelMatrixCol1 = [];
    this.modelMatrixCol2 = [];
  }
};

// ../sdk/src/webglrenderer/vbo/instancing/VBOInstancingLayer.ts
var tempUint8Vec4 = new Uint8Array(4);
var tempFloat32 = new Float32Array(1);
var tempVec4a5 = createVec4([0, 0, 0, 1]);
var tempVec3fa = new Float32Array(3);
var tempVec3a7 = createVec3();
var tempVec3b7 = createVec3();
var tempVec3c5 = createVec3();
var tempVec3d3 = createVec3();
var tempVec3e3 = createVec3();
var tempVec3f2 = createVec3();
var tempVec3g = createVec3();
var tempFloat32Vec4 = new Float32Array(4);
var VBOInstancingLayer = class {
  rendererModel;
  renderState;
  #rendererSet;
  #aabb;
  #buffer;
  #meshes;
  #portions;
  #built;
  layerIndex;
  sortId;
  primitive;
  aabbDirty;
  meshCounts;
  renderContext;
  saoSupported;
  constructor(layerParams, rendererSet) {
    console.info("Creating VBOInstancingLayer");
    this.renderContext = layerParams.renderContext;
    this.rendererModel = layerParams.rendererModel;
    this.sortId = `VBOInstancingLayer-${layerParams.sceneGeometry.primitive}`;
    this.layerIndex = layerParams.layerIndex;
    this.#buffer = new VBOInstancingBuffer();
    this.#rendererSet = rendererSet;
    this.#aabb = collapseAABB3();
    this.meshCounts = [];
    for (let i = 0, len = this.renderContext.viewer.viewList.length; i < len; i++) {
      this.meshCounts.push(new MeshCounts());
    }
    const geometry = layerParams.sceneGeometry;
    const aabb = geometry.aabb;
    const positionsDecompressOffset = createVec3([aabb[0], aabb[1], aabb[2]]);
    const positionsDecompressScale = createVec3([(aabb[3] - aabb[0]) / 65535, (aabb[4] - aabb[1]) / 65535, (aabb[5] - aabb[2]) / 65535]);
    this.renderState = {
      numVertices: 0,
      numIndices: 0,
      numEdgeIndices: 0,
      numInstances: 0,
      obb: createOBB3(),
      origin: createVec3(layerParams.origin),
      sceneGeometry: layerParams.sceneGeometry,
      textureSet: layerParams.textureSet,
      pbrSupported: false,
      positionsDecompressScale,
      positionsDecompressOffset,
      colorsBuf: [],
      flagsBufs: [],
      modelMatrixBuf: null,
      modelMatrixCol0Buf: null,
      modelMatrixCol1Buf: null,
      modelMatrixCol2Buf: null,
      modelNormalMatrixCol0Buf: null,
      modelNormalMatrixCol1Buf: null,
      modelNormalMatrixCol2Buf: null,
      pickColorsBuf: null
    };
    this.#portions = [];
    this.#meshes = [];
    this.#aabb = collapseAABB3();
    this.aabbDirty = true;
    this.#built = false;
  }
  get hash() {
    return `${this.primitive}`;
  }
  get aabb() {
    if (this.aabbDirty) {
      collapseAABB3(this.#aabb);
      for (let i = 0, len = this.#meshes.length; i < len; i++) {
        expandAABB3(this.#aabb, this.#meshes[i].aabb);
      }
      this.aabbDirty = false;
    }
    return this.#aabb;
  }
  canCreateLayerMesh(sceneGeometry) {
    if (this.#built) {
      throw new SDKError("Already built");
    }
    return true;
  }
  createLayerMesh(layerMeshParams, sceneMesh) {
    const color2 = sceneMesh.color;
    const opacity = sceneMesh.opacity !== null && sceneMesh.opacity !== void 0 ? sceneMesh.opacity : 255;
    const rtcMatrix = sceneMesh.rtcMatrix;
    const pickColor = layerMeshParams.pickColor;
    if (this.#built) {
      throw "Already finalized";
    }
    const r = color2[0] * 255;
    const g = color2[1] * 255;
    const b4 = color2[2] * 255;
    this.#buffer.colors.push(r);
    this.#buffer.colors.push(g);
    this.#buffer.colors.push(b4);
    this.#buffer.colors.push(opacity);
    this.#buffer.modelMatrixCol0.push(rtcMatrix[0]);
    this.#buffer.modelMatrixCol0.push(rtcMatrix[4]);
    this.#buffer.modelMatrixCol0.push(rtcMatrix[8]);
    this.#buffer.modelMatrixCol0.push(rtcMatrix[12]);
    this.#buffer.modelMatrixCol1.push(rtcMatrix[1]);
    this.#buffer.modelMatrixCol1.push(rtcMatrix[5]);
    this.#buffer.modelMatrixCol1.push(rtcMatrix[9]);
    this.#buffer.modelMatrixCol1.push(rtcMatrix[13]);
    this.#buffer.modelMatrixCol2.push(rtcMatrix[2]);
    this.#buffer.modelMatrixCol2.push(rtcMatrix[6]);
    this.#buffer.modelMatrixCol2.push(rtcMatrix[10]);
    this.#buffer.modelMatrixCol2.push(rtcMatrix[14]);
    this.#buffer.pickColors.push(...pickColor);
    this.renderState.numInstances++;
    const layerMeshIndex = this.#portions.length;
    const portion = {};
    this.#portions.push(portion);
    for (let viewIndex = 0, len = this.meshCounts.length; viewIndex < len; viewIndex++) {
      this.meshCounts[viewIndex].numMeshes++;
      this.rendererModel.meshCounts[viewIndex].numMeshes++;
    }
    this.#meshes.push(sceneMesh);
    return layerMeshIndex;
  }
  build() {
    if (this.#built) {
      return;
    }
    const renderState = this.renderState;
    const sceneGeometry = renderState.sceneGeometry;
    const numViews = this.meshCounts.length;
    const textureSet = renderState.textureSet;
    const gl = this.renderContext.gl;
    const colorsLength = this.#buffer.colors.length;
    const flagsLength = colorsLength / 4;
    if (colorsLength > 0) {
      let notNormalized = false;
      const colors = new Uint8Array(this.#buffer.colors);
      for (let viewIndex = 0; viewIndex < numViews; viewIndex++) {
        renderState.colorsBuf[viewIndex] = new WebGLArrayBuf(gl, gl.ARRAY_BUFFER, colors, this.#buffer.colors.length, 4, gl.DYNAMIC_DRAW, notNormalized);
      }
      this.#buffer.colors = [];
    }
    if (flagsLength > 0) {
      let notNormalized = false;
      const flagsArray = new Float32Array(flagsLength);
      for (let viewIndex = 0; viewIndex < numViews; viewIndex++) {
        renderState.flagsBufs[viewIndex] = new WebGLArrayBuf(gl, gl.ARRAY_BUFFER, flagsArray, flagsLength, 1, gl.DYNAMIC_DRAW, notNormalized);
      }
    }
    const positionsCompressed = sceneGeometry.positionsCompressed;
    const indices = sceneGeometry.indices;
    const edgeIndices = sceneGeometry.edgeIndices;
    const uvsCompressed = sceneGeometry.uvsCompressed;
    const colorsCompressed = sceneGeometry.colorsCompressed;
    if (positionsCompressed && positionsCompressed.length > 0) {
      const normalized = false;
      renderState.positionsBuf = new WebGLArrayBuf(gl, gl.ARRAY_BUFFER, new Uint16Array(positionsCompressed), positionsCompressed.length, 3, gl.STATIC_DRAW, normalized);
    }
    if (indices && indices.length > 0) {
      renderState.indicesBuf = new WebGLArrayBuf(gl, gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(indices), indices.length, 1, gl.STATIC_DRAW);
      renderState.numIndices = indices.length;
    }
    if (edgeIndices && edgeIndices.length > 0) {
      renderState.edgeIndicesBuf = new WebGLArrayBuf(gl, gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(edgeIndices), edgeIndices.length, 1, gl.STATIC_DRAW);
      renderState.numEdgeIndices = edgeIndices.length;
    }
    if (uvsCompressed && uvsCompressed.length > 0) {
      renderState.uvDecodeMatrix = sceneGeometry.uvsDecompressMatrix;
      renderState.uvBuf = new WebGLArrayBuf(gl, gl.ARRAY_BUFFER, new Uint8Array(uvsCompressed), uvsCompressed.length, 2, gl.STATIC_DRAW, false);
    }
    if (this.#buffer.modelMatrixCol0.length > 0) {
      const normalized = false;
      renderState.modelMatrixCol0Buf = new WebGLArrayBuf(gl, gl.ARRAY_BUFFER, new Float32Array(this.#buffer.modelMatrixCol0), this.#buffer.modelMatrixCol0.length, 4, gl.STATIC_DRAW, normalized);
      renderState.modelMatrixCol1Buf = new WebGLArrayBuf(gl, gl.ARRAY_BUFFER, new Float32Array(this.#buffer.modelMatrixCol1), this.#buffer.modelMatrixCol1.length, 4, gl.STATIC_DRAW, normalized);
      renderState.modelMatrixCol2Buf = new WebGLArrayBuf(gl, gl.ARRAY_BUFFER, new Float32Array(this.#buffer.modelMatrixCol2), this.#buffer.modelMatrixCol2.length, 4, gl.STATIC_DRAW, normalized);
      this.#buffer.modelMatrixCol0 = [];
      this.#buffer.modelMatrixCol1 = [];
      this.#buffer.modelMatrixCol2 = [];
      if (renderState.normalsBuf) {
        renderState.modelNormalMatrixCol0Buf = new WebGLArrayBuf(gl, gl.ARRAY_BUFFER, new Float32Array(this.#buffer.modelNormalMatrixCol0), this.#buffer.modelNormalMatrixCol0.length, 4, gl.STATIC_DRAW, normalized);
        renderState.modelNormalMatrixCol1Buf = new WebGLArrayBuf(gl, gl.ARRAY_BUFFER, new Float32Array(this.#buffer.modelNormalMatrixCol1), this.#buffer.modelNormalMatrixCol1.length, 4, gl.STATIC_DRAW, normalized);
        renderState.modelNormalMatrixCol2Buf = new WebGLArrayBuf(gl, gl.ARRAY_BUFFER, new Float32Array(this.#buffer.modelNormalMatrixCol2), this.#buffer.modelNormalMatrixCol2.length, 4, gl.STATIC_DRAW, normalized);
        this.#buffer.modelNormalMatrixCol0 = [];
        this.#buffer.modelNormalMatrixCol1 = [];
        this.#buffer.modelNormalMatrixCol2 = [];
      }
    }
    if (this.#buffer.pickColors.length > 0) {
      const normalized = false;
      renderState.pickColorsBuf = new WebGLArrayBuf(gl, gl.ARRAY_BUFFER, new Uint8Array(this.#buffer.pickColors), this.#buffer.pickColors.length, 4, gl.STATIC_DRAW, normalized);
      this.#buffer.pickColors = [];
    }
    renderState.pbrSupported = !!renderState.metallicRoughnessBuf && !!renderState.uvBuf && !!renderState.normalsBuf && !!textureSet && !!textureSet.colorTexture && !!textureSet.metallicRoughnessTexture;
    renderState.colorTextureSupported = !!renderState.uvBuf && !!textureSet && !!textureSet.colorTexture;
    this.saoSupported = sceneGeometry.primitive === SolidPrimitive || sceneGeometry.primitive === SurfacePrimitive || sceneGeometry.primitive === TrianglesPrimitive;
    this.renderState.sceneGeometry = null;
    this.#built = true;
  }
  initFlags(viewIndex, layerMeshIndex, flags, meshTransparent) {
    const layerMeshCounts = this.meshCounts[viewIndex];
    const modelMeshCounts = this.rendererModel.meshCounts[viewIndex];
    if (flags & SCENE_OBJECT_FLAGS.VISIBLE) {
      layerMeshCounts.numVisible++;
      modelMeshCounts.numVisible++;
    }
    if (flags & SCENE_OBJECT_FLAGS.HIGHLIGHTED) {
      layerMeshCounts.numHighlighted++;
      modelMeshCounts.numHighlighted++;
    }
    if (flags & SCENE_OBJECT_FLAGS.XRAYED) {
      layerMeshCounts.numXRayed++;
      modelMeshCounts.numXRayed++;
    }
    if (flags & SCENE_OBJECT_FLAGS.SELECTED) {
      layerMeshCounts.numSelected++;
      modelMeshCounts.numSelected++;
    }
    if (flags & SCENE_OBJECT_FLAGS.CLIPPABLE) {
      layerMeshCounts.numClippable++;
      modelMeshCounts.numClippable++;
    }
    if (flags & SCENE_OBJECT_FLAGS.PICKABLE) {
      layerMeshCounts.numPickable++;
      modelMeshCounts.numPickable++;
    }
    if (flags & SCENE_OBJECT_FLAGS.CULLED) {
      layerMeshCounts.numCulled++;
      modelMeshCounts.numCulled++;
    }
    if (meshTransparent) {
      layerMeshCounts.numTransparent++;
      modelMeshCounts.numTransparent++;
    }
    this.setLayerMeshFlags(viewIndex, layerMeshIndex, flags, meshTransparent);
  }
  setLayerMeshVisible(viewIndex, layerMeshIndex, flags, transparent) {
    if (!this.#built) {
      throw "Not finalized";
    }
    if (flags & SCENE_OBJECT_FLAGS.VISIBLE) {
      this.meshCounts[viewIndex].numVisible++;
      this.rendererModel.meshCounts[viewIndex].numVisible++;
    } else {
      this.meshCounts[viewIndex].numVisible--;
      this.rendererModel.meshCounts[viewIndex].numVisible--;
    }
    this.setLayerMeshFlags(viewIndex, layerMeshIndex, flags, transparent);
  }
  setLayerMeshHighlighted(viewIndex, layerMeshIndex, flags, transparent) {
    if (!this.#built) {
      throw "Not finalized";
    }
    if (flags & SCENE_OBJECT_FLAGS.HIGHLIGHTED) {
      this.meshCounts[viewIndex].numHighlighted++;
      this.rendererModel.meshCounts[viewIndex].numHighlighted++;
    } else {
      this.meshCounts[viewIndex].numHighlighted--;
      this.rendererModel.meshCounts[viewIndex].numHighlighted--;
    }
    this.setLayerMeshFlags(viewIndex, layerMeshIndex, flags, transparent);
  }
  setLayerMeshXRayed(viewIndex, layerMeshIndex, flags, transparent) {
    if (!this.#built) {
      throw "Not finalized";
    }
    if (flags & SCENE_OBJECT_FLAGS.XRAYED) {
      this.meshCounts[viewIndex].numXRayed++;
      this.rendererModel.meshCounts[viewIndex].numXRayed++;
    } else {
      this.meshCounts[viewIndex].numXRayed--;
      this.rendererModel.meshCounts[viewIndex].numXRayed--;
    }
    this.setLayerMeshFlags(viewIndex, layerMeshIndex, flags, transparent);
  }
  setLayerMeshSelected(viewIndex, layerMeshIndex, flags, transparent) {
    if (!this.#built) {
      throw "Not finalized";
    }
    if (flags & SCENE_OBJECT_FLAGS.SELECTED) {
      this.meshCounts[viewIndex].numSelected++;
      this.rendererModel.meshCounts[viewIndex].numSelected++;
    } else {
      this.meshCounts[viewIndex].numSelected--;
      this.rendererModel.meshCounts[viewIndex].numSelected--;
    }
    this.setLayerMeshFlags(viewIndex, layerMeshIndex, flags, transparent);
  }
  setLayerMeshClippable(viewIndex, layerMeshIndex, flags) {
    if (!this.#built) {
      throw "Not finalized";
    }
    if (flags & SCENE_OBJECT_FLAGS.CLIPPABLE) {
      this.meshCounts[viewIndex].numClippable++;
      this.rendererModel.meshCounts[viewIndex].numClippable++;
    } else {
      this.meshCounts[viewIndex].numClippable--;
      this.rendererModel.meshCounts[viewIndex].numClippable--;
    }
    this.setLayerMeshFlags(viewIndex, layerMeshIndex, flags);
  }
  setCollidable(viewIndex, layerMeshIndex, flags) {
    if (!this.#built) {
      throw "Not finalized";
    }
  }
  setLayerMeshPickable(viewIndex, layerMeshIndex, flags, transparent) {
    if (!this.#built) {
      throw "Not finalized";
    }
    if (flags & SCENE_OBJECT_FLAGS.PICKABLE) {
      this.meshCounts[viewIndex].numPickable++;
      this.rendererModel.meshCounts[viewIndex].numPickable++;
    } else {
      this.meshCounts[viewIndex].numPickable--;
      this.rendererModel.meshCounts[viewIndex].numPickable--;
    }
    this.setLayerMeshFlags(viewIndex, layerMeshIndex, flags, transparent);
  }
  setLayerMeshCulled(viewIndex, layerMeshIndex, flags, transparent) {
    if (!this.#built) {
      throw "Not finalized";
    }
    if (flags & SCENE_OBJECT_FLAGS.CULLED) {
      this.meshCounts[viewIndex].numCulled++;
      this.rendererModel.meshCounts[viewIndex].numCulled++;
    } else {
      this.meshCounts[viewIndex].numCulled--;
      this.rendererModel.meshCounts[viewIndex].numCulled--;
    }
    this.setLayerMeshFlags(viewIndex, layerMeshIndex, flags, transparent);
  }
  setLayerMeshColor(viewIndex, layerMeshIndex, color2) {
    if (!this.#built) {
      throw "Not finalized";
    }
    tempUint8Vec4[0] = color2[0];
    tempUint8Vec4[1] = color2[1];
    tempUint8Vec4[2] = color2[2];
    tempUint8Vec4[3] = color2[3];
    if (this.renderState.colorsBuf[viewIndex]) {
      this.renderState.colorsBuf[viewIndex].setData(tempUint8Vec4, layerMeshIndex * 4);
    }
  }
  setLayerMeshTransparent(viewIndex, layerMeshIndex, flags, transparent) {
    if (transparent) {
      this.meshCounts[viewIndex].numTransparent++;
      this.rendererModel.meshCounts[viewIndex].numTransparent++;
    } else {
      this.meshCounts[viewIndex].numTransparent--;
      this.rendererModel.meshCounts[viewIndex].numTransparent--;
    }
    this.setLayerMeshFlags(viewIndex, layerMeshIndex, flags, transparent);
  }
  setLayerMeshFlags(viewIndex, layerMeshIndex, flags, transparent = false) {
    if (!this.#built) {
      throw "Not finalized";
    }
    const view = this.renderContext.viewer.viewList[viewIndex];
    const visible = !!(flags & SCENE_OBJECT_FLAGS.VISIBLE);
    const xrayed = !!(flags & SCENE_OBJECT_FLAGS.XRAYED);
    const highlighted = !!(flags & SCENE_OBJECT_FLAGS.HIGHLIGHTED);
    const selected = !!(flags & SCENE_OBJECT_FLAGS.SELECTED);
    const pickable = !!(flags & SCENE_OBJECT_FLAGS.PICKABLE);
    const culled = !!(flags & SCENE_OBJECT_FLAGS.CULLED);
    let colorFlag;
    if (!visible || culled || xrayed || highlighted && !view.highlightMaterial.glowThrough || selected && !view.selectedMaterial.glowThrough) {
      colorFlag = RENDER_PASSES.NOT_RENDERED;
    } else {
      if (transparent) {
        colorFlag = RENDER_PASSES.DRAW_TRANSPARENT;
      } else {
        colorFlag = RENDER_PASSES.DRAW_OPAQUE;
      }
    }
    let silhouetteFlag;
    if (!visible || culled) {
      silhouetteFlag = RENDER_PASSES.NOT_RENDERED;
    } else if (selected) {
      silhouetteFlag = RENDER_PASSES.SILHOUETTE_SELECTED;
    } else if (highlighted) {
      silhouetteFlag = RENDER_PASSES.SILHOUETTE_HIGHLIGHTED;
    } else if (xrayed) {
      silhouetteFlag = RENDER_PASSES.SILHOUETTE_XRAYED;
    } else {
      silhouetteFlag = RENDER_PASSES.NOT_RENDERED;
    }
    const pickFlag = visible && !culled && pickable ? RENDER_PASSES.PICK : RENDER_PASSES.NOT_RENDERED;
    const clippableFlag = !!(flags & SCENE_OBJECT_FLAGS.CLIPPABLE) ? 1 : 0;
    let vertFlag = 0;
    vertFlag |= colorFlag;
    vertFlag |= silhouetteFlag << 4;
    vertFlag |= pickFlag << 8;
    vertFlag |= clippableFlag << 12;
    tempFloat32[0] = vertFlag;
    if (this.renderState.flagsBufs[viewIndex]) {
      this.renderState.flagsBufs[viewIndex].setData(tempFloat32, layerMeshIndex);
    }
  }
  setMatrix(viewIndex, layerMeshIndex, matrix) {
    if (!this.#built) {
      throw "Not finalized";
    }
    const offset = layerMeshIndex * 4;
    tempFloat32Vec4[0] = matrix[0];
    tempFloat32Vec4[1] = matrix[4];
    tempFloat32Vec4[2] = matrix[8];
    tempFloat32Vec4[3] = matrix[12];
    this.renderState.modelMatrixCol0Buf.setData(tempFloat32Vec4, offset);
    tempFloat32Vec4[0] = matrix[1];
    tempFloat32Vec4[1] = matrix[5];
    tempFloat32Vec4[2] = matrix[9];
    tempFloat32Vec4[3] = matrix[13];
    this.renderState.modelMatrixCol1Buf.setData(tempFloat32Vec4, offset);
    tempFloat32Vec4[0] = matrix[2];
    tempFloat32Vec4[1] = matrix[6];
    tempFloat32Vec4[2] = matrix[10];
    tempFloat32Vec4[3] = matrix[14];
    this.renderState.modelMatrixCol2Buf.setData(tempFloat32Vec4, offset);
  }
  drawColorOpaque() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numCulled === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numVisible === 0 || this.meshCounts[viewIndex].numTransparent === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numXRayed === this.meshCounts[viewIndex].numMeshes) {
      return;
    }
    if (this.#rendererSet.colorRenderer) {
      this.#rendererSet.colorRenderer.renderVBOInstancingLayer(this, RENDER_PASSES.DRAW_OPAQUE);
    }
  }
  drawColorSAOOpaque() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numCulled === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numVisible === 0 || this.meshCounts[viewIndex].numTransparent === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numXRayed === this.meshCounts[viewIndex].numMeshes) {
      return;
    }
    if (this.#rendererSet.colorSAORenderer) {
      this.#rendererSet.colorSAORenderer.renderVBOInstancingLayer(this, RENDER_PASSES.DRAW_OPAQUE);
    }
  }
  drawColorTranslucent() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numCulled === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numVisible === 0 || this.meshCounts[viewIndex].numTransparent === 0 || this.meshCounts[viewIndex].numXRayed === this.meshCounts[viewIndex].numMeshes) {
      return;
    }
    if (this.#rendererSet.colorRenderer) {
      this.#rendererSet.colorRenderer.renderVBOInstancingLayer(this, RENDER_PASSES.DRAW_TRANSPARENT);
    }
  }
  drawDepth() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numCulled === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numVisible === 0 || this.meshCounts[viewIndex].numTransparent === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numXRayed === this.meshCounts[viewIndex].numMeshes) {
      return;
    }
    if (this.#rendererSet.drawDepthRenderer) {
      this.#rendererSet.drawDepthRenderer.renderVBOInstancingLayer(this, RENDER_PASSES.DRAW_OPAQUE);
    }
  }
  drawNormals() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numCulled === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numVisible === 0 || this.meshCounts[viewIndex].numTransparent === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numXRayed === this.meshCounts[viewIndex].numMeshes) {
      return;
    }
  }
  drawSilhouetteXRayed() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numCulled === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numVisible === 0 || this.meshCounts[viewIndex].numXRayed === 0) {
      return;
    }
    if (this.#rendererSet.silhouetteRenderer) {
      this.#rendererSet.silhouetteRenderer.renderVBOInstancingLayer(this, RENDER_PASSES.SILHOUETTE_XRAYED);
    }
  }
  drawSilhouetteHighlighted() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numCulled === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numVisible === 0 || this.meshCounts[viewIndex].numHighlighted === 0) {
      return;
    }
    if (this.#rendererSet.silhouetteRenderer) {
      this.#rendererSet.silhouetteRenderer.renderVBOInstancingLayer(this, RENDER_PASSES.SILHOUETTE_HIGHLIGHTED);
    }
  }
  drawSilhouetteSelected() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numCulled === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numVisible === 0 || this.meshCounts[viewIndex].numSelected === 0) {
      return;
    }
    if (this.#rendererSet.silhouetteRenderer) {
      this.#rendererSet.silhouetteRenderer.renderVBOInstancingLayer(this, RENDER_PASSES.SILHOUETTE_SELECTED);
    }
  }
  drawEdgesColorOpaque() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numCulled === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numVisible === 0) {
      return;
    }
    if (this.#rendererSet.edgesColorRenderer) {
      this.#rendererSet.edgesColorRenderer.renderVBOInstancingLayer(this, RENDER_PASSES.DRAW_OPAQUE);
    }
  }
  drawEdgesColorTranslucent() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numCulled === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numVisible === 0 || this.meshCounts[viewIndex].numTransparent === 0) {
      return;
    }
    if (this.#rendererSet.edgesColorRenderer) {
      this.#rendererSet.edgesColorRenderer.renderVBOInstancingLayer(this, RENDER_PASSES.DRAW_TRANSPARENT);
    }
  }
  drawEdgesHighlighted() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numCulled === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numVisible === 0 || this.meshCounts[viewIndex].numHighlighted === 0) {
      return;
    }
    if (this.#rendererSet.edgesSilhouetteRenderer) {
      this.#rendererSet.edgesSilhouetteRenderer.renderVBOInstancingLayer(this, RENDER_PASSES.SILHOUETTE_HIGHLIGHTED);
    }
  }
  drawEdgesSelected() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numCulled === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numVisible === 0 || this.meshCounts[viewIndex].numSelected === 0) {
      return;
    }
    if (this.#rendererSet.edgesSilhouetteRenderer) {
      this.#rendererSet.edgesSilhouetteRenderer.renderVBOInstancingLayer(this, RENDER_PASSES.SILHOUETTE_SELECTED);
    }
  }
  drawEdgesXRayed() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numCulled === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numVisible === 0 || this.meshCounts[viewIndex].numXRayed === 0) {
      return;
    }
    if (this.#rendererSet.edgesSilhouetteRenderer) {
      this.#rendererSet.edgesSilhouetteRenderer.renderVBOInstancingLayer(this, RENDER_PASSES.SILHOUETTE_XRAYED);
    }
  }
  drawOcclusion() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numCulled === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numVisible === 0) {
      return;
    }
    if (this.#rendererSet.occlusionRenderer) {
      this.#rendererSet.occlusionRenderer.renderVBOInstancingLayer(this, RENDER_PASSES.DRAW_OPAQUE);
    }
  }
  drawShadow() {
  }
  drawPickMesh() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numVisible === 0) {
      return;
    }
    if (this.#rendererSet.pickMeshRenderer) {
      this.#rendererSet.pickMeshRenderer.renderVBOInstancingLayer(this, RENDER_PASSES.PICK);
    }
  }
  drawPickDepths() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numVisible === 0) {
      return;
    }
    if (this.#rendererSet.pickDepthRenderer) {
      this.#rendererSet.pickDepthRenderer.renderVBOInstancingLayer(this, RENDER_PASSES.PICK);
    }
  }
  drawSnapInit() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numCulled === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numVisible === 0) {
      return;
    }
    if (this.#rendererSet.snapInitRenderer) {
      this.#rendererSet.snapInitRenderer.renderVBOInstancingLayer(this, RENDER_PASSES.PICK);
    }
  }
  drawSnap() {
    const viewIndex = this.renderContext.view.viewIndex;
    if (this.meshCounts[viewIndex].numCulled === this.meshCounts[viewIndex].numMeshes || this.meshCounts[viewIndex].numVisible === 0) {
      return;
    }
    if (this.#rendererSet.snapRenderer) {
      this.#rendererSet.snapRenderer.renderVBOInstancingLayer(this, RENDER_PASSES.PICK);
    }
  }
  drawPickNormals() {
  }
  destroy() {
    const renderState = this.renderState;
    for (let viewIndex = 0, len = renderState.flagsBufs.length; viewIndex < len; viewIndex++) {
      if (renderState.colorsBuf[viewIndex]) {
        renderState.colorsBuf[viewIndex].destroy();
        renderState.colorsBuf[viewIndex] = null;
      }
    }
    if (renderState.metallicRoughnessBuf) {
      renderState.metallicRoughnessBuf.destroy();
      renderState.metallicRoughnessBuf = null;
    }
    for (let viewIndex = 0, len = renderState.flagsBufs.length; viewIndex < len; viewIndex++) {
      if (renderState.flagsBufs[viewIndex]) {
        renderState.flagsBufs[viewIndex].destroy();
        renderState.flagsBufs[viewIndex] = null;
      }
    }
    if (renderState.modelMatrixCol0Buf) {
      renderState.modelMatrixCol0Buf.destroy();
      renderState.modelMatrixCol0Buf = null;
    }
    if (renderState.modelMatrixCol1Buf) {
      renderState.modelMatrixCol1Buf.destroy();
      renderState.modelMatrixCol1Buf = null;
    }
    if (renderState.modelMatrixCol2Buf) {
      renderState.modelMatrixCol2Buf.destroy();
      renderState.modelMatrixCol2Buf = null;
    }
    if (renderState.modelNormalMatrixCol0Buf) {
      renderState.modelNormalMatrixCol0Buf.destroy();
      renderState.modelNormalMatrixCol0Buf = null;
    }
    if (renderState.modelNormalMatrixCol1Buf) {
      renderState.modelNormalMatrixCol1Buf.destroy();
      renderState.modelNormalMatrixCol1Buf = null;
    }
    if (renderState.modelNormalMatrixCol2Buf) {
      renderState.modelNormalMatrixCol2Buf.destroy();
      renderState.modelNormalMatrixCol2Buf = null;
    }
    if (renderState.pickColorsBuf) {
      renderState.pickColorsBuf.destroy();
      renderState.pickColorsBuf = null;
    }
    if (renderState.indicesBuf) {
      renderState.indicesBuf.destroy();
      renderState.indicesBuf = null;
    }
    if (renderState.edgeIndicesBuf) {
      renderState.edgeIndicesBuf.destroy();
      renderState.indicesBuf = null;
    }
    this.renderState = null;
  }
  commitRendererState(viewIndex) {
  }
  isEmpty() {
    return false;
  }
  setLayerMeshCollidable(layerMeshIndex, flags) {
    if (!this.#built) {
      throw new SDKError("Not built");
    }
  }
  setLayerMeshMatrix(layerMeshIndex, matrix) {
    if (!this.#built) {
      throw new SDKError("Not built");
    }
  }
  setLayerMeshOffset(viewIndex, layerMeshIndex, offset) {
    if (!this.#built) {
      throw new SDKError("Not built");
    }
  }
};

// ../sdk/src/webglrenderer/vbo/instancing/VBOInstancingRenderer.ts
var VBOInstancingRenderer = class extends VBORenderer {
  renderVBOInstancingLayer(vboInstancingLayer, renderPass) {
    if (!this.bind(renderPass)) {
      return;
    }
    const attributes = this.attributes;
    const renderState = vboInstancingLayer.renderState;
    const view = this.renderContext.view;
    const viewIndex = view.viewIndex;
    const gl = this.renderContext.gl;
    gl.uniform1i(this.uniforms.renderPass, renderPass);
    attributes.position.bindArrayBuffer(renderState.positionsBuf);
    if (attributes.uv) {
      attributes.uv.bindArrayBuffer(renderState.uvBuf);
    }
    if (attributes.flags) {
      attributes.flags.bindArrayBuffer(renderState.flagsBufs[viewIndex]);
      gl.vertexAttribDivisor(attributes.flags.location, 1);
    }
    if (attributes.color) {
      attributes.color.bindArrayBuffer(renderState.colorsBuf[viewIndex]);
      gl.vertexAttribDivisor(attributes.color.location, 1);
    }
    if (attributes.pickColor) {
      attributes.pickColor.bindArrayBuffer(renderState.pickColorsBuf);
      gl.vertexAttribDivisor(attributes.pickColor.location, 1);
    }
    if (attributes.intensity) {
    }
    if (attributes.modelMatrixCol0) {
      attributes.modelMatrixCol0.bindArrayBuffer(renderState.modelMatrixCol0Buf);
      gl.vertexAttribDivisor(attributes.modelMatrixCol0.location, 1);
    }
    if (attributes.modelMatrixCol1) {
      attributes.modelMatrixCol1.bindArrayBuffer(renderState.modelMatrixCol1Buf);
      gl.vertexAttribDivisor(attributes.modelMatrixCol1.location, 1);
    }
    if (attributes.modelMatrixCol2) {
      attributes.modelMatrixCol2.bindArrayBuffer(renderState.modelMatrixCol2Buf);
      gl.vertexAttribDivisor(attributes.modelMatrixCol2.location, 1);
    }
    gl.uniform3fv(this.uniforms.positionsDecompressOffset, renderState.positionsDecompressOffset);
    gl.uniform3fv(this.uniforms.positionsDecompressScale, renderState.positionsDecompressScale);
    gl.uniformMatrix4fv(this.uniforms.worldMatrix, false, vboInstancingLayer.rendererModel.worldMatrix);
    gl.uniformMatrix4fv(
      this.uniforms.viewMatrix,
      false,
      createRTCViewMat(
        renderPass === RENDER_PASSES.PICK ? this.renderContext.pickViewMatrix : this.renderContext.view.camera.viewMatrix,
        renderState.origin
      )
    );
    if (renderState.indicesBuf) {
      renderState.indicesBuf.bind();
    }
    this.drawVBOInstancingLayerPrimitives(vboInstancingLayer, renderPass);
  }
};

// ../sdk/src/webglrenderer/vbo/instancing/triangles/renderers/VBOTrianglesInstancingDrawColorRenderer.ts
var VBOTrianglesInstancingDrawColorRenderer = class extends VBOInstancingRenderer {
  getHash() {
    return `${this.lambertShadingHash}-${this.slicingHash}`;
  }
  buildVertexShader(src) {
    this.vertexHeader(src);
    this.vertexCommonDefs(src);
    this.vertexInstancingTransformDefs(src);
    this.vertexSlicingDefs(src);
    this.vertexDrawLambertDefs(src);
    this.vertexDrawMainOpen(src);
    {
      this.vertexDrawInstancingTransformLogic(src);
      this.vertexDrawLambertLogic(src);
      this.vertexSlicingLogic(src);
    }
    this.vertexMainClose(src);
  }
  buildFragmentShader(src) {
    this.fragmentHeader(src);
    this.fragmentPrecisionDefs(src);
    this.fragmentCommonDefs(src);
    this.fragmentSlicingDefs(src);
    this.fragmentDrawLambertDefs(src);
    src.push("void main(void) {");
    {
      this.fragmentSlicingLogic(src);
      this.fragmentDrawLambertLogic(src);
      this.fragmentCommonOutput(src);
    }
    src.push("}");
  }
  drawVBOInstancingLayerPrimitives(vboInstancingLayer, renderPass) {
    const gl = this.renderContext.gl;
    const renderState = vboInstancingLayer.renderState;
    gl.drawElementsInstanced(gl.TRIANGLES, renderState.indicesBuf.numItems, renderState.indicesBuf.itemType, 0, renderState.numInstances);
  }
};

// ../sdk/src/webglrenderer/vbo/instancing/triangles/renderers/VBOTrianglesInstancingSilhouetteRenderer.ts
var VBOTrianglesInstancingSilhouetteRenderer = class extends VBOInstancingRenderer {
  getHash() {
    return this.slicingHash;
  }
  buildVertexShader(src) {
    this.vertexHeader(src);
    this.vertexCommonDefs(src);
    this.vertexInstancingTransformDefs(src);
    this.vertexSlicingDefs(src);
    this.vertexSilhouetteDefs(src);
    this.vertexSilhouetteMainOpen(src);
    {
      this.vertexDrawInstancingTransformLogic(src);
      this.vertexSilhouetteLogic(src);
      this.vertexSlicingLogic(src);
    }
    this.vertexMainClose(src);
  }
  buildFragmentShader(src) {
    this.fragmentHeader(src);
    this.fragmentPrecisionDefs(src);
    this.fragmentCommonDefs(src);
    this.fragmentSlicingDefs(src);
    this.fragmentSilhouetteDefs(src);
    src.push("void main(void) {");
    {
      this.fragmentSlicingLogic(src);
      this.fragmentSilhouetteLogic(src);
      this.fragmentCommonOutput(src);
    }
    src.push("}");
  }
  drawVBOInstancingLayerPrimitives(vboInstancingLayer, renderPass) {
    const gl = this.renderContext.gl;
    const renderState = vboInstancingLayer.renderState;
    gl.drawElementsInstanced(gl.TRIANGLES, renderState.indicesBuf.numItems, renderState.indicesBuf.itemType, 0, renderState.numInstances);
  }
};

// ../sdk/src/webglrenderer/vbo/instancing/triangles/renderers/VBOTrianglesInstancingPickMeshRenderer.ts
var VBOTrianglesInstancingPickMeshRenderer = class extends VBOInstancingRenderer {
  getHash() {
    return this.slicingHash;
  }
  buildVertexShader(src) {
    this.vertexHeader(src);
    this.vertexCommonDefs(src);
    this.vertexInstancingTransformDefs(src);
    this.vertexSlicingDefs(src);
    this.vertexPickMeshDefs(src);
    this.vertexPickMainOpen(src);
    {
      this.vertexPickInstancingTransformLogic(src);
      this.vertexPickMeshLogic(src);
      this.vertexSlicingLogic(src);
    }
    this.vertexMainClose(src);
  }
  buildFragmentShader(src) {
    this.fragmentHeader(src);
    this.fragmentPrecisionDefs(src);
    this.fragmentCommonDefs(src);
    this.fragmentSlicingDefs(src);
    this.fragmentPickMeshDefs(src);
    src.push("void main(void) {");
    {
      this.fragmentSlicingLogic(src);
      this.fragmentPickMeshLogic(src);
      this.fragmentCommonOutput(src);
    }
    src.push("}");
  }
  drawVBOInstancingLayerPrimitives(vboInstancingLayer, renderPass) {
    const gl = this.renderContext.gl;
    const renderState = vboInstancingLayer.renderState;
    gl.drawElementsInstanced(gl.TRIANGLES, renderState.indicesBuf.numItems, renderState.indicesBuf.itemType, 0, renderState.numInstances);
  }
};

// ../sdk/src/webglrenderer/vbo/instancing/triangles/renderers/VBOTrianglesInstancingEdgesDrawRenderer.ts
var VBOTrianglesInstancingEdgesDrawRenderer = class extends VBOInstancingRenderer {
  constructor(renderContext) {
    super(renderContext, { edges: true });
  }
  getHash() {
    return this.slicingHash;
  }
  buildVertexShader(src) {
    this.vertexHeader(src);
    this.vertexCommonDefs(src);
    this.vertexInstancingTransformDefs(src);
    this.vertexSlicingDefs(src);
    this.vertexDrawFlatColorDefs(src);
    this.vertexDrawMainOpen(src);
    {
      this.vertexDrawInstancingTransformLogic(src);
      this.vertexDrawEdgesColorLogic(src);
      this.vertexSlicingLogic(src);
    }
    this.vertexMainClose(src);
  }
  buildFragmentShader(src) {
    this.fragmentHeader(src);
    this.fragmentPrecisionDefs(src);
    this.fragmentCommonDefs(src);
    this.fragmentSlicingDefs(src);
    this.fragmentDrawFlatColorDefs(src);
    src.push("void main(void) {");
    {
      this.fragmentSlicingLogic(src);
      this.fragmentDrawFlatColorLogic(src);
      this.fragmentCommonOutput(src);
    }
    src.push("}");
  }
  drawVBOInstancingLayerPrimitives(vboInstancingLayer, renderPass) {
    const gl = this.renderContext.gl;
    const renderState = vboInstancingLayer.renderState;
    gl.drawElementsInstanced(gl.LINES, renderState.edgeIndicesBuf.numItems, renderState.edgeIndicesBuf.itemType, 0, renderState.numInstances);
  }
};

// ../sdk/src/webglrenderer/vbo/instancing/triangles/renderers/VBOTrianglesInstancingEdgesSilhouetteRenderer.ts
var VBOTrianglesInstancingEdgesSilhouetteRenderer = class extends VBOInstancingRenderer {
  constructor(renderContext) {
    super(renderContext, { edges: true });
  }
  getHash() {
    return this.slicingHash;
  }
  buildVertexShader(src) {
    this.vertexHeader(src);
    this.vertexCommonDefs(src);
    this.vertexInstancingTransformDefs(src);
    this.vertexSlicingDefs(src);
    this.vertexSilhouetteDefs(src);
    this.vertexSilhouetteMainOpen(src);
    {
      this.vertexDrawInstancingTransformLogic(src);
      this.vertexSilhouetteLogic(src);
      this.vertexSlicingLogic(src);
    }
    this.vertexMainClose(src);
  }
  buildFragmentShader(src) {
    this.fragmentHeader(src);
    this.fragmentPrecisionDefs(src);
    this.fragmentCommonDefs(src);
    this.fragmentSlicingDefs(src);
    this.fragmentSilhouetteDefs(src);
    src.push("void main(void) {");
    {
      this.fragmentSlicingLogic(src);
      this.fragmentSilhouetteLogic(src);
      this.fragmentCommonOutput(src);
    }
    src.push("}");
  }
  drawVBOInstancingLayerPrimitives(vboInstancingLayer, renderPass) {
    const gl = this.renderContext.gl;
    const renderState = vboInstancingLayer.renderState;
    gl.drawElementsInstanced(gl.LINES, renderState.edgeIndicesBuf.numItems, renderState.edgeIndicesBuf.itemType, 0, renderState.numInstances);
  }
};

// ../sdk/src/webglrenderer/vbo/instancing/triangles/renderers/VBOTrianglesInstancingDrawDepthRenderer.ts
var VBOTrianglesInstancingDrawDepthRenderer = class extends VBOInstancingRenderer {
  getHash() {
    return `${this.slicingHash}`;
  }
  buildVertexShader(src) {
    this.vertexHeader(src);
    this.vertexCommonDefs(src);
    this.vertexInstancingTransformDefs(src);
    this.vertexSlicingDefs(src);
    this.vertexDrawMainOpen(src);
    {
      this.vertexDrawInstancingTransformLogic(src);
      this.vertexSlicingLogic(src);
    }
    this.vertexMainClose(src);
  }
  buildFragmentShader(src) {
    this.fragmentHeader(src);
    this.fragmentPrecisionDefs(src);
    this.fragmentCommonDefs(src);
    this.fragmentDrawDepthDefs(src);
    this.fragmentSlicingDefs(src);
    src.push("void main(void) {");
    {
      this.fragmentSlicingLogic(src);
      this.fragmentDrawDepthLogic(src);
      this.fragmentCommonOutput(src);
    }
    src.push("}");
  }
  drawVBOInstancingLayerPrimitives(vboInstancingLayer, renderPass) {
    const gl = this.renderContext.gl;
    const renderState = vboInstancingLayer.renderState;
    gl.drawElementsInstanced(gl.TRIANGLES, renderState.indicesBuf.numItems, renderState.indicesBuf.itemType, 0, renderState.numInstances);
  }
};

// ../sdk/src/webglrenderer/vbo/instancing/triangles/renderers/VBOTrianglesInstancingDrawColorSAORenderer.ts
var VBOTrianglesInstancingDrawColorSAORenderer = class extends VBOInstancingRenderer {
  getHash() {
    return `${this.lambertShadingHash}-${this.slicingHash}`;
  }
  buildVertexShader(src) {
    this.vertexHeader(src);
    this.vertexCommonDefs(src);
    this.vertexInstancingTransformDefs(src);
    this.vertexSlicingDefs(src);
    this.vertexDrawLambertDefs(src);
    this.vertexDrawMainOpen(src);
    {
      this.vertexDrawInstancingTransformLogic(src);
      this.vertexDrawLambertLogic(src);
      this.vertexSlicingLogic(src);
    }
    this.vertexMainClose(src);
  }
  buildFragmentShader(src) {
    this.fragmentHeader(src);
    this.fragmentPrecisionDefs(src);
    this.fragmentCommonDefs(src);
    this.fragmentSlicingDefs(src);
    this.fragmentDrawLambertDefs(src);
    this.fragmentDrawSAODefs(src);
    src.push("void main(void) {");
    {
      this.fragmentSlicingLogic(src);
      this.fragmentDrawLambertLogic(src);
      this.fragmentDrawSAOLogic(src);
      this.fragmentCommonOutput(src);
    }
    src.push("}");
  }
  drawVBOInstancingLayerPrimitives(vboInstancingLayer, renderPass) {
    const gl = this.renderContext.gl;
    const renderState = vboInstancingLayer.renderState;
    gl.drawElementsInstanced(gl.TRIANGLES, renderState.indicesBuf.numItems, renderState.indicesBuf.itemType, 0, renderState.numInstances);
  }
};

// ../sdk/src/webglrenderer/vbo/instancing/triangles/renderers/rendererFactory.ts
var RendererFactory3 = class extends VBORendererSet {
  createDrawColorRenderer() {
    return new VBOTrianglesInstancingDrawColorRenderer(this.renderContext);
  }
  createDrawColorSAORenderer() {
    return new VBOTrianglesInstancingDrawColorSAORenderer(this.renderContext);
  }
  createDrawDepthRenderer() {
    return new VBOTrianglesInstancingDrawDepthRenderer(this.renderContext);
  }
  createSilhouetteRenderer() {
    return new VBOTrianglesInstancingSilhouetteRenderer(this.renderContext);
  }
  createPickMeshRenderer() {
    return new VBOTrianglesInstancingPickMeshRenderer(this.renderContext);
  }
  createEdgesColorRenderer() {
    return new VBOTrianglesInstancingEdgesDrawRenderer(this.renderContext);
  }
  createEdgesSilhouetteRenderer() {
    return new VBOTrianglesInstancingEdgesSilhouetteRenderer(this.renderContext);
  }
};
var rendererFactory3 = new RendererSetFactory((webglRenderer) => {
  return new RendererFactory3(webglRenderer);
});

// ../sdk/src/webglrenderer/vbo/instancing/triangles/VBOTrianglesInstancingLayer.ts
var VBOTrianglesInstancingLayer = class extends VBOInstancingLayer {
  constructor(VBOInstancingLayerParams) {
    super(VBOInstancingLayerParams, rendererFactory3.getRenderers(VBOInstancingLayerParams.renderContext.webglRenderer));
  }
};

// ../sdk/src/webglrenderer/vbo/instancing/lines/renderers/VBOLinesInstancingDrawColorRenderer.ts
var VBOLinesInstancingDrawColorRenderer = class extends VBOInstancingRenderer {
  getHash() {
    return this.slicingHash;
  }
  buildVertexShader(src) {
    this.vertexHeader(src);
    this.vertexCommonDefs(src);
    this.vertexInstancingTransformDefs(src);
    this.vertexSlicingDefs(src);
    this.vertexDrawFlatColorDefs(src);
    this.vertexDrawMainOpen(src);
    {
      this.vertexDrawInstancingTransformLogic(src);
      this.vertexDrawFlatColorLogic(src);
      this.vertexSlicingLogic(src);
    }
    this.vertexMainClose(src);
  }
  buildFragmentShader(src) {
    this.fragmentHeader(src);
    this.fragmentPrecisionDefs(src);
    this.fragmentCommonDefs(src);
    this.fragmentSlicingDefs(src);
    this.fragmentDrawFlatColorDefs(src);
    src.push("void main(void) {");
    {
      this.fragmentSlicingLogic(src);
      this.fragmentDrawFlatColorLogic(src);
      this.fragmentCommonOutput(src);
    }
    src.push("}");
  }
  drawVBOInstancingLayerPrimitives(vboInstancingLayer, renderPass) {
    const gl = this.renderContext.gl;
    const renderState = vboInstancingLayer.renderState;
    gl.drawElementsInstanced(gl.LINES, renderState.indicesBuf.numItems, renderState.indicesBuf.itemType, 0, renderState.numInstances);
  }
};

// ../sdk/src/webglrenderer/vbo/instancing/lines/renderers/VBOLinesInstancingPickMeshRenderer.ts
var VBOLinesInstancingPickMeshRenderer = class extends VBOInstancingRenderer {
  getHash() {
    return this.slicingHash;
  }
  buildVertexShader(src) {
    this.vertexHeader(src);
    this.vertexCommonDefs(src);
    this.vertexInstancingTransformDefs(src);
    this.vertexSlicingDefs(src);
    this.vertexPickMeshDefs(src);
    this.vertexPickMainOpen(src);
    {
      this.vertexDrawInstancingTransformLogic(src);
      this.vertexPickMeshLogic(src);
      this.vertexSlicingLogic(src);
    }
    this.vertexMainClose(src);
  }
  buildFragmentShader(src) {
    this.fragmentHeader(src);
    this.fragmentPrecisionDefs(src);
    this.fragmentCommonDefs(src);
    this.fragmentSlicingDefs(src);
    this.fragmentPickMeshDefs(src);
    src.push("void main(void) {");
    {
      this.fragmentSlicingLogic(src);
      this.fragmentPickMeshLogic(src);
      this.fragmentCommonOutput(src);
    }
    src.push("}");
  }
  drawVBOInstancingLayerPrimitives(vboInstancingLayer, renderPass) {
    const gl = this.renderContext.gl;
    const renderState = vboInstancingLayer.renderState;
    gl.drawElementsInstanced(gl.LINES, renderState.indicesBuf.numItems, renderState.indicesBuf.itemType, 0, renderState.numInstances);
  }
};

// ../sdk/src/webglrenderer/vbo/instancing/lines/renderers/VBOLinesInstancingSilhouetteRenderer.ts
var VBOLinesInstancingSilhouetteRenderer = class extends VBOInstancingRenderer {
  getHash() {
    return this.slicingHash;
  }
  buildVertexShader(src) {
    this.vertexHeader(src);
    this.vertexCommonDefs(src);
    this.vertexInstancingTransformDefs(src);
    this.vertexSlicingDefs(src);
    this.vertexSilhouetteDefs(src);
    this.vertexSilhouetteMainOpen(src);
    {
      this.vertexDrawInstancingTransformLogic(src);
      this.vertexSilhouetteLogic(src);
      this.vertexSlicingLogic(src);
    }
    this.vertexMainClose(src);
  }
  buildFragmentShader(src) {
    this.fragmentHeader(src);
    this.fragmentPrecisionDefs(src);
    this.fragmentCommonDefs(src);
    this.fragmentSlicingDefs(src);
    this.fragmentSilhouetteDefs(src);
    src.push("void main(void) {");
    {
      this.fragmentSlicingLogic(src);
      this.fragmentSilhouetteLogic(src);
      this.fragmentCommonOutput(src);
    }
    src.push("}");
  }
  drawVBOInstancingLayerPrimitives(vboInstancingLayer, renderPass) {
    const gl = this.renderContext.gl;
    const renderState = vboInstancingLayer.renderState;
    gl.drawElementsInstanced(gl.LINES, renderState.indicesBuf.numItems, renderState.indicesBuf.itemType, 0, renderState.numInstances);
  }
};

// ../sdk/src/webglrenderer/vbo/instancing/lines/renderers/rendererFactory.ts
var RendererFactory4 = class extends VBORendererSet {
  createDrawColorRenderer() {
    return new VBOLinesInstancingDrawColorRenderer(this.renderContext);
  }
  createPickMeshRenderer() {
    return new VBOLinesInstancingPickMeshRenderer(this.renderContext);
  }
  createSilhouetteRenderer() {
    return new VBOLinesInstancingSilhouetteRenderer(this.renderContext);
  }
};
var rendererFactory4 = new RendererSetFactory((webglRenderer) => {
  return new RendererFactory4(webglRenderer);
});

// ../sdk/src/webglrenderer/vbo/instancing/lines/VBOLinesInstancingLayer.ts
var VBOLinesInstancingLayer = class extends VBOInstancingLayer {
  constructor(layerParams) {
    super(layerParams, rendererFactory4.getRenderers(layerParams.renderContext.webglRenderer));
  }
};

// ../sdk/src/webglrenderer/vbo/batching/lines/renderers/VBOLinesBatchingDrawColorRenderer.ts
var VBOLinesBatchingDrawColorRenderer = class extends VBOBatchingRenderer {
  getHash() {
    return this.slicingHash;
  }
  buildVertexShader(src) {
    this.vertexHeader(src);
    this.vertexCommonDefs(src);
    this.vertexBatchingTransformDefs(src);
    this.vertexSlicingDefs(src);
    this.vertexDrawFlatColorDefs(src);
    this.vertexDrawMainOpen(src);
    {
      this.vertexDrawBatchingTransformLogic(src);
      this.vertexDrawFlatColorLogic(src);
      this.vertexSlicingLogic(src);
    }
    this.vertexMainClose(src);
  }
  buildFragmentShader(src) {
    this.fragmentHeader(src);
    this.fragmentPrecisionDefs(src);
    this.fragmentCommonDefs(src);
    this.fragmentSlicingDefs(src);
    this.fragmentDrawFlatColorDefs(src);
    src.push("void main(void) {");
    this.fragmentSlicingLogic(src);
    this.fragmentDrawFlatColorLogic(src);
    this.fragmentCommonOutput(src);
    src.push("}");
  }
  drawVBOBatchingLayerPrimitives(vboBatchingLayer, renderPass) {
    const gl = this.renderContext.gl;
    const renderState = vboBatchingLayer.renderState;
    gl.drawElements(gl.LINES, renderState.indicesBuf.numItems, renderState.indicesBuf.itemType, 0);
  }
};

// ../sdk/src/webglrenderer/vbo/batching/lines/renderers/VBOLinesBatchingPickMeshRenderer.ts
var VBOLinesBatchingPickMeshRenderer = class extends VBOBatchingRenderer {
  getHash() {
    return this.slicingHash;
  }
  buildVertexShader(src) {
    this.vertexHeader(src);
    this.vertexCommonDefs(src);
    this.vertexBatchingTransformDefs(src);
    this.vertexSlicingDefs(src);
    this.vertexPickMeshDefs(src);
    this.vertexPickMainOpen(src);
    {
      this.vertexDrawBatchingTransformLogic(src);
      this.vertexPickMeshLogic(src);
      this.vertexSlicingLogic(src);
    }
    this.vertexMainClose(src);
  }
  buildFragmentShader(src) {
    this.fragmentHeader(src);
    this.fragmentPrecisionDefs(src);
    this.fragmentCommonDefs(src);
    this.fragmentSlicingDefs(src);
    this.fragmentPickMeshDefs(src);
    src.push("void main(void) {");
    this.fragmentSlicingLogic(src);
    this.fragmentPickMeshLogic(src);
    this.fragmentCommonOutput(src);
    src.push("}");
  }
  drawVBOBatchingLayerPrimitives(vboBatchingLayer, renderPass) {
    const gl = this.renderContext.gl;
    const renderState = vboBatchingLayer.renderState;
    gl.drawElements(gl.LINES, renderState.indicesBuf.numItems, renderState.indicesBuf.itemType, 0);
  }
};

// ../sdk/src/webglrenderer/vbo/batching/lines/renderers/VBOLinesBatchingSilhouetteRenderer.ts
var VBOLinesBatchingSilhouetteRenderer = class extends VBOBatchingRenderer {
  getHash() {
    return this.slicingHash;
  }
  buildVertexShader(src) {
    this.vertexHeader(src);
    this.vertexCommonDefs(src);
    this.vertexBatchingTransformDefs(src);
    this.vertexSlicingDefs(src);
    this.vertexSilhouetteDefs(src);
    this.vertexSilhouetteMainOpen(src);
    {
      this.vertexDrawBatchingTransformLogic(src);
      this.vertexSilhouetteLogic(src);
      this.vertexSlicingLogic(src);
      src.push("}");
    }
    src.push("}");
  }
  buildFragmentShader(src) {
    this.fragmentHeader(src);
    this.fragmentPrecisionDefs(src);
    this.fragmentCommonDefs(src);
    this.fragmentSlicingDefs(src);
    this.fragmentSilhouetteDefs(src);
    src.push("void main(void) {");
    this.fragmentSlicingLogic(src);
    this.fragmentSilhouetteLogic(src);
    this.fragmentCommonOutput(src);
    src.push("}");
  }
  drawVBOBatchingLayerPrimitives(vboBatchingLayer, renderPass) {
    const gl = this.renderContext.gl;
    const renderState = vboBatchingLayer.renderState;
    gl.drawElements(gl.LINES, renderState.indicesBuf.numItems, renderState.indicesBuf.itemType, 0);
  }
};

// ../sdk/src/webglrenderer/vbo/batching/lines/renderers/rendererFactory.ts
var RendererFactory5 = class extends VBORendererSet {
  createDrawColorRenderer() {
    return new VBOLinesBatchingDrawColorRenderer(this.renderContext);
  }
  createPickMeshRenderer() {
    return new VBOLinesBatchingPickMeshRenderer(this.renderContext);
  }
  createSilhouetteRenderer() {
    return new VBOLinesBatchingSilhouetteRenderer(this.renderContext);
  }
};
var rendererFactory5 = new RendererSetFactory((webglRenderer) => {
  return new RendererFactory5(webglRenderer);
});

// ../sdk/src/webglrenderer/vbo/batching/lines/VBOLinesBatchingLayer.ts
var VBOLinesBatchingLayer = class extends VBOBatchingLayer {
  constructor(layerParams) {
    super(layerParams, rendererFactory5.getRenderers(layerParams.renderContext.webglRenderer));
  }
};

// ../sdk/src/webglrenderer/WebGLRendererModel.ts
var defaultScale = createVec3([1, 1, 1]);
var defaultPosition = createVec3([0, 0, 0]);
var defaultRotation = createVec3([0, 0, 0]);
var defaultQuaternion = identityQuat();
var defaultColorTextureId = "defaultColorTexture";
var defaultMetalRoughTextureId = "defaultMetalRoughTexture";
var defaultNormalsTextureId = "defaultNormalsTexture";
var defaultEmissiveTextureId = "defaultEmissiveTexture";
var defaultOcclusionTextureId = "defaultOcclusionTexture";
var defaultTextureSetId = "defaultTextureSet";
var WebGLRendererModel = class extends Component {
  viewer;
  qualityRender;
  rendererGeometries;
  rendererTextures;
  rendererTextureSets;
  rendererMeshes;
  rendererObjects;
  rendererObjectsList;
  layerList;
  #layers;
  #currentLayers;
  meshCounts;
  webglRenderer;
  #renderContext;
  #position;
  #rotation;
  #quaternion;
  #scale;
  #worldMatrix;
  #viewMatrix;
  #colorTextureEnabled;
  #backfaces;
  #numGeometries;
  #numTextures;
  #numMeshes;
  #numTriangles;
  #numLines;
  #numPoints;
  #numRendererObjects;
  #textureTranscoder;
  #aabbDirty;
  #edgeThreshold;
  #aabb;
  #viewMatrixDirty;
  #worldMatrixNonIdentity;
  #onCameraViewMatrix;
  #layerId;
  numSubMeshes;
  renderFlags;
  constructor(params2) {
    super(params2.viewer);
    this.id = params2.id;
    this.viewer = params2.viewer;
    this.meshCounts = [
      new MeshCounts(),
      new MeshCounts(),
      new MeshCounts(),
      new MeshCounts()
    ];
    this.webglRenderer = params2.webglRenderer;
    this.#renderContext = params2.renderContext;
    this.#textureTranscoder = params2.textureTranscoder;
    this.#aabb = collapseAABB3();
    this.#aabbDirty = false;
    this.#layers = {};
    this.layerList = [];
    this.#currentLayers = {};
    this.rendererGeometries = {};
    this.rendererTextures = {};
    this.rendererTextureSets = {};
    this.rendererMeshes = {};
    this.rendererObjects = {};
    this.rendererObjectsList = [];
    this.rendererObjects = {};
    this.#numGeometries = 0;
    this.#numRendererObjects = 0;
    this.#numTextures = 0;
    this.#numMeshes = 0;
    this.#numTriangles = 0;
    this.#numLines = 0;
    this.#numPoints = 0;
    this.#edgeThreshold = params2.edgeThreshold || 10;
    this.numSubMeshes = 0;
    this.#position = createVec3(params2.position || [0, 0, 0]);
    this.#rotation = createVec3(params2.rotation || [0, 0, 0]);
    this.#quaternion = createVec4(params2.quaternion || [0, 0, 0, 1]);
    if (params2.rotation) {
      eulerToQuat(this.#rotation, "XYZ", this.#quaternion);
    }
    this.#scale = createVec3(params2.scale || [1, 1, 1]);
    this.#worldMatrix = createMat4();
    composeMat4(this.#position, this.#quaternion, this.#scale, this.#worldMatrix);
    if (params2.matrix || params2.position || params2.rotation || params2.scale || params2.quaternion) {
      this.#viewMatrix = createMat4();
      this.#viewMatrixDirty = true;
      this.#worldMatrixNonIdentity = true;
    }
    this.qualityRender = params2.qualityRender !== false;
    this.#createDefaultTextureSet();
    for (let i = 0, len = this.layerList.length; i < len; i++) {
      const layer = this.layerList[i];
      layer.layerIndex = i;
    }
    this.#currentLayers = {};
    this.#attachSceneModel(params2.sceneModel);
    this.webglRenderer.setImageDirty();
    this.renderFlags = [
      new RenderFlags(),
      new RenderFlags(),
      new RenderFlags(),
      new RenderFlags()
    ];
  }
  #attachSceneModel(sceneModel) {
    const textures = sceneModel.textures;
    const geometries = sceneModel.geometries;
    const meshes = sceneModel.meshes;
    const objects = sceneModel.objects;
    if (textures) {
      for (let textureId in textures) {
        this.#attachTexture(textures[textureId]);
      }
    }
    if (geometries) {
      for (let geometryId in geometries) {
        this.#attachGeometry(geometries[geometryId]);
      }
    }
    if (meshes) {
      for (let meshId in meshes) {
        this.#attachMesh(meshes[meshId]);
      }
    }
    if (objects) {
      for (let objectId in objects) {
        this.#attachSceneObject(objects[objectId]);
      }
    }
    for (let layerId in this.#currentLayers) {
      this.#currentLayers[layerId].build();
    }
    const numViews = this.viewer.viewList.length;
  }
  #attachTexture(texture) {
    const textureId = texture.id;
    if (this.rendererTextures[textureId]) {
      throw new SDKError(`WebGLRendererTexture with ID ${textureId} already created in WebGLRendererModel`);
    }
    const glTexture = new WebGLTexture({ gl: this.#renderContext.gl });
    if (texture.preloadColor) {
      glTexture.setPreloadColor(texture.preloadColor);
    }
    if (texture.image) {
      const image = texture.image;
      image.crossOrigin = "Anonymous";
      glTexture.setImage(image, {
        minFilter: texture.minFilter,
        magFilter: texture.magFilter,
        wrapS: texture.wrapS,
        wrapT: texture.wrapT,
        wrapR: texture.wrapR,
        flipY: texture.flipY,
        encoding: texture.encoding
      });
    } else if (texture.src) {
      const ext = texture.src.split(".").pop();
      switch (ext) {
        case "jpeg":
        case "jpg":
        case "png":
        case "gif":
          const image = new Image();
          image.onload = () => {
            glTexture.setImage(image, {
              minFilter: texture.minFilter,
              magFilter: texture.magFilter,
              wrapS: texture.wrapS,
              wrapT: texture.wrapT,
              wrapR: texture.wrapR,
              flipY: texture.flipY,
              encoding: texture.encoding
            });
          };
          image.src = texture.src;
          break;
        default:
          if (!this.#textureTranscoder) {
            this.error(`Can't create texture from 'src' - rendererModel needs to be configured with a TextureTranscoder for this file type ('${ext}')`);
          } else {
            loadArraybuffer(
              texture.src,
              (arrayBuffer) => {
                if (!arrayBuffer.byteLength) {
                  this.error(`Can't create texture from 'src': file data is zero length`);
                  return;
                }
                this.#textureTranscoder.transcode([arrayBuffer]).then((compressedTextureData) => {
                  glTexture.setCompressedData(compressedTextureData);
                  this.webglRenderer.setImageDirty();
                });
              },
              (errMsg) => {
                this.error(`Can't create texture from 'src': ${errMsg}`);
              }
            );
          }
          break;
      }
    } else if (texture.buffers) {
      if (!this.#textureTranscoder) {
        this.error(`Can't create texture from 'buffers' - rendererModel needs to be configured with a TextureTranscoder for this option`);
      } else {
        this.#textureTranscoder.transcode(texture.buffers).then((compressedTextureData) => {
          glTexture.setCompressedData(compressedTextureData);
          this.webglRenderer.setImageDirty();
        });
      }
    }
    const rendererTexture = new WebGLRendererTexture(texture, glTexture);
    texture.rendererTexture = rendererTexture;
    this.rendererTextures[textureId] = rendererTexture;
  }
  #attachGeometry(geometry) {
    const geometryId = geometry.id;
    if (this.rendererGeometries[geometryId]) {
      throw new SDKError(`RendererGeometry with ID ${geometryId} already created in WebGLRendererModel`);
    }
    const rendererGeometry = new WebGLRendererGeometry();
    this.rendererGeometries[geometryId] = rendererGeometry;
    geometry.rendererGeometry = rendererGeometry;
    this.#numGeometries++;
  }
  #attachMesh(mesh) {
    const rendererGeometry = this.rendererGeometries[mesh.geometry.id];
    if (!rendererGeometry) {
      throw new SDKError(`RendererGeometry with ID ${mesh.geometry.id} not found in WebGLRendererModel`);
    }
    const textureSetId = mesh.textureSet ? mesh.textureSet.id : defaultTextureSetId;
    const rendererTextureSet = this.rendererTextureSets[textureSetId];
    if (!rendererTextureSet) {
      this.error(`TextureSet with ID "${textureSetId}" not found in WebGLRendererModel`);
    }
    const layer = this.#getLayer(textureSetId, mesh);
    if (!layer) {
      return;
    }
    let matrix = mesh.rtcMatrix;
    const color2 = mesh.color ? new Uint8Array([Math.floor(mesh.color[0] * 255), Math.floor(mesh.color[1] * 255), Math.floor(mesh.color[2] * 255)]) : [255, 255, 255];
    const opacity = mesh.opacity !== void 0 && mesh.opacity !== null ? Math.floor(mesh.opacity * 255) : 255;
    const rendererMesh = new WebGLRendererMesh({
      tileManager: this.webglRenderer.tileManager,
      id: mesh.id,
      layer,
      color: color2,
      opacity,
      matrix,
      rendererTextureSet,
      rendererGeometry,
      meshIndex: 0
    });
    rendererMesh.pickId = this.webglRenderer.attachPickable(rendererMesh);
    const a2 = rendererMesh.pickId >> 24 & 255;
    const b4 = rendererMesh.pickId >> 16 & 255;
    const g = rendererMesh.pickId >> 8 & 255;
    const r = rendererMesh.pickId & 255;
    const pickColor = new Uint8Array([r, g, b4, a2]);
    const meshIndex = layer.createLayerMesh({ pickColor }, mesh);
    rendererMesh.layer = layer;
    rendererMesh.meshIndex = meshIndex;
    this.rendererMeshes[mesh.id] = rendererMesh;
    this.#numMeshes++;
  }
  #getLayer(textureSetId, mesh) {
    const sceneGeometry = mesh.geometry;
    const primitive = sceneGeometry.primitive;
    const instancing = sceneGeometry.numMeshes > 1;
    const origin = mesh.tile.origin;
    const layerId = `VBO-${instancing ? "Instancing" : "Batching"}
        .${textureSetId}
        .${primitive}
        .${Math.round(origin[0])}.${Math.round(origin[1])}.${Math.round(origin[2])}
        .${instancing ? sceneGeometry.id : ""}`;
    let layer = this.#currentLayers[layerId];
    if (layer) {
      if (layer.canCreateLayerMesh(sceneGeometry)) {
        return layer;
      } else {
        layer.build();
        delete this.#currentLayers[layerId];
      }
    }
    let textureSet;
    if (textureSetId) {
      textureSet = this.rendererTextureSets[textureSetId];
      if (!textureSet) {
        this.error(`TextureSet with ID "${textureSetId}" not found in WebGLRendererModel - ensure that you create it first with createTextureSet()`);
      }
    }
    if (instancing) {
      switch (sceneGeometry.primitive) {
        case TrianglesPrimitive:
        case SolidPrimitive:
        case SurfacePrimitive:
          layer = new VBOTrianglesInstancingLayer({
            renderContext: this.#renderContext,
            rendererModel: this,
            sceneGeometry,
            textureSet,
            layerIndex: 0,
            origin
          });
          this.log(`Creating new VBOTrianglesInstancingLayer`);
          break;
        case LinesPrimitive:
          layer = new VBOLinesInstancingLayer({
            renderContext: this.#renderContext,
            rendererModel: this,
            sceneGeometry,
            textureSet,
            layerIndex: 0,
            origin
          });
          this.log(`Creating new VBOLinesInstancingLayer`);
          break;
        case PointsPrimitive:
          this.log(`Creating new VBOPointsInstancingLayer`);
          break;
        default:
          this.error(`Primitive type not supported: ${sceneGeometry.primitive}`);
          return;
      }
    } else {
      switch (sceneGeometry.primitive) {
        case TrianglesPrimitive:
        case SolidPrimitive:
        case SurfacePrimitive:
          layer = new VBOTrianglesBatchingLayer({
            renderContext: this.#renderContext,
            rendererModel: this,
            primitive,
            textureSet,
            layerIndex: 0,
            origin
          });
          this.log(`Creating new VBOTrianglesBatchingLayer`);
          break;
        case LinesPrimitive:
          layer = new VBOLinesBatchingLayer({
            primitive,
            renderContext: this.#renderContext,
            rendererModel: this,
            textureSet,
            layerIndex: 0,
            origin
          });
          this.log(`Creating new VBOLinesBatchingLayer`);
          break;
        case PointsPrimitive:
          layer = new VBOPointsBatchingLayer({
            renderContext: this.#renderContext,
            rendererModel: this,
            primitive,
            textureSet,
            layerIndex: 0,
            origin
          });
          this.log(`Creating new VBOPointsBatchingLayer`);
          break;
        default:
          this.error(`Primitive type not supported: ${sceneGeometry.primitive}`);
          return;
      }
    }
    this.#layers[layerId] = layer;
    this.layerList.push(layer);
    this.#currentLayers[layerId] = layer;
    return layer;
  }
  #attachSceneObject(sceneObject) {
    let objectId = sceneObject.id;
    if (objectId === void 0) {
      objectId = createUUID2();
    } else if (this.rendererObjects[objectId]) {
      this.error("Already has a WebGLRenderObject with this ID: " + objectId + " - will assign random ID");
      objectId = createUUID2();
    }
    const meshes = sceneObject.meshes;
    if (meshes === void 0) {
      throw new SDKError("SceneObject property expected: meshes");
    }
    const rendererMeshes = [];
    for (let i = 0, len = meshes.length; i < len; i++) {
      const mesh = meshes[i];
      const rendererMesh = this.rendererMeshes[mesh.id];
      if (!rendererMesh) {
        console.error("WebGLRendererMesh not found: + " + mesh.id);
      } else {
        rendererMeshes.push(rendererMesh);
      }
    }
    if (rendererMeshes.length === 0) {
      return;
    }
    const rendererObject = new WebGLRendererObject({
      id: objectId,
      rendererModel: this,
      rendererMeshes,
      aabb: sceneObject.aabb
    });
    this.rendererObjectsList.push(rendererObject);
    this.rendererObjects[objectId] = rendererObject;
    sceneObject.rendererObject = rendererObject;
    this.#numRendererObjects++;
  }
  get position() {
    return this.#position;
  }
  get rotation() {
    return this.#rotation;
  }
  get quaternion() {
    return this.#quaternion;
  }
  get scale() {
    return this.#scale;
  }
  get worldMatrix() {
    return this.#worldMatrix;
  }
  get colorTextureEnabled() {
    return this.#colorTextureEnabled;
  }
  get backfaces() {
    return this.#backfaces;
  }
  set backfaces(backfaces) {
    backfaces = !!backfaces;
    this.#backfaces = backfaces;
    this.webglRenderer.setImageDirty();
  }
  get matrix() {
    return this.#worldMatrix;
  }
  get aabb() {
    if (this.#aabbDirty) {
      this.#rebuildAABB();
    }
    return this.#aabb;
  }
  get numTriangles() {
    return this.#numTriangles;
  }
  get numLines() {
    return this.#numLines;
  }
  get numPoints() {
    return this.#numPoints;
  }
  #createDefaultTextureSet() {
    const defaultColorRendererTexture = new WebGLRendererTexture(
      null,
      new WebGLTexture({
        gl: this.#renderContext.gl,
        preloadColor: [1, 1, 1, 1]
        // [r, g, b, a]})
      })
    );
    const defaultMetalRoughRendererTexture = new WebGLRendererTexture(
      null,
      new WebGLTexture({
        gl: this.#renderContext.gl,
        preloadColor: [0, 1, 1, 1]
        // [unused, roughness, metalness, unused]
      })
    );
    const defaultNormalsRendererTexture = new WebGLRendererTexture(
      null,
      new WebGLTexture({
        gl: this.#renderContext.gl,
        preloadColor: [0, 0, 0, 0]
        // [x, y, z, unused] - these must be zeros
      })
    );
    const defaultEmissiveRendererTexture = new WebGLRendererTexture(
      null,
      new WebGLTexture({
        gl: this.#renderContext.gl,
        preloadColor: [0, 0, 0, 1]
        // [x, y, z, unused]
      })
    );
    const defaultOcclusionRendererTexture = new WebGLRendererTexture(
      null,
      new WebGLTexture({
        gl: this.#renderContext.gl,
        preloadColor: [1, 1, 1, 1]
        // [x, y, z, unused]
      })
    );
    this.rendererTextures[defaultColorTextureId] = defaultColorRendererTexture;
    this.rendererTextures[defaultMetalRoughTextureId] = defaultMetalRoughRendererTexture;
    this.rendererTextures[defaultNormalsTextureId] = defaultNormalsRendererTexture;
    this.rendererTextures[defaultEmissiveTextureId] = defaultEmissiveRendererTexture;
    this.rendererTextures[defaultOcclusionTextureId] = defaultOcclusionRendererTexture;
    this.rendererTextureSets[defaultTextureSetId] = new WebGLRendererTextureSet({
      id: defaultTextureSetId,
      colorRendererTexture: defaultColorRendererTexture,
      metallicRoughnessRendererTexture: defaultMetalRoughRendererTexture,
      emissiveRendererTexture: defaultEmissiveRendererTexture,
      occlusionRendererTexture: defaultOcclusionRendererTexture
    });
  }
  #rebuildAABB() {
    collapseAABB3(this.#aabb);
    for (let i = 0, len = this.rendererObjectsList.length; i < len; i++) {
      const rendererObject = this.rendererObjectsList[i];
      expandAABB3(this.#aabb, rendererObject.aabb);
    }
    this.#aabbDirty = false;
  }
  /** @private */
  rebuildRenderFlags(viewIndex) {
    const renderFlags = this.renderFlags[viewIndex];
    renderFlags.reset();
    this.#updateRenderFlagsVisibleLayers(viewIndex);
    if (renderFlags.numLayers > 0 && renderFlags.numVisibleLayers === 0) {
      renderFlags.culled = true;
      return;
    }
    this.#updateRenderFlags(viewIndex);
  }
  /**
   * @private
   */
  #updateRenderFlagsVisibleLayers(viewIndex) {
    const renderFlags = this.renderFlags[viewIndex];
    renderFlags.numLayers = this.layerList.length;
    renderFlags.numVisibleLayers = 0;
    for (let layerIndex = 0, len = this.layerList.length; layerIndex < len; layerIndex++) {
      const layer = this.layerList[layerIndex];
      const layerVisible = this.#getActiveSectionPlanesForLayer(layer);
      if (layerVisible) {
        renderFlags.visibleLayers[renderFlags.numVisibleLayers++] = layerIndex;
      }
    }
  }
  #getActiveSectionPlanesForLayer(layer) {
    return true;
  }
  #updateRenderFlags(viewIndex) {
    const meshCounts = this.meshCounts[viewIndex];
    if (meshCounts.numVisible === 0) {
      return;
    }
    if (meshCounts.numCulled === meshCounts.numMeshes) {
      return;
    }
    const renderFlags = this.renderFlags[viewIndex];
    renderFlags.colorOpaque = meshCounts.numTransparent < meshCounts.numMeshes;
    if (meshCounts.numTransparent > 0) {
      renderFlags.colorTransparent = true;
    }
    if (meshCounts.numXRayed > 0) {
      const xrayMaterial = this.viewer[viewIndex].xrayMaterial;
      if (xrayMaterial.fill) {
        if (xrayMaterial.fillAlpha < 1) {
          renderFlags.xrayedSilhouetteTransparent = true;
        } else {
          renderFlags.xrayedSilhouetteOpaque = true;
        }
      }
      if (xrayMaterial.edges) {
        if (xrayMaterial.edgeAlpha < 1) {
          renderFlags.xrayedEdgesTransparent = true;
        } else {
          renderFlags.xrayedEdgesOpaque = true;
        }
      }
    }
    const edgeMaterial = this.viewer[viewIndex].edges;
    if (edgeMaterial.enabled) {
      renderFlags.edgesOpaque = meshCounts.numTransparent < meshCounts.numMeshes;
      if (meshCounts.numTransparent > 0) {
        renderFlags.edgesTransparent = true;
      }
    }
    if (meshCounts.numSelected > 0) {
      const selectedMaterial = this.viewer[viewIndex].selectedMaterial;
      if (selectedMaterial.fill) {
        if (selectedMaterial.fillAlpha < 1) {
          renderFlags.selectedSilhouetteTransparent = true;
        } else {
          renderFlags.selectedSilhouetteOpaque = true;
        }
      }
      if (selectedMaterial.edges) {
        if (selectedMaterial.edgeAlpha < 1) {
          renderFlags.selectedEdgesTransparent = true;
        } else {
          renderFlags.selectedEdgesOpaque = true;
        }
      }
    }
    if (meshCounts.numHighlighted > 0) {
      const highlightMaterial = this.viewer[viewIndex].highlightMaterial;
      if (highlightMaterial.fill) {
        if (highlightMaterial.fillAlpha < 1) {
          renderFlags.highlightedSilhouetteTransparent = true;
        } else {
          renderFlags.highlightedSilhouetteOpaque = true;
        }
      }
      if (highlightMaterial.edges) {
        if (highlightMaterial.edgeAlpha < 1) {
          renderFlags.highlightedEdgesTransparent = true;
        } else {
          renderFlags.highlightedEdgesOpaque = true;
        }
      }
    }
  }
  #build() {
  }
  // build() {
  //     if (this.destroyed) {
  //         this.log("rendererModel already destroyed");
  //         return;
  //     }
  //     if (this.built) {
  //         this.log("rendererModel already built");
  //         return;
  //     }
  //     for (let layerId in this.#currentLayers) {
  //         if (this.#currentLayers.hasOwnProperty(layerId)) {
  //             this.#currentLayers[layerId].build();
  //         }
  //     }
  //     for (let i = 0, len = this.objectList.length; i < len; i++) {
  //         const rendererObject = this.objectList[i];
  //         rendererObject.build();
  //     }
  //     for (let i = 0, len = this.objectList.length; i < len; i++) {
  //         const rendererObject = this.objectList[i];
  //         rendererObject.build2();
  //     }
  //     // this.layerList.sort((a, b) => {
  //     //     if (a.sortId < b.sortId) {
  //     //         return -1;
  //     //     }
  //     //     if (a.sortId > b.sortId) {
  //     //         return 1;
  //     //     }
  //     //     return 0;
  //     // });
  //     for (let i = 0, len = this.layerList.length; i < len; i++) {
  //         const layer = this.layerList[i];
  //         layer.layerIndex = i;
  //     }
  //     this.#currentLayers = {};
  //     this.built = true;
  //     this.webglRenderer.setImageDirty();
  //     //     this.#view.viewer.scene.setAABBDirty();
  //     this.onBuilt.dispatch(this, null);
  // }
  //
  destroy() {
    if (this.destroyed) {
      return;
    }
    for (let layerId in this.#currentLayers) {
      if (this.#currentLayers.hasOwnProperty(layerId)) {
        this.#currentLayers[layerId].destroy();
      }
    }
    for (let i = 0, len = this.layerList.length; i < len; i++) {
      this.layerList[i].destroy();
    }
    for (let objectId in this.rendererObjects) {
      this.rendererObjects[objectId].destroy();
    }
    for (let meshId in this.rendererMeshes) {
      this.rendererMeshes[meshId].destroy();
    }
    this.#currentLayers = {};
    this.#layers = {};
    this.layerList = [];
    this.rendererGeometries = {};
    this.rendererTextures = {};
    this.rendererTextureSets = {};
    this.rendererMeshes = {};
    this.rendererObjects = {};
    super.destroy();
  }
  // detachSceneModel(): void {
  //     const sceneModel = this.sceneModel;
  //     if (!sceneModel) {
  //         return;
  //     }
  //     const textures = sceneModel.textures;
  //     const geometries = sceneModel.geometries;
  //     const meshes = sceneModel.meshes;
  //     const objects = sceneModel.objects;
  //     if (textures) {
  //         for (let textureId in textures) {
  //             const texture = textures[textureId];
  //             if (texture.rendererTexture) {
  //                 texture.rendererTexture = null;
  //             }
  //         }
  //     }
  //     if (geometries) {
  //         for (let geometryId in geometries) {
  //             const geometry = geometries[geometryId];
  //             if (geometry.rendererGeometry) {
  //                 geometry.rendererGeometry = null;
  //             }
  //         }
  //     }
  //     if (meshes) {
  //         for (let meshId in meshes) {
  //             const mesh = meshes[meshId];
  //             if (mesh.rendererMesh) {
  //                 mesh.rendererMesh = null;
  //             }
  //         }
  //     }
  //     if (objects) {
  //         for (let objectId in objects) {
  //             const object = objects[objectId];
  //             if (object.rendererObject) {
  //                 object.rendererObject = null;
  //             }
  //         }
  //     }
  //     this.sceneModel = null;
  // }
};

// ../sdk/src/webglrenderer/RenderStats.ts
var RenderStats = class {
  /**
   * Number of WebGL programs that were bound in the rendered frame.
   */
  numProgramBinds;
  /**
   * Number of WebGL drawArrays calls performed during the rendered frame.
   */
  numDrawArrays;
  /**
   * Number of WebGL textures that were bound in the rendered frame.
   */
  numTextureBinds;
  /**
   * Creates a new RenderStats.
   */
  constructor() {
    this.reset();
  }
  /**
   * Called by the renderers before each frame.
   */
  reset() {
    this.numProgramBinds = 0;
    this.numDrawArrays = 0;
    this.numTextureBinds = 0;
  }
};

// ../sdk/src/webglrenderer/WebGLRenderer.ts
var import_strongly_typed_events17 = __toESM(require_dist8());

// ../sdk/src/webglrenderer/WebGLRenderBufferManager.ts
var WebGLRenderBufferManager = class {
  #gl;
  #view;
  #renderBuffersBasic;
  #renderBuffersScaled;
  #webglCanvas;
  constructor(gl, webglCanvas) {
    this.#gl = gl;
    this.#webglCanvas = webglCanvas;
    this.#renderBuffersBasic = {};
    this.#renderBuffersScaled = {};
  }
  getRenderBuffer(id, options) {
    const renderBuffers = this.#renderBuffersBasic;
    let renderBuffer = renderBuffers[id];
    if (!renderBuffer) {
      renderBuffer = new WebGLRenderBuffer(this.#webglCanvas, this.#gl, options);
      renderBuffers[id] = renderBuffer;
    } else {
      if (options && options.size) {
        renderBuffer.setSize(options.size);
      }
    }
    return renderBuffer;
  }
  destroy() {
    for (let id in this.#renderBuffersBasic) {
      this.#renderBuffersBasic[id].destroy();
    }
    for (let id in this.#renderBuffersScaled) {
      this.#renderBuffersScaled[id].destroy();
    }
  }
};

// ../sdk/src/webglrenderer/SAOOcclusionRenderer.ts
var tempVec2 = createVec2();
var SAOOcclusionRenderer = class {
  #numSamples;
  #program;
  #programError;
  #aPosition;
  #aUV;
  #uDepthTexture;
  #uCameraNear;
  #uCameraFar;
  #uCameraProjectionMatrix;
  #uCameraInverseProjectionMatrix;
  #uScale;
  #uIntensity;
  #uBias;
  #uKernelRadius;
  #uMinResolution;
  #uRandomSeed;
  #uvBuf;
  #positionsBuf;
  #indicesBuf;
  #uPerspective;
  #uViewport;
  #dirty;
  #renderContext;
  constructor(params2) {
    this.#renderContext = params2.renderContext;
    this.#numSamples = null;
    this.#program = null;
    this.#programError = false;
    this.#aPosition = null;
    this.#aUV = null;
    this.#uDepthTexture = "uDepthTexture";
    this.#uCameraNear = null;
    this.#uCameraFar = null;
    this.#uCameraProjectionMatrix = null;
    this.#uCameraInverseProjectionMatrix = null;
    this.#uScale = null;
    this.#uIntensity = null;
    this.#uBias = null;
    this.#uKernelRadius = null;
    this.#uMinResolution = null;
    this.#uRandomSeed = null;
    this.#uvBuf = null;
    this.#positionsBuf = null;
    this.#indicesBuf = null;
  }
  render(params2) {
    this.#build();
    if (this.#programError) {
      return;
    }
    const { depthRenderBuffer, view } = params2;
    const gl = this.#renderContext.gl;
    const program = this.#program;
    const sao = view.sao;
    const viewportWidth = gl.drawingBufferWidth;
    const viewportHeight = gl.drawingBufferHeight;
    const projection = view.camera.projectionType === PerspectiveProjectionType ? view.camera.perspectiveProjection : view.camera.orthoProjection;
    const near = projection.near;
    const far = projection.far;
    const projectionMatrix = projection.projMatrix;
    const inverseProjectionMatrix = projection.inverseProjMatrix;
    const randomSeed = Math.random();
    const perspective = view.camera.projectionType === PerspectiveProjectionType;
    tempVec2[0] = viewportWidth;
    tempVec2[1] = viewportHeight;
    gl.viewport(0, 0, viewportWidth, viewportHeight);
    gl.clearColor(0, 0, 0, 1);
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.BLEND);
    gl.frontFace(gl.CCW);
    gl.clear(gl.COLOR_BUFFER_BIT);
    program.bind();
    gl.uniform1f(this.#uCameraNear, near);
    gl.uniform1f(this.#uCameraFar, far);
    gl.uniformMatrix4fv(this.#uCameraProjectionMatrix, false, projectionMatrix);
    gl.uniformMatrix4fv(this.#uCameraInverseProjectionMatrix, false, inverseProjectionMatrix);
    gl.uniform1i(this.#uPerspective, perspective ? 1 : 0);
    gl.uniform1f(this.#uScale, sao.scale * (far / 5));
    gl.uniform1f(this.#uIntensity, sao.intensity);
    gl.uniform1f(this.#uBias, sao.bias);
    gl.uniform1f(this.#uKernelRadius, sao.kernelRadius);
    gl.uniform1f(this.#uMinResolution, sao.minResolution);
    gl.uniform2fv(this.#uViewport, tempVec2);
    gl.uniform1f(this.#uRandomSeed, randomSeed);
    const depthTexture = depthRenderBuffer.getDepthTexture();
    program.bindTexture(this.#uDepthTexture, depthTexture, 0);
    this.#aUV.bindArrayBuffer(this.#uvBuf);
    this.#aPosition.bindArrayBuffer(this.#positionsBuf);
    this.#indicesBuf.bind();
    gl.drawElements(gl.TRIANGLES, this.#indicesBuf.numItems, this.#indicesBuf.itemType, 0);
  }
  #build() {
    let dirty = false;
    const sao = this.#renderContext.view.sao;
    if (sao.numSamples !== this.#numSamples) {
      this.#numSamples = Math.floor(sao.numSamples);
      dirty = true;
    }
    if (!dirty) {
      return;
    }
    const gl = this.#renderContext.gl;
    if (this.#program) {
      this.#program.destroy();
      this.#program = null;
    }
    this.#program = new WebGLProgram(gl, {
      vertex: `#version 300 es
                    precision highp float;
                    precision highp int;

                    in vec3 aPosition;
                    in vec2 aUV;

                    out vec2 vUV;

                    void main () {
                        gl_Position = vec4(aPosition, 1.0);
                        vUV = aUV;
                    }`,
      fragment: `#version 300 es
                precision highp float;
                precision highp int;

                #define NORMAL_TEXTURE 0
                #define PI 3.14159265359
                #define PI2 6.28318530718
                #define EPSILON 1e-6
                #define NUM_SAMPLES ${this.#numSamples}
                #define NUM_RINGS 4

                in vec2        vUV;

                uniform sampler2D   uDepthTexture;

                uniform float       uCameraNear;
                uniform float       uCameraFar;
                uniform mat4        uProjectMatrix;
                uniform mat4        uInverseProjectMatrix;

                uniform bool        uPerspective;

                uniform float       uScale;
                uniform float       uIntensity;
                uniform float       uBias;
                uniform float       uKernelRadius;
                uniform float       uMinResolution;
                uniform vec2        uViewport;
                uniform float       uRandomSeed;

                float pow2( const in float x ) { return x*x; }

                highp float rand( const in vec2 uv ) {
                    const highp float a = 12.9898, b = 78.233, c = 43758.5453;
                    highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
                    return fract(sin(sn) * c);
                }

                vec3 packNormalToRGB( const in vec3 normal ) {
                    return normalize( normal ) * 0.5 + 0.5;
                }

                vec3 unpackRGBToNormal( const in vec3 rgb ) {
                    return 2.0 * rgb.xyz - 1.0;
                }

                const float packUpscale = 256. / 255.;
                const float unpackDownScale = 255. / 256.;

                const vec3 packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );
                const vec4 unPackFactors = unpackDownScale / vec4( packFactors, 1. );

                const float shiftRights = 1. / 256.;

                vec4 packFloatToRGBA( const in float v ) {
                    vec4 r = vec4( fract( v * packFactors ), v );
                    r.yzw -= r.xyz * shiftRights;
                    return r * packUpscale;
                }

                float unpackRGBAToFloat( const in vec4 v ) {
                    return dot( floor( v * 255.0 + 0.5 ) / 255.0, unPackFactors );
                }

                float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
                    return ( near * far ) / ( ( far - near ) * invClipZ - far );
                }

                float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
                    return linearClipZ * ( near - far ) - near;
                }

                float getDepth( const in vec2 screenPosition ) {
                    return vec4(texture(uDepthTexture, screenPosition)).r;
                }

                float getViewZ( const in float depth ) {
                     if (uPerspective) {
                         return perspectiveDepthToViewZ( depth, uCameraNear, uCameraFar );
                     } else {
                        return orthographicDepthToViewZ( depth, uCameraNear, uCameraFar );
                     }
                }

                vec3 getViewPos( const in vec2 screenPos, const in float depth, const in float viewZ ) {
                	float clipW = uProjectMatrix[2][3] * viewZ + uProjectMatrix[3][3];
                	vec4 clipPosition = vec4( ( vec3( screenPos, depth ) - 0.5 ) * 2.0, 1.0 );
                	clipPosition *= clipW;
                	return ( uInverseProjectMatrix * clipPosition ).xyz;
                }

                vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPos ) {
                    return normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );
                }

                float scaleDividedByCameraFar;
                float minResolutionMultipliedByCameraFar;

                float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {
                	vec3 viewDelta = sampleViewPosition - centerViewPosition;
                	float viewDistance = length( viewDelta );
                	float scaledScreenDistance = scaleDividedByCameraFar * viewDistance;
                	return max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - uBias) / (1.0 + pow2( scaledScreenDistance ) );
                }

                const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );
                const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );

                float getAmbientOcclusion( const in vec3 centerViewPosition ) {

                	scaleDividedByCameraFar = uScale / uCameraFar;
                	minResolutionMultipliedByCameraFar = uMinResolution * uCameraFar;
                	vec3 centerViewNormal = getViewNormal( centerViewPosition, vUV );

                	float angle = rand( vUV + uRandomSeed ) * PI2;
                	vec2 radius = vec2( uKernelRadius * INV_NUM_SAMPLES ) / uViewport;
                	vec2 radiusStep = radius;

                	float occlusionSum = 0.0;
                	float weightSum = 0.0;

                	for( int i = 0; i < NUM_SAMPLES; i ++ ) {
                		vec2 sampleUv = vUV + vec2( cos( angle ), sin( angle ) ) * radius;
                		radius += radiusStep;
                		angle += ANGLE_STEP;

                		float sampleDepth = getDepth( sampleUv );
                		if( sampleDepth >= ( 1.0 - EPSILON ) ) {
                			continue;
                		}

                		float sampleViewZ = getViewZ( sampleDepth );
                		vec3 sampleViewPosition = getViewPos( sampleUv, sampleDepth, sampleViewZ );
                		occlusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );
                		weightSum += 1.0;
                	}

                	if( weightSum == 0.0 ) discard;

                	return occlusionSum * ( uIntensity / weightSum );
                }

                out vec4 outColor;

                void main() {

                	float centerDepth = getDepth( vUV );

                	if( centerDepth >= ( 1.0 - EPSILON ) ) {
                		discard;
                	}

                	float centerViewZ = getViewZ( centerDepth );
                	vec3 viewPosition = getViewPos( vUV, centerDepth, centerViewZ );

                	float ambientOcclusion = getAmbientOcclusion( viewPosition );

                	outColor = packFloatToRGBA(  1.0- ambientOcclusion );
                }`
    });
    if (this.#program.errors) {
      console.error(this.#program.errors.join("\n"));
      this.#programError = true;
      return;
    }
    const uv = new Float32Array([1, 1, 0, 1, 0, 0, 1, 0]);
    const positions = new Float32Array([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0]);
    const indices = new Uint32Array([0, 1, 2, 0, 2, 3]);
    this.#positionsBuf = new WebGLArrayBuf(gl, gl.ARRAY_BUFFER, positions, positions.length, 3, gl.STATIC_DRAW);
    this.#uvBuf = new WebGLArrayBuf(gl, gl.ARRAY_BUFFER, uv, uv.length, 2, gl.STATIC_DRAW);
    this.#indicesBuf = new WebGLArrayBuf(gl, gl.ELEMENT_ARRAY_BUFFER, indices, indices.length, 1, gl.STATIC_DRAW);
    this.#program.bind();
    this.#uCameraNear = this.#program.getLocation("uCameraNear");
    this.#uCameraFar = this.#program.getLocation("uCameraFar");
    this.#uCameraProjectionMatrix = this.#program.getLocation("uProjectMatrix");
    this.#uCameraInverseProjectionMatrix = this.#program.getLocation("uInverseProjectMatrix");
    this.#uPerspective = this.#program.getLocation("uPerspective");
    this.#uScale = this.#program.getLocation("uScale");
    this.#uIntensity = this.#program.getLocation("uIntensity");
    this.#uBias = this.#program.getLocation("uBias");
    this.#uKernelRadius = this.#program.getLocation("uKernelRadius");
    this.#uMinResolution = this.#program.getLocation("uMinResolution");
    this.#uViewport = this.#program.getLocation("uViewport");
    this.#uRandomSeed = this.#program.getLocation("uRandomSeed");
    this.#aPosition = this.#program.getAttribute("aPosition");
    this.#aUV = this.#program.getAttribute("aUV");
    this.#dirty = false;
  }
  destroy() {
    if (this.#program) {
      this.#program.destroy();
      this.#program = null;
    }
  }
};

// ../sdk/src/webglrenderer/SAODepthLimitedBlurRenderer.ts
var blurStdDev = 4;
var blurDepthCutoff = 0.01;
var KERNEL_RADIUS = 16;
var sampleOffsetsVert = new Float32Array(createSampleOffsets(KERNEL_RADIUS + 1, [0, 1]));
var sampleOffsetsHor = new Float32Array(createSampleOffsets(KERNEL_RADIUS + 1, [1, 0]));
var sampleWeights = new Float32Array(createSampleWeights(KERNEL_RADIUS + 1, blurStdDev));
var tempVec2a2 = new Float32Array(2);
var SAODepthLimitedBlurRenderer = class {
  #renderContext;
  #program;
  #programError;
  #aPosition;
  #aUV;
  #uDepthTexture;
  #uOcclusionTexture;
  #uViewport;
  #uCameraNear;
  #uCameraFar;
  #uCameraProjectionMatrix;
  #uCameraInverseProjectionMatrix;
  #uvBuf;
  #positionsBuf;
  #indicesBuf;
  #uDepthCutoff;
  #uSampleOffsets;
  #uSampleWeights;
  constructor(params2) {
    this.#renderContext = params2.renderContext;
    this.#program = null;
    this.#programError = false;
    this.#aPosition = null;
    this.#aUV = null;
    this.#uDepthTexture = "uDepthTexture";
    this.#uOcclusionTexture = "uOcclusionTexture";
    this.#uViewport = null;
    this.#uCameraNear = null;
    this.#uCameraFar = null;
    this.#uCameraProjectionMatrix = null;
    this.#uCameraInverseProjectionMatrix = null;
    this.#uvBuf = null;
    this.#positionsBuf = null;
    this.#indicesBuf = null;
    this.init();
  }
  init() {
    const gl = this.#renderContext.gl;
    this.#program = new WebGLProgram(gl, {
      vertex: `#version 300 es
                precision highp float;
                precision highp int;

                in vec3 aPosition;
                in vec2 aUV;
                uniform vec2 uViewport;
                out vec2 vUV;
                out vec2 vInvSize;
                void main () {
                    vUV = aUV;
                    vInvSize = 1.0 / uViewport;
                    gl_Position = vec4(aPosition, 1.0);
                }`,
      fragment: `#version 300 es
                precision highp float;
                precision highp int;

                #define PI 3.14159265359
                #define PI2 6.28318530718
                #define EPSILON 1e-6

                #define KERNEL_RADIUS ${KERNEL_RADIUS}

                in vec2        vUV;
                in vec2        vInvSize;

                uniform sampler2D   uDepthTexture;
                uniform sampler2D   uOcclusionTexture;

                uniform float       uCameraNear;
                uniform float       uCameraFar;
                uniform float       uDepthCutoff;

                uniform vec2        uSampleOffsets[ KERNEL_RADIUS + 1 ];
                uniform float       uSampleWeights[ KERNEL_RADIUS + 1 ];

                const float         unpackDownscale = 255. / 256.;

                const vec3          packFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );
                const vec4          unpackFactors = unpackDownscale / vec4( packFactors, 1. );

                const float packUpscale = 256. / 255.;

                const float shiftRights = 1. / 256.;

                float unpackRGBAToFloat( const in vec4 v ) {
                    return dot( floor( v * 255.0 + 0.5 ) / 255.0, unpackFactors );
                }

                vec4 packFloatToRGBA( const in float v ) {
                    vec4 r = vec4( fract( v * packFactors ), v );
                    r.yzw -= r.xyz * shiftRights;
                    return r * packUpscale;
                }

                float viewZToOrthographicDepth( const in float viewZ) {
                    return ( viewZ + uCameraNear ) / ( uCameraNear - uCameraFar );
                }

                float orthographicDepthToViewZ( const in float linearClipZ) {
                    return linearClipZ * ( uCameraNear - uCameraFar ) - uCameraNear;
                }

                float viewZToPerspectiveDepth( const in float viewZ) {
                    return (( uCameraNear + viewZ ) * uCameraFar ) / (( uCameraFar - uCameraNear ) * viewZ );
                }

                float perspectiveDepthToViewZ( const in float invClipZ) {
                    return ( uCameraNear * uCameraFar ) / ( ( uCameraFar - uCameraNear ) * invClipZ - uCameraFar );
                }

                float getDepth( const in vec2 screenPosition ) {
                    return vec4(texture(uDepthTexture, screenPosition)).r;
                }

                float getViewZ( const in float depth ) {
                     return perspectiveDepthToViewZ( depth );
                }

                out vec4 outColor;

                void main() {

                    float depth = getDepth( vUV );
                    if( depth >= ( 1.0 - EPSILON ) ) {
                        discard;
                    }

                    float centerViewZ = -getViewZ( depth );
                    bool rBreak = false;
                    bool lBreak = false;

                    float weightSum = uSampleWeights[0];
                    float occlusionSum = unpackRGBAToFloat(texture( uOcclusionTexture, vUV )) * weightSum;

                    for( int i = 1; i <= KERNEL_RADIUS; i ++ ) {

                        float sampleWeight = uSampleWeights[i];
                        vec2 sampleUVOffset = uSampleOffsets[i] * vInvSize;

                        vec2 sampleUV = vUV + sampleUVOffset;
                        float viewZ = -getViewZ( getDepth( sampleUV ) );

                        if( abs( viewZ - centerViewZ ) > uDepthCutoff ) {
                            rBreak = true;
                        }

                        if( ! rBreak ) {
                            occlusionSum += unpackRGBAToFloat(texture( uOcclusionTexture, sampleUV )) * sampleWeight;
                            weightSum += sampleWeight;
                        }

                        sampleUV = vUV - sampleUVOffset;
                        viewZ = -getViewZ( getDepth( sampleUV ) );

                        if( abs( viewZ - centerViewZ ) > uDepthCutoff ) {
                            lBreak = true;
                        }

                        if( ! lBreak ) {
                            occlusionSum += unpackRGBAToFloat(texture( uOcclusionTexture, sampleUV )) * sampleWeight;
                            weightSum += sampleWeight;
                        }
                    }

                    outColor = packFloatToRGBA(occlusionSum / weightSum);
                }`
    });
    if (this.#program.errors) {
      console.error(this.#program.errors.join("\n"));
      this.#programError = true;
      return;
    }
    const uv = new Float32Array([1, 1, 0, 1, 0, 0, 1, 0]);
    const positions = new Float32Array([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0]);
    const indices = new Uint32Array([0, 1, 2, 0, 2, 3]);
    this.#positionsBuf = new WebGLArrayBuf(gl, gl.ARRAY_BUFFER, positions, positions.length, 3, gl.STATIC_DRAW);
    this.#uvBuf = new WebGLArrayBuf(gl, gl.ARRAY_BUFFER, uv, uv.length, 2, gl.STATIC_DRAW);
    this.#indicesBuf = new WebGLArrayBuf(gl, gl.ELEMENT_ARRAY_BUFFER, indices, indices.length, 1, gl.STATIC_DRAW);
    this.#program.bind();
    this.#uViewport = this.#program.getLocation("uViewport");
    this.#uCameraNear = this.#program.getLocation("uCameraNear");
    this.#uCameraFar = this.#program.getLocation("uCameraFar");
    this.#uDepthCutoff = this.#program.getLocation("uDepthCutoff");
    this.#uSampleOffsets = gl.getUniformLocation(this.#program.handle, "uSampleOffsets");
    this.#uSampleWeights = gl.getUniformLocation(this.#program.handle, "uSampleWeights");
    this.#aPosition = this.#program.getAttribute("aPosition");
    this.#aUV = this.#program.getAttribute("aUV");
  }
  render(params2) {
    if (this.#programError) {
      return;
    }
    const { view, depthRenderBuffer, occlusionRenderBuffer, direction } = params2;
    const gl = this.#renderContext.gl;
    const program = this.#program;
    const viewportWidth = gl.drawingBufferWidth;
    const viewportHeight = gl.drawingBufferHeight;
    const projection = view.camera.projectionType === PerspectiveProjectionType ? view.camera.perspectiveProjection : view.camera.orthoProjection;
    const near = projection.near;
    const far = projection.far;
    gl.viewport(0, 0, viewportWidth, viewportHeight);
    gl.clearColor(0, 0, 0, 1);
    gl.enable(gl.DEPTH_TEST);
    gl.disable(gl.BLEND);
    gl.frontFace(gl.CCW);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    program.bind();
    tempVec2a2[0] = viewportWidth;
    tempVec2a2[1] = viewportHeight;
    gl.uniform2fv(this.#uViewport, tempVec2a2);
    gl.uniform1f(this.#uCameraNear, near);
    gl.uniform1f(this.#uCameraFar, far);
    gl.uniform1f(this.#uDepthCutoff, blurDepthCutoff);
    if (direction === 0) {
      gl.uniform2fv(this.#uSampleOffsets, sampleOffsetsHor);
    } else {
      gl.uniform2fv(this.#uSampleOffsets, sampleOffsetsVert);
    }
    gl.uniform1fv(this.#uSampleWeights, sampleWeights);
    const depthTexture = depthRenderBuffer.getDepthTexture();
    const saoOcclusionTexture = occlusionRenderBuffer.getTexture();
    program.bindTexture(this.#uDepthTexture, depthTexture, 0);
    program.bindTexture(this.#uOcclusionTexture, saoOcclusionTexture, 1);
    this.#aUV.bindArrayBuffer(this.#uvBuf);
    this.#aPosition.bindArrayBuffer(this.#positionsBuf);
    this.#indicesBuf.bind();
    gl.drawElements(gl.TRIANGLES, this.#indicesBuf.numItems, this.#indicesBuf.itemType, 0);
  }
  destroy() {
    this.#program.destroy();
  }
};
function createSampleWeights(kernelRadius, stdDev) {
  const weights = [];
  for (let i = 0; i <= kernelRadius; i++) {
    weights.push(gaussian(i, stdDev));
  }
  return weights;
}
function gaussian(x, stdDev) {
  return Math.exp(-(x * x) / (2 * (stdDev * stdDev))) / (Math.sqrt(2 * Math.PI) * stdDev);
}
function createSampleOffsets(kernelRadius, uvIncrement) {
  const offsets = [];
  for (let i = 0; i <= kernelRadius; i++) {
    offsets.push(uvIncrement[0] * i);
    offsets.push(uvIncrement[1] * i);
  }
  return offsets;
}

// ../sdk/src/webglrenderer/WebGLRenderer.ts
var WebGLRendererView = class {
  view;
  transparencyEnabled;
  imageDirty;
  viewMatrixDirty;
  canvasTransparent;
  saoEnabled;
  edgesEnabled;
  transparentEnabled;
  pbrEnabled;
  saveCanvasBoundary;
  gl;
  renderBufferManager;
  pickIDs;
  constructor(gl, webglCanvasElement, view) {
    this.gl = gl;
    this.view = view;
    this.transparencyEnabled = true;
    this.imageDirty = true;
    this.viewMatrixDirty = true;
    this.canvasTransparent = false;
    this.pbrEnabled = false;
    this.saoEnabled = false;
    this.edgesEnabled = true;
    this.transparentEnabled = true;
    this.saveCanvasBoundary = view.htmlElement.getBoundingClientRect();
    this.renderBufferManager = new WebGLRenderBufferManager(gl, webglCanvasElement);
    this.pickIDs = new Map2({});
  }
  destroy() {
    this.renderBufferManager.destroy();
  }
};
var tempVec3a8 = createVec3();
var tempVec3b8 = createVec3();
var tempVec3c6 = createVec3();
var tempMat4b3 = createMat4();
var pickTemps = {
  pickCanvasPos: createVec2(),
  pickWorldRayDir: createVec3(),
  pickWorldRayOrigin: createVec3(),
  pickViewMatrix: createMat4(),
  pickProjMatrix: createMat4()
};
var WebGLRenderer = class {
  /**
   * Interfaces through which each {@link viewer!ViewObject | ViewObject} shows/hides/highlights/selects/xrays/colorizes
   * its {@link scene!SceneObject | SceneObject} within the WebGLRenderer that's
   * configured on its {@link viewer!Viewer | Viewer}.
   *
   * @internal
   */
  rendererObjects;
  /**
   * @internal
   */
  renderStats;
  /**
   * @internal
   */
  tileManager;
  #saoOcclusionRenderer;
  #saoDepthLimitedBlurRenderer;
  #pickBufferManager;
  #rendererViews;
  #rendererViewsList;
  #activeRendererView;
  #viewer;
  renderContext;
  #shadersDirty;
  #rendererModels;
  #layerList;
  #layerListDirty;
  #stateSortDirty;
  #pickIDs = new Map2({});
  #extensionHandles;
  #logarithmicDepthBufferEnabled;
  #alphaDepthMask;
  #occlusionTester;
  // #saoOcclusionRenderer: null | SAOOcclusionRenderer;
  // #saoDepthLimitedBlurRenderer: SAODepthLimitedBlurRenderer;
  #textureTranscoder;
  #viewMatrixDirty;
  #snapshotBound;
  #destroyed;
  #onViewCameraMatrix;
  /**
   * @internal
   * @event
   */
  onCompiled;
  /**
   * @internal
   * @event
   */
  onDestroyed;
  #webglCanvasElement;
  #gl;
  #pickResult;
  /**
   * Creates a WebGLRenderer.
   *
   * @param params Configs
   * @param params.textureTranscoder Injects an optional transcoder that will be used internally by {@link rendererModel.createTexture}
   * to convert transcoded texture data. The transcoder is only required when we'll be providing transcoded data
   * to {@link rendererModel.createTexture}. We assume that all transcoded texture data added to a  ````rendererModel````
   * will then be in a format supported by this transcoder.
   */
  constructor(params2) {
    this.renderStats = new RenderStats();
    this.rendererObjects = {};
    this.tileManager = null;
    this.renderContext = null;
    this.#textureTranscoder = params2.textureTranscoder || new KTX2TextureTranscoder({});
    this.#alphaDepthMask = false;
    this.#extensionHandles = {};
    this.#pickIDs = new Map2({});
    this.#layerList = [];
    this.#layerListDirty = true;
    this.#stateSortDirty = true;
    this.#shadersDirty = true;
    this.#occlusionTester = null;
    this.#logarithmicDepthBufferEnabled = false;
    this.#rendererModels = {};
    this.#viewMatrixDirty = true;
    this.#snapshotBound = false;
    this.#destroyed = false;
    this.#rendererViews = {};
    this.#rendererViewsList = [];
    this.#activeRendererView = null;
    this.#pickResult = new PickResult();
    this.onCompiled = new EventEmitter(new import_strongly_typed_events17.EventDispatcher());
    this.onDestroyed = new EventEmitter(new import_strongly_typed_events17.EventDispatcher());
    this.#webglCanvasElement = document.createElement("canvas");
    const webglCanvasElement = this.#webglCanvasElement;
    webglCanvasElement.width = 400;
    webglCanvasElement.height = 400;
    webglCanvasElement.style.position = "absolute";
    webglCanvasElement.style.top = "50px";
    webglCanvasElement.style.left = "50px";
    webglCanvasElement.style.border = "1px solid black";
    webglCanvasElement.style["pointer-events"] = "none";
    webglCanvasElement.style["z-index"] = 1e5;
    document.body.appendChild(webglCanvasElement);
    const contextAttr = {
      alpha: true,
      preserveDrawingBuffer: true,
      stencil: false,
      premultipliedAlpha: false,
      antialias: true
    };
    this.#gl = webglCanvasElement.getContext("webgl2", contextAttr);
    if (!this.#gl) {
      throw new SDKError(`Failed to get a WebGL2 context`);
    }
    this.#gl.hint(this.#gl.FRAGMENT_SHADER_DERIVATIVE_HINT, this.#gl.NICEST);
    this.#pickBufferManager = new WebGLRenderBufferManager(this.#gl, webglCanvasElement);
  }
  /**
   * The Viewer this WebGLRenderer is currently attached to, if any.
   */
  get viewer() {
    return this.#viewer;
  }
  /**
   * Gets the TextureTranscoder this WebGLRenderer was configured with, if any.
   *
   * @internal
   */
  get textureTranscoder() {
    return this.#textureTranscoder;
  }
  /**
   * Gets the capabilities of this WebGLRenderer.
   *
   * @param capabilities Returns the capabilities of this WebGLRenderer.
   * @internal
   */
  getCapabilities(capabilities) {
    capabilities.maxViews = 4;
    const htmlElement = document.createElement("canvas");
    let gl;
    try {
      gl = htmlElement.getContext("webgl2");
    } catch (e) {
      console.error("Failed to get a WebGL context");
    }
    if (gl) {
      capabilities.astcSupported = !!getWebGLExtension(gl, "WEBGL_compressed_texture_astc");
      capabilities.etc1Supported = true;
      capabilities.etc2Supported = !!getWebGLExtension(gl, "WEBGL_compressed_texture_etc");
      capabilities.dxtSupported = !!getWebGLExtension(gl, "WEBGL_compressed_texture_s3tc");
      capabilities.bptcSupported = !!getWebGLExtension(gl, "EXT_texture_compression_bptc");
      capabilities.pvrtcSupported = !!(getWebGLExtension(gl, "WEBGL_compressed_texture_pvrtc") || getWebGLExtension(gl, "WEBKIT_WEBGL_compressed_texture_pvrtc"));
    }
  }
  /**
   * Initializes this WebGLRenderer by attaching a {@link viewer!Viewer | Viewer}.
   *
   * @internal
   * @param viewer Viewer to attach.
   * @returns *void*
   * * Viewer successfully attached.
   * @returns *{@link core!SDKError | SDKError}*
   * * A Viewer is already attached to this Renderer.
   * * The given Viewer is already attached to another Renderer.
   */
  attachViewer(viewer) {
    if (this.#viewer) {
      throw new SDKError("Can't attach Viewer to WebGLRenderer - a Viewer is already attached");
    }
    if (viewer.renderer) {
      throw new SDKError("Can't attach Viewer to WebGLRenderer - given Viewer is already attached to another Renderer");
    }
    this.#viewer = viewer;
    this.#textureTranscoder.init(this.#viewer.capabilities);
    this.renderContext = new RenderContext(this.#viewer, this.#gl, this);
    this.#saoOcclusionRenderer = new SAOOcclusionRenderer({
      renderContext: this.renderContext
    });
    this.#saoDepthLimitedBlurRenderer = new SAODepthLimitedBlurRenderer({
      renderContext: this.renderContext
    });
  }
  /**
   * Detaches the {@link viewer!Viewer | Viewer} that is currently attached, if any.
   *
   * @internal
   * @returns *void*
   * * Viewer successfully detached.
   * @returns *{@link core!SDKError | SDKError}*
   * * No Viewer is currently attached to this WebGLRenderer.
   */
  detachViewer() {
    if (this.#viewer) {
      return new SDKError("Can't detach Viewer from WebGLRenderer - no Viewer is currently attached");
    }
    for (let id in this.#rendererModels) {
      const rendererModel = this.#rendererModels[id];
      this.#detachRendererObjects(rendererModel);
      rendererModel.destroy();
      delete this.#rendererModels[id];
    }
    this.#viewer = null;
    this.#rendererViews = {};
    this.renderContext = null;
    this.#layerList = [];
    this.rendererObjects = {};
    this.tileManager = null;
  }
  /**
   * Attaches a {@link viewer!View} to this WebGLRenderer.
   *
   * The WebGLRenderer will then begin rendering each {@link scene!SceneModel | SceneModel} previously or subsequently
   * created with {@link scene!Scene.createModel | Scene.createModel}, for the new View.
   *
   * You can only attach as many Views as indicated in {@link  core!Capabilities.maxViews | Capabilities.maxViews}, as returned by
   * {@link WebGLRenderer.getCapabilities | WebGLRenderer.getCapabilities}.
   *
   * @internal
   * @param view The View to attach.
   * @returns *void*
   * * View successfully attached.
   * @returns *{@link core!SDKError | SDKError}*
   * * No Viewer is attached to this WebGLRenderer.
   * * Caller attempted to attach too many Views.
   * * The WebGLRenderer failed to get a WebGL2 context on the View's canvas.
   */
  attachView(view) {
    if (!this.#viewer) {
      throw new SDKError("Can't attach View to WebGLRenderer - no Viewer is attached");
    }
    if (this.#rendererViews[view.id]) {
      return new SDKError("Can't attach additional View to WebGLRenderer - View already attached (see WebViewerCapabilities.maxViews)");
    }
    view.camera.onViewMatrix.subscribe(this.#onViewCameraMatrix = () => {
      this.#viewMatrixDirty = true;
    });
    const rendererView = new WebGLRendererView(this.renderContext.gl, this.#webglCanvasElement, view);
    this.#rendererViews[view.id] = rendererView;
    view.viewIndex = this.#rendererViewsList.length;
    this.#rendererViewsList.push(rendererView);
  }
  // #updateViewIndices() {
  //     this.#rendererViewsList = [];
  //     for (let viewIndex = 0, len = this.#viewer.viewList.length; viewIndex < len; viewIndex++) {
  //         const view = this.#viewer.viewList[viewIndex];
  //         view.viewIndex = viewIndex;
  //         this.#rendererViewsList[viewIndex] = this.#rendererViews[view.id];
  //     }
  // }
  /**
   * Detaches the given {@link viewer!View} from this Renderer.
   *
   * The Renderer will then cease rendering for that View.
   *
   * @internal
   * @param view The View to detach.
   * @returns *void*
   * * View successfully detached.
   * @returns *{@link core!SDKError | SDKError}*
   * * No Viewer is attached to this WebGLRenderer.
   * * View is not currently attached to this WebGLRenderer.
   */
  detachView(view) {
    if (!this.#viewer) {
      throw new SDKError("Can't detach View from WebGLRenderer - no Viewer is attached");
    }
    const rendererView = this.#rendererViews[view.id];
    if (!rendererView) {
      return new SDKError("Can't detach View to WebGLRenderer - given View is not attached");
    }
    rendererView.destroy();
    delete this.#rendererViews[view.id];
    view.camera.onViewMatrix.unsubscribe(this.#onViewCameraMatrix);
    view.viewIndex = 0;
    this.#onViewCameraMatrix = null;
    for (let id in this.#rendererModels) {
      const rendererModel = this.#rendererModels[id];
      this.#detachRendererObjects(rendererModel);
      rendererModel.destroy();
      delete this.#rendererModels[id];
    }
    this.renderContext = null;
    this.#layerList = [];
    this.rendererObjects = {};
    this.tileManager = null;
  }
  /**
   * Attaches a {@link scene!SceneModel | SceneModel} to this WebGLRenderer.
   *
   * This method attaches various hooks to the elements within the SceneModel, through which they can
   * upload state updates to the Renderer.
   *
   * * Sets a {@link scene!RendererModel} on {@link scene!SceneModel.rendererModel | SceneModel.rendererModel}
   * * Sets a {@link scene!RendererObject} on each {@link scene!SceneObject.rendererObject | SceneObject.rendererObject}
   * * Sets a {@link scene!RendererMesh} on each {@link scene!SceneMesh.rendererMesh | SceneMesh.rendererMesh}
   * * Sets a {@link scene!RendererTextureSet} on each {@link scene!SceneTextureSet.rendererTextureSet | SceneTextureSet.rendererTextureSet}
   * * Sets a {@link scene!RendererTexture} on each {@link scene!SceneTexture.rendererTexture | SceneTexture.rendererTexture}
   *
   * Then, when we make any state updates to those components, they will upload the updates into the Renderer.
   *
   * You must first attach a View with {@link webglrenderer!WebGLRenderer.attachView | Renderer.attachView} before you can attach a SceneModel.
   *
   * @param sceneModel
   * @internal
   * @returns *void*
   * * SceneModel successfully attached.
   * @returns *{@link core!SDKError | SDKError}*
   * * No View is currently attached to this WebGLRenderer.
   * * SceneModel already attached to this WebGLRenderer, or to another Renderer.
   */
  attachSceneModel(sceneModel) {
    if (!this.#viewer) {
      return new SDKError("Can't attach SceneModel to WebGLRenderer - no Viewer is attached");
    }
    if (this.#rendererViewsList.length === 0) {
      return new SDKError("Can't attach SceneModel to WebGLRenderer - no View is attached");
    }
    const rendererModel = new WebGLRendererModel({
      id: sceneModel.id,
      sceneModel,
      viewer: this.viewer,
      textureTranscoder: this.#textureTranscoder,
      webglRenderer: this,
      renderContext: this.renderContext
    });
    this.#rendererModels[rendererModel.id] = rendererModel;
    this.#attachRendererObjects(rendererModel);
    this.#layerListDirty = true;
    sceneModel.rendererModel = rendererModel;
  }
  #attachRendererObjects(rendererModel) {
    const rendererObjects = rendererModel.rendererObjects;
    for (let id in rendererObjects) {
      this.rendererObjects[id] = rendererObjects[id];
    }
  }
  /**
   * Detaches a {@link scene!SceneModel | SceneModel} from this WebGLRenderer.
   *
   * Detaches and destroys the {@link scene!RendererModel}, {@link scene!RendererObject} and
   * {@link scene!RendererMesh},
   * {@link scene!RendererTexture} instances that were attached in {@link webglrenderer!WebGLRenderer.attachSceneModel}.
   *
   * @internal
   * @returns *void*
   * * SceneModel successfully detached.
   * @returns *{@link core!SDKError | SDKError}*
   * * No View is currently attached to this WebGLRenderer.
   * * SceneModel is not attached to this WebGLRenderer.
   */
  detachSceneModel(sceneModel) {
    if (!this.#viewer) {
      throw new SDKError("Can't detach SceneModel from WebGLRenderer - no Viewer is attached");
    }
    if (this.#rendererViewsList.length === 0) {
      throw new SDKError("Can't detach SceneModel to WebGLRenderer - no View is attached");
    }
    if (this.#rendererModels[sceneModel.id] == void 0) {
      return new SDKError(`Can't detach SceneModel from WebGLRenderer - no SceneModel with this ID ("${sceneModel.id}") has been attached to this WebGLRenderer`);
    }
    this.#detachSceneModel(sceneModel);
  }
  #detachSceneModel(sceneModel) {
    if (this.#rendererModels[sceneModel.id]) {
      const rendererModel = this.#rendererModels[sceneModel.id];
      this.#detachRendererObjects(rendererModel);
      rendererModel.destroy();
      delete this.#rendererModels[sceneModel.id];
      this.#layerListDirty = true;
      sceneModel.rendererModel = null;
    }
  }
  #detachRendererObjects(rendererModel) {
    const rendererObjects = rendererModel.rendererObjects;
    for (let id in rendererObjects) {
      delete this.rendererObjects[id];
    }
  }
  /**
   * @private
   */
  attachPickable(pickable) {
    return this.#pickIDs.addItem(pickable);
  }
  /**
   * @private
   */
  detachPickable(pickId) {
    this.#pickIDs.removeItem(pickId);
  }
  /**
   * Indicates that the WebGLRenderer needs to draw a new frame.
   * @internal
   */
  setImageDirty(viewIndex) {
    const rendererView = this.#rendererViewsList[viewIndex];
    if (rendererView) {
      rendererView.imageDirty = true;
    }
  }
  /**
   * Sets whether the WebGLRenderer draws edges.
   * Triggers a new frame render.
   * @internal
   */
  setEdgesEnabled(viewIndex, enabled2) {
    const rendererView = this.#rendererViewsList[viewIndex];
    if (rendererView) {
      rendererView.edgesEnabled = enabled2;
      rendererView.imageDirty = true;
    }
  }
  /**
   * Sets whether the WebGLRenderer draws with physically-based rendering.
   * Triggers a new frame render.
   * @internal
   */
  setPBREnabled(viewIndex, enabled2) {
    const rendererView = this.#rendererViewsList[viewIndex];
    if (rendererView) {
      rendererView.pbrEnabled = enabled2;
      rendererView.imageDirty = true;
    }
  }
  getSAOSupported() {
    return true;
  }
  /**
   * Sets whether the WebGLRenderer draws with SAO.
   * Triggers a new frame render.
   * @internal
   */
  setSAOEnabled(viewIndex, enabled2) {
    const rendererView = this.#rendererViewsList[viewIndex];
    if (rendererView) {
      rendererView.saoEnabled = enabled2;
      rendererView.imageDirty = true;
    }
  }
  /**
   * Enable/disable rendering of transparent objects for the given View.
   *
   * @param viewIndex Handle to the View, returned earlier by {@link webglrenderer!WebGLRenderer.attachView | Renderer.attachView}.
   * @param enabled Whether to enable or disable transparent objects for the View.
   * @internal
   * @returns *void*
   * * Success.
   * @returns *{@link core!SDKError | SDKError}*
   * * No View is currently attached to this Renderer.
   * * Can't find a View attached to this Renderer with the given handle.
   */
  setTransparentEnabled(viewIndex, enabled2) {
    const rendererView = this.#rendererViewsList[viewIndex];
    if (rendererView) {
      rendererView.transparentEnabled = enabled2;
      rendererView.imageDirty = true;
    }
  }
  /**
   * Clears this WebGLRenderer for the given view.
   *
   * @internal
   * @param viewIndex Handle to the View, returned earlier by {@link webglrenderer!WebGLRenderer.attachView | Renderer.attachView}.
   * @returns *void*
   * * Success.
   * @returns *{@link core!SDKError | SDKError}*
   * * No View is currently attached to this WebGLRenderer.
   * * Can't find a View attached to this WebGLRenderer with the given handle.
   */
  clear(viewIndex) {
    if (!this.#viewer) {
      return new SDKError("Can't clear canvas with WebGLRenderer - no Viewer and View is attached");
    }
    const rendererView = this.#rendererViewsList[viewIndex];
    if (!rendererView) {
      return new SDKError(`Can't clear canvas with WebGLRenderer - no View attached at given viewIndex: ${viewIndex}`);
    }
    const gl = this.renderContext.gl;
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    if (rendererView.canvasTransparent) {
      gl.clearColor(0, 0, 0, 0);
    } else {
      gl.clearColor(rendererView.view.backgroundColor[0], rendererView.view.backgroundColor[1], rendererView.view.backgroundColor[2], 1);
    }
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  }
  /**
   * Triggers a rebuild of the shaders within this WebGLRenderer for the given View.
   * @internal
   * @param viewIndex Handle to the View, returned earlier by {@link webglrenderer!WebGLRenderer.attachView | Renderer.attachView}.
   * @returns *void*
   * * Success.
   * @returns *{@link core!SDKError | SDKError}*
   * * No View is currently attached to this WebGLRenderer.
   * * Can't find a View attached to this WebGLRenderer with the given handle.
   */
  setNeedsRebuild(viewIndex) {
    this.#shadersDirty = true;
  }
  /**
   * Gets if a new frame needs to be rendered for the given View.
   * @internal
   * @param viewIndex Handle to the View, returned earlier by {@link webglrenderer!WebGLRenderer.attachView | Renderer.attachView}.
   * @returns *boolean*
   * * True if a new frame needs to be rendered for the View.
   * @returns *{@link core!SDKError | SDKError}*
   * * No View is currently attached to this WebGLRenderer.
   * * Can't find a View attached to this WebGLRenderer with the given handle.
   */
  getNeedsRender(viewIndex) {
    const rendererView = this.#rendererViewsList[viewIndex];
    if (!rendererView) {
      return false;
    }
    return rendererView.imageDirty || this.#layerListDirty || this.#stateSortDirty;
  }
  /**
   * Renders a frame for a View.
   *
   * @internal
   * @param viewIndex Handle to the View.
   * @param [params.force=false] True to force a render, else only render if needed.
   * @returns *{@link core!SDKError | SDKError}*
   * * No View is currently attached to this Renderer.
   * * Can't find a View attached to this Renderer with the given handle.
   */
  render(viewIndex, params2) {
    if (!this.#viewer) {
      return new SDKError("Can't render with WebGLRenderer - no Viewer and View is attached");
    }
    const rendererView = this.#rendererViewsList[viewIndex];
    if (!rendererView) {
      return new SDKError(`Can't render with WebGLRenderer - no View attached at given viewIndex: ${viewIndex}`);
    }
    this.renderStats.reset();
    if (this.#shadersDirty) {
      this.onCompiled.dispatch(this, true);
      this.#shadersDirty = false;
    }
    if (params2.force) {
      rendererView.imageDirty = true;
    }
    this.#updateLayerList();
    if (rendererView.imageDirty) {
      this.#activateView(viewIndex);
      this.#draw({
        viewIndex,
        clear: true
      });
      rendererView.imageDirty = false;
    }
  }
  #activateView(viewIndex) {
    const targetRendererView = this.#rendererViewsList[viewIndex];
    if (!targetRendererView) {
      throw new SDKError(`Can't activate View - no such target View attached: ${viewIndex}`);
    }
    const activeRendererView = this.#activeRendererView;
    if (activeRendererView) {
      const activeCanvasBoundingRect = activeRendererView.view.htmlElement.getBoundingClientRect();
      const primarySnapshotBuffer = activeRendererView.renderBufferManager.getRenderBuffer("snapshot", {
        depthTexture: false,
        size: [activeCanvasBoundingRect.width, activeCanvasBoundingRect.height]
      });
      primarySnapshotBuffer.bind();
      primarySnapshotBuffer.clear();
      this.#draw({
        viewIndex: activeRendererView.view.viewIndex,
        clear: true
      });
      const image = primarySnapshotBuffer.readImage({
        format: "png",
        height: activeCanvasBoundingRect.height,
        width: activeCanvasBoundingRect.width
      });
      primarySnapshotBuffer.unbind();
      activeRendererView.view.htmlElement.src = image;
    }
    const webglCanvasElement = this.#webglCanvasElement;
    const targetView = targetRendererView.view;
    const targetCanvasElement = targetView.htmlElement;
    const targetCanvasBoundingRect = targetCanvasElement.getBoundingClientRect();
    webglCanvasElement.style["left"] = `${targetCanvasBoundingRect.left}px`;
    webglCanvasElement.style["top"] = `${targetCanvasBoundingRect.top}px`;
    webglCanvasElement.style["width"] = `${targetCanvasBoundingRect.width}px`;
    webglCanvasElement.style["height"] = `${targetCanvasBoundingRect.height}px`;
    webglCanvasElement.width = targetCanvasBoundingRect.width;
    webglCanvasElement.height = targetCanvasBoundingRect.height;
    webglCanvasElement.style["z-index"] = 1e5;
    this.#activeRendererView = targetRendererView;
  }
  #updateLayerList() {
    if (this.#layerListDirty) {
      this.#buildLayerList();
      this.#layerListDirty = false;
      this.#stateSortDirty = true;
    }
    if (this.#stateSortDirty) {
      this.#sortLayerList();
      this.#stateSortDirty = false;
      for (let viewIndex = 0, len = this.#rendererViewsList.length; viewIndex < len; viewIndex++) {
        const rendererView = this.#rendererViewsList[viewIndex];
        rendererView.imageDirty = true;
      }
    }
  }
  #buildLayerList() {
    let lenLayerList = 0;
    for (let id in this.#rendererModels) {
      const rendererModel = this.#rendererModels[id];
      for (let i = 0, len = rendererModel.layerList.length; i < len; i++) {
        this.#layerList[lenLayerList++] = rendererModel.layerList[i];
      }
    }
    this.#layerList.length = lenLayerList;
  }
  #sortLayerList() {
    this.#layerList.sort((layer1, layer2) => {
      if (layer1.sortId < layer2.sortId) {
        return -1;
      }
      if (layer1.sortId > layer2.sortId) {
        return 1;
      }
      return 0;
    });
  }
  #draw(params2) {
    const rendererView = this.#rendererViewsList[params2.viewIndex];
    if (!rendererView) {
      return;
    }
    this.#activateExtensions();
    if (rendererView.view.sao.applied) {
    }
    this.#drawColor(params2);
  }
  #activateExtensions() {
    if (WEBGL_INFO.SUPPORTED_EXTENSIONS["OES_element_index_uint"]) {
      this.#extensionHandles.OES_element_index_uint = this.renderContext.gl.getExtension("OES_element_index_uint");
    }
    if (this.#logarithmicDepthBufferEnabled && WEBGL_INFO.SUPPORTED_EXTENSIONS["EXT_frag_depth"]) {
      this.#extensionHandles.EXT_frag_depth = this.renderContext.gl.getExtension("EXT_frag_depth");
    }
    if (WEBGL_INFO.SUPPORTED_EXTENSIONS["WEBGL_depth_texture"]) {
      this.#extensionHandles.WEBGL_depth_texture = this.renderContext.gl.getExtension("WEBGL_depth_texture");
    }
  }
  #drawSAOBuffers(params2) {
    const viewIndex = params2.viewIndex;
    const rendererView = this.#rendererViewsList[viewIndex];
    const view = rendererView.view;
    const sao = view.sao;
    const depthRenderBuffer = rendererView.renderBufferManager.getRenderBuffer("saoDepth", {
      depthTexture: WEBGL_INFO.SUPPORTED_EXTENSIONS["WEBGL_depth_texture"]
    });
    depthRenderBuffer.bind();
    depthRenderBuffer.clear();
    this.#drawDepth(params2);
    depthRenderBuffer.unbind();
    const occlusionRenderBuffer1 = rendererView.renderBufferManager.getRenderBuffer("saoOcclusion");
    occlusionRenderBuffer1.bind();
    occlusionRenderBuffer1.clear();
    this.#saoOcclusionRenderer.render({
      view,
      depthRenderBuffer
    });
    occlusionRenderBuffer1.unbind();
    if (sao.blur) {
      const occlusionRenderBuffer2 = rendererView.renderBufferManager.getRenderBuffer("saoOcclusion2");
      occlusionRenderBuffer2.bind();
      occlusionRenderBuffer2.clear();
      this.#saoDepthLimitedBlurRenderer.render({
        view,
        depthRenderBuffer,
        occlusionRenderBuffer: occlusionRenderBuffer1,
        direction: 0
      });
      occlusionRenderBuffer2.unbind();
      occlusionRenderBuffer1.bind();
      occlusionRenderBuffer1.clear();
      this.#saoDepthLimitedBlurRenderer.render({
        view,
        depthRenderBuffer,
        occlusionRenderBuffer: occlusionRenderBuffer2,
        direction: 1
      });
      occlusionRenderBuffer1.unbind();
    }
  }
  #drawDepth(params2) {
    const viewIndex = params2.viewIndex;
    const rendererView = this.#rendererViewsList[viewIndex];
    const view = rendererView.view;
    const renderContext = this.renderContext;
    const gl = renderContext.gl;
    renderContext.reset();
    renderContext.view = view;
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.clearColor(0, 0, 0, 0);
    gl.enable(gl.DEPTH_TEST);
    gl.frontFace(gl.CCW);
    gl.enable(gl.CULL_FACE);
    gl.depthMask(true);
    if (params2.clear !== false) {
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    }
    for (let i = 0, len = this.#layerList.length; i < len; i++) {
      const layer = this.#layerList[i];
      const meshCounts = layer.meshCounts[viewIndex];
      if (meshCounts.numTransparent < meshCounts.numMeshes) {
        layer.drawDepth();
      }
    }
  }
  #drawColor(params2) {
    const viewIndex = params2.viewIndex;
    const rendererView = this.#rendererViewsList[viewIndex];
    const view = rendererView.view;
    const renderContext = this.renderContext;
    const gl = renderContext.gl;
    const normalDrawSAOBin = [];
    const edgesColorOpaqueBin = [];
    const normalFillTransparentBin = [];
    const edgesColorTransparentBin = [];
    const xrayedSilhouetteOpaqueBin = [];
    const xrayEdgesOpaqueBin = [];
    const xrayedSilhouetteTransparentBin = [];
    const xrayEdgesTransparentBin = [];
    const highlightedSilhouetteOpaqueBin = [];
    const highlightedEdgesOpaqueBin = [];
    const highlightedSilhouetteTransparentBin = [];
    const highlightedEdgesTransparentBin = [];
    const selectedSilhouetteOpaqueBin = [];
    const selectedEdgesOpaqueBin = [];
    const selectedSilhouetteTransparentBin = [];
    const selectedEdgesTransparentBin = [];
    renderContext.reset();
    renderContext.view = view;
    renderContext.pbrEnabled = rendererView.pbrEnabled;
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    if (rendererView.canvasTransparent) {
      gl.clearColor(0, 0, 0, 0);
    } else {
      gl.clearColor(rendererView.view.backgroundColor[0], rendererView.view.backgroundColor[1], rendererView.view.backgroundColor[2], 1);
    }
    gl.enable(gl.DEPTH_TEST);
    gl.frontFace(gl.CCW);
    gl.enable(gl.CULL_FACE);
    gl.depthMask(true);
    gl.lineWidth(1);
    renderContext.lineWidth = 1;
    const drawWithSAO = rendererView.saoEnabled && view.sao.possible;
    if (drawWithSAO) {
      const saoOcclusionRenderBuffer = rendererView.renderBufferManager.getRenderBuffer("saoOcclusion");
      renderContext.saoOcclusionTexture = saoOcclusionRenderBuffer ? saoOcclusionRenderBuffer.getTexture() : null;
    } else {
      renderContext.saoOcclusionTexture = null;
    }
    if (params2.clear !== false) {
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    }
    for (let i = 0, len = this.#layerList.length; i < len; i++) {
      const layer = this.#layerList[i];
      const meshCounts = layer.meshCounts[viewIndex];
      if (meshCounts.numCulled === meshCounts.numMeshes || meshCounts.numVisible === 0) {
        continue;
      }
      if (meshCounts.numTransparent < meshCounts.numMeshes) {
        if (drawWithSAO && layer.saoSupported) {
          normalDrawSAOBin.push(layer);
        } else {
          layer.drawColorOpaque();
        }
      }
      if (rendererView.transparentEnabled) {
        if (meshCounts.numTransparent > 0) {
          normalFillTransparentBin.push(layer);
        }
      }
      if (meshCounts.numXRayed > 0) {
        if (view.xrayMaterial.fill) {
          if (view.xrayMaterial.fillAlpha < 1) {
            xrayedSilhouetteTransparentBin.push(layer);
          } else {
            xrayedSilhouetteOpaqueBin.push(layer);
          }
        }
      }
      if (meshCounts.numHighlighted > 0) {
        if (view.highlightMaterial.fill) {
          if (view.highlightMaterial.fillAlpha < 1) {
            highlightedSilhouetteTransparentBin.push(layer);
          } else {
            highlightedSilhouetteOpaqueBin.push(layer);
          }
        }
      }
      if (meshCounts.numSelected > 0) {
        if (view.selectedMaterial.fill) {
          if (view.selectedMaterial.fillAlpha < 1) {
            selectedSilhouetteTransparentBin.push(layer);
          } else {
            selectedSilhouetteOpaqueBin.push(layer);
          }
        }
      }
      if (rendererView.edgesEnabled && view.edges.applied) {
        if (meshCounts.numTransparent < meshCounts.numMeshes) {
          edgesColorOpaqueBin.push(layer);
        }
        if (meshCounts.numTransparent > 0) {
          edgesColorTransparentBin.push(layer);
        }
        if (view.selectedMaterial.edgeAlpha < 1) {
          selectedEdgesTransparentBin.push(layer);
        } else {
          selectedEdgesOpaqueBin.push(layer);
        }
        if (meshCounts.numXRayed > 0) {
          if (view.xrayMaterial.edgeAlpha < 1) {
            xrayEdgesTransparentBin.push(layer);
          } else {
            xrayEdgesOpaqueBin.push(layer);
          }
        }
        if (view.highlightMaterial.edgeAlpha < 1) {
          highlightedEdgesTransparentBin.push(layer);
        } else {
          highlightedEdgesOpaqueBin.push(layer);
        }
      }
    }
    if (normalDrawSAOBin.length > 0) {
      for (let i = 0; i < normalDrawSAOBin.length; i++) {
        normalDrawSAOBin[i].drawColorSAOOpaque();
      }
    }
    for (let i = 0; i < edgesColorOpaqueBin.length; i++) {
      edgesColorOpaqueBin[i].drawEdgesColorOpaque();
    }
    for (let i = 0; i < xrayedSilhouetteOpaqueBin.length; i++) {
      xrayedSilhouetteOpaqueBin[i].drawSilhouetteXRayed();
    }
    for (let i = 0; i < xrayEdgesOpaqueBin.length; i++) {
      xrayEdgesOpaqueBin[i].drawEdgesXRayed();
    }
    if (xrayedSilhouetteTransparentBin.length > 0 || xrayEdgesTransparentBin.length > 0 || normalFillTransparentBin.length > 0 || edgesColorTransparentBin.length > 0) {
      gl.enable(gl.CULL_FACE);
      gl.enable(gl.BLEND);
      if (rendererView.canvasTransparent) {
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      } else {
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      }
      renderContext.backfaces = false;
      if (!this.#alphaDepthMask) {
        gl.depthMask(false);
      }
      for (let i = 0; i < xrayEdgesTransparentBin.length; i++) {
        xrayEdgesTransparentBin[i].drawEdgesXRayed();
      }
      for (let i = 0; i < xrayedSilhouetteTransparentBin.length; i++) {
        xrayedSilhouetteTransparentBin[i].drawSilhouetteXRayed();
      }
      if (normalFillTransparentBin.length > 0 || edgesColorTransparentBin.length > 0) {
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      }
      for (let i = 0; i < edgesColorTransparentBin.length; i++) {
        edgesColorTransparentBin[i].drawEdgesColorTranslucent();
      }
      for (let i = 0; i < normalFillTransparentBin.length; i++) {
        normalFillTransparentBin[i].drawColorTranslucent();
      }
      gl.disable(gl.BLEND);
      if (!this.#alphaDepthMask) {
        gl.depthMask(true);
      }
    }
    if (highlightedSilhouetteOpaqueBin.length > 0 || highlightedEdgesOpaqueBin.length > 0) {
      renderContext.lastProgramId = -1;
      gl.clear(gl.DEPTH_BUFFER_BIT);
      for (let i = 0; i < highlightedEdgesOpaqueBin.length; i++) {
        highlightedEdgesOpaqueBin[i].drawEdgesHighlighted();
      }
      for (let i = 0; i < highlightedSilhouetteOpaqueBin.length; i++) {
        highlightedSilhouetteOpaqueBin[i].drawSilhouetteHighlighted();
      }
    }
    if (highlightedSilhouetteTransparentBin.length > 0 || highlightedEdgesTransparentBin.length > 0 || highlightedSilhouetteOpaqueBin.length > 0) {
      renderContext.lastProgramId = -1;
      gl.clear(gl.DEPTH_BUFFER_BIT);
      gl.enable(gl.CULL_FACE);
      gl.enable(gl.BLEND);
      if (rendererView.canvasTransparent) {
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      } else {
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      }
      for (let i = 0; i < highlightedEdgesTransparentBin.length; i++) {
        highlightedEdgesTransparentBin[i].drawEdgesHighlighted();
      }
      for (let i = 0; i < highlightedSilhouetteTransparentBin.length; i++) {
        highlightedSilhouetteTransparentBin[i].drawSilhouetteHighlighted();
      }
      gl.disable(gl.BLEND);
    }
    if (selectedSilhouetteOpaqueBin.length > 0 || selectedEdgesOpaqueBin.length > 0) {
      renderContext.lastProgramId = -1;
      gl.clear(gl.DEPTH_BUFFER_BIT);
      for (let i = 0; i < selectedEdgesOpaqueBin.length; i++) {
        selectedEdgesOpaqueBin[i].drawEdgesSelected();
      }
      for (let i = 0; i < selectedSilhouetteOpaqueBin.length; i++) {
        selectedSilhouetteOpaqueBin[i].drawSilhouetteSelected();
      }
    }
    if (selectedSilhouetteTransparentBin.length > 0 || selectedEdgesTransparentBin.length > 0) {
      renderContext.lastProgramId = -1;
      gl.clear(gl.DEPTH_BUFFER_BIT);
      gl.enable(gl.CULL_FACE);
      gl.enable(gl.BLEND);
      if (rendererView.canvasTransparent) {
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      } else {
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      }
      for (let i = 0; i < selectedEdgesTransparentBin.length; i++) {
        selectedEdgesTransparentBin[i].drawEdgesSelected();
      }
      for (let i = 0; i < selectedSilhouetteTransparentBin.length; i++) {
        selectedSilhouetteTransparentBin[i].drawSilhouetteSelected();
      }
      gl.disable(gl.BLEND);
    }
    const numTextureUnits = WEBGL_INFO.MAX_TEXTURE_UNITS;
    for (let ii = 0; ii < numTextureUnits; ii++) {
      gl.activeTexture(gl.TEXTURE0 + ii);
    }
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
    gl.bindTexture(gl.TEXTURE_2D, null);
    const numVertexAttribs = WEBGL_INFO.MAX_VERTEX_ATTRIBS;
    for (let ii = 0; ii < numVertexAttribs; ii++) {
      gl.disableVertexAttribArray(ii);
    }
  }
  /**
   * TODO
   * @internal
   */
  pick(viewIndex, pickParams, pickResult = this.#pickResult) {
    if (!this.#viewer) {
      throw new SDKError("Can't pick object with WebGLRenderer - no Viewer and View is attached");
    }
    const targetRendererView = this.#rendererViewsList[viewIndex];
    if (!targetRendererView) {
      throw new SDKError(`Can't pick object with WebGLRenderer - no View attached at given viewInded: ${viewIndex}`);
    }
    const view = targetRendererView.view;
    if (this.#shadersDirty) {
      this.onCompiled.dispatch(this, true);
      this.#shadersDirty = false;
    }
    this.#updateLayerList();
    pickResult.reset();
    const {
      pickCanvasPos,
      pickViewMatrix,
      pickProjMatrix,
      pickWorldRayOrigin,
      pickWorldRayDir
    } = pickTemps;
    if (pickParams.canvasPos) {
      pickCanvasPos.set(pickParams.canvasPos);
      pickViewMatrix.set(view.camera.viewMatrix);
      pickProjMatrix.set(view.camera.projMatrix);
      pickResult.canvasPos = pickParams.canvasPos;
    } else {
      if (pickParams.rayMatrix) {
        pickViewMatrix.set(params.rayMatrix);
        pickProjMatrix.set(view.camera.projMatrix);
      } else {
        pickWorldRayOrigin.set(pickParams.rayOrigin || [0, 0, 0]);
        pickWorldRayDir.set(pickParams.rayDirection || [0, 0, 1]);
        const look = addVec3(pickWorldRayOrigin, pickWorldRayDir, tempVec3a8);
        tempVec3b8[0] = Math.random();
        tempVec3b8[1] = Math.random();
        tempVec3b8[2] = Math.random();
        normalizeVec3(tempVec3b8);
        cross3Vec3(pickWorldRayDir, tempVec3b8, tempVec3c6);
        pickViewMatrix.set(lookAtMat4v(pickWorldRayOrigin, look, tempVec3c6, tempMat4b3));
        pickProjMatrix.set(view.camera.orthoProjection.projMatrix);
        pickResult.origin = pickWorldRayOrigin;
        pickResult.direction = pickWorldRayDir;
      }
      pickCanvasPos[0] = targetRendererView.view.htmlElement.clientWidth * 0.5;
      pickCanvasPos[1] = targetRendererView.view.htmlElement.clientHeight * 0.5;
    }
    if (pickParams.pickViewObject) {
      const rendererMesh = this.#pickMesh(viewIndex, targetRendererView, {
        pickCanvasPos,
        pickViewMatrix,
        pickProjMatrix,
        pickInvisible: !!pickParams.pickInvisible
      });
      if (rendererMesh) {
        const rendererObject = rendererMesh.rendererObject;
        const view2 = targetRendererView.view;
        const viewObject = view2.objects[rendererObject.id];
        pickResult.viewObject = viewObject;
      }
    }
    return pickResult;
  }
  #pickMesh(viewIndex, targetRendererView, params2) {
    const gl = this.#gl;
    const view = targetRendererView.view;
    const targetCanvasBoundingRect = targetRendererView.view.htmlElement.getBoundingClientRect();
    const pickProjMatrix = params2.pickProjMatrix;
    const pickViewMatrix = params2.pickViewMatrix;
    const resolutionScale = view.resolutionScale;
    const renderContext = this.renderContext;
    const pickBuffer = this.#pickBufferManager.getRenderBuffer("pickMesh", {
      depthTexture: false,
      size: [1, 1]
    });
    pickBuffer.bind();
    pickBuffer.clear();
    renderContext.reset();
    renderContext.backfaces = true;
    renderContext.frontface = true;
    renderContext.pickViewMatrix = pickViewMatrix;
    renderContext.pickProjMatrix = pickProjMatrix;
    renderContext.pickInvisible = !!params2.pickInvisible;
    renderContext.pickClipPos = [
      this.#getClipPosX(params2.pickCanvasPos[0] * resolutionScale.resolutionScale, gl.drawingBufferWidth),
      this.#getClipPosY(params2.pickCanvasPos[1] * resolutionScale.resolutionScale, gl.drawingBufferHeight)
    ];
    gl.viewport(0, 0, 1, 1);
    gl.depthMask(true);
    gl.enable(gl.DEPTH_TEST);
    gl.disable(gl.CULL_FACE);
    gl.disable(gl.BLEND);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    for (let i = 0, len = this.#layerList.length; i < len; i++) {
      const layer = this.#layerList[i];
      const meshCounts = layer.meshCounts[viewIndex];
      if (meshCounts.numPickable < meshCounts.numMeshes || meshCounts.numCulled === meshCounts.numMeshes || meshCounts.numVisible === 0) {
        continue;
      }
      layer.drawPickMesh();
    }
    const pix = pickBuffer.read(0, 0);
    const pickID = pix[0] + (pix[1] << 8) + (pix[2] << 16) + (pix[3] << 24);
    console.log("pickID = " + pickID);
    pickBuffer.unbind();
    if (pickID < 0) {
      return null;
    }
    return this.#pickIDs.items[pickID];
  }
  #pickWorldPos(viewIndex, params2) {
    const targetRendererView = this.#rendererViewsList[viewIndex];
    if (!targetRendererView) {
      throw new SDKError(`Can't activate View - no such target View attached: ${viewIndex}`);
    }
    const gl = this.#gl;
    const view = targetRendererView.view;
    const pickProjMatrix = params2.pickProjMatrix;
    const pickViewMatrix = params2.pickViewMatrix;
    const resolutionScale = view.resolutionScale;
    const renderContext = this.renderContext;
    const targetCanvasBoundingRect = targetRendererView.view.htmlElement.getBoundingClientRect();
    const pickBuffer = targetRendererView.renderBufferManager.getRenderBuffer("pickDepth", {
      depthTexture: true,
      size: [targetCanvasBoundingRect.width, targetCanvasBoundingRect.height]
    });
    pickBuffer.setSize([targetCanvasBoundingRect.width, targetCanvasBoundingRect.height]);
    pickBuffer.bind();
    pickBuffer.clear();
    renderContext.reset();
    renderContext.backfaces = true;
    renderContext.frontface = true;
    renderContext.pickViewMatrix = pickViewMatrix;
    renderContext.pickProjMatrix = pickProjMatrix;
    renderContext.pickInvisible = !!params2.pickInvisible;
    renderContext.pickClipPos[0] = this.#getClipPosX(params2.canvasPos[0] * resolutionScale.resolutionScale, gl.drawingBufferWidth);
    renderContext.pickClipPos[0] = this.#getClipPosY(params2.canvasPos[1] * resolutionScale.resolutionScale, gl.drawingBufferHeight);
    gl.viewport(0, 0, 1, 1);
    gl.depthMask(true);
    gl.enable(gl.DEPTH_TEST);
    gl.disable(gl.CULL_FACE);
    gl.disable(gl.BLEND);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    if (params2.layer) {
      params2.layer.drawPickDepths();
    } else {
      for (let i = 0, len = this.#layerList.length; i < len; i++) {
        const layer = this.#layerList[i];
        const meshCounts = layer.meshCounts[viewIndex];
        if (meshCounts.numPickable < meshCounts.numMeshes || meshCounts.numCulled === meshCounts.numMeshes || meshCounts.numVisible === 0) {
          continue;
        }
        layer.drawPickDepths();
      }
    }
    const pix = pickBuffer.read(0, 0);
    pickBuffer.unbind();
    const pickID = pix[0] + (pix[1] << 8) + (pix[2] << 16) + (pix[3] << 24);
    if (pickID < 0) {
      return null;
    }
    return this.#pickIDs.items[pickID];
  }
  #getClipPosX(pos, size) {
    return 2 * (pos / size) - 1;
  }
  #getClipPosY(pos, size) {
    return 1 - 2 * (pos / size);
  }
  beginSnapshot(viewIndex, params2) {
  }
  renderSnapshot() {
  }
  readSnapshot() {
    return "";
  }
  readSnapshotAsCanvas() {
    return null;
  }
  /**
   * Exits snapshot mode.
   *
   * Switches rendering back to the main canvas.
   */
  endSnapshot() {
    this.#snapshotBound = false;
  }
  destroy() {
    if (this.#destroyed) {
      return;
    }
    if (this.#viewer) {
      this.detachViewer();
    }
    this.#saoOcclusionRenderer.destroy();
    this.#saoDepthLimitedBlurRenderer.destroy();
    this.#pickBufferManager.destroy();
    this.#destroyed = true;
    this.onDestroyed.dispatch(this, true);
  }
};

// ../sdk/src/cameracontrol/index.ts
var cameracontrol_exports = {};
__export(cameracontrol_exports, {
  CameraControl: () => CameraControl,
  KEY_A: () => KEY_A,
  KEY_ADD: () => KEY_ADD,
  KEY_ALT: () => KEY_ALT,
  KEY_B: () => KEY_B,
  KEY_BACKSPACE: () => KEY_BACKSPACE,
  KEY_BACK_SLASH: () => KEY_BACK_SLASH,
  KEY_C: () => KEY_C,
  KEY_CAPS_LOCK: () => KEY_CAPS_LOCK,
  KEY_CLOSE_BRACKET: () => KEY_CLOSE_BRACKET,
  KEY_COMMA: () => KEY_COMMA,
  KEY_CTRL: () => KEY_CTRL,
  KEY_D: () => KEY_D,
  KEY_DASH: () => KEY_DASH,
  KEY_DECIMAL_POINT: () => KEY_DECIMAL_POINT,
  KEY_DELETE: () => KEY_DELETE,
  KEY_DIVIDE: () => KEY_DIVIDE,
  KEY_DOWN_ARROW: () => KEY_DOWN_ARROW,
  KEY_E: () => KEY_E,
  KEY_END: () => KEY_END,
  KEY_ENTER: () => KEY_ENTER,
  KEY_EQUAL_SIGN: () => KEY_EQUAL_SIGN,
  KEY_ESCAPE: () => KEY_ESCAPE,
  KEY_F: () => KEY_F,
  KEY_F1: () => KEY_F1,
  KEY_F10: () => KEY_F10,
  KEY_F11: () => KEY_F11,
  KEY_F12: () => KEY_F12,
  KEY_F2: () => KEY_F2,
  KEY_F3: () => KEY_F3,
  KEY_F4: () => KEY_F4,
  KEY_F5: () => KEY_F5,
  KEY_F6: () => KEY_F6,
  KEY_F7: () => KEY_F7,
  KEY_F8: () => KEY_F8,
  KEY_F9: () => KEY_F9,
  KEY_FORWARD_SLASH: () => KEY_FORWARD_SLASH,
  KEY_G: () => KEY_G,
  KEY_GRAVE_ACCENT: () => KEY_GRAVE_ACCENT,
  KEY_H: () => KEY_H,
  KEY_HOME: () => KEY_HOME,
  KEY_I: () => KEY_I,
  KEY_INSERT: () => KEY_INSERT,
  KEY_J: () => KEY_J,
  KEY_K: () => KEY_K,
  KEY_L: () => KEY_L,
  KEY_LEFT_ARROW: () => KEY_LEFT_ARROW,
  KEY_LEFT_WINDOW: () => KEY_LEFT_WINDOW,
  KEY_M: () => KEY_M,
  KEY_MULTIPLY: () => KEY_MULTIPLY,
  KEY_N: () => KEY_N,
  KEY_NUMPAD_0: () => KEY_NUMPAD_0,
  KEY_NUMPAD_1: () => KEY_NUMPAD_1,
  KEY_NUMPAD_2: () => KEY_NUMPAD_2,
  KEY_NUMPAD_3: () => KEY_NUMPAD_3,
  KEY_NUMPAD_4: () => KEY_NUMPAD_4,
  KEY_NUMPAD_5: () => KEY_NUMPAD_5,
  KEY_NUMPAD_6: () => KEY_NUMPAD_6,
  KEY_NUMPAD_7: () => KEY_NUMPAD_7,
  KEY_NUMPAD_8: () => KEY_NUMPAD_8,
  KEY_NUMPAD_9: () => KEY_NUMPAD_9,
  KEY_NUM_0: () => KEY_NUM_0,
  KEY_NUM_1: () => KEY_NUM_1,
  KEY_NUM_2: () => KEY_NUM_2,
  KEY_NUM_3: () => KEY_NUM_3,
  KEY_NUM_4: () => KEY_NUM_4,
  KEY_NUM_5: () => KEY_NUM_5,
  KEY_NUM_6: () => KEY_NUM_6,
  KEY_NUM_7: () => KEY_NUM_7,
  KEY_NUM_8: () => KEY_NUM_8,
  KEY_NUM_9: () => KEY_NUM_9,
  KEY_NUM_LOCK: () => KEY_NUM_LOCK,
  KEY_O: () => KEY_O,
  KEY_OPEN_BRACKET: () => KEY_OPEN_BRACKET,
  KEY_P: () => KEY_P,
  KEY_PAGE_DOWN: () => KEY_PAGE_DOWN,
  KEY_PAGE_UP: () => KEY_PAGE_UP,
  KEY_PAUSE_BREAK: () => KEY_PAUSE_BREAK,
  KEY_PERIOD: () => KEY_PERIOD,
  KEY_Q: () => KEY_Q,
  KEY_R: () => KEY_R,
  KEY_RIGHT_ARROW: () => KEY_RIGHT_ARROW,
  KEY_RIGHT_WINDOW: () => KEY_RIGHT_WINDOW,
  KEY_S: () => KEY_S,
  KEY_SCROLL_LOCK: () => KEY_SCROLL_LOCK,
  KEY_SELECT_KEY: () => KEY_SELECT_KEY,
  KEY_SEMI_COLON: () => KEY_SEMI_COLON,
  KEY_SHIFT: () => KEY_SHIFT,
  KEY_SINGLE_QUOTE: () => KEY_SINGLE_QUOTE,
  KEY_SPACE: () => KEY_SPACE,
  KEY_SUBTRACT: () => KEY_SUBTRACT,
  KEY_T: () => KEY_T,
  KEY_TAB: () => KEY_TAB,
  KEY_U: () => KEY_U,
  KEY_UP_ARROW: () => KEY_UP_ARROW,
  KEY_V: () => KEY_V,
  KEY_W: () => KEY_W,
  KEY_X: () => KEY_X,
  KEY_Y: () => KEY_Y,
  KEY_Z: () => KEY_Z
});

// ../sdk/src/cameracontrol/PickController.ts
var PickController = class {
  #view;
  #cameraControl;
  #configs;
  schedulePickEntity;
  schedulePickSurface;
  scheduleSnapOrPick;
  pickCursorPos;
  picked;
  pickedSurface;
  pickResult;
  #lastPickedEntityId;
  #lastHash;
  #needFireEvents;
  snappedOrPicked;
  hoveredSnappedOrSurfaceOff;
  snapPickResult;
  constructor(cameraControl, configs) {
    this.#view = cameraControl.view;
    this.#cameraControl = cameraControl;
    this.#view.htmlElement.oncontextmenu = function(e) {
      e.preventDefault();
    };
    this.#configs = configs;
    this.schedulePickEntity = false;
    this.schedulePickSurface = false;
    this.scheduleSnapOrPick = false;
    this.pickCursorPos = createVec2();
    this.picked = false;
    this.pickedSurface = false;
    this.pickResult = null;
    this.#lastPickedEntityId = null;
    this.#lastHash = null;
    this.#needFireEvents = 0;
  }
  /**
   * Immediately attempts a pick, if scheduled.
   */
  update() {
    if (!this.#configs.pointerEnabled) {
      return;
    }
    if (!this.schedulePickEntity && !this.schedulePickSurface) {
      return;
    }
    const hash = `${~~this.pickCursorPos[0]}-${~~this.pickCursorPos[1]}-${this.scheduleSnapOrPick}-${this.schedulePickSurface}-${this.schedulePickEntity}`;
    if (this.#lastHash === hash) {
      return;
    }
    this.picked = false;
    this.pickedSurface = false;
    this.snappedOrPicked = false;
    this.hoveredSnappedOrSurfaceOff = false;
    const hasHoverSurfaceSubs = this.#cameraControl.onHoverSurface.count > 0;
    if (this.scheduleSnapOrPick) {
      const snapPickResult = this.#view.pick({
        canvasPos: this.pickCursorPos,
        snapRadius: this.#configs.snapRadius,
        snapToVertex: this.#configs.snapToVertex,
        snapToEdge: this.#configs.snapToEdge
      });
      if (snapPickResult instanceof PickResult && (snapPickResult.snappedToEdge || snapPickResult.snappedToVertex)) {
        this.snapPickResult = snapPickResult;
        this.snappedOrPicked = true;
        this.#needFireEvents++;
      } else {
        this.schedulePickSurface = true;
        this.snapPickResult = null;
      }
    }
    if (this.schedulePickSurface) {
      if (this.pickResult && this.pickResult.worldPos) {
        const pickResultCanvasPos = this.pickResult.canvasPos;
        if (pickResultCanvasPos[0] === this.pickCursorPos[0] && pickResultCanvasPos[1] === this.pickCursorPos[1]) {
          this.picked = true;
          this.pickedSurface = true;
          this.#needFireEvents += hasHoverSurfaceSubs ? 1 : 0;
          this.schedulePickEntity = false;
          this.schedulePickSurface = false;
          if (this.scheduleSnapOrPick) {
            this.snappedOrPicked = true;
          } else {
            this.hoveredSnappedOrSurfaceOff = true;
          }
          this.scheduleSnapOrPick = false;
          return;
        }
      }
    }
    if (this.schedulePickEntity) {
      if (this.pickResult && (this.pickResult.canvasPos || this.pickResult.snappedCanvasPos)) {
        const pickResultCanvasPos = this.pickResult.canvasPos || this.pickResult.snappedCanvasPos;
        if (pickResultCanvasPos[0] === this.pickCursorPos[0] && pickResultCanvasPos[1] === this.pickCursorPos[1]) {
          this.picked = true;
          this.pickedSurface = false;
          this.schedulePickEntity = false;
          this.schedulePickSurface = false;
          return;
        }
      }
    }
    if (this.schedulePickSurface || this.scheduleSnapOrPick && !this.snapPickResult) {
      const pickResult = this.#view.pick({
        pickSurface: true,
        pickSurfaceNormal: false,
        canvasPos: this.pickCursorPos
      });
      this.pickResult = pickResult instanceof PickResult ? pickResult : null;
      if (this.pickResult) {
        this.picked = true;
        if (this.scheduleSnapOrPick) {
          this.snappedOrPicked = true;
        } else {
          this.pickedSurface = true;
        }
        this.#needFireEvents++;
      } else if (this.scheduleSnapOrPick) {
        this.hoveredSnappedOrSurfaceOff = true;
        this.#needFireEvents++;
      }
    } else {
      const pickResult = this.#view.pick({
        canvasPos: this.pickCursorPos
      });
      this.pickResult = pickResult instanceof PickResult ? pickResult : null;
      if (this.pickResult) {
        this.picked = true;
        this.pickedSurface = false;
        this.#needFireEvents++;
      }
    }
    this.scheduleSnapOrPick = false;
    this.schedulePickEntity = false;
    this.schedulePickSurface = false;
  }
  fireEvents() {
    if (this.#needFireEvents === 0) {
      return;
    }
    if (this.hoveredSnappedOrSurfaceOff) {
      this.#cameraControl.onHoverSnapOrSurfaceOff.dispatch(this.#cameraControl, {
        canvasPos: this.pickCursorPos,
        pointerPos: this.pickCursorPos
      });
    }
    if (this.snappedOrPicked) {
      if (this.snapPickResult) {
        const pickResult = new PickResult();
        pickResult.viewObject = this.snapPickResult.viewObject;
        pickResult.snappedToVertex = this.snapPickResult.snappedToVertex;
        pickResult.snappedToEdge = this.snapPickResult.snappedToEdge;
        pickResult.worldPos = this.snapPickResult.worldPos;
        pickResult.canvasPos = this.pickCursorPos;
        pickResult.snappedCanvasPos = this.snapPickResult.snappedCanvasPos;
        this.#cameraControl.onHoverSnapOrSurface.dispatch(this.#cameraControl, pickResult);
        this.snapPickResult = null;
      } else {
        this.#cameraControl.onHoverSnapOrSurface.dispatch(this.#cameraControl, this.pickResult);
      }
    } else {
    }
    if (this.picked && this.pickResult && (this.pickResult.viewObject || this.pickResult.worldPos)) {
      if (this.pickResult.viewObject) {
        const pickedEntityId = this.pickResult.viewObject.id;
        if (this.#lastPickedEntityId !== pickedEntityId) {
          if (this.#lastPickedEntityId !== void 0) {
            this.#cameraControl.onHoverOut.dispatch(this.#cameraControl, {
              viewObject: this.#view.objects[this.#lastPickedEntityId]
            });
          }
          this.#cameraControl.onHoverEnter.dispatch(this.#cameraControl, this.pickResult);
          this.#lastPickedEntityId = pickedEntityId;
        }
      }
      this.#cameraControl.onHover.dispatch(this.#cameraControl, this.pickResult);
      if (this.pickResult.worldPos) {
        this.pickedSurface = true;
        this.#cameraControl.onHoverSurface.dispatch(this.#cameraControl, this.pickResult);
      }
    } else {
      if (this.#lastPickedEntityId !== void 0) {
        this.#cameraControl.onHoverOut.dispatch(this.#cameraControl, {
          viewObject: this.#view.objects[this.#lastPickedEntityId]
        });
        this.#lastPickedEntityId = void 0;
      }
      this.#cameraControl.onHoverOff.dispatch(this.#cameraControl, {
        canvasPos: this.pickCursorPos
      });
    }
    this.pickResult = null;
    this.#needFireEvents = 0;
  }
};

// ../sdk/src/cameracontrol/PivotController.ts
var tempVec3a9 = createVec3();
var tempVec3b9 = createVec3();
var tempVec3c7 = createVec3();
var tempVec4a6 = createVec4();
var tempVec4b5 = createVec4();
var tempVec4c = createVec4();
var PivotController = class {
  #view;
  #configs;
  #pivotWorldPos;
  #cameraOffset;
  #azimuth;
  #polar;
  #radius;
  #pivotPosSet;
  #pivoting;
  #shown;
  #pivotSphereEnabled;
  #pivotSphere;
  #pivotSphereSize;
  #pivotSphereGeometry;
  #pivotSphereMaterial;
  #rtcCenter;
  #rtcPos;
  #pivotViewPos;
  #pivotProjPos;
  #pivotCanvasPos;
  #cameraDirty;
  #onViewMatrix;
  #onProjMatrix;
  #onTick;
  #pivotElement;
  /**
   * @private
   */
  constructor(view, configs) {
    this.#view = view;
    this.#configs = configs;
    this.#pivotWorldPos = createVec3();
    this.#cameraOffset = createVec3();
    this.#azimuth = 0;
    this.#polar = 0;
    this.#radius = 0;
    this.#pivotPosSet = false;
    this.#pivoting = false;
    this.#shown = false;
    this.#pivotSphereEnabled = false;
    this.#pivotSphere = null;
    this.#pivotSphereSize = 1;
    this.#pivotSphereGeometry = null;
    this.#pivotSphereMaterial = null;
    this.#rtcCenter = createVec3();
    this.#rtcPos = createVec3();
    this.#pivotViewPos = createVec4();
    this.#pivotProjPos = createVec4();
    this.#pivotCanvasPos = createVec2();
    this.#cameraDirty = true;
    this.#onViewMatrix = this.#view.camera.onViewMatrix.sub(() => {
      this.#cameraDirty = true;
    });
    this.#onProjMatrix = this.#view.camera.onProjMatrix.sub(() => {
      this.#cameraDirty = true;
    });
    this.#onTick = this.#view.viewer.onTick.sub(() => {
      this.updatePivotElement();
      this.updatePivotSphere();
    });
  }
  createPivotSphere() {
  }
  destroyPivotSphere() {
    if (this.#pivotSphere) {
      this.#pivotSphere.destroy();
      this.#pivotSphere = null;
    }
    if (this.#pivotSphereGeometry) {
      this.#pivotSphereGeometry.destroy();
      this.#pivotSphereGeometry = null;
    }
  }
  updatePivotElement() {
  }
  updatePivotSphere() {
    if (this.#pivoting && this.#pivotSphere) {
      worldToRTCPos(this.getPivotPos(), this.#rtcCenter, this.#rtcPos);
      if (!compareVec3(this.#rtcPos, this.#pivotSphere.position)) {
        this.destroyPivotSphere();
        this.createPivotSphere();
      }
    }
  }
  /**
   * Sets the HTML DOM element that will represent the pivot position.
   *
   * @param pivotElement
   */
  setPivotElement(pivotElement) {
    this.#pivotElement = pivotElement;
  }
  /**
   * Sets a sphere as the representation of the pivot position.
   *
   * @param {Object} [cfg] Sphere configuration.
   * @param {String} [cfg.size=1] Optional size factor of the sphere. Defaults to 1.
   * @param {String} [cfg.color=Array] Optional maretial color. Defaults to a red.
   */
  enablePivotSphere(cfg = {
    size: 0,
    color: [1, 1, 1]
  }) {
  }
  /**
   * Remove the sphere as the representation of the pivot position.
   *
   */
  disablePivotSphere() {
    this.destroyPivotSphere();
    this.#pivotSphereEnabled = false;
  }
  /**
   * Begins pivoting.
   */
  startPivot() {
    if (this.#cameraLookingDownwards()) {
      this.#pivoting = false;
      return false;
    }
    const camera = this.#view.camera;
    let lookat = lookAtMat4v(camera.eye, camera.look, camera.worldUp);
    transformPoint3(lookat, this.getPivotPos(), this.#cameraOffset);
    const pivotPos = this.getPivotPos();
    this.#cameraOffset[2] += distVec3(camera.eye, pivotPos);
    lookat = inverseMat4(lookat);
    const offset = transformVec3(lookat, this.#cameraOffset);
    const diff = createVec3();
    subVec3(camera.eye, pivotPos, diff);
    addVec3(diff, offset);
    if (camera.zUp) {
      const t = diff[1];
      diff[1] = diff[2];
      diff[2] = t;
    }
    this.#radius = lenVec3(diff);
    this.#polar = Math.acos(diff[1] / this.#radius);
    this.#azimuth = Math.atan2(diff[0], diff[2]);
    this.#pivoting = true;
  }
  #cameraLookingDownwards() {
    const camera = this.#view.camera;
    const forwardAxis = normalizeVec3(subVec3(camera.look, camera.eye, tempVec3a9));
    const rightAxis = cross3Vec3(forwardAxis, camera.worldUp, tempVec3b9);
    let rightAxisLen = sqLenVec3(rightAxis);
    return rightAxisLen <= 1e-4;
  }
  /**
   * Returns true if we are currently pivoting.
   *
   * @returns {Boolean}
   */
  getPivoting() {
    return this.#pivoting;
  }
  /**
   * Sets a 3D World-space position to pivot about.
   *
   * @param {Number[]} worldPos The new World-space pivot position.
   */
  setPivotPos(worldPos) {
    this.#pivotWorldPos.set(worldPos);
    this.#pivotPosSet = true;
  }
  /**
   * Sets the pivot position to the 3D projection of the given 2D canvas coordinates on a sphere centered
   * at the viewpoint. The radius of the sphere is configured via {@link CameraControl#smartPivot}.
   *
   *
   * @param canvasPos
   */
  setCanvasPivotPos(canvasPos2) {
    const camera = this.#view.camera;
    const pivotShereRadius = Math.abs(distVec3(this.#view.viewer.scene.center, camera.eye));
    const transposedProjectMat = camera.projection.transposedProjMatrix;
    const Pt3 = transposedProjectMat.subarray(8, 12);
    const Pt4 = transposedProjectMat.subarray(12);
    const D = [0, 0, -1, 1];
    const screenZ = dotVec4(D, Pt3) / dotVec4(D, Pt4);
    const worldPos = tempVec4a6;
    camera.projection.unproject(canvasPos2, screenZ, tempVec4b5, tempVec4c, worldPos);
    const eyeWorldPosVec = normalizeVec3(subVec3(worldPos, camera.eye, tempVec3a9));
    const posOnSphere = addVec3(camera.eye, mulVec3Scalar(eyeWorldPosVec, pivotShereRadius, tempVec3b9), tempVec3c7);
    this.setPivotPos(posOnSphere);
  }
  /**
   * Gets the current position we're pivoting about.
   * @returns {Number[]} The current World-space pivot position.
   */
  getPivotPos() {
    return this.#pivotPosSet ? this.#pivotWorldPos : this.#view.camera.look;
  }
  /**
   * Continues to pivot.
   *
   * @param {Number} yawInc Yaw rotation increment.
   * @param {Number} pitchInc Pitch rotation increment.
   */
  continuePivot(yawInc, pitchInc) {
    if (!this.#pivoting) {
      return;
    }
    if (yawInc === 0 && pitchInc === 0) {
      return;
    }
    const camera = this.#view.camera;
    var dx = -yawInc;
    const dy = -pitchInc;
    if (camera.worldUp[2] === 1) {
      dx = -dx;
    }
    this.#azimuth += -dx * 0.01;
    this.#polar += dy * 0.01;
    this.#polar = clamp(this.#polar, 1e-3, Math.PI - 1e-3);
    const pos = [
      this.#radius * Math.sin(this.#polar) * Math.sin(this.#azimuth),
      this.#radius * Math.cos(this.#polar),
      this.#radius * Math.sin(this.#polar) * Math.cos(this.#azimuth)
    ];
    if (camera.worldUp[2] === 1) {
      const t = pos[1];
      pos[1] = pos[2];
      pos[2] = t;
    }
    const eyeLookLen = lenVec3(subVec3(camera.look, camera.eye, createVec3()));
    const pivotPos = this.getPivotPos();
    addVec3(pos, pivotPos);
    let lookat = lookAtMat4v(pos, pivotPos, camera.worldUp);
    lookat = inverseMat4(lookat);
    const offset = transformVec3(lookat, this.#cameraOffset);
    lookat[12] -= offset[0];
    lookat[13] -= offset[1];
    lookat[14] -= offset[2];
    const zAxis = [lookat[8], lookat[9], lookat[10]];
    camera.eye = [lookat[12], lookat[13], lookat[14]];
    subVec3(camera.eye, mulVec3Scalar(zAxis, eyeLookLen), camera.look);
    camera.up = [lookat[4], lookat[5], lookat[6]];
    this.showPivot();
  }
  /**
   * Shows the pivot position.
   *
   * Only works if we set an  HTML DOM element to represent the pivot position.
   */
  showPivot() {
    if (this.#shown) {
      return;
    }
    if (this.#pivotElement) {
      this.updatePivotElement();
      this.#pivotElement.style.visibility = "visible";
    }
    if (this.#pivotSphereEnabled) {
      this.destroyPivotSphere();
      this.createPivotSphere();
    }
    this.#shown = true;
  }
  /**
   * Hides the pivot position.
   *
   * Only works if we set an  HTML DOM element to represent the pivot position.
   */
  hidePivot() {
    if (!this.#shown) {
      return;
    }
    if (this.#pivotElement) {
      this.#pivotElement.style.visibility = "hidden";
    }
    if (this.#pivotSphereEnabled) {
      this.destroyPivotSphere();
    }
    this.#shown = false;
  }
  /**
   * Finishes pivoting.
   */
  endPivot() {
    this.#pivoting = false;
  }
  destroy() {
    this.destroyPivotSphere();
    this.#view.camera.onViewMatrix.unsub(this.#onViewMatrix);
    this.#view.camera.onProjMatrix.unsub(this.#onProjMatrix);
    this.#view.viewer.onTick.unsub(this.#onTick);
  }
};

// ../sdk/src/cameracontrol/PanController.ts
var screenPos = createVec4();
var viewPos = createVec4();
var tempVec3a10 = createVec3();
var tempVec3b10 = createVec3();
var tempVec3c8 = createVec3();
var tempVec4a7 = createVec4();
var tempVec4b6 = createVec4();
var tempVec4c2 = createVec4();
var PanController = class {
  #view;
  constructor(view) {
    this.#view = view;
  }
  /**
   * Dollys the Camera towards the given target 2D canvas position.
   *
   * When the target's corresponding World-space position is also provided, then this function will also test if we've
   * dollied past the target, and will return ````true```` if that's the case.
   *
   * @param [optionalTargetWorldPos] Optional world position of the target
   * @param targetCanvasPos Canvas position of the target
   * @param dollyDelta Amount to dolly
   * @return True if optionalTargetWorldPos was given, and we've dollied past that position.
   */
  dollyToCanvasPos(optionalTargetWorldPos, targetCanvasPos, dollyDelta) {
    let dolliedThroughSurface = false;
    const camera = this.#view.camera;
    if (optionalTargetWorldPos) {
      const eyeToWorldPosVec = subVec3(optionalTargetWorldPos, camera.eye, tempVec3a10);
      const eyeWorldPosDist = lenVec3(eyeToWorldPosVec);
      dolliedThroughSurface = eyeWorldPosDist < dollyDelta;
    }
    if (camera.projectionType === PerspectiveProjectionType) {
      camera.orthoProjection.scale = camera.orthoProjection.scale - dollyDelta;
      const unprojectedWorldPos = this._unproject(targetCanvasPos, tempVec4a7);
      const offset = subVec3(unprojectedWorldPos, camera.eye, tempVec4c2);
      const moveVec = mulVec3Scalar(normalizeVec3(offset), -dollyDelta, []);
      camera.eye = [camera.eye[0] - moveVec[0], camera.eye[1] - moveVec[1], camera.eye[2] - moveVec[2]];
      camera.look = [camera.look[0] - moveVec[0], camera.look[1] - moveVec[1], camera.look[2] - moveVec[2]];
      if (optionalTargetWorldPos) {
        const eyeTargetVec = subVec3(optionalTargetWorldPos, camera.eye, tempVec3a10);
        const lenEyeTargetVec = lenVec3(eyeTargetVec);
        const eyeLookVec2 = mulVec3Scalar(normalizeVec3(subVec3(camera.look, camera.eye, tempVec3b10)), lenEyeTargetVec);
        camera.look = [camera.eye[0] + eyeLookVec2[0], camera.eye[1] + eyeLookVec2[1], camera.eye[2] + eyeLookVec2[2]];
      }
    } else if (camera.projectionType === OrthoProjectionType) {
      const worldPos1 = this._unproject(targetCanvasPos, tempVec4a7);
      camera.orthoProjection.scale = camera.orthoProjection.scale - dollyDelta;
      const worldPos2 = this._unproject(targetCanvasPos, tempVec4b6);
      const offset = subVec3(worldPos2, worldPos1, tempVec4c2);
      const eyeLookMoveVec = mulVec3Scalar(normalizeVec3(subVec3(camera.look, camera.eye, tempVec3a10)), -dollyDelta, tempVec3b10);
      const moveVec = addVec3(offset, eyeLookMoveVec, tempVec3c8);
      camera.eye = [camera.eye[0] - moveVec[0], camera.eye[1] - moveVec[1], camera.eye[2] - moveVec[2]];
      camera.look = [camera.look[0] - moveVec[0], camera.look[1] - moveVec[1], camera.look[2] - moveVec[2]];
    }
    return dolliedThroughSurface;
  }
  _unproject(canvasPos2, worldPos) {
    const camera = this.#view.camera;
    const transposedProjectMat = camera.projection.transposedProjMatrix;
    const Pt3 = transposedProjectMat.subarray(8, 12);
    const Pt4 = transposedProjectMat.subarray(12);
    const D = [0, 0, -1, 1];
    const screenZ = dotVec4(D, Pt3) / dotVec4(D, Pt4);
    camera.projection.unproject(canvasPos2, screenZ, screenPos, viewPos, worldPos);
    return worldPos;
  }
  destroy() {
  }
};

// ../sdk/src/cameracontrol/MouseMiscHandler.ts
var MouseMiscHandler = class {
  #view;
  #mouseEnterHandler;
  #mouseLeaveHandler;
  #mouseMoveHandler;
  #mouseDownHandler;
  #mouseUpHandler;
  constructor(view, controllers, configs, states, updates) {
    this.#view = view;
    const htmlElement = this.#view.htmlElement;
    htmlElement.addEventListener("mouseenter", this.#mouseEnterHandler = () => {
      states.mouseover = true;
    });
    htmlElement.addEventListener("mouseleave", this.#mouseLeaveHandler = () => {
      states.mouseover = false;
      htmlElement.style.cursor = null;
    });
    document.addEventListener("mousemove", this.#mouseMoveHandler = (e) => {
      getCanvasPosFromEvent(e, htmlElement, states.pointerCanvasPos);
    });
    htmlElement.addEventListener("mousedown", this.#mouseDownHandler = (e) => {
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
      getCanvasPosFromEvent(e, htmlElement, states.pointerCanvasPos);
      states.mouseover = true;
    });
    htmlElement.addEventListener("mouseup", this.#mouseUpHandler = (e) => {
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
    });
  }
  reset() {
  }
  destroy() {
    const htmlElement = this.#view.htmlElement;
    document.removeEventListener("mousemove", this.#mouseMoveHandler);
    htmlElement.removeEventListener("mouseenter", this.#mouseEnterHandler);
    htmlElement.removeEventListener("mouseleave", this.#mouseLeaveHandler);
    htmlElement.removeEventListener("mousedown", this.#mouseDownHandler);
    htmlElement.removeEventListener("mouseup", this.#mouseUpHandler);
  }
};
function getCanvasPosFromEvent(event, htmlElement, canvasPos2) {
  if (!event) {
    event = window.event;
    canvasPos2[0] = event.x;
    canvasPos2[1] = event.y;
  } else {
    const { left, top } = htmlElement.getBoundingClientRect();
    canvasPos2[0] = event.clientX - left;
    canvasPos2[1] = event.clientY - top;
  }
  return canvasPos2;
}

// ../sdk/src/cameracontrol/TouchPanRotateAndDollyHandler.ts
var getCanvasPosFromEvent2 = function(event, canvasPos2) {
  if (!event) {
    event = window.event;
    canvasPos2[0] = event.x;
    canvasPos2[1] = event.y;
  } else {
    let element = event.target;
    let totalOffsetLeft = 0;
    let totalOffsetTop = 0;
    while (element.offsetParent) {
      totalOffsetLeft += element.offsetLeft;
      totalOffsetTop += element.offsetTop;
      element = element.offsetParent;
    }
    canvasPos2[0] = event.pageX - totalOffsetLeft;
    canvasPos2[1] = event.pageY - totalOffsetTop;
  }
  return canvasPos2;
};
var TouchPanRotateAndDollyHandler = class {
  #canvasTouchMoveHandler;
  #canvasTouchStartHandler;
  #view;
  #canvasTouchEndHandler;
  #tickSub;
  constructor(view, controllers, configs, states, updates) {
    this.#view = view;
    const pickController = controllers.pickController;
    const pivotController = controllers.pivotController;
    const tapStartCanvasPos = createVec2();
    const tapCanvasPos0 = createVec2();
    const tapCanvasPos1 = createVec2();
    const touch0Vec = createVec2();
    const lastCanvasTouchPosList = [];
    const canvas2 = this.#view.htmlElement;
    let numTouches = 0;
    let tapStartTime = -1;
    let waitForTick = false;
    this.#tickSub = view.viewer.onTick.sub(() => {
      waitForTick = false;
    });
    let firstDragDeltaX = 0;
    let firstDragDeltaY = 1;
    let absorbTinyFirstDrag = false;
    canvas2.addEventListener("touchstart", this.#canvasTouchStartHandler = (event) => {
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
      event.preventDefault();
      const touches = event.touches;
      const changedTouches = event.changedTouches;
      states.touchStartTime = Date.now();
      if (touches.length === 1 && changedTouches.length === 1) {
        tapStartTime = states.touchStartTime;
        getCanvasPosFromEvent2(touches[0], tapStartCanvasPos);
        if (configs.followPointer) {
          pickController.pickCursorPos = tapStartCanvasPos;
          pickController.schedulePickSurface = true;
          pickController.update();
          if (!configs.planView) {
            if (pickController.picked && pickController.pickedSurface && pickController.pickResult && pickController.pickResult.worldPos) {
              pivotController.setPivotPos(pickController.pickResult.worldPos);
              if (!configs.firstPerson && pivotController.startPivot()) {
                pivotController.showPivot();
              }
            } else {
              if (configs.smartPivot) {
                pivotController.setCanvasPivotPos(states.pointerCanvasPos);
              } else {
                pivotController.setPivotPos(view.camera.look);
              }
              if (!configs.firstPerson && pivotController.startPivot()) {
                pivotController.showPivot();
              }
            }
          }
        }
      } else {
        tapStartTime = -1;
      }
      while (lastCanvasTouchPosList.length < touches.length) {
        lastCanvasTouchPosList.push(createVec2());
      }
      for (let i = 0, len = touches.length; i < len; ++i) {
        getCanvasPosFromEvent2(touches[i], lastCanvasTouchPosList[i]);
      }
      numTouches = touches.length;
    });
    canvas2.addEventListener("touchend", this.#canvasTouchEndHandler = () => {
      if (pivotController.getPivoting()) {
        pivotController.endPivot();
      }
      firstDragDeltaX = 0;
      firstDragDeltaY = 0;
      absorbTinyFirstDrag = true;
    });
    canvas2.addEventListener("touchmove", this.#canvasTouchMoveHandler = (event) => {
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
      event.stopPropagation();
      event.preventDefault();
      if (waitForTick) {
        return;
      }
      waitForTick = true;
      const canvasBoundary = view.boundary;
      const canvasWidth = canvasBoundary[2];
      const canvasHeight = canvasBoundary[3];
      const touches = event.touches;
      if (event.touches.length !== numTouches) {
        return;
      }
      if (numTouches === 1) {
        getCanvasPosFromEvent2(touches[0], tapCanvasPos0);
        subVec2(tapCanvasPos0, lastCanvasTouchPosList[0], touch0Vec);
        const xPanDelta = touch0Vec[0];
        const yPanDelta = touch0Vec[1];
        if (states.longTouchTimeout !== null && (Math.abs(xPanDelta) > configs.longTapRadius || Math.abs(yPanDelta) > configs.longTapRadius)) {
          clearTimeout(states.longTouchTimeout);
          states.longTouchTimeout = null;
        }
        if (configs.planView) {
          const camera = view.camera;
          if (camera.projectionType === PerspectiveProjectionType) {
            const touchPicked = false;
            const pickedWorldPos = [0, 0, 0];
            const depth = Math.abs(touchPicked ? lenVec3(subVec3(pickedWorldPos, view.camera.eye, [])) : view.camera.eyeLookDist);
            const targetDistance = depth * Math.tan(camera.perspectiveProjection.fov / 2 * Math.PI / 180);
            updates.panDeltaX += xPanDelta * targetDistance / canvasHeight * configs.touchPanRate;
            updates.panDeltaY += yPanDelta * targetDistance / canvasHeight * configs.touchPanRate;
          } else {
            updates.panDeltaX += 0.5 * camera.orthoProjection.scale * (xPanDelta / canvasHeight) * configs.touchPanRate;
            updates.panDeltaY += 0.5 * camera.orthoProjection.scale * (yPanDelta / canvasHeight) * configs.touchPanRate;
          }
        } else {
          updates.rotateDeltaY -= xPanDelta / canvasWidth * (configs.dragRotationRate * 1);
          updates.rotateDeltaX += yPanDelta / canvasHeight * (configs.dragRotationRate * 1.5);
        }
      } else if (numTouches === 2) {
        const touch0 = touches[0];
        const touch1 = touches[1];
        getCanvasPosFromEvent2(touch0, tapCanvasPos0);
        getCanvasPosFromEvent2(touch1, tapCanvasPos1);
        const lastMiddleTouch = geometricMeanVec2(lastCanvasTouchPosList[0], lastCanvasTouchPosList[1]);
        const currentMiddleTouch = geometricMeanVec2(tapCanvasPos0, tapCanvasPos1);
        const touchDelta = createVec2();
        subVec2(lastMiddleTouch, currentMiddleTouch, touchDelta);
        const xPanDelta = touchDelta[0];
        const yPanDelta = touchDelta[1];
        const camera = view.camera;
        const d1 = distVec2([touch0.pageX, touch0.pageY], [touch1.pageX, touch1.pageY]);
        const d2 = distVec2(lastCanvasTouchPosList[0], lastCanvasTouchPosList[1]);
        const dollyDelta = (d2 - d1) * configs.touchDollyRate;
        updates.dollyDelta = dollyDelta;
        if (Math.abs(dollyDelta) < 1) {
          if (camera.projectionType === PerspectiveProjectionType) {
            const pickedWorldPos = pickController.pickResult ? pickController.pickResult.worldPos : view.viewer.scene.center;
            const depth = Math.abs(lenVec3(subVec3(pickedWorldPos, view.camera.eye, [])));
            const targetDistance = depth * Math.tan(camera.perspectiveProjection.fov / 2 * Math.PI / 180);
            updates.panDeltaX -= xPanDelta * targetDistance / canvasHeight * configs.touchPanRate;
            updates.panDeltaY -= yPanDelta * targetDistance / canvasHeight * configs.touchPanRate;
          } else {
            updates.panDeltaX -= 0.5 * camera.orthoProjection.scale * (xPanDelta / canvasHeight) * configs.touchPanRate;
            updates.panDeltaY -= 0.5 * camera.orthoProjection.scale * (yPanDelta / canvasHeight) * configs.touchPanRate;
          }
        }
        states.pointerCanvasPos = currentMiddleTouch;
      }
      for (let i = 0; i < numTouches; ++i) {
        getCanvasPosFromEvent2(touches[i], lastCanvasTouchPosList[i]);
      }
    });
  }
  reset() {
  }
  destroy() {
    const canvas2 = this.#view.htmlElement;
    canvas2.removeEventListener("touchstart", this.#canvasTouchStartHandler);
    canvas2.removeEventListener("touchend", this.#canvasTouchEndHandler);
    canvas2.removeEventListener("touchmove", this.#canvasTouchMoveHandler);
    this.#view.viewer.onTick.unsub(this.#tickSub);
  }
};

// ../sdk/src/cameracontrol/keycodes.ts
var KEY_BACKSPACE = 8;
var KEY_TAB = 9;
var KEY_ENTER = 13;
var KEY_SHIFT = 16;
var KEY_CTRL = 17;
var KEY_ALT = 18;
var KEY_PAUSE_BREAK = 19;
var KEY_CAPS_LOCK = 20;
var KEY_ESCAPE = 27;
var KEY_PAGE_UP = 33;
var KEY_PAGE_DOWN = 34;
var KEY_END = 35;
var KEY_HOME = 36;
var KEY_LEFT_ARROW = 37;
var KEY_UP_ARROW = 38;
var KEY_RIGHT_ARROW = 39;
var KEY_DOWN_ARROW = 40;
var KEY_INSERT = 45;
var KEY_DELETE = 46;
var KEY_NUM_0 = 48;
var KEY_NUM_1 = 49;
var KEY_NUM_2 = 50;
var KEY_NUM_3 = 51;
var KEY_NUM_4 = 52;
var KEY_NUM_5 = 53;
var KEY_NUM_6 = 54;
var KEY_NUM_7 = 55;
var KEY_NUM_8 = 56;
var KEY_NUM_9 = 57;
var KEY_A = 65;
var KEY_B = 66;
var KEY_C = 67;
var KEY_D = 68;
var KEY_E = 69;
var KEY_F = 70;
var KEY_G = 71;
var KEY_H = 72;
var KEY_I = 73;
var KEY_J = 74;
var KEY_K = 75;
var KEY_L = 76;
var KEY_M = 77;
var KEY_N = 78;
var KEY_O = 79;
var KEY_P = 80;
var KEY_Q = 81;
var KEY_R = 82;
var KEY_S = 83;
var KEY_T = 84;
var KEY_U = 85;
var KEY_V = 86;
var KEY_W = 87;
var KEY_X = 88;
var KEY_Y = 89;
var KEY_Z = 90;
var KEY_LEFT_WINDOW = 91;
var KEY_RIGHT_WINDOW = 92;
var KEY_SELECT_KEY = 93;
var KEY_NUMPAD_0 = 96;
var KEY_NUMPAD_1 = 97;
var KEY_NUMPAD_2 = 98;
var KEY_NUMPAD_3 = 99;
var KEY_NUMPAD_4 = 100;
var KEY_NUMPAD_5 = 101;
var KEY_NUMPAD_6 = 102;
var KEY_NUMPAD_7 = 103;
var KEY_NUMPAD_8 = 104;
var KEY_NUMPAD_9 = 105;
var KEY_MULTIPLY = 106;
var KEY_ADD = 107;
var KEY_SUBTRACT = 109;
var KEY_DECIMAL_POINT = 110;
var KEY_DIVIDE = 111;
var KEY_F1 = 112;
var KEY_F2 = 113;
var KEY_F3 = 114;
var KEY_F4 = 115;
var KEY_F5 = 116;
var KEY_F6 = 117;
var KEY_F7 = 118;
var KEY_F8 = 119;
var KEY_F9 = 120;
var KEY_F10 = 121;
var KEY_F11 = 122;
var KEY_F12 = 123;
var KEY_NUM_LOCK = 144;
var KEY_SCROLL_LOCK = 145;
var KEY_SEMI_COLON = 186;
var KEY_EQUAL_SIGN = 187;
var KEY_COMMA = 188;
var KEY_DASH = 189;
var KEY_PERIOD = 190;
var KEY_FORWARD_SLASH = 191;
var KEY_GRAVE_ACCENT = 192;
var KEY_OPEN_BRACKET = 219;
var KEY_BACK_SLASH = 220;
var KEY_CLOSE_BRACKET = 221;
var KEY_SINGLE_QUOTE = 222;
var KEY_SPACE = 32;

// ../sdk/src/cameracontrol/MousePanRotateDollyHandler.ts
var canvasPos = createVec2();
var getCanvasPosFromEvent3 = function(event, canvasPos2) {
  if (!event) {
    event = window.event;
    canvasPos2[0] = event.x;
    canvasPos2[1] = event.y;
  } else {
    let element = event.target;
    let totalOffsetLeft = 0;
    let totalOffsetTop = 0;
    let totalScrollX = 0;
    let totalScrollY = 0;
    while (element.offsetParent) {
      totalOffsetLeft += element.offsetLeft;
      totalOffsetTop += element.offsetTop;
      totalScrollX += element.scrollLeft;
      totalScrollY += element.scrollTop;
      element = element.offsetParent;
    }
    canvasPos2[0] = event.pageX + totalScrollX - totalOffsetLeft;
    canvasPos2[1] = event.pageY + totalScrollY - totalOffsetTop;
  }
  return canvasPos2;
};
var MousePanRotateDollyHandler = class {
  #canvasMouseMoveHandler;
  #documentKeyDownHandler;
  #documentKeyUpHandler;
  #view;
  #documentMouseUpHandler;
  #mouseEnterHandler;
  #mouseDownHandler;
  #documentMouseMoveHandler;
  #mouseUpHandler;
  #mouseWheelHandler;
  constructor(view, controllers, configs, states, updates) {
    this.#view = view;
    const pickController = controllers.pickController;
    let lastX = 0;
    let lastY = 0;
    let lastXDown = 0;
    let lastYDown = 0;
    let xRotateDelta = 0;
    let yRotateDelta = 0;
    let mouseDownLeft;
    let mouseDownMiddle;
    let mouseDownRight;
    let mouseDownPicked = false;
    const pickedWorldPos = createVec3();
    let mouseMovedOnCanvasSinceLastWheel = true;
    const htmlElement = this.#view.htmlElement;
    const keyDown = [];
    document.addEventListener("keydown", this.#documentKeyDownHandler = (e) => {
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
      const keyCode = e.keyCode;
      keyDown[keyCode] = true;
    });
    document.addEventListener("keyup", this.#documentKeyUpHandler = (e) => {
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
      const keyCode = e.keyCode;
      keyDown[keyCode] = false;
    });
    function setMousedownState(pick = true) {
      htmlElement.style.cursor = "move";
      setMousedownPositions();
      if (pick) {
        setMousedownPick();
      }
    }
    function setMousedownPositions() {
      xRotateDelta = 0;
      yRotateDelta = 0;
      lastX = states.pointerCanvasPos[0];
      lastY = states.pointerCanvasPos[1];
      lastXDown = states.pointerCanvasPos[0];
      lastYDown = states.pointerCanvasPos[1];
    }
    function setMousedownPick() {
      pickController.pickCursorPos = states.pointerCanvasPos;
      pickController.schedulePickSurface = true;
      pickController.update();
      if (pickController.picked && pickController.pickedSurface && pickController.pickResult && pickController.pickResult.worldPos) {
        mouseDownPicked = true;
        pickedWorldPos.set(pickController.pickResult.worldPos);
      } else {
        mouseDownPicked = false;
      }
    }
    htmlElement.addEventListener("mousedown", this.#mouseDownHandler = (e) => {
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
      switch (e.which) {
        case 1:
          if (keyDown[KEY_SHIFT] || configs.planView) {
            mouseDownLeft = true;
            setMousedownState();
          } else {
            mouseDownLeft = true;
            setMousedownState(false);
          }
          break;
        case 2:
          mouseDownMiddle = true;
          setMousedownState();
          break;
        case 3:
          mouseDownRight = true;
          if (configs.panRightClick) {
            setMousedownState();
          }
          break;
        default:
          break;
      }
    });
    document.addEventListener("mousemove", this.#documentMouseMoveHandler = (e) => {
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
      if (!mouseDownLeft && !mouseDownMiddle && !mouseDownRight) {
        return;
      }
      const canvasBoundary = view.boundary;
      const canvasWidth = canvasBoundary[2];
      const canvasHeight = canvasBoundary[3];
      const x = states.pointerCanvasPos[0];
      const y = states.pointerCanvasPos[1];
      const panning = keyDown[KEY_SHIFT] || configs.planView || !configs.panRightClick && mouseDownMiddle || configs.panRightClick && mouseDownRight;
      const xDelta = document.pointerLockElement ? e.movementX : x - lastX;
      const yDelta = document.pointerLockElement ? e.movementY : y - lastY;
      if (panning) {
        const camera = view.camera;
        if (camera.projectionType === PerspectiveProjectionType) {
          const depth = Math.abs(mouseDownPicked ? lenVec3(subVec3(pickedWorldPos, view.camera.eye, [])) : view.camera.eyeLookDist);
          const targetDistance = depth * Math.tan(camera.perspectiveProjection.fov / 2 * Math.PI / 180);
          updates.panDeltaX += 1.5 * xDelta * targetDistance / canvasHeight;
          updates.panDeltaY += 1.5 * yDelta * targetDistance / canvasHeight;
        } else {
          updates.panDeltaX += 0.5 * camera.orthoProjection.scale * (xDelta / canvasHeight);
          updates.panDeltaY += 0.5 * camera.orthoProjection.scale * (yDelta / canvasHeight);
        }
      } else if (mouseDownLeft && !mouseDownMiddle && !mouseDownRight) {
        if (!configs.planView) {
          if (configs.firstPerson) {
            updates.rotateDeltaY -= xDelta / canvasWidth * configs.dragRotationRate / 2;
            updates.rotateDeltaX += yDelta / canvasHeight * (configs.dragRotationRate / 4);
          } else {
            updates.rotateDeltaY -= xDelta / canvasWidth * (configs.dragRotationRate * 1.5);
            updates.rotateDeltaX += yDelta / canvasHeight * (configs.dragRotationRate * 1.5);
          }
        }
      }
      lastX = x;
      lastY = y;
    });
    htmlElement.addEventListener("mousemove", this.#canvasMouseMoveHandler = (e) => {
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
      if (!states.mouseover) {
        return;
      }
      mouseMovedOnCanvasSinceLastWheel = true;
    });
    document.addEventListener("mouseup", this.#documentMouseUpHandler = (e) => {
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
      switch (e.which) {
        case 1:
          mouseDownLeft = false;
          mouseDownMiddle = false;
          mouseDownRight = false;
          break;
        case 2:
          mouseDownLeft = false;
          mouseDownMiddle = false;
          mouseDownRight = false;
          break;
        case 3:
          mouseDownLeft = false;
          mouseDownMiddle = false;
          mouseDownRight = false;
          break;
        default:
          break;
      }
      xRotateDelta = 0;
      yRotateDelta = 0;
    });
    htmlElement.addEventListener("mouseup", this.#mouseUpHandler = (e) => {
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
      switch (e.which) {
        case 3:
          getCanvasPosFromEvent3(e, canvasPos);
          const x = canvasPos[0];
          const y = canvasPos[1];
          if (Math.abs(x - lastXDown) < 3 && Math.abs(y - lastYDown) < 3) {
            controllers.cameraControl.fire("rightClick", {
              // For context menus
              pagePos: [Math.round(e.pageX), Math.round(e.pageY)],
              canvasPos,
              event: e
            }, true);
          }
          break;
        default:
          break;
      }
      htmlElement.style.removeProperty("cursor");
    });
    htmlElement.addEventListener("mouseenter", this.#mouseEnterHandler = () => {
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
      xRotateDelta = 0;
      yRotateDelta = 0;
    });
    const maxElapsed = 1 / 20;
    const minElapsed = 1 / 60;
    let secsNowLast = null;
    htmlElement.addEventListener("wheel", this.#mouseWheelHandler = (e) => {
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
      const secsNow = performance.now() / 1e3;
      var secsElapsed = secsNowLast !== null ? secsNow - secsNowLast : 0;
      secsNowLast = secsNow;
      if (secsElapsed > maxElapsed) {
        secsElapsed = maxElapsed;
      }
      if (secsElapsed < minElapsed) {
        secsElapsed = minElapsed;
      }
      const delta = Math.max(-1, Math.min(1, -e.deltaY * 40));
      if (delta === 0) {
        return;
      }
      const normalizedDelta = delta / Math.abs(delta);
      updates.dollyDelta += -normalizedDelta * secsElapsed * configs.mouseWheelDollyRate;
      if (mouseMovedOnCanvasSinceLastWheel) {
        states.followPointerDirty = true;
        mouseMovedOnCanvasSinceLastWheel = false;
      }
    }, { passive: true });
  }
  reset() {
  }
  destroy() {
    const htmlElement = this.#view.htmlElement;
    document.removeEventListener("keydown", this.#documentKeyDownHandler);
    document.removeEventListener("keyup", this.#documentKeyUpHandler);
    htmlElement.removeEventListener("mousedown", this.#mouseDownHandler);
    document.removeEventListener("mousemove", this.#documentMouseMoveHandler);
    htmlElement.removeEventListener("mousemove", this.#canvasMouseMoveHandler);
    document.removeEventListener("mouseup", this.#documentMouseUpHandler);
    htmlElement.removeEventListener("mouseup", this.#mouseUpHandler);
    htmlElement.removeEventListener("mouseenter", this.#mouseEnterHandler);
    htmlElement.removeEventListener("wheel", this.#mouseWheelHandler);
  }
};

// ../sdk/src/cameracontrol/KeyboardAxisViewHandler.ts
var center = createVec3();
var tempVec3a11 = createVec3();
var tempVec3b11 = createVec3();
var tempVec3c9 = createVec3();
var tempVec3d4 = createVec3();
var tempCameraTarget = {
  eye: createVec3(),
  look: createVec3(),
  up: createVec3()
};
var KeyboardAxisViewHandler = class {
  #view;
  constructor(view, controllers, configs, states, updates) {
    this.#view = view;
  }
  reset() {
  }
  destroy() {
  }
};

// ../sdk/src/cameracontrol/MousePickHandler.ts
var MousePickHandler = class {
  #view;
  #clicks;
  #timeout;
  #lastPickedEntityId;
  #canvasMouseDownHandler;
  #canvasMouseMoveHandler;
  #canvasMouseUpHandler;
  #documentMouseUpHandler;
  constructor(view, controllers, configs, states, updates) {
    this.#view = view;
    const pickController = controllers.pickController;
    const pivotController = controllers.pivotController;
    const cameraControl = controllers.cameraControl;
    this.#clicks = 0;
    this.#timeout = null;
    this.#lastPickedEntityId = null;
    let leftDown = false;
    let rightDown = false;
    const htmlElement = this.#view.htmlElement;
    const flyCameraTo = (pickResult) => {
      let pos;
      if (pickResult && pickResult.worldPos) {
        pos = pickResult.worldPos;
      }
      const aabb = pickResult && pickResult.viewObject ? pickResult.viewObject.aabb : view.aabb;
      if (pos) {
        const camera = view.camera;
        const diff = subVec3(camera.eye, camera.look, []);
        controllers.cameraFlight.flyTo({
          // look: pos,
          // eye: xeokit.addVec3(pos, diff, []),
          // up: camera.up,
          aabb
        });
      } else {
        controllers.cameraFlight.flyTo({
          aabb
        });
      }
    };
    const tickifiedMouseMoveFn = view.viewer.tickify(
      this.#canvasMouseMoveHandler = (e) => {
        if (!(configs.active && configs.pointerEnabled)) {
          return;
        }
        if (leftDown || rightDown) {
          return;
        }
        if (cameraControl.onRayMove.count > 0) {
          const origin = createVec3();
          const direction = createVec3();
          canvasPosToWorldRay(view.htmlElement, view.camera.viewMatrix, view.camera.projMatrix, view.camera.projection, states.pointerCanvasPos, origin, direction);
          cameraControl.onRayMove.dispatch(cameraControl, {
            canvasPos: states.pointerCanvasPos,
            ray: {
              origin,
              direction,
              canvasPos: states.pointerCanvasPos
            }
          });
        }
        const hoverSubs = cameraControl.onHover.count > 0;
        const hoverEnterSubs = cameraControl.onHoverEnter.count > 0;
        const hoverOutSubs = cameraControl.onHoverOut.count > 0;
        const hoverOffSubs = cameraControl.onHoverOff.count > 0;
        const hoverSurfaceSubs = cameraControl.onHoverSurface.count > 0;
        const hoverSnapOrSurfaceSubs = cameraControl.onHoverSnapOrSurface.count > 0;
        if (hoverSubs || hoverEnterSubs || hoverOutSubs || hoverOffSubs || hoverSurfaceSubs || hoverSnapOrSurfaceSubs) {
          pickController.pickCursorPos = states.pointerCanvasPos;
          pickController.schedulePickEntity = true;
          pickController.schedulePickSurface = hoverSurfaceSubs;
          pickController.scheduleSnapOrPick = hoverSnapOrSurfaceSubs;
          pickController.update();
          if (pickController.pickResult) {
            if (pickController.pickResult.viewObject) {
              const pickedEntityId = pickController.pickResult.viewObject.id;
              if (this.#lastPickedEntityId !== pickedEntityId) {
                if (this.#lastPickedEntityId !== void 0) {
                  cameraControl.onHoverOut.dispatch(cameraControl, {
                    // Hovered off an entity
                    viewObject: view.objects[this.#lastPickedEntityId]
                  });
                }
                cameraControl.onHoverEnter.dispatch(cameraControl, pickController.pickResult);
                this.#lastPickedEntityId = pickedEntityId;
              }
            }
            cameraControl.onHover.dispatch(cameraControl, pickController.pickResult);
            if (pickController.pickResult.worldPos || pickController.pickResult.snappedWorldPos) {
              cameraControl.onHoverSurface.dispatch(cameraControl, pickController.pickResult);
            }
          } else {
            if (this.#lastPickedEntityId !== void 0) {
              cameraControl.onHoverOut.dispatch(cameraControl, {
                // Hovered off an entity
                viewObject: view.objects[this.#lastPickedEntityId]
              });
              this.#lastPickedEntityId = void 0;
            }
            cameraControl.onHoverOff.dispatch(cameraControl, {
              // Not hovering on any entity
              canvasPos: pickController.pickCursorPos
            });
          }
        }
      }
    );
    htmlElement.addEventListener("mousemove", tickifiedMouseMoveFn);
    htmlElement.addEventListener("mousedown", this.#canvasMouseDownHandler = (e) => {
      if (e.which === 1) {
        leftDown = true;
      }
      if (e.which === 3) {
        rightDown = true;
      }
      const leftButtonDown = e.which === 1;
      if (!leftButtonDown) {
        return;
      }
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
      states.mouseDownClientX = e.clientX;
      states.mouseDownClientY = e.clientY;
      states.mouseDownCursorX = states.pointerCanvasPos[0];
      states.mouseDownCursorY = states.pointerCanvasPos[1];
      if (!configs.firstPerson && configs.followPointer) {
        pickController.pickCursorPos = states.pointerCanvasPos;
        pickController.schedulePickSurface = true;
        pickController.update();
        if (e.which === 1) {
          const pickResult = pickController.pickResult;
          if (pickResult && pickResult.worldPos) {
            pivotController.setPivotPos(pickResult.worldPos);
            pivotController.startPivot();
          } else {
            if (configs.smartPivot) {
              pivotController.setCanvasPivotPos(states.pointerCanvasPos);
            } else {
              pivotController.setPivotPos(view.camera.look);
            }
            pivotController.startPivot();
          }
        }
      }
    });
    document.addEventListener("mouseup", this.#documentMouseUpHandler = (e) => {
      if (e.which === 1) {
        leftDown = false;
      }
      if (e.which === 3) {
        rightDown = false;
      }
      if (pivotController.getPivoting()) {
        pivotController.endPivot();
      }
    });
    htmlElement.addEventListener("mouseup", this.#canvasMouseUpHandler = (e) => {
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
      const leftButtonUp = e.which === 1;
      if (!leftButtonUp) {
        return;
      }
      pivotController.hidePivot();
      if (Math.abs(e.clientX - states.mouseDownClientX) > 3 || Math.abs(e.clientY - states.mouseDownClientY) > 3) {
        return;
      }
      const pickedSubs = cameraControl.onPicked.count > 0;
      const pickedNothingSubs = cameraControl.onPickedNothing.count > 0;
      const pickedSurfaceSubs = cameraControl.onPickedSurface.count > 0;
      const doublePickedSubs = cameraControl.onDoublePicked.count > 0;
      const doublePickedSurfaceSubs = cameraControl.onDoublePickedSurface.count > 0;
      const doublePickedNothingSubs = cameraControl.onDoublePickedNothing.count > 0;
      if (!configs.doublePickFlyTo && !doublePickedSubs && !doublePickedSurfaceSubs && !doublePickedNothingSubs) {
        if (pickedSubs || pickedNothingSubs || pickedSurfaceSubs) {
          pickController.pickCursorPos = states.pointerCanvasPos;
          pickController.schedulePickEntity = true;
          pickController.schedulePickSurface = pickedSurfaceSubs;
          pickController.update();
          if (pickController.pickResult) {
            cameraControl.onPicked.dispatch(cameraControl, pickController.pickResult);
            if (pickController.pickedSurface) {
              cameraControl.onPickedSurface.dispatch(cameraControl, pickController.pickResult);
            }
          } else {
            cameraControl.onPickedNothing(cameraControl, {
              canvasPos: states.pointerCanvasPos
            });
          }
        }
        this.#clicks = 0;
        return;
      }
      this.#clicks++;
      if (this.#clicks === 1) {
        pickController.pickCursorPos = states.pointerCanvasPos;
        pickController.schedulePickEntity = configs.doublePickFlyTo;
        pickController.schedulePickSurface = pickedSurfaceSubs;
        pickController.update();
        const firstClickPickResult = pickController.pickResult;
        const firstClickPickSurface = pickController.pickedSurface;
        this.#timeout = setTimeout(() => {
          if (firstClickPickResult && firstClickPickResult.worldPos) {
            cameraControl.onPicked.dispatch(cameraControl, firstClickPickResult);
            if (firstClickPickSurface) {
              cameraControl.onPickedSurface.dispatch(cameraControl, firstClickPickResult);
              if (!configs.firstPerson && configs.followPointer) {
                controllers.pivotController.setPivotPos(firstClickPickResult.worldPos);
                if (controllers.pivotController.startPivot()) {
                  controllers.pivotController.showPivot();
                }
              }
            }
          } else {
            cameraControl.onPickedNothing.dispatch(cameraControl, {
              canvasPos: states.pointerCanvasPos
            });
          }
          this.#clicks = 0;
        }, configs.doubleClickTimeFrame);
      } else {
        if (this.#timeout !== null) {
          window.clearTimeout(this.#timeout);
          this.#timeout = null;
        }
        pickController.pickCursorPos = states.pointerCanvasPos;
        pickController.schedulePickEntity = configs.doublePickFlyTo || doublePickedSubs || doublePickedSurfaceSubs;
        pickController.schedulePickSurface = pickController.schedulePickEntity && doublePickedSurfaceSubs;
        pickController.update();
        if (pickController.pickResult) {
          cameraControl.onDoublePicked.dispatch(cameraControl, pickController.pickResult);
          if (pickController.pickedSurface) {
            cameraControl.onDoublePickedSurface.dispatch(cameraControl, pickController.pickResult);
          }
          if (configs.doublePickFlyTo) {
            flyCameraTo(pickController.pickResult);
            if (!configs.firstPerson && configs.followPointer) {
              const pickedEntityAABB = pickController.pickResult.viewObject.aabb;
              const pickedEntityCenterPos = getAABB3Center(pickedEntityAABB);
              controllers.pivotController.setPivotPos(pickedEntityCenterPos);
              if (controllers.pivotController.startPivot()) {
                controllers.pivotController.showPivot();
              }
            }
          }
        } else {
          cameraControl.onDoublePickedNothing.dispatch(cameraControl, {
            canvasPos: states.pointerCanvasPos
          });
          if (configs.doublePickFlyTo) {
            flyCameraTo();
            if (!configs.firstPerson && configs.followPointer) {
              const sceneAABB = view.aabb;
              const sceneCenterPos = getAABB3Center(sceneAABB);
              controllers.pivotController.setPivotPos(sceneCenterPos);
              if (controllers.pivotController.startPivot()) {
                controllers.pivotController.showPivot();
              }
            }
          }
        }
        this.#clicks = 0;
      }
    }, false);
  }
  reset() {
    this.#clicks = 0;
    this.#lastPickedEntityId = null;
    if (this.#timeout) {
      window.clearTimeout(this.#timeout);
      this.#timeout = null;
    }
  }
  destroy() {
    const htmlElement = this.#view.htmlElement;
    htmlElement.removeEventListener("mousemove", this.#canvasMouseMoveHandler);
    htmlElement.removeEventListener("mousedown", this.#canvasMouseDownHandler);
    document.removeEventListener("mouseup", this.#documentMouseUpHandler);
    htmlElement.removeEventListener("mouseup", this.#canvasMouseUpHandler);
    if (this.#timeout) {
      window.clearTimeout(this.#timeout);
      this.#timeout = null;
    }
  }
};

// ../sdk/src/cameracontrol/TouchPickHandler.ts
var TAP_INTERVAL = 150;
var DBL_TAP_INTERVAL = 325;
var TAP_DISTANCE_THRESHOLD = 4;
var getCanvasPosFromEvent4 = function(event, canvasPos2) {
  if (!event) {
    event = window.event;
    canvasPos2[0] = event.x;
    canvasPos2[1] = event.y;
  } else {
    let element = event.target;
    let totalOffsetLeft = 0;
    let totalOffsetTop = 0;
    while (element.offsetParent) {
      totalOffsetLeft += element.offsetLeft;
      totalOffsetTop += element.offsetTop;
      element = element.offsetParent;
    }
    canvasPos2[0] = event.pageX - totalOffsetLeft;
    canvasPos2[1] = event.pageY - totalOffsetTop;
  }
  return canvasPos2;
};
var TouchPickHandler = class {
  #view;
  #canvasTouchStartHandler;
  #canvasTouchEndHandler;
  constructor(view, controllers, configs, states, updates) {
    this.#view = view;
    const pickController = controllers.pickController;
    const cameraControl = controllers.cameraControl;
    let touchStartTime;
    const activeTouches = [];
    const tapStartPos = new Float32Array(2);
    let tapStartTime = -1;
    let lastTapTime = -1;
    const htmlElement = this.#view.htmlElement;
    const flyCameraTo = (pickResult) => {
      let pos;
      if (pickResult && pickResult.worldPos) {
        pos = pickResult.worldPos;
      }
      const aabb = pickResult ? pickResult.viewObject.aabb : view.aabb;
      if (pos) {
        const camera = view.camera;
        const diff = subVec3(camera.eye, camera.look, []);
        controllers.cameraFlight.flyTo({
          aabb
        });
      } else {
        controllers.cameraFlight.flyTo({
          aabb
        });
      }
    };
    htmlElement.addEventListener("touchstart", this.#canvasTouchStartHandler = (e) => {
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
      if (states.longTouchTimeout !== null) {
        clearTimeout(states.longTouchTimeout);
        states.longTouchTimeout = null;
      }
      const touches = e.touches;
      const changedTouches = e.changedTouches;
      touchStartTime = Date.now();
      if (touches.length === 1 && changedTouches.length === 1) {
        tapStartTime = touchStartTime;
        getCanvasPosFromEvent4(touches[0], tapStartPos);
        const rightClickClientX = tapStartPos[0];
        const rightClickClientY = tapStartPos[1];
        const rightClickPageX = touches[0].pageX;
        const rightClickPageY = touches[0].pageY;
        states.longTouchTimeout = setTimeout(() => {
          controllers.cameraControl.fire("rightClick", {
            // For context menus
            pagePos: [Math.round(rightClickPageX), Math.round(rightClickPageY)],
            canvasPos: [Math.round(rightClickClientX), Math.round(rightClickClientY)],
            event: e
          }, true);
          states.longTouchTimeout = null;
        }, configs.longTapTimeout);
      } else {
        tapStartTime = -1;
      }
      while (activeTouches.length < touches.length) {
        activeTouches.push(new Float32Array(2));
      }
      for (let i = 0, len = touches.length; i < len; ++i) {
        getCanvasPosFromEvent4(touches[i], activeTouches[i]);
      }
      activeTouches.length = touches.length;
    }, { passive: true });
    htmlElement.addEventListener("touchend", this.#canvasTouchEndHandler = (e) => {
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
      const currentTime = Date.now();
      const touches = e.touches;
      const changedTouches = e.changedTouches;
      const pickedSurfaceSubs = cameraControl.hasSubs("pickedSurface");
      if (states.longTouchTimeout !== null) {
        clearTimeout(states.longTouchTimeout);
        states.longTouchTimeout = null;
      }
      if (touches.length === 0 && changedTouches.length === 1) {
        if (tapStartTime > -1 && currentTime - tapStartTime < TAP_INTERVAL) {
          if (lastTapTime > -1 && tapStartTime - lastTapTime < DBL_TAP_INTERVAL) {
            getCanvasPosFromEvent4(changedTouches[0], pickController.pickCursorPos);
            pickController.schedulePickEntity = true;
            pickController.schedulePickSurface = pickedSurfaceSubs;
            pickController.update();
            if (pickController.pickResult) {
              pickController.pickResult.touchInput = true;
              cameraControl.fire("doublePicked", pickController.pickResult);
              if (pickController.pickedSurface) {
                cameraControl.fire("doublePickedSurface", pickController.pickResult);
              }
              if (configs.doublePickFlyTo) {
                flyCameraTo(pickController.pickResult);
              }
            } else {
              cameraControl.fire("doublePickedNothing");
              if (configs.doublePickFlyTo) {
                flyCameraTo();
              }
            }
            lastTapTime = -1;
          } else if (distVec2(activeTouches[0], tapStartPos) < TAP_DISTANCE_THRESHOLD) {
            getCanvasPosFromEvent4(changedTouches[0], pickController.pickCursorPos);
            pickController.schedulePickEntity = true;
            pickController.schedulePickSurface = pickedSurfaceSubs;
            pickController.update();
            if (pickController.pickResult) {
              pickController.pickResult.touchInput = true;
              cameraControl.fire("picked", pickController.pickResult);
              if (pickController.pickedSurface) {
                cameraControl.fire("pickedSurface", pickController.pickResult);
              }
            } else {
              cameraControl.fire("pickedNothing");
            }
            lastTapTime = currentTime;
          }
          tapStartTime = -1;
        }
      }
      activeTouches.length = touches.length;
      for (let i = 0, len = touches.length; i < len; ++i) {
        activeTouches[i][0] = touches[i].pageX;
        activeTouches[i][1] = touches[i].pageY;
      }
    }, { passive: true });
  }
  reset() {
  }
  destroy() {
    const htmlElement = this.#view.htmlElement;
    htmlElement.removeEventListener("touchstart", this.#canvasTouchStartHandler);
    htmlElement.removeEventListener("touchend", this.#canvasTouchEndHandler);
  }
};

// ../sdk/src/cameracontrol/KeyboardPanRotateDollyHandler.ts
var KeyboardPanRotateDollyHandler = class {
  #view;
  constructor(view, controllers, configs, states, updates) {
    this.#view = view;
    const keyDownMap = [];
  }
  reset() {
  }
  destroy() {
  }
};

// ../sdk/src/cameracontrol/CameraUpdater.ts
var SCALE_DOLLY_EACH_FRAME = 1;
var EPSILON2 = 1e-3;
var tempVec33 = createVec3();
var CameraUpdater = class {
  #view;
  #onTick;
  constructor(view, controllers, configs, states, updates) {
    this.#view = view;
    const camera = view.camera;
    const pickController = controllers.pickController;
    const pivotController = controllers.pivotController;
    const panController = controllers.panController;
    let countDown = SCALE_DOLLY_EACH_FRAME;
    let dollyDistFactor = 1;
    let followPointerWorldPos = null;
    this.#onTick = view.viewer.onTick.subscribe(() => {
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
      let cursorType = "default";
      if (Math.abs(updates.dollyDelta) < EPSILON2) {
        updates.dollyDelta = 0;
      }
      if (Math.abs(updates.rotateDeltaX) < EPSILON2) {
        updates.rotateDeltaX = 0;
      }
      if (Math.abs(updates.rotateDeltaY) < EPSILON2) {
        updates.rotateDeltaY = 0;
      }
      if (updates.rotateDeltaX !== 0 || updates.rotateDeltaY !== 0) {
        updates.dollyDelta = 0;
      }
      if (configs.followPointer) {
        if (--countDown <= 0) {
          countDown = SCALE_DOLLY_EACH_FRAME;
          if (updates.dollyDelta !== 0) {
            if (updates.rotateDeltaY === 0 && updates.rotateDeltaX === 0) {
              if (configs.followPointer && states.followPointerDirty) {
                pickController.pickCursorPos = states.pointerCanvasPos;
                pickController.schedulePickSurface = true;
                pickController.update();
                if (pickController.pickResult && pickController.pickResult.worldPos) {
                  followPointerWorldPos = pickController.pickResult.worldPos;
                } else {
                  dollyDistFactor = 1;
                  followPointerWorldPos = null;
                }
                states.followPointerDirty = false;
              }
            }
            if (followPointerWorldPos) {
              const dist = Math.abs(lenVec3(subVec3(followPointerWorldPos, view.camera.eye, tempVec33)));
              dollyDistFactor = dist / configs.dollyProximityThreshold;
            }
            if (dollyDistFactor < configs.dollyMinSpeed) {
              dollyDistFactor = configs.dollyMinSpeed;
            }
          }
        }
      } else {
        dollyDistFactor = 1;
        followPointerWorldPos = null;
      }
      const dollyDeltaForDist = updates.dollyDelta * dollyDistFactor;
      if (updates.rotateDeltaY !== 0 || updates.rotateDeltaX !== 0) {
        if (!configs.firstPerson && configs.followPointer && pivotController.getPivoting()) {
          pivotController.continuePivot(updates.rotateDeltaY, updates.rotateDeltaX);
          pivotController.showPivot();
        } else {
          if (updates.rotateDeltaX !== 0) {
            if (configs.firstPerson) {
              camera.pitch(-updates.rotateDeltaX);
            } else {
              camera.orbitPitch(updates.rotateDeltaX);
            }
          }
          if (updates.rotateDeltaY !== 0) {
            if (configs.firstPerson) {
              camera.yaw(updates.rotateDeltaY);
            } else {
              camera.orbitYaw(updates.rotateDeltaY);
            }
          }
        }
        updates.rotateDeltaX *= configs.rotationInertia;
        updates.rotateDeltaY *= configs.rotationInertia;
        cursorType = "grabbing";
      }
      if (Math.abs(updates.panDeltaX) < EPSILON2) {
        updates.panDeltaX = 0;
      }
      if (Math.abs(updates.panDeltaY) < EPSILON2) {
        updates.panDeltaY = 0;
      }
      if (Math.abs(updates.panDeltaZ) < EPSILON2) {
        updates.panDeltaZ = 0;
      }
      if (updates.panDeltaX !== 0 || updates.panDeltaY !== 0 || updates.panDeltaZ !== 0) {
        const vec = createVec3();
        vec[0] = updates.panDeltaX;
        vec[1] = updates.panDeltaY;
        vec[2] = updates.panDeltaZ;
        let verticalEye;
        let verticalLook;
        if (configs.constrainVertical) {
          if (camera.xUp) {
            verticalEye = camera.eye[0];
            verticalLook = camera.look[0];
          } else if (camera.yUp) {
            verticalEye = camera.eye[1];
            verticalLook = camera.look[1];
          } else if (camera.zUp) {
            verticalEye = camera.eye[2];
            verticalLook = camera.look[2];
          }
          camera.pan(vec);
          const eye = camera.eye;
          const look = camera.look;
          if (camera.xUp) {
            eye[0] = verticalEye;
            look[0] = verticalLook;
          } else if (camera.yUp) {
            eye[1] = verticalEye;
            look[1] = verticalLook;
          } else if (camera.zUp) {
            eye[2] = verticalEye;
            look[2] = verticalLook;
          }
          camera.eye = eye;
          camera.look = look;
        } else {
          camera.pan(vec);
        }
        cursorType = "grabbing";
      }
      updates.panDeltaX *= configs.panInertia;
      updates.panDeltaY *= configs.panInertia;
      updates.panDeltaZ *= configs.panInertia;
      if (dollyDeltaForDist !== 0) {
        if (dollyDeltaForDist < 0) {
          cursorType = "zoom-in";
        } else {
          cursorType = "zoom-out";
        }
        if (configs.firstPerson) {
          let verticalEye;
          let verticalLook;
          if (configs.constrainVertical) {
            if (camera.xUp) {
              verticalEye = camera.eye[0];
              verticalLook = camera.look[0];
            } else if (camera.yUp) {
              verticalEye = camera.eye[1];
              verticalLook = camera.look[1];
            } else if (camera.zUp) {
              verticalEye = camera.eye[2];
              verticalLook = camera.look[2];
            }
          }
          if (configs.followPointer) {
            const dolliedThroughSurface = panController.dollyToCanvasPos(followPointerWorldPos, states.pointerCanvasPos, -dollyDeltaForDist);
            if (dolliedThroughSurface) {
              states.followPointerDirty = true;
            }
          } else {
            camera.pan([0, 0, dollyDeltaForDist]);
            camera.orthoProjection.scale = camera.orthoProjection.scale - dollyDeltaForDist;
          }
          if (configs.constrainVertical) {
            const eye = camera.eye;
            const look = camera.look;
            if (camera.xUp) {
              eye[0] = verticalEye;
              look[0] = verticalLook;
            } else if (camera.yUp) {
              eye[1] = verticalEye;
              look[1] = verticalLook;
            } else if (camera.zUp) {
              eye[2] = verticalEye;
              look[2] = verticalLook;
            }
            camera.eye = eye;
            camera.look = look;
          }
        } else if (configs.planView) {
          if (configs.followPointer) {
            const dolliedThroughSurface = panController.dollyToCanvasPos(followPointerWorldPos, states.pointerCanvasPos, -dollyDeltaForDist);
            if (dolliedThroughSurface) {
              states.followPointerDirty = true;
            }
          } else {
            camera.orthoProjection.scale = camera.orthoProjection.scale + dollyDeltaForDist;
            camera.zoom(dollyDeltaForDist);
          }
        } else {
          if (configs.followPointer) {
            const dolliedThroughSurface = panController.dollyToCanvasPos(followPointerWorldPos, states.pointerCanvasPos, -dollyDeltaForDist);
            if (dolliedThroughSurface) {
              states.followPointerDirty = true;
            }
          } else {
            camera.orthoProjection.scale = camera.orthoProjection.scale + dollyDeltaForDist;
            camera.zoom(dollyDeltaForDist);
          }
        }
        updates.dollyDelta *= configs.dollyInertia;
      }
      pickController.fireEvents();
      document.body.style.cursor = cursorType;
    });
  }
  destroy() {
    this.#view.viewer.onTick.unsub(this.#onTick);
  }
};

// ../sdk/src/cameracontrol/CameraControl.ts
var import_strongly_typed_events19 = __toESM(require_dist8());

// ../sdk/src/cameraflight/index.ts
var cameraflight_exports = {};
__export(cameraflight_exports, {
  CameraFlightAnimation: () => CameraFlightAnimation
});

// ../sdk/src/cameraflight/CameraFlightAnimation.ts
var import_strongly_typed_events18 = __toESM(require_dist8());
var tempVec34 = createVec3();
var newLook = createVec3();
var newEye = createVec3();
var newUp = createVec3();
var newLookEyeVec = createVec3();
var CameraFlightAnimation = class _CameraFlightAnimation extends Component {
  /**
   * The View that owns this CameraFlightAnimation.
   */
  view;
  /**
   * The Camera controlled by this CameraFlightAnimation.
   */
  camera;
  #duration;
  #look1;
  #eye1;
  #up1;
  #look2;
  #eye2;
  #up2;
  #orthoScale1;
  #orthoScale2;
  #fit;
  #trail;
  #flying;
  #flyEyeLookUp;
  #flyingEye;
  #flyingLook;
  #callback;
  #callbackScope;
  #time1;
  #time2;
  easing;
  #flyingEyeLookUp;
  #fitFOV;
  #projection2;
  #projMatrix1;
  #projMatrix2;
  /**
   * Emits an event each time the animation starts.
   */
  onStarted;
  /**
   * Emits an event each time the animation stops.
   */
  onStopped;
  /**
   * Emits an event each time the animation stops.
   */
  onCancelled;
  /**
   * Creates a new CameraFlightAnimation
   *
   * @param cfg.view The {@link viewer!View | View} whose {@link viewer!Camera | Camera} we'll animate.
   * @param cfg.duration Animation duration in seconds when using {@link cameraflight!CameraFlightAnimation.flyTo | CameraFlightAnimation.flyTo}.
   */
  constructor(view, cfg) {
    super(view, cfg);
    if (!(view instanceof View)) {
      throw "[CameraFlightAnimation] Expected instance of View";
    }
    this.view = view;
    this.camera = view.camera;
    this.#look1 = createVec3();
    this.#eye1 = createVec3();
    this.#up1 = createVec3();
    this.#look2 = createVec3();
    this.#eye2 = createVec3();
    this.#up2 = createVec3();
    this.#orthoScale1 = 1;
    this.#orthoScale2 = 1;
    this.#flying = false;
    this.#flyEyeLookUp = false;
    this.#flyingEye = false;
    this.#flyingLook = false;
    this.#callback = null;
    this.#callbackScope = null;
    this.#time1 = null;
    this.#time2 = null;
    this.easing = true;
    this.#trail = false;
    this.#fit = true;
    this.#duration = 500;
    this.#fitFOV = 60;
    this.onStarted = new EventEmitter(new import_strongly_typed_events18.EventDispatcher());
    this.onStopped = new EventEmitter(new import_strongly_typed_events18.EventDispatcher());
    this.onCancelled = new EventEmitter(new import_strongly_typed_events18.EventDispatcher());
  }
  /**
   * Flies the {@link viewer!Camera | Camera}  to a target.
   *
   *  * When the target is a boundary, the {@link viewer!Camera | Camera}  will fly towards the target and stop when the target fills most of the canvas.
   *  * When the target is an explicit {@link viewer!Camera | Camera}  position, given as ````eye````, ````look```` and ````up````, then CameraFlightAnimation will interpolate the {@link viewer!Camera | Camera}  to that target and stop there.
   *
   * @param {Object|Component} [params=Scene] Either a parameters object or a {@link core!Component | Component} subtype that has
   * an AABB. Defaults to the {@link scene!Scene | Scene}, which causes the {@link viewer!Camera | Camera}  to fit the Scene in view.
   * @param [params.arc=0] Factor in range ````[0..1]```` indicating how much the {@link viewer!Camera.eye | Camera.eye} position
   * will swing away from its {@link viewer!Camera.look | Camera.look} position as it flies to the target.
   * @param {Number|String|Component} [params.component] ID or instance of a component to fly to. Defaults to the entire {@link scene!Scene | Scene}.
   * @param [params.aabb] World-space axis-aligned bounding box (AABB) target to fly to.
   * @param [params.eye] Position to fly the eye position to.
   * @param [params.look] Position to fly the look position to.
   * @param [params.up] Position to fly the up vector to.
   * @param [params.projection] Projection type to transition into as we fly. Can be any of the values of {@link viewer!Camera.projectionType | Camera.projectionType | Camera.projectionType}.
   * @param [params.fit=true] Whether to fit the target to the view volume. Overrides {@link CameraFlightAnimation.fit | CameraFlightAnimation.fit}.
   * @param [params.fitFOV] How much of field-of-view, in degrees, that a target {@link viewer!ViewObject | ViewObject} or its AABB should
   * fill the canvas on arrival. Overrides {@link CameraFlightAnimation.fitFOV | CameraFlightAnimation.fitFOV}.
   * @param [params.duration] Flight duration in seconds.  Overrides {@link CameraFlightAnimation.duration | CameraFlightAnimation.duration}.
   * @param [params.orthoScale] Animate the Camera's orthographic scale to this target value. See {@link viewer!OrthoProjection.scale | OrthoProjection.scale}.
   * @param {Function} [callback] Callback fired on arrival.
   */
  flyTo(params2 = {}, callback) {
    if (this.#flying) {
      this.stop();
    }
    this.#flying = false;
    this.#flyingEye = false;
    this.#flyingLook = false;
    this.#flyingEyeLookUp = false;
    this.#callback = callback || function() {
    };
    const camera = this.camera;
    const flyToProjection = !!params2.projection && params2.projection !== camera.projectionType;
    this.#eye1[0] = camera.eye[0];
    this.#eye1[1] = camera.eye[1];
    this.#eye1[2] = camera.eye[2];
    this.#look1[0] = camera.look[0];
    this.#look1[1] = camera.look[1];
    this.#look1[2] = camera.look[2];
    this.#up1[0] = camera.up[0];
    this.#up1[1] = camera.up[1];
    this.#up1[2] = camera.up[2];
    this.#orthoScale1 = camera.orthoProjection.scale;
    this.#orthoScale2 = params2.orthoScale || this.#orthoScale1;
    let aabb;
    let eye;
    let look;
    let up;
    if (params2.aabb) {
      aabb = params2.aabb;
    } else if (params2.eye && params2.look || params2.up) {
      eye = params2.eye;
      look = params2.look;
      up = params2.up;
    } else if (params2.eye) {
      eye = params2.eye;
    } else if (params2.look) {
      look = params2.look;
    } else {
      if (!flyToProjection) {
        aabb = this.view.aabb;
      }
    }
    const poi = params2.poi;
    if (aabb) {
      if (aabb[3] < aabb[0] || aabb[4] < aabb[1] || aabb[5] < aabb[2]) {
        return;
      }
      if (aabb[3] === aabb[0] && aabb[4] === aabb[1] && aabb[5] === aabb[2]) {
        return;
      }
      aabb = aabb.slice();
      const aabbCenter = getAABB3Center(aabb);
      this.#look2 = poi || aabbCenter;
      const eyeLookVec2 = subVec3(this.#eye1, this.#look1, tempVec34);
      const eyeLookVecNorm2 = normalizeVec3(eyeLookVec2);
      const diag = poi ? getAABB3DiagPoint(aabb, poi) : getAABB3Diag(aabb);
      const fitFOV = params2.fitFOV || this.#fitFOV;
      const sca = Math.abs(diag / Math.tan(fitFOV * DEGTORAD));
      this.#orthoScale2 = diag * 1.1;
      this.#eye2[0] = this.#look2[0] + eyeLookVecNorm2[0] * sca;
      this.#eye2[1] = this.#look2[1] + eyeLookVecNorm2[1] * sca;
      this.#eye2[2] = this.#look2[2] + eyeLookVecNorm2[2] * sca;
      this.#up2[0] = this.#up1[0];
      this.#up2[1] = this.#up1[1];
      this.#up2[2] = this.#up1[2];
      this.#flyingEyeLookUp = true;
    } else if (eye || look || up) {
      this.#flyingEyeLookUp = !!eye && !!look && !!up;
      this.#flyingEye = !!eye && !look;
      this.#flyingLook = !!look && !eye;
      if (eye) {
        this.#eye2[0] = eye[0];
        this.#eye2[1] = eye[1];
        this.#eye2[2] = eye[2];
      }
      if (look) {
        this.#look2[0] = look[0];
        this.#look2[1] = look[1];
        this.#look2[2] = look[2];
      }
      if (up) {
        this.#up2[0] = up[0];
        this.#up2[1] = up[1];
        this.#up2[2] = up[2];
      }
    }
    if (flyToProjection) {
      if (params2.projection === OrthoProjectionType && camera.projectionType !== OrthoProjectionType) {
        this.#projection2 = OrthoProjectionType;
        this.#projMatrix1 = camera.projMatrix.slice();
        this.#projMatrix2 = camera.orthoProjection.projMatrix.slice();
        camera.projectionType = CustomProjectionType;
      }
      if (params2.projection === PerspectiveProjectionType && camera.projectionType !== PerspectiveProjectionType) {
        this.#projection2 = PerspectiveProjectionType;
        this.#projMatrix1 = camera.projMatrix.slice();
        this.#projMatrix2 = camera.perspectiveProjection.projMatrix.slice();
        camera.projectionType = CustomProjectionType;
      }
    } else {
      this.#projection2 = null;
    }
    this.onStarted.dispatch(this, null);
    this.#time1 = Date.now();
    this.#time2 = this.#time1 + (params2.duration ? params2.duration * 1e3 : this.#duration);
    this.#flying = true;
    scheduler.scheduleTask(this.#update, this);
  }
  /**
   * Jumps the {@link viewer!Camera | Camera}  to the given target.
   *
   * * When the target is a boundary, this CameraFlightAnimation will position the {@link viewer!Camera | Camera}  at where the target fills most of the canvas.
   * * When the target is an explicit {@link viewer!Camera | Camera}  position, given as ````eye````, ````look```` and ````up```` vectors, then this CameraFlightAnimation will jump the {@link viewer!Camera | Camera}  to that target.
   *
   * @param {*|Component} params  Either a parameters object or a {@link core!Component | Component} subtype that has a World-space AABB.
   * @param [params.arc=0]  Factor in range [0..1] indicating how much the {@link viewer!Camera.eye | Camera.eye} will swing away from its {@link viewer!Camera.look | Camera.look} as it flies to the target.
   * @param {Number|String|Component} [params.component] ID or instance of a component to fly to.
   * @param [params.aabb]  World-space axis-aligned bounding box (AABB) target to fly to.
   * @param [params.eye] Position to fly the eye position to.
   * @param [params.look]  Position to fly the look position to.
   * @param [params.up] Position to fly the up vector to.
   * @param [params.projection] Projection type to transition into. Can be any of the values of {@link viewer!Camera.projectionType | Camera.projectionType}.
   * @param [params.fitFOV] How much of field-of-view, in degrees, that a target {@link viewer!Viewer | Viewer} or its AABB should fill the canvas on arrival. Overrides {@link CameraFlightAnimation.fitFOV}.
   * @param [params.fit] Whether to fit the target to the view volume. Overrides {@link cameraFlightAnimation.fit | CameraFlightAnimation.fit}.
   */
  jumpTo(params2) {
    this.#jumpTo(params2);
  }
  #jumpTo(params2) {
    if (this.#flying) {
      this.stop();
    }
    const camera = this.camera;
    let aabb;
    let newEye2;
    let newLook2;
    let newUp2;
    if (params2.aabb) {
      aabb = params2.aabb;
    } else if (params2.eye || params2.look || params2.up) {
      newEye2 = params2.eye;
      newLook2 = params2.look;
      newUp2 = params2.up;
    } else {
      aabb = this.view.aabb;
    }
    const poi = params2.poi;
    if (aabb) {
      if (aabb[3] <= aabb[0] || aabb[4] <= aabb[1] || aabb[5] <= aabb[2]) {
        return;
      }
      const diag = poi ? getAABB3DiagPoint(aabb, poi) : getAABB3Diag(aabb);
      newLook2 = poi || getAABB3Center(aabb, newLook2);
      if (this.#trail) {
        subVec3(camera.look, newLook2, newLookEyeVec);
      } else {
        subVec3(camera.eye, camera.look, newLookEyeVec);
      }
      normalizeVec3(newLookEyeVec);
      let dist;
      const fit = params2.fit !== void 0 ? params2.fit : this.#fit;
      if (fit) {
        dist = Math.abs(diag / Math.tan((params2.fitFOV || this.#fitFOV) * DEGTORAD));
      } else {
        dist = lenVec3(subVec3(camera.eye, camera.look, tempVec34));
      }
      mulVec3Scalar(newLookEyeVec, dist);
      camera.eye = addVec3(newLook2, newLookEyeVec, tempVec34);
      camera.look = newLook2;
      this.camera.orthoProjection.scale = diag * 1.1;
    } else if (newEye2 || newLook2 || newUp2) {
      if (newEye2) {
        camera.eye = newEye2;
      }
      if (newLook2) {
        camera.look = newLook2;
      }
      if (newUp2) {
        camera.up = newUp2;
      }
    }
    if (params2.projection) {
      camera.projectionType = params2.projection;
    }
  }
  #update() {
    if (!this.#flying) {
      return;
    }
    const time = Date.now();
    let t = (time - this.#time1) / (this.#time2 - this.#time1);
    const stopping = t >= 1;
    if (t > 1) {
      t = 1;
    }
    const tFlight = this.easing ? _CameraFlightAnimation.#ease(t, 0, 1, 1) : t;
    const camera = this.camera;
    if (this.#flyingEye || this.#flyingLook) {
      if (this.#flyingEye) {
        subVec3(camera.eye, camera.look, newLookEyeVec);
        camera.eye = lerpVec3(tFlight, 0, 1, this.#eye1, this.#eye2, newEye);
        camera.look = subVec3(newEye, newLookEyeVec, newLook);
      } else if (this.#flyingLook) {
        camera.look = lerpVec3(tFlight, 0, 1, this.#look1, this.#look2, newLook);
        camera.up = lerpVec3(tFlight, 0, 1, this.#up1, this.#up2, newUp);
      }
    } else if (this.#flyingEyeLookUp) {
      camera.eye = lerpVec3(tFlight, 0, 1, this.#eye1, this.#eye2, newEye);
      camera.look = lerpVec3(tFlight, 0, 1, this.#look1, this.#look2, newLook);
      camera.up = lerpVec3(tFlight, 0, 1, this.#up1, this.#up2, newUp);
    }
    if (this.#projection2) {
      const tProj = this.#projection2 === OrthoProjectionType ? _CameraFlightAnimation.#easeOutExpo(t, 0, 1, 1) : _CameraFlightAnimation.#easeInCubic(t, 0, 1, 1);
      camera.customProjection.projMatrix = lerpMat4(tProj, 0, 1, this.#projMatrix1, this.#projMatrix2);
    } else {
      camera.orthoProjection.scale = this.#orthoScale1 + t * (this.#orthoScale2 - this.#orthoScale1);
    }
    if (stopping) {
      camera.orthoProjection.scale = this.#orthoScale2;
      this.stop();
      return;
    }
    scheduler.scheduleTask(this.#update, this);
  }
  static #ease(t, b4, c2, d) {
    t /= d;
    return -c2 * t * (t - 2) + b4;
  }
  static #easeInCubic(t, b4, c2, d) {
    t /= d;
    return c2 * t * t * t + b4;
  }
  static #easeOutExpo(t, b4, c2, d) {
    return c2 * (-Math.pow(2, -10 * t / d) + 1) + b4;
  }
  /**
   * Stops an earlier {@link CameraFlightAnimation.flyTo | CameraFlightAnimation.flyTo}, fires arrival callback, then "stopped" event.
   */
  stop() {
    if (!this.#flying) {
      return;
    }
    this.#flying = false;
    this.#time1 = null;
    this.#time2 = null;
    if (this.#projection2) {
      this.camera.projectionType = this.#projection2;
    }
    const callback = this.#callback;
    if (callback) {
      this.#callback = null;
      callback();
    }
    this.onStopped.dispatch(this, null);
  }
  /**
   * Cancels a flight in progress, without calling the arrival callback.
   */
  cancel() {
    if (!this.#flying) {
      return;
    }
    this.#flying = false;
    this.#time1 = null;
    this.#time2 = null;
    if (this.#callback) {
      this.#callback = null;
    }
    this.onCancelled.dispatch(this, null);
  }
  /**
   * Sets the flight duration in seconds.
   *
   * Stops any flight currently in progress.
   *
   * Default value is ````0.5````.
   */
  set duration(value) {
    this.#duration = value ? value * 1e3 : 500;
    this.stop();
  }
  /**
   * Gets the flight duration in seconds.
   *
   * Default value is ````0.5````.
   */
  get duration() {
    return this.#duration / 1e3;
  }
  /**
   * When flying to a {@link scene!SceneModel | SceneModel}, {@link viewer!ViewObject | ViewObject} or boundary, indicates if the CameraFlightAnimation always adjusts
   * the distance of {@link viewer!Camera.eye | Camera.eye} from {@link viewer!Camera.look | Camera.look} to ensure that the target always fits in view.
   *
   * When false, the eye will remain fixed at its current distance from the look position.
   *
   * Default value is ````true````.
   */
  set fit(value) {
    this.#fit = value;
  }
  /**
   * When flying to a {@link scene!SceneModel | SceneModel}, {@link viewer!ViewObject | ViewObject} or boundary, indicates if the CameraFlightAnimation always adjusts
   * the distance of {@link viewer!Camera.eye | Camera.eye} from {@link viewer!Camera.look | Camera.look} to ensure that the target always fits in view.
   *
   * When false, the eye will remain fixed at its current distance from the look position.
   *
   * Default value is ````true````.
   */
  get fit() {
    return this.#fit;
  }
  /**
   * Sets how much of the perspective field-of-view, in degrees, that a target {@link viewer!ViewObject | ViewObject} should
   * fill the canvas when calling {@link CameraFlightAnimation.flyTo | CameraFlightAnimation.flyTo} or {@link CameraFlightAnimation.jumpTo | CameraFlightAnimation.jumpTo}.
   *
   * Default value is ````45````.
   */
  set fitFOV(value) {
    this.#fitFOV = value;
  }
  /**
   * Gets how much of the perspective field-of-view, in degrees, that a target {@link viewer!ViewObject | ViewObject} should
   * fill the canvas when calling {@link CameraFlightAnimation.flyTo | CameraFlightAnimation.flyTo} or {@link CameraFlightAnimation.jumpTo | CameraFlightAnimation.jumpTo}.
   *
   * Default value is ````45````.
   */
  get fitFOV() {
    return this.#fitFOV;
  }
  /**
   * Indicates if this CameraFlightAnimation will orient the {@link viewer!Camera | Camera}
   * in the direction that it is flying.
   *
   * Default value is ````false````.
   */
  set trail(value) {
    this.#trail = value;
  }
  /**
   * Indicates if this CameraFlightAnimation will orient the {@link viewer!Camera | Camera}
   * in the direction that it is flying.
   *
   * Default value is ````false````.
   */
  get trail() {
    return this.#trail;
  }
  /**
   * @private
   */
  destroy() {
    this.stop();
    super.destroy();
    this.onStarted.clear();
    this.onStopped.clear();
    this.onCancelled.clear();
  }
};

// ../sdk/src/cameracontrol/CameraControl.ts
var DEFAULT_SNAP_PICK_RADIUS = 30;
var DEFAULT_SNAP_VERTEX = true;
var DEFAULT_SNAP_EDGE = true;
var CameraControl = class _CameraControl extends Component {
  /**
   * Represents a leftward panning action.
   */
  static PAN_LEFT = 0;
  /**
   * Represents a rightward panning action.
   */
  static PAN_RIGHT = 1;
  /**
   * Represents an upward panning action.
   */
  static PAN_UP = 2;
  /**
   * Represents a downward panning action.
   */
  static PAN_DOWN = 3;
  /**
   * Represents a forward panning action.
   */
  static PAN_FORWARDS = 4;
  /**
   * Represents a backward panning action.
   */
  static PAN_BACKWARDS = 5;
  /**
   * Rotates the view clockwise around the X-axis.
   */
  static ROTATE_X_POS = 6;
  /**
   * Rotates the view counterclockwise around the X-axis.
   */
  static ROTATE_X_NEG = 7;
  /**
   * Rotates the view clockwise around the Y-axis.
   */
  static ROTATE_Y_POS = 8;
  /**
   * Rotates the view counterclockwise around the Y-axis.
   */
  static ROTATE_Y_NEG = 9;
  /**
   * Moves the camera forward (dolly in).
   */
  static DOLLY_FORWARDS = 10;
  /**
   * Moves the camera backward (dolly out).
   */
  static DOLLY_BACKWARDS = 11;
  /**
   * Positions the {@link viewer!Camera | Camera} to view the right side
   * of the entire extents of the {@link viewer!View | View}.
   */
  static AXIS_VIEW_RIGHT = 12;
  /**
   * Positions the {@link viewer!Camera | Camera} to view the back side
   * of the entire extents of the {@link viewer!View | View}.
   */
  static AXIS_VIEW_BACK = 13;
  /**
   * Positions the {@link viewer!Camera | Camera} to view the left side
   * of the entire extents of the {@link viewer!View | View}.
   */
  static AXIS_VIEW_LEFT = 14;
  /**
   * Positions the {@link viewer!Camera | Camera} to view the front side
   * of the entire extents of the {@link viewer!View | View}.
   */
  static AXIS_VIEW_FRONT = 15;
  /**
   * Positions the {@link viewer!Camera | Camera} to look downward
   * at the entire extents of the {@link viewer!View | View}.
   */
  static AXIS_VIEW_TOP = 16;
  /**
   * Positions the {@link viewer!Camera | Camera} to look upward from below
   * at the entire extents of the {@link viewer!View | View}.
   */
  static AXIS_VIEW_BOTTOM = 17;
  view;
  /**
   * Event fired when we right-click.
   *
   * @event
   */
  onRightClick;
  /**
   * Event fired when the pointer moves while over a {@link viewer!ViewObject}.
   *
   * @event
   */
  onHover;
  /**
   * Event fired when the pointer moves while over a {@link viewer!ViewObject}.
   *
   * @event
   */
  onHoverSurface;
  /**
   * Event fired when the pointer moves while over empty space.
   *
   * @event
   */
  onHoverOff;
  /**
   * Event fired when the pointer moves onto a {@link viewer!ViewObject}.
   *
   * @event
   */
  onHoverEnter;
  /**
   * Event fired when the pointer moves off a {@link viewer!ViewObject}.
   *
   * @event
   */
  onHoverOut;
  /**
   * Event fired when a {@link viewer!ViewObject} is picked.
   *
   * @event
   */
  onPicked;
  /**
   * Event fired when empty space is picked.
   *
   * @event
   */
  onPickedSurface;
  /**
   * Event fired when empty space is picked.
   *
   * @event
   */
  onPickedNothing;
  /**
   * Event fired when a ViewObject is double-picked.
   *
   * @event
   */
  onDoublePicked;
  /**
   * Event fired when a surface is double-picked.
   *
   * @event
   */
  onDoublePickedSurface;
  /**
   * Event fired when empty space is double-picked.
   *
   * @event
   */
  onDoublePickedNothing;
  /**
   * Event fired when snapping off a surface, vertex, or edge.
   *
   * @event
   */
  onHoverSnapOrSurfaceOff;
  /**
   * Event fired when snapping onto a surface, vertex, or edge.
   *
   * @event
   */
  onHoverSnapOrSurface;
  /**
   * Event fired when ray moves.
   *
   * @event
   */
  onRayMove;
  #configs;
  #states;
  #updates;
  #controllers;
  #handlers;
  #cameraUpdater;
  #keyMap;
  /**
   * @private
   *
   */
  constructor(view, cfg = {}) {
    super(view, cfg);
    this.#keyMap = {};
    this.view = view;
    this.view.htmlElement.oncontextmenu = (e) => {
      e.preventDefault();
    };
    this.#configs = {
      // Private
      longTapTimeout: 600,
      // Millisecs
      longTapRadius: 5,
      // Pixels
      // General
      active: true,
      navMode: OrbitNavigationMode,
      planView: false,
      firstPerson: false,
      followPointer: true,
      doublePickFlyTo: true,
      panRightClick: true,
      showPivot: false,
      pointerEnabled: true,
      constrainVertical: false,
      smartPivot: false,
      doubleClickTimeFrame: 250,
      snapToVertex: DEFAULT_SNAP_VERTEX,
      snapToEdge: DEFAULT_SNAP_EDGE,
      snapRadius: DEFAULT_SNAP_PICK_RADIUS,
      keyboardEnabledOnlyIfMouseover: true,
      // Rotation
      dragRotationRate: 360,
      keyboardRotationRate: 90,
      rotationInertia: 0,
      // Panning
      keyboardPanRate: 1,
      touchPanRate: 1,
      panInertia: 0.5,
      // Dollying
      keyboardDollyRate: 10,
      mouseWheelDollyRate: 100,
      touchDollyRate: 0.2,
      dollyInertia: 0,
      dollyProximityThreshold: 30,
      dollyMinSpeed: 0.04
    };
    this.#states = {
      pointerCanvasPos: createVec2(),
      mouseover: false,
      followPointerDirty: true,
      mouseDownClientX: 0,
      mouseDownClientY: 0,
      mouseDownCursorX: 0,
      mouseDownCursorY: 0,
      touchStartTime: null,
      activeTouches: [],
      tapStartPos: createVec2(),
      tapStartTime: -1,
      lastTapTime: -1,
      longTouchTimeout: null
    };
    this.#updates = {
      rotateDeltaX: 0,
      rotateDeltaY: 0,
      panDeltaX: 0,
      panDeltaY: 0,
      panDeltaZ: 0,
      dollyDelta: 0
    };
    this.#controllers = {
      cameraControl: this,
      pickController: new PickController(this, this.#configs),
      pivotController: new PivotController(view, this.#configs),
      panController: new PanController(view),
      cameraFlight: new CameraFlightAnimation(this.view, {
        duration: 0.5
      })
    };
    this.#handlers = [
      new MouseMiscHandler(this.view, this.#controllers, this.#configs, this.#states, this.#updates),
      new TouchPanRotateAndDollyHandler(this.view, this.#controllers, this.#configs, this.#states, this.#updates),
      new MousePanRotateDollyHandler(this.view, this.#controllers, this.#configs, this.#states, this.#updates),
      new KeyboardAxisViewHandler(this.view, this.#controllers, this.#configs, this.#states, this.#updates),
      new MousePickHandler(this.view, this.#controllers, this.#configs, this.#states, this.#updates),
      new TouchPickHandler(this.view, this.#controllers, this.#configs, this.#states, this.#updates),
      new KeyboardPanRotateDollyHandler(this.view, this.#controllers, this.#configs, this.#states, this.#updates)
    ];
    this.#cameraUpdater = new CameraUpdater(this.view, this.#controllers, this.#configs, this.#states, this.#updates);
    this.onHover = new EventEmitter(new import_strongly_typed_events19.EventDispatcher());
    this.onHoverOff = new EventEmitter(new import_strongly_typed_events19.EventDispatcher());
    this.onHoverEnter = new EventEmitter(new import_strongly_typed_events19.EventDispatcher());
    this.onHoverOut = new EventEmitter(new import_strongly_typed_events19.EventDispatcher());
    this.onRightClick = new EventEmitter(new import_strongly_typed_events19.EventDispatcher());
    this.onHoverSurface = new EventEmitter(new import_strongly_typed_events19.EventDispatcher());
    this.onPicked = new EventEmitter(new import_strongly_typed_events19.EventDispatcher());
    this.onPickedSurface = new EventEmitter(new import_strongly_typed_events19.EventDispatcher());
    this.onPickedNothing = new EventEmitter(new import_strongly_typed_events19.EventDispatcher());
    this.onDoublePicked = new EventEmitter(new import_strongly_typed_events19.EventDispatcher());
    this.onDoublePickedSurface = new EventEmitter(new import_strongly_typed_events19.EventDispatcher());
    this.onDoublePickedNothing = new EventEmitter(new import_strongly_typed_events19.EventDispatcher());
    this.onHoverSnapOrSurfaceOff = new EventEmitter(new import_strongly_typed_events19.EventDispatcher());
    this.onHoverSnapOrSurface = new EventEmitter(new import_strongly_typed_events19.EventDispatcher());
    this.onRayMove = new EventEmitter(new import_strongly_typed_events19.EventDispatcher());
    this.navMode = cfg.navMode;
    this.constrainVertical = cfg.constrainVertical;
    this.keyMap = cfg.keyMap;
    this.doublePickFlyTo = cfg.doublePickFlyTo;
    this.panRightClick = cfg.panRightClick;
    this.active = cfg.active;
    this.followPointer = cfg.followPointer;
    this.rotationInertia = cfg.rotationInertia;
    this.keyboardPanRate = cfg.keyboardPanRate;
    this.touchPanRate = cfg.touchPanRate;
    this.keyboardRotationRate = cfg.keyboardRotationRate;
    this.dragRotationRate = cfg.dragRotationRate;
    this.touchDollyRate = cfg.touchDollyRate;
    this.dollyInertia = cfg.dollyInertia;
    this.dollyProximityThreshold = cfg.dollyProximityThreshold;
    this.dollyMinSpeed = cfg.dollyMinSpeed;
    this.panInertia = cfg.panInertia;
    this.pointerEnabled = true;
    this.keyboardDollyRate = cfg.keyboardDollyRate;
    this.mouseWheelDollyRate = cfg.mouseWheelDollyRate;
  }
  /**
   * Sets custom mappings of keys to ````CameraControl```` actions.
   *
   * See class docs for usage.
   *
   * @param {{Number:Number}|String} value Either a set of new key mappings, or a string to select a keyboard layout,
   * which causes ````CameraControl```` to use the default key mappings for that layout.
   */
  set keyMap(value) {
    value = value || QWERTYLayout;
    if (isString(value)) {
      const keyMap = {};
      switch (value) {
        default:
          this.error("Unsupported value for 'keyMap': " + value + " defaulting to 'qwerty'");
        case QWERTYLayout:
          keyMap[_CameraControl.PAN_LEFT] = [KEY_A];
          keyMap[_CameraControl.PAN_RIGHT] = [KEY_D];
          keyMap[_CameraControl.PAN_UP] = [KEY_Z];
          keyMap[_CameraControl.PAN_DOWN] = [KEY_X];
          keyMap[_CameraControl.PAN_BACKWARDS] = [];
          keyMap[_CameraControl.PAN_FORWARDS] = [];
          keyMap[_CameraControl.DOLLY_FORWARDS] = [KEY_W, KEY_ADD];
          keyMap[_CameraControl.DOLLY_BACKWARDS] = [KEY_S, KEY_SUBTRACT];
          keyMap[_CameraControl.ROTATE_X_POS] = [KEY_DOWN_ARROW];
          keyMap[_CameraControl.ROTATE_X_NEG] = [KEY_UP_ARROW];
          keyMap[_CameraControl.ROTATE_Y_POS] = [KEY_Q, KEY_LEFT_ARROW];
          keyMap[_CameraControl.ROTATE_Y_NEG] = [KEY_E, KEY_RIGHT_ARROW];
          keyMap[_CameraControl.AXIS_VIEW_RIGHT] = [KEY_NUM_1];
          keyMap[_CameraControl.AXIS_VIEW_BACK] = [KEY_NUM_2];
          keyMap[_CameraControl.AXIS_VIEW_LEFT] = [KEY_NUM_3];
          keyMap[_CameraControl.AXIS_VIEW_FRONT] = [KEY_NUM_4];
          keyMap[_CameraControl.AXIS_VIEW_TOP] = [KEY_NUM_5];
          keyMap[_CameraControl.AXIS_VIEW_BOTTOM] = [KEY_NUM_6];
          break;
        case "azerty":
          keyMap[_CameraControl.PAN_LEFT] = [KEY_Q];
          keyMap[_CameraControl.PAN_RIGHT] = [KEY_D];
          keyMap[_CameraControl.PAN_UP] = [KEY_W];
          keyMap[_CameraControl.PAN_DOWN] = [KEY_X];
          keyMap[_CameraControl.PAN_BACKWARDS] = [];
          keyMap[_CameraControl.PAN_FORWARDS] = [];
          keyMap[_CameraControl.DOLLY_FORWARDS] = [KEY_Z, KEY_ADD];
          keyMap[_CameraControl.DOLLY_BACKWARDS] = [KEY_S, KEY_SUBTRACT];
          keyMap[_CameraControl.ROTATE_X_POS] = [KEY_DOWN_ARROW];
          keyMap[_CameraControl.ROTATE_X_NEG] = [KEY_UP_ARROW];
          keyMap[_CameraControl.ROTATE_Y_POS] = [KEY_A, KEY_LEFT_ARROW];
          keyMap[_CameraControl.ROTATE_Y_NEG] = [KEY_E, KEY_RIGHT_ARROW];
          keyMap[_CameraControl.AXIS_VIEW_RIGHT] = [KEY_NUM_1];
          keyMap[_CameraControl.AXIS_VIEW_BACK] = [KEY_NUM_2];
          keyMap[_CameraControl.AXIS_VIEW_LEFT] = [KEY_NUM_3];
          keyMap[_CameraControl.AXIS_VIEW_FRONT] = [KEY_NUM_4];
          keyMap[_CameraControl.AXIS_VIEW_TOP] = [KEY_NUM_5];
          keyMap[_CameraControl.AXIS_VIEW_BOTTOM] = [KEY_NUM_6];
          break;
      }
      this.#keyMap = keyMap;
    } else {
      const keyMap = value;
      this.#keyMap = keyMap;
    }
  }
  /**
   * Gets custom mappings of keys to {@link CameraControl} actions.
   */
  get keyMap() {
    return this.#keyMap;
  }
  /**
   * Returns true if any keys configured for the given action are down.
   * @param action
   * @param keyDownMap
   * @private
   */
  _isKeyDownForAction(action, keyDownMap) {
    return false;
  }
  /**
   * Sets the HTMl element to represent the pivot point when {@link CameraControl#followPointer} is true.
   *
   * See class comments for an example.
   */
  set pivotElement(element) {
    this.#controllers.pivotController.setPivotElement(element);
  }
  /**
   *  Sets if this ````CameraControl```` is active or not.
   *
   * When inactive, the ````CameraControl```` will not react to input.
   *
   * Default is ````true````.
   */
  set active(value) {
    value = value !== false;
    this.#configs.active = value;
    this.#handlers[1]._active = value;
    this.#handlers[5]._active = value;
  }
  /**
   * Gets if this ````CameraControl```` is active or not.
   *
   * When inactive, the ````CameraControl```` will not react to input.
   *
   * Default is ````true````.
   *
   * @returns Returns ````true```` if this ````CameraControl```` is active.
   */
  get active() {
    return this.#configs.active;
  }
  /**
   * Sets whether the pointer snap to vertex.
   */
  set snapToVertex(snapToVertex) {
    this.#configs.snapToVertex = !!snapToVertex;
  }
  /**
   * Gets whether the pointer snap to vertex.
   */
  get snapToVertex() {
    return this.#configs.snapToVertex;
  }
  /**
   * Sets whether the pointer snap to edge.
   */
  set snapToEdge(snapToEdge) {
    this.#configs.snapToEdge = !!snapToEdge;
  }
  /**
   * Gets whether the pointer snap to edge.
   */
  get snapToEdge() {
    return this.#configs.snapToEdge;
  }
  /**
   * Sets the current snap radius for "hoverSnapOrSurface" events, to specify whether the radius
   * within which the pointer snaps to the nearest vertex or the nearest edge.
   *
   * Default value is 30 pixels.
   */
  set snapRadius(snapRadius) {
    snapRadius = snapRadius || DEFAULT_SNAP_PICK_RADIUS;
    this.#configs.snapRadius = snapRadius;
  }
  /**
   * Gets the current snap radius.
   */
  get snapRadius() {
    return this.#configs.snapRadius;
  }
  /**
   * If `true`, the keyboard shortcuts are enabled ONLY if the mouse is over the canvas.
   */
  set keyboardEnabledOnlyIfMouseover(value) {
    this.#configs.keyboardEnabledOnlyIfMouseover = !!value;
  }
  /**
   * Gets whether the keyboard shortcuts are enabled ONLY if the mouse is over the canvas or ALWAYS.
   */
  get keyboardEnabledOnlyIfMouseover() {
    return this.#configs.keyboardEnabledOnlyIfMouseover;
  }
  /**
   * Gets the current navigation mode.
   *
   * Returned values are:
   *
   * * {@link constants!OrbitNavigationMode} - rotation orbits about the current target or pivot point,
   * * {@link constants!FirstPersonNavigationMode} - rotation is about the current eye position,
   * * {@link constants!PlanViewNavigationMode} - rotation is disabled.
   *
   * @returns The navigation mode: OrbitNavigationMode, FirstPersonNavigationMode or PlanViewNavigationMode.
   */
  get navMode() {
    return this.#configs.navMode;
  }
  /**
   * Sets the current navigation mode.
   *
   * Accepted values are:
   *
   * * {@link constants!OrbitNavigationMode} - rotation orbits about the current target or pivot point,
   * * {@link constants!FirstPersonNavigationMode} - rotation is about the current eye position,
   * * {@link constants!PlanViewNavigationMode} - rotation is disabled.
   *
   * See class comments for more info.
   *
   * @param navMode The navigation mode: OrbitNavigationMode, FirstPersonNavigationMode or PlanViewNavigationMode.
   */
  set navMode(navMode) {
    navMode = navMode || OrbitNavigationMode;
    if (navMode !== FirstPersonNavigationMode && navMode !== OrbitNavigationMode && navMode !== PlanViewNavigationMode) {
      this.error("Unsupported value for navMode: " + navMode + " - supported values are 'orbit', 'firstPerson' and 'planView' - defaulting to 'orbit'");
      navMode = OrbitNavigationMode;
    }
    this.#configs.firstPerson = navMode === FirstPersonNavigationMode;
    this.#configs.planView = navMode === PlanViewNavigationMode;
    if (this.#configs.firstPerson || this.#configs.planView) {
      this.#controllers.pivotController.hidePivot();
      this.#controllers.pivotController.endPivot();
    }
    this.#configs.navMode = navMode;
  }
  /**
   * Sets whether mouse and touch input is enabled.
   *
   * Default is ````true````.
   *
   * Disabling mouse and touch input on ````CameraControl```` is useful when we want to temporarily use mouse or
   * touch input to interact with some other 3D control, without disturbing the {@link viewer!Camera}.
   *
   * @param value Set ````true```` to enable mouse and touch input.
   */
  set pointerEnabled(value) {
    this._reset();
    this.#configs.pointerEnabled = !!value;
  }
  _reset() {
    for (let i = 0, len = this.#handlers.length; i < len; i++) {
      const handler = this.#handlers[i];
      if (handler.reset) {
        handler.reset();
      }
    }
    this.#updates.panDeltaX = 0;
    this.#updates.panDeltaY = 0;
    this.#updates.rotateDeltaX = 0;
    this.#updates.rotateDeltaY = 0;
    this.#updates.dollyDelta = 0;
  }
  /**
   * Gets whether mouse and touch input is enabled.
   *
   * Default is ````true````.
   *
   * Disabling mouse and touch input on ````CameraControl```` is desirable when we want to temporarily use mouse or
   * touch input to interact with some other 3D control, without interfering with the {@link viewer!Camera}.
   *
   * @returns Returns ````true```` if mouse and touch input is enabled.
   */
  get pointerEnabled() {
    return this.#configs.pointerEnabled;
  }
  /**
   * Sets whether the {@link viewer!Camera} follows the mouse/touch pointer.
   *
   * In orbiting mode, the Camera will orbit about the pointer, and will dolly to and from the pointer.
   *
   * In fly-to mode, the Camera will dolly to and from the pointer, however the World will always rotate about the Camera position.
   *
   * In plan-view mode, the Camera will dolly to and from the pointer, however the Camera will not rotate.
   *
   * Default is ````true````.
   *
   * See class comments for more info.
   *
   * @param value Set ````true```` to enable the Camera to follow the pointer.
   */
  set followPointer(value) {
    this.#configs.followPointer = value !== false;
  }
  /**
   * Sets whether the {@link viewer!Camera} follows the mouse/touch pointer.
   *
   * In orbiting mode, the Camera will orbit about the pointer, and will dolly to and from the pointer.
   *
   * In fly-to mode, the Camera will dolly to and from the pointer, however the World will always rotate about the Camera position.
   *
   * In plan-view mode, the Camera will dolly to and from the pointer, however the Camera will not rotate.
   *
   * Default is ````true````.
   *
   * See class comments for more info.
   *
   * @returns Returns ````true```` if the Camera follows the pointer.
   */
  get followPointer() {
    return this.#configs.followPointer;
  }
  /**
   * Sets the current World-space 3D target position.
   *
   * Only applies when {@link CameraControl#followPointer} is ````true````.
   *
   * @param worldPos The new World-space 3D target position.
   */
  set pivotPos(worldPos) {
    this.#controllers.pivotController.setPivotPos(worldPos);
  }
  /**
   * Gets the current World-space 3D pivot position.
   *
   * Only applies when {@link CameraControl#followPointer} is ````true````.
   *
   * @return  worldPos The current World-space 3D pivot position.
   */
  get pivotPos() {
    return this.#controllers.pivotController.getPivotPos();
  }
  /**
   * Sets whether to vertically constrain the {@link viewer!Camera} position for first-person navigation.
   *
   * When set ````true````, this constrains {@link viewer!Camera#eye} to its current vertical position.
   *
   * Only applies when {@link CameraControl#navMode} is ````"firstPerson"````.
   *
   * Default is ````false````.
   *
   * @param value Set ````true```` to vertically constrain the Camera.
   */
  set constrainVertical(value) {
    this.#configs.constrainVertical = !!value;
  }
  /**
   * Gets whether to vertically constrain the {@link viewer!Camera} position for first-person navigation.
   *
   * When set ````true````, this constrains {@link viewer!Camera#eye} to its current vertical position.
   *
   * Only applies when {@link CameraControl#navMode} is ````"firstPerson"````.
   *
   * Default is ````false````.
   *
   * @returns ````true```` when Camera is vertically constrained.
   */
  get constrainVertical() {
    return this.#configs.constrainVertical;
  }
  /**
   * Sets whether double-picking an object causes the {@link viewer!Camera} to fly to its boundary.
   *
   * Default is ````false````.
   *
   * @param value Set ````true```` to enable double-pick-fly-to mode.
   */
  set doublePickFlyTo(value) {
    this.#configs.doublePickFlyTo = value !== false;
  }
  /**
   * Gets whether double-picking an object causes the {@link viewer!Camera} to fly to its boundary.
   *
   * Default is ````false````.
   *
   * @returns Returns ````true```` when double-pick-fly-to mode is enabled.
   */
  get doublePickFlyTo() {
    return this.#configs.doublePickFlyTo;
  }
  /**
   * Sets whether either right-clicking (true) or middle-clicking (false) pans the {@link viewer!Camera}.
   *
   * Default is ````true````.
   *
   * @param value Set ````false```` to disable pan on right-click.
   */
  set panRightClick(value) {
    this.#configs.panRightClick = value !== false;
  }
  /**
   * Gets whether right-clicking pans the {@link viewer!Camera}.
   *
   * Default is ````true````.
   *
   * @returns Returns ````false```` when pan on right-click is disabled.
   */
  get panRightClick() {
    return this.#configs.panRightClick;
  }
  /**
   * Sets a factor in range ````[0..1]```` indicating how much the {@link viewer!Camera} keeps moving after you finish rotating it.
   *
   * A value of ````0.0```` causes it to immediately stop, ````0.5```` causes its movement to decay 50% on each tick,
   * while ````1.0```` causes no decay, allowing it continue moving, by the current rate of rotation.
   *
   * You may choose an inertia of zero when you want be able to precisely rotate the Camera,
   * without interference from inertia. Zero inertia can also mean that less frames are rendered while
   * you are rotating the Camera.
   *
   * Default is ````0.0````.
   *
   * Does not apply when {@link CameraControl#navMode} is ````"planView"````, which disallows rotation.
   *
   * @param rotationInertia New inertial factor.
   */
  set rotationInertia(rotationInertia) {
    this.#configs.rotationInertia = rotationInertia !== void 0 && rotationInertia !== null ? rotationInertia : 0;
  }
  /**
   * Gets the rotation inertia factor.
   *
   * Default is ````0.0````.
   *
   * Does not apply when {@link CameraControl#navMode} is ````"planView"````, which disallows rotation.
   *
   * @returns The inertia factor.
   */
  get rotationInertia() {
    return this.#configs.rotationInertia;
  }
  /**
   * Sets how much the {@link viewer!Camera} pans each second with keyboard input.
   *
   * Default is ````5.0````, to pan the Camera ````5.0```` World-space units every second that
   * a panning key is depressed. See the ````CameraControl```` class documentation for which keys control
   * panning.
   *
   * Panning direction is aligned to our Camera's orientation. When we pan horizontally, we pan
   * to our left and right, when we pan vertically, we pan upwards and downwards, and when we pan forwards
   * and backwards, we pan along the direction the Camera is pointing.
   *
   * Unlike dollying when {@link followPointer} is ````true````, panning does not follow the pointer.
   *
   * @param keyboardPanRate The new keyboard pan rate.
   */
  set keyboardPanRate(keyboardPanRate) {
    this.#configs.keyboardPanRate = keyboardPanRate !== null && keyboardPanRate !== void 0 ? keyboardPanRate : 5;
  }
  /**
   * Sets how fast the camera pans on touch panning
   *
   * @param touchPanRate The new touch pan rate.
   */
  set touchPanRate(touchPanRate) {
    this.#configs.touchPanRate = touchPanRate !== null && touchPanRate !== void 0 ? touchPanRate : 1;
  }
  /**
   * Gets how fast the {@link viewer!Camera} pans on touch panning
   *
   * Default is ````1.0````.
   *
   * @returns The current touch pan rate.
   */
  get touchPanRate() {
    return this.#configs.touchPanRate;
  }
  /**
   * Gets how much the {@link viewer!Camera} pans each second with keyboard input.
   *
   * Default is ````5.0````.
   *
   * @returns The current keyboard pan rate.
   */
  get keyboardPanRate() {
    return this.#configs.keyboardPanRate;
  }
  /**
   * Sets how many degrees per second the {@link viewer!Camera} rotates/orbits with keyboard input.
   *
   * Default is ````90.0````, to rotate/orbit the Camera ````90.0```` degrees every second that
   * a rotation key is depressed. See the ````CameraControl```` class documentation for which keys control
   * rotation/orbit.
   *
   * @param keyboardRotationRate The new keyboard rotation rate.
   */
  set keyboardRotationRate(keyboardRotationRate) {
    this.#configs.keyboardRotationRate = keyboardRotationRate !== null && keyboardRotationRate !== void 0 ? keyboardRotationRate : 90;
  }
  /**
   * Sets how many degrees per second the {@link viewer!Camera} rotates/orbits with keyboard input.
   *
   * Default is ````90.0````.
   *
   * @returns The current keyboard rotation rate.
   */
  get keyboardRotationRate() {
    return this.#configs.keyboardRotationRate;
  }
  /**
   * Sets the current drag rotation rate.
   *
   * This configures how many degrees the {@link viewer!Camera} rotates/orbits for a full sweep of the canvas by mouse or touch dragging.
   *
   * For example, a value of ````360.0```` indicates that the ````Camera```` rotates/orbits ````360.0```` degrees horizontally
   * when we sweep the entire width of the canvas.
   *
   * ````CameraControl```` makes vertical rotation half as sensitive as horizontal rotation, so that we don't tend to
   * flip upside-down. Therefore, a value of ````360.0```` rotates/orbits the ````Camera```` through ````180.0```` degrees
   * vertically when we sweep the entire height of the canvas.
   *
   * Default is ````360.0````.
   *
   * @param dragRotationRate The new drag rotation rate.
   */
  set dragRotationRate(dragRotationRate) {
    this.#configs.dragRotationRate = dragRotationRate !== null && dragRotationRate !== void 0 ? dragRotationRate : 360;
  }
  /**
   * Gets the current drag rotation rate.
   *
   * Default is ````360.0````.
   *
   * @returns The current drag rotation rate.
   */
  get dragRotationRate() {
    return this.#configs.dragRotationRate;
  }
  /**
   * Sets how much the {@link viewer!Camera} dollys each second with keyboard input.
   *
   * Default is ````15.0````, to dolly the {@link viewer!Camera} ````15.0```` World-space units per second while we hold down
   * the ````+```` and ````-```` keys.
   *
   * @param keyboardDollyRate The new keyboard dolly rate.
   */
  set keyboardDollyRate(keyboardDollyRate) {
    this.#configs.keyboardDollyRate = keyboardDollyRate !== null && keyboardDollyRate !== void 0 ? keyboardDollyRate : 15;
  }
  /**
   * Gets how much the {@link viewer!Camera} dollys each second with keyboard input.
   *
   * Default is ````15.0````.
   *
   * @returns The current keyboard dolly rate.
   */
  get keyboardDollyRate() {
    return this.#configs.keyboardDollyRate;
  }
  /**
   * Sets how much the {@link viewer!Camera} dollys with touch input.
   *
   * Default is ````0.2````
   *
   * @param touchDollyRate The new touch dolly rate.
   */
  set touchDollyRate(touchDollyRate) {
    this.#configs.touchDollyRate = touchDollyRate !== null && touchDollyRate !== void 0 ? touchDollyRate : 0.2;
  }
  /**
   * Gets how much the {@link viewer!Camera} dollys each second with touch input.
   *
   * Default is ````0.2````.
   *
   * @returns The current touch dolly rate.
   */
  get touchDollyRate() {
    return this.#configs.touchDollyRate;
  }
  /**
   * Sets how much the {@link viewer!Camera} dollys each second while the mouse wheel is spinning.
   *
   * Default is ````100.0````, to dolly the {@link viewer!Camera} ````10.0```` World-space units per second as we spin
   * the mouse wheel.
   *
   * @param mouseWheelDollyRate The new mouse wheel dolly rate.
   */
  set mouseWheelDollyRate(mouseWheelDollyRate) {
    this.#configs.mouseWheelDollyRate = mouseWheelDollyRate !== null && mouseWheelDollyRate !== void 0 ? mouseWheelDollyRate : 100;
  }
  /**
   * Gets how much the {@link viewer!Camera} dollys each second while the mouse wheel is spinning.
   *
   * Default is ````100.0````.
   *
   * @returns The current mouseWheel dolly rate.
   */
  get mouseWheelDollyRate() {
    return this.#configs.mouseWheelDollyRate;
  }
  /**
   * Sets the dolly inertia factor.
   *
   * This factor configures how much the {@link viewer!Camera} keeps moving after you finish dollying it.
   *
   * This factor is a value in range ````[0..1]````. A value of ````0.0```` causes dollying to immediately stop,
   * ````0.5```` causes dollying to decay 50% on each animation frame, while ````1.0```` causes no decay, which allows dollying
   * to continue until further input stops it.
   *
   * You might set ````dollyInertia```` to zero when you want be able to precisely position or rotate the Camera,
   * without interference from inertia. This also means that xeokit renders less frames while dollying the Camera,
   * which can improve rendering performance.
   *
   * Default is ````0````.
   *
   * @param dollyInertia New dolly inertia factor.
   */
  set dollyInertia(dollyInertia) {
    this.#configs.dollyInertia = dollyInertia !== void 0 && dollyInertia !== null ? dollyInertia : 0;
  }
  /**
   * Gets the dolly inertia factor.
   *
   * Default is ````0````.
   *
   * @returns The current dolly inertia factor.
   */
  get dollyInertia() {
    return this.#configs.dollyInertia;
  }
  /**
   * Sets the proximity to the closest object below which dolly speed decreases, and above which dolly speed increases.
   *
   * Default is ````35.0````.
   *
   * @param dollyProximityThreshold New dolly proximity threshold.
   */
  set dollyProximityThreshold(dollyProximityThreshold) {
    this.#configs.dollyProximityThreshold = dollyProximityThreshold !== void 0 && dollyProximityThreshold !== null ? dollyProximityThreshold : 35;
  }
  /**
   * Gets the proximity to the closest object below which dolly speed decreases, and above which dolly speed increases.
   *
   * Default is ````35.0````.
   *
   * @returns The current dolly proximity threshold.
   */
  get dollyProximityThreshold() {
    return this.#configs.dollyProximityThreshold;
  }
  /**
   * Sets the minimum dolly speed.
   *
   * Default is ````0.04````.
   *
   * @param dollyMinSpeed New dolly minimum speed.
   */
  set dollyMinSpeed(dollyMinSpeed) {
    this.#configs.dollyMinSpeed = dollyMinSpeed !== void 0 && dollyMinSpeed !== null ? dollyMinSpeed : 0.04;
  }
  /**
   * Gets the minimum dolly speed.
   *
   * Default is ````0.04````.
   *
   * @returns The current minimum dolly speed.
   */
  get dollyMinSpeed() {
    return this.#configs.dollyMinSpeed;
  }
  /**
   * Sets the pan inertia factor.
   *
   * This factor configures how much the {@link viewer!Camera} keeps moving after you finish panning it.
   *
   * This factor is a value in range ````[0..1]````. A value of ````0.0```` causes panning to immediately stop,
   * ````0.5```` causes panning to decay 50% on each animation frame, while ````1.0```` causes no decay, which allows panning
   * to continue until further input stops it.
   *
   * You might set ````panInertia```` to zero when you want be able to precisely position or rotate the Camera,
   * without interference from inertia. This also means that xeokit renders less frames while panning the Camera,
   * wich can improve rendering performance.
   *
   * Default is ````0.5````.
   *
   * @param panInertia New pan inertia factor.
   */
  set panInertia(panInertia) {
    this.#configs.panInertia = panInertia !== void 0 && panInertia !== null ? panInertia : 0.5;
  }
  /**
   * Gets the pan inertia factor.
   *
   * Default is ````0.5````.
   *
   * @returns The current pan inertia factor.
   */
  get panInertia() {
    return this.#configs.panInertia;
  }
  /**
   * Sets a sphere as the representation of the pivot position.
   *
   * @param [cfg] Sphere configuration.
   * @param [cfg.size=1] Optional size factor of the sphere. Defaults to 1.
   * @param [cfg.material=PhongMaterial] Optional size factor of the sphere. Defaults to a red opaque material.
   */
  enablePivotSphere(cfg = {}) {
    this.#controllers.pivotController.enablePivotSphere(cfg);
  }
  /**
   * Remove the sphere as the representation of the pivot position.
   */
  disablePivotSphere() {
    this.#controllers.pivotController.disablePivotSphere();
  }
  /**
   * Sets whether smart default pivoting is enabled.
   *
   * When ````true````, we'll pivot by default about the 3D position of the mouse/touch pointer on an
   * imaginary sphere that's centered at {@link viewer!Camera#eye} and sized to the {@link scene!Scene} boundary.
   *
   * When ````false````, we'll pivot by default about {@link viewer!Camera#look}.
   *
   * Default is ````false````.
   *
   * @param enabled Set ````true```` to pivot by default about the selected point on the virtual sphere, or ````false```` to pivot by default about {@link viewer!Camera#look}.
   */
  set smartPivot(enabled2) {
    this.#configs.smartPivot = enabled2 !== false;
  }
  /**
   * Gets whether smart default pivoting is enabled.
   *
   * When ````true````, we'll pivot by default about the 3D position of the mouse/touch pointer on an
   * imaginary sphere that's centered at {@link viewer!Camera#eye} and sized to the {@link scene!Scene} boundary.
   *
   * When ````false````, we'll pivot by default about {@link viewer!Camera#look}.
   *
   * Default is ````false````.
   *
   * @returns Returns ````true```` when pivoting by default about the selected point on the virtual sphere, or ````false```` when pivoting by default about {@link viewer!Camera#look}.
   */
  get smartPivot() {
    return this.#configs.smartPivot;
  }
  /**
   * Sets the double click time frame length in milliseconds.
   *
   * If two mouse click events occur within this time frame, it is considered a double click.
   *
   * Default is ````250````
   *
   * @param value New double click time frame.
   */
  set doubleClickTimeFrame(value) {
    this.#configs.doubleClickTimeFrame = value !== void 0 && value !== null ? value : 250;
  }
  /**
   * Gets the double click time frame length in milliseconds.
   *
   * Default is ````250````
   *
   * @returns Current double click time frame.
   */
  get doubleClickTimeFrame() {
    return this.#configs.doubleClickTimeFrame;
  }
  /**
   * Destroys this ````CameraControl````.
   * @private
   */
  destroy() {
    this._destroyHandlers();
    this._destroyControllers();
    this.#cameraUpdater.destroy();
    super.destroy();
  }
  _destroyHandlers() {
    for (let i = 0, len = this.#handlers.length; i < len; i++) {
      const handler = this.#handlers[i];
      if (handler.destroy) {
        handler.destroy();
      }
    }
  }
  _destroyControllers() {
    for (let key in this.#controllers) {
      const controller = this.#controllers[key];
      if (controller.destroy) {
        controller.destroy();
      }
    }
  }
};

// ../sdk/src/bcf/index.ts
var bcf_exports = {};
__export(bcf_exports, {
  loadBCFViewpoint: () => loadBCFViewpoint,
  saveBCFViewpoint: () => saveBCFViewpoint
});

// ../sdk/src/bcf/loadBCFViewpoint.ts
var tempVec35 = createVec3();
var tempVec3a12 = createVec3();
var tempVec3b12 = createVec3();
var tempVec3c10 = createVec3();
function loadBCFViewpoint(params2) {
  const includeViewLayers = params2.includeViewLayerIds ? new Set(params2.includeViewLayerIds) : null;
  const excludeViewLayers = params2.excludeViewLayerIds ? new Set(params2.excludeViewLayerIds) : null;
  const view = params2.view;
  const data = params2.data;
  const camera = view.camera;
  const rayCast = !!params2.rayCast;
  const reset = params2.reset !== false;
  const realWorldOffset = createVec3();
  const reverseClippingPlanes = params2.reverseClippingPlanes === true;
  const bcfViewpoint = params2.bcfViewpoint;
  view.clearSectionPlanes();
  if (bcfViewpoint.clipping_planes) {
    bcfViewpoint.clipping_planes.forEach((e) => {
      let pos = xyzObjectToArray(e.location, tempVec3a12);
      let dir = xyzObjectToArray(e.direction, tempVec3b12);
      if (reverseClippingPlanes) {
        negateVec3(dir);
      }
      subVec3(pos, realWorldOffset);
      if (camera.yUp) {
        pos = ZToY(pos);
        dir = ZToY(dir);
      }
      view.createSectionPlane({ pos, dir });
    });
  }
  if (bcfViewpoint.lines) {
    const positions = [];
    const indices = [];
    let i = 0;
    bcfViewpoint.lines.forEach((e) => {
      if (!e.start_point) {
        return;
      }
      if (!e.end_point) {
        return;
      }
      positions.push(e.start_point.x);
      positions.push(e.start_point.y);
      positions.push(e.start_point.z);
      positions.push(e.end_point.x);
      positions.push(e.end_point.y);
      positions.push(e.end_point.z);
      indices.push(i++);
      indices.push(i++);
    });
  }
  if (bcfViewpoint.bitmaps) {
    bcfViewpoint.bitmaps.forEach((e) => {
      const bitmap_type = e.bitmap_type || "jpg";
      const bitmap_data = e.bitmap_data;
      let location = xyzObjectToArray(e.location, tempVec3a12);
      let normal2 = xyzObjectToArray(e.normal, tempVec3b12);
      let up = xyzObjectToArray(e.up, tempVec3c10);
      let height = e.height || 1;
      if (!bitmap_type) {
        return;
      }
      if (!bitmap_data) {
        return;
      }
      if (!location) {
        return;
      }
      if (!normal2) {
        return;
      }
      if (!up) {
        return;
      }
      if (camera.yUp) {
        location = ZToY(location);
        normal2 = ZToY(normal2);
        up = ZToY(up);
      }
    });
  }
  function filterViewObject(viewObject) {
    return !viewObject.layer || (!includeViewLayers || includeViewLayers.has(viewObject.layer.id)) && (!excludeViewLayers || !excludeViewLayers.has(viewObject.layer.id));
  }
  function withFilteredViewLayers(callback) {
    for (let layerId in view.layers) {
      if (excludeViewLayers && excludeViewLayers.has(layerId)) {
        continue;
      }
      if (includeViewLayers && !includeViewLayers.has(layerId)) {
        continue;
      }
      callback(view.layers[layerId]);
    }
  }
  function withViewObjectsOfType(type, callback) {
    const dataObjects = data.objectsByType[type];
    for (let dataObjectId in dataObjects) {
      const viewObject = view.objects[dataObjectId];
      if (viewObject && filterViewObject(viewObject)) {
        callback(viewObject);
      }
    }
  }
  function withBCFComponent(component, callback) {
    if (component.authoring_tool_id && component.originating_system === params2.originatingSystem) {
      const id = component.authoring_tool_id;
      const viewObject = view.objects[id];
      if (viewObject) {
        if (filterViewObject(viewObject)) {
          callback(viewObject);
        }
        return;
      }
      if (params2.updateCompositeObjects) {
        const dataObject = data.objects[id];
        if (dataObject) {
          searchObjects(data, {
            // Updated aggregated IFC elements
            startObjectId: dataObject.id,
            includeStart: true,
            includeRelated: [BasicAggregation],
            resultCallback: (dataObject2) => {
              const viewObject2 = view.objects[dataObject2.id];
              if (viewObject2) {
                if (filterViewObject(viewObject2)) {
                  callback(viewObject2);
                }
              }
              return false;
            }
          });
          return;
        }
      }
    }
    if (component.ifc_guid) {
      const originalSystemId = component.ifc_guid;
      const viewObject = view.objects[originalSystemId];
      if (viewObject) {
        callback(viewObject);
        return;
      }
      if (params2.updateCompositeObjects) {
        const dataObject = data.objects[originalSystemId];
        if (dataObject) {
          searchObjects(data, {
            startObjectId: dataObject.id,
            includeStart: true,
            includeRelated: [BasicAggregation],
            resultCallback: (dataObject2) => {
              const viewObject2 = view.objects[dataObject2.id];
              if (viewObject2) {
                if (filterViewObject(viewObject2)) {
                  callback(viewObject2);
                }
              }
              return false;
            }
          });
          return;
        }
      }
    }
  }
  if (reset) {
    withFilteredViewLayers((viewLayer) => {
      viewLayer.setObjectsXRayed(viewLayer.xrayedObjectIds, false);
      viewLayer.setObjectsHighlighted(viewLayer.highlightedObjectIds, false);
      viewLayer.setObjectsSelected(viewLayer.selectedObjectIds, false);
    });
  }
  if (bcfViewpoint.components) {
    if (bcfViewpoint.components.visibility) {
      if (!bcfViewpoint.components.visibility.default_visibility) {
        withFilteredViewLayers((viewLayer) => {
          viewLayer.setObjectsVisible(viewLayer.objectIds, false);
        });
        if (bcfViewpoint.components.visibility.exceptions) {
          bcfViewpoint.components.visibility.exceptions.forEach(
            (component) => withBCFComponent(
              component,
              (viewObject) => {
                viewObject.visible = true;
              }
            )
          );
        }
      } else {
        withFilteredViewLayers((viewLayer) => {
          viewLayer.setObjectsVisible(viewLayer.objectIds, true);
        });
        if (bcfViewpoint.components.visibility.exceptions) {
          bcfViewpoint.components.visibility.exceptions.forEach(
            (component) => withBCFComponent(
              component,
              (viewObject) => {
                viewObject.visible = false;
              }
            )
          );
        }
      }
      const view_setup_hints = bcfViewpoint.components.visibility.view_setup_hints;
      if (view_setup_hints) {
        if (view_setup_hints.spaces_visible === false) {
          withViewObjectsOfType(IfcSpace, (viewObject) => {
            viewObject.visible = false;
          });
        }
        if (view_setup_hints.spaces_translucent !== void 0) {
          withViewObjectsOfType(IfcSpace, (viewObject) => {
            viewObject.xrayed = true;
          });
        }
        if (view_setup_hints.space_boundaries_visible !== void 0) {
        }
        if (view_setup_hints.openings_visible === false) {
          withViewObjectsOfType(IfcOpeningElement, (viewObject) => {
            viewObject.visible = false;
          });
        }
        if (view_setup_hints.space_boundaries_translucent !== void 0) {
        }
        if (view_setup_hints.openings_translucent !== void 0) {
          withViewObjectsOfType(IfcOpeningElement, (viewObject) => {
            viewObject.xrayed = true;
          });
        }
      }
    }
    if (bcfViewpoint.components.selection) {
      withFilteredViewLayers((viewLayer) => {
        viewLayer.setObjectsSelected(viewLayer.selectedObjectIds, false);
      });
      bcfViewpoint.components.selection.forEach(
        (component) => withBCFComponent(
          component,
          (viewObject) => {
            viewObject.selected = true;
          }
        )
      );
    }
    if (bcfViewpoint.components.translucency) {
      view.setObjectsXRayed(view.xrayedObjectIds, false);
      bcfViewpoint.components.translucency.forEach(
        (component) => withBCFComponent(
          component,
          (viewObject) => {
            viewObject.xrayed = true;
          }
        )
      );
    }
    if (bcfViewpoint.components.coloring) {
      bcfViewpoint.components.coloring.forEach((coloring) => {
        let color2 = coloring.color;
        let alpha = 0;
        let alphaDefined = false;
        if (color2.length === 8) {
          alpha = parseInt(color2.substring(0, 2), 16) / 256;
          if (alpha <= 1 && alpha >= 0.95) {
            alpha = 1;
          }
          color2 = color2.substring(2);
          alphaDefined = true;
        }
        const colorize = [
          parseInt(color2.substring(0, 2), 16) / 256,
          parseInt(color2.substring(2, 4), 16) / 256,
          parseInt(color2.substring(4, 6), 16) / 256
        ];
        coloring.components.map((component) => withBCFComponent(
          component,
          (viewObject) => {
            viewObject.colorize = colorize;
            if (alphaDefined) {
              viewObject.opacity = alpha;
            }
          }
        ));
      });
    }
  }
  if (bcfViewpoint.perspective_camera || bcfViewpoint.orthogonal_camera) {
    let eye;
    let look;
    let up;
    let projection;
    if (bcfViewpoint.perspective_camera) {
      eye = xyzObjectToArray(bcfViewpoint.perspective_camera.camera_view_point, tempVec3a12);
      look = xyzObjectToArray(bcfViewpoint.perspective_camera.camera_direction, tempVec3b12);
      up = xyzObjectToArray(bcfViewpoint.perspective_camera.camera_up_vector, tempVec3c10);
      camera.perspectiveProjection.fov = bcfViewpoint.perspective_camera.field_of_view;
      projection = PerspectiveProjectionType;
    } else {
      eye = xyzObjectToArray(bcfViewpoint.orthogonal_camera.camera_view_point, tempVec3a12);
      look = xyzObjectToArray(bcfViewpoint.orthogonal_camera.camera_direction, tempVec3b12);
      up = xyzObjectToArray(bcfViewpoint.orthogonal_camera.camera_up_vector, tempVec3c10);
      camera.orthoProjection.scale = bcfViewpoint.orthogonal_camera.view_to_world_scale;
      projection = OrthoProjectionType;
    }
    subVec3(eye, realWorldOffset);
    if (camera.yUp) {
      eye = ZToY(eye);
      look = ZToY(look);
      up = ZToY(up);
    }
    if (rayCast) {
      const hit = view.pick({
        pickSurface: true,
        // <<------ This causes picking to find the intersection point on the viewObject
        rayOrigin: eye,
        rayDirection: look
      });
      look = hit instanceof PickResult ? hit.worldPos : addVec3(eye, look, tempVec35);
    } else {
      look = addVec3(eye, look, tempVec35);
    }
    camera.eye = eye;
    camera.look = look;
    camera.up = up;
    camera.projectionType = projection;
  }
}
function xyzObjectToArray(xyz, arry) {
  arry[0] = xyz.x;
  arry[1] = xyz.y;
  arry[2] = xyz.z;
  return arry;
}
function ZToY(vec) {
  return new Float64Array([vec[0], vec[2], -vec[1]]);
}

// ../sdk/src/bcf/saveBCFViewpoint.ts
function saveBCFViewpoint(params2) {
  const includeViewLayers = params2.includeViewLayerIds ? new Set(params2.includeViewLayerIds) : null;
  const excludeViewLayers = params2.excludeViewLayerIds ? new Set(params2.excludeViewLayerIds) : null;
  const view = params2.view;
  const camera = view.camera;
  const realWorldOffset = createVec3();
  const reverseClippingPlanes = params2.reverseClippingPlanes === true;
  let bcfViewpoint = {};
  let lookDirection = normalizeVec3(subVec3(camera.look, camera.eye, createVec3()));
  let eye = camera.eye;
  let up = camera.up;
  if (camera.yUp) {
    lookDirection = YToZ(lookDirection);
    eye = YToZ(eye);
    up = YToZ(up);
  }
  function filterViewObject(viewObject) {
    return !viewObject.layer || (!includeViewLayers || includeViewLayers.has(viewObject.layer.id)) && (!excludeViewLayers || !excludeViewLayers.has(viewObject.layer.id));
  }
  function createBCFComponents(objectIds2) {
    const view2 = params2.view;
    const components = [];
    for (let i = 0, len = objectIds2.length; i < len; i++) {
      const objectId = objectIds2[i];
      const viewObject = view2.objects[objectId];
      if (viewObject) {
        if (filterViewObject(viewObject)) {
          const component = {
            ifc_guid: viewObject.originalSystemId,
            originating_system: params2.originatingSystem
          };
          if (viewObject.originalSystemId !== objectId) {
            component.authoring_tool_id = objectId;
          }
          components.push(component);
        }
      }
    }
    return components;
  }
  const camera_view_point = xyzArrayToObject(addVec3(eye, realWorldOffset));
  if (camera.projectionType === OrthoProjectionType) {
    bcfViewpoint.orthogonal_camera = {
      camera_view_point,
      camera_direction: xyzArrayToObject(lookDirection),
      camera_up_vector: xyzArrayToObject(up),
      view_to_world_scale: camera.orthoProjection.scale
    };
  } else {
    bcfViewpoint.perspective_camera = {
      camera_view_point,
      camera_direction: xyzArrayToObject(lookDirection),
      camera_up_vector: xyzArrayToObject(up),
      field_of_view: camera.perspectiveProjection.fov
    };
  }
  const sectionPlanes = view.sectionPlanes;
  for (let id in sectionPlanes) {
    if (sectionPlanes.hasOwnProperty(id)) {
      let sectionPlane = sectionPlanes[id];
      if (!sectionPlane.active) {
        continue;
      }
      let location = sectionPlane.pos;
      let direction;
      if (reverseClippingPlanes) {
        direction = negateVec3(sectionPlane.dir, createVec3());
      } else {
        direction = sectionPlane.dir;
      }
      if (camera.yUp) {
        location = YToZ(location);
        direction = YToZ(direction);
      }
      addVec3(location, realWorldOffset);
      location = xyzArrayToObject(location);
      direction = xyzArrayToObject(direction);
      if (!bcfViewpoint.clipping_planes) {
        bcfViewpoint.clipping_planes = [];
      }
      bcfViewpoint.clipping_planes.push({ location, direction });
    }
  }
  bcfViewpoint.components = {
    visibility: {
      view_setup_hints: {
        spaces_visible: !!params2.spacesVisible,
        space_boundaries_visible: !!params2.spaceBoundariesVisible,
        openings_visible: !!params2.openingsVisible,
        spaces_translucent: !!params2.spaces_translucent,
        space_boundaries_translucent: !!params2.space_boundaries_translucent,
        openings_translucent: !!params2.openings_translucent
      }
    }
  };
  const opacityObjectIds = new Set(view.opacityObjectIds);
  const xrayedObjectIds = new Set(view.xrayedObjectIds);
  const colorizedObjectIds = new Set(view.colorizedObjectIds);
  const coloringMap = Object.values(view.objects).filter((viewObject) => !viewObject.layer || (!includeViewLayers || includeViewLayers.has(viewObject.layer.id)) && (!excludeViewLayers || !excludeViewLayers.has(viewObject.layer.id)) && (opacityObjectIds.has(viewObject.id) || colorizedObjectIds.has(viewObject.id) || xrayedObjectIds.has(viewObject.id))).reduce((coloringMap2, viewObject) => {
    let color2 = colorizeToRGB(viewObject.colorize);
    let alpha;
    if (viewObject.xrayed) {
      if (view.xrayMaterial.fillAlpha === 0 && view.xrayMaterial.edgeAlpha !== 0) {
        alpha = 0.1;
      } else {
        alpha = view.xrayMaterial.fillAlpha;
      }
      alpha = Math.round(alpha * 255).toString(16).padStart(2, "0");
      color2 = alpha + color2;
    } else if (opacityObjectIds.has(viewObject.id)) {
      alpha = Math.round(viewObject.opacity * 255).toString(16).padStart(2, "0");
      color2 = alpha + color2;
    }
    if (!coloringMap2[color2]) {
      coloringMap2[color2] = [];
    }
    const objectId = viewObject.id;
    const originalSystemId = viewObject.originalSystemId;
    const component = {
      ifc_guid: originalSystemId,
      originating_system: params2.originatingSystem
    };
    if (originalSystemId !== objectId) {
      component.authoring_tool_id = objectId;
    }
    coloringMap2[color2].push(component);
    return coloringMap2;
  }, {});
  const coloringArray = Object.entries(coloringMap).map(([color2, components]) => {
    return { color: color2, components };
  });
  bcfViewpoint.components.coloring = coloringArray;
  const objectIds = view.objectIds;
  const visibleObjects = view.visibleObjects;
  const visibleObjectIds = view.visibleObjectIds;
  const invisibleObjectIds = objectIds.filter((id) => !visibleObjects[id]);
  const selectedObjectIds = view.selectedObjectIds;
  if (params2.defaultInvisible || visibleObjectIds.length < invisibleObjectIds.length) {
    bcfViewpoint.components.visibility.exceptions = createBCFComponents(visibleObjectIds);
    bcfViewpoint.components.visibility.default_visibility = false;
  } else {
    bcfViewpoint.components.visibility.exceptions = createBCFComponents(invisibleObjectIds);
    bcfViewpoint.components.visibility.default_visibility = true;
  }
  bcfViewpoint.components.selection = createBCFComponents(selectedObjectIds);
  bcfViewpoint.components.translucency = createBCFComponents(view.xrayedObjectIds);
  if (params2.snapshot !== false) {
    bcfViewpoint.snapshot = {
      snapshot_type: "png",
      snapshot_data: view.getSnapshot({ format: "png" })
    };
  }
  return bcfViewpoint;
}
function xyzArrayToObject(arr) {
  return { "x": arr[0], "y": arr[1], "z": arr[2] };
}
function YToZ(vec) {
  return new Float64Array([vec[0], -vec[2], vec[1]]);
}
function colorizeToRGB(color2) {
  let rgb = "";
  rgb += Math.round(color2[0] * 255).toString(16).padStart(2, "0");
  rgb += Math.round(color2[1] * 255).toString(16).padStart(2, "0");
  rgb += Math.round(color2[2] * 255).toString(16).padStart(2, "0");
  return rgb;
}

// ../sdk/src/treeview/index.ts
var treeview_exports = {};
__export(treeview_exports, {
  TreeView: () => TreeView
});

// ../sdk/src/treeview/TreeView.ts
var import_strongly_typed_events20 = __toESM(require_dist8());
var TreeView = class _TreeView extends Component {
  /**
   * Hierarchy mode that arranges the {@link TreeViewNode | TreeViewNodes} as an aggregation hierarchy.
   *
   * The mode creates a TreeViewNode hierarchy that mirrors that of the
   * {@link data!DataObject | DataObjects} and
   * aggregation {@link data!Relationship | Relationships} in the {@link data!Data | Data}.
   *
   * In this hierarchy, each TreeViewNode corresponds to a DataObject in the Data. The TreeViewNodes are connected
   * into a hierarchy that reflects a depth-first traversal from the root DataObjects that follows each DataObject's
   * outgoing Relationships of the type given in {@link TreeView.linkType | TreeView.linkType}.
   */
  static AggregationHierarchy = 0;
  /**
   * Hierarchy mode that groups the {@link TreeViewNode | TreeViewNodes} by type.
   *
   * This mode creates a two-level hierarchy. At the root level, we get TreeViewNodes that represent each of the
   * distinct types in our {@link data!Data | Data}. Each of those gets one or more child TreeViewNodes
   * that represent {@link data!DataObject | DataObjects} of that type. When those DataObjects have
   * {@link viewer!ViewObject | ViewObjects} of the same ID, then the TreeViewNodes will have checkboxes
   * that we can use to show, hide, and X-ray their ViewObjects.
   */
  static TypesHierarchy = 1;
  /**
   * Hierarchy mode that arranges the {@link TreeViewNode | TreeViewNodes} into an n-level grouped hierarchy.
   *
   * This mode creates a multi-level grouped hierarchy, following the order given
   * in {@link TreeViewParams.groupTypes | TreeViewParams.groupTypes}. The TreeViewNodes at level 0 are all the same
   * type as ````TreeViewParams.groupTypes[0]````, TreeViewNodes at level 1 are all the same type
   * as ````TreeViewParams.groupTypes[2]````, and so on. Once descended beyond the length of ````TreeViewParams.groupTypes````,
   * the TreeViewNodes are just grouped by type.
   */
  static GroupsHierarchy = 2;
  /**
   * The semantic {@link data!Data | Data} model that determines the structure of this TreeView.
   */
  data;
  /**
   * The {@link viewer!View | View} that contains the {@link viewer!ViewObject | ViewObjects}
   * navigated by this TreeView.
   */
  view;
  /**
   * Emits an event each time the title of a node is clicked in the tree view.
   *
   * @event
   */
  onNodeTitleClicked;
  /**
   * Emits an event each time we right-click on a tree node.
   *
   * @event
   */
  onContextMenu;
  #linkType;
  #groupTypes;
  #containerElement;
  #hierarchy;
  #dataModels;
  #autoAddModels;
  #autoExpandDepth;
  #sortNodes;
  #pruneEmptyNodes;
  #viewer;
  #rootElement;
  #muteSceneEvents;
  #muteTreeEvents;
  #rootNodes;
  #objectNodes;
  #rootName;
  #showListItemElementId;
  #spatialSortFunc;
  #switchExpandHandler;
  #switchCollapseHandler;
  #checkboxChangeHandler;
  #destroyed;
  #onViewObjectVisibility;
  #onViewObjectXRayed;
  #dataObjectSceneObjectCounts;
  /**
   *
   * @param params
   */
  constructor(params2) {
    super(null);
    if (!params2.containerElement) {
      throw new Error("Config expected: containerElement");
    }
    if (!params2.data) {
      throw new Error("Config expected: data");
    }
    if (!params2.view) {
      throw new Error("Config expected: view");
    }
    this.data = params2.data;
    this.view = params2.view;
    this.#viewer = params2.view.viewer;
    this.#linkType = params2.linkType;
    this.#groupTypes = params2.groupTypes;
    this.#hierarchy = _TreeView.AggregationHierarchy;
    this.#containerElement = params2.containerElement;
    this.#dataModels = {};
    this.#autoExpandDepth = params2.autoExpandDepth || 0;
    this.#sortNodes = params2.sortNodes !== false;
    this.#pruneEmptyNodes = params2.pruneEmptyNodes !== false;
    this.#rootElement = null;
    this.#muteSceneEvents = false;
    this.#muteTreeEvents = false;
    this.#rootNodes = [];
    this.#objectNodes = {};
    this.#rootName = params2.rootName;
    this.#sortNodes = params2.sortNodes;
    this.#pruneEmptyNodes = params2.pruneEmptyNodes;
    this.#showListItemElementId = null;
    this.#destroyed = false;
    this.onNodeTitleClicked = new EventEmitter(new import_strongly_typed_events20.EventDispatcher());
    this.onContextMenu = new EventEmitter(new import_strongly_typed_events20.EventDispatcher());
    this.onDestroyed = new EventEmitter(new import_strongly_typed_events20.EventDispatcher());
    this.#containerElement.oncontextmenu = (e) => {
      e.preventDefault();
    };
    this.#onViewObjectVisibility = this.view.onObjectVisibility.subscribe((view, viewObject) => {
      if (this.#muteSceneEvents) {
        return;
      }
      const objectId = viewObject.id;
      const node = this.#objectNodes[objectId];
      if (!node) {
        return;
      }
      const visible = viewObject.visible;
      const updated = visible !== node.checked;
      if (!updated) {
        return;
      }
      this.#muteTreeEvents = true;
      node.checked = visible;
      if (visible) {
        node.numVisibleViewObjects++;
      } else {
        node.numVisibleViewObjects--;
      }
      const checkbox = document.getElementById(node.nodeId);
      if (checkbox) {
        checkbox.checked = visible;
      }
      let parentNode = node.parentNode;
      while (parentNode) {
        parentNode.checked = visible;
        if (visible) {
          parentNode.numVisibleViewObjects++;
        } else {
          parentNode.numVisibleViewObjects--;
        }
        const parentCheckbox = document.getElementById(parentNode.nodeId);
        if (parentCheckbox) {
          const newChecked = parentNode.numVisibleViewObjects > 0;
          if (newChecked !== parentCheckbox.checked) {
            parentCheckbox.checked = newChecked;
          }
        }
        parentNode = parentNode.parentNode;
      }
      this.#muteTreeEvents = false;
    });
    this.#onViewObjectXRayed = this.view.onObjectXRayed.subscribe((view, viewObject) => {
      if (this.#muteSceneEvents) {
        return;
      }
      const objectId = viewObject.id;
      const node = this.#objectNodes[objectId];
      if (!node) {
        return;
      }
      this.#muteTreeEvents = true;
      const xrayed = viewObject.xrayed;
      const updated = xrayed !== node.xrayed;
      if (!updated) {
        return;
      }
      node.xrayed = xrayed;
      const listItemElementId = "node-" + node.nodeId;
      const listItemElement = document.getElementById(listItemElementId);
      if (listItemElement !== null) {
        if (xrayed) {
          listItemElement.classList.add("xrayed-node");
        } else {
          listItemElement.classList.remove("xrayed-node");
        }
      }
      this.#muteTreeEvents = false;
    });
    this.#switchExpandHandler = (event) => {
      event.preventDefault();
      event.stopPropagation();
      const switchElement = event.target;
      this.#expandSwitchElement(switchElement);
    };
    this.#switchCollapseHandler = (event) => {
      event.preventDefault();
      event.stopPropagation();
      const switchElement = event.target;
      this.#collapseSwitchElement(switchElement);
    };
    this.#checkboxChangeHandler = (event) => {
      if (this.#muteTreeEvents) {
        return;
      }
      this.#muteSceneEvents = true;
      const checkbox = event.target;
      const visible = checkbox.checked;
      const nodeId = checkbox.id;
      const checkedObjectId = nodeId;
      const checkedNode = this.#objectNodes[checkedObjectId];
      const objects = this.view.objects;
      let numUpdated = 0;
      this.#withNodeTree(checkedNode, (node) => {
        const objectId = node.objectId;
        const checkBoxId = node.nodeId;
        const viewObject = objects[objectId];
        const isLeaf = node.childNodes.length === 0;
        node.numVisibleViewObjects = visible ? node.numViewObjects : 0;
        if (isLeaf && visible !== node.checked) {
          numUpdated++;
        }
        node.checked = visible;
        const checkbox2 = document.getElementById(checkBoxId);
        if (checkbox2) {
          checkbox2.checked = visible;
        }
        if (viewObject) {
          viewObject.visible = visible;
        }
      });
      let parentNode = checkedNode.parentNode;
      while (parentNode) {
        parentNode.checked = visible;
        const checkbox2 = document.getElementById(parentNode.nodeId);
        if (visible) {
          parentNode.numVisibleViewObjects += numUpdated;
        } else {
          parentNode.numVisibleViewObjects -= numUpdated;
        }
        const newChecked = parentNode.numVisibleViewObjects > 0;
        if (newChecked !== checkbox2.checked) {
          checkbox2.checked = newChecked;
        }
        parentNode = parentNode.parentNode;
      }
      this.#muteSceneEvents = false;
    };
    this.hierarchy = params2.hierarchy;
    const modelIds = Object.keys(this.data.models);
    for (let i = 0, len = modelIds.length; i < len; i++) {
      const modelId = modelIds[i];
      this.#addModel(modelId);
    }
    this.#viewer.scene.onModelCreated.subscribe((scene, sceneModel) => {
      if (this.data.models[sceneModel.id]) {
        this.#addModel(sceneModel.id);
      }
    });
  }
  /**
   * Gets how the nodes are organized within this tree view.
   *
   * Accepted values are:
   *
   * * {@link TreeView.AggregationHierarchy} (default)
   * * {@link TreeView.TypesHierarchy}
   * * {@link TreeView.GroupsHierarchy}
   */
  get hierarchy() {
    return this.#hierarchy;
  }
  /**
   * Sets how the nodes are organized within this tree view.
   *
   * Accepted values are:
   *
   * * {@link TreeView.AggregationHierarchy} (default)
   * * {@link TreeView.TypesHierarchy}
   * * {@link TreeView.GroupsHierarchy}
   */
  set hierarchy(hierarchy) {
    hierarchy = hierarchy !== null && hierarchy !== void 0 ? hierarchy : _TreeView.AggregationHierarchy;
    if (hierarchy !== _TreeView.AggregationHierarchy && hierarchy !== _TreeView.GroupsHierarchy && hierarchy !== _TreeView.TypesHierarchy) {
      this.error("Unsupported value for `hierarchy' - defaulting to TreeView.AggregationHierarchy ");
      hierarchy = _TreeView.AggregationHierarchy;
    }
    if (this.#hierarchy === hierarchy) {
      return;
    }
    this.#hierarchy = hierarchy;
    this.#rebuildNodes();
  }
  /**
   * When traversing the {@link data!Data | Data} to build the tree UI nodes, at each
   * {@link data!DataObject | DataObjects}, the TreeView will traverse only the outgoing
   * {@link data!Relationship | Relationships} of this type in
   * {@link data!DataObject.relating | DataObject.relating}.
   */
  get linkType() {
    return this.#linkType;
  }
  /**
   * When traversing the {@link data!Data | Data} to build the tree UI nodes, at each
   * {@link data!DataObject | DataObjects}, the TreeView will traverse only the outgoing
   * {@link data!Relationship | Relationships} of this type in
   * {@link data!DataObject.relating | DataObject.relating}.
   */
  set linkType(linkType) {
    if (this.#linkType === linkType) {
      return;
    }
    this.#linkType = linkType;
    this.#rebuildNodes();
  }
  /**
   * When traversing the {@link data!Data | Data} to build the tree UI nodes for
   * a {@link TreeView.GroupsHierarchy}, these are the values
   * of {@link data!DataObject.type | DataObject.type} that the
   * TreeView groups and subgroups the {@link data!DataObject | DataObjects} on.
   *
   * The grouping for {@link TreeView.GroupsHierarchy} has two levels. The major grouping type is given
   * in ````groupTypes[0]```` and the minor grouping type is given in ````storeyGroups[1]````.
   *
   * Example: ````[IfcBuilding, IfcBuildingStorey]````.
   */
  get groupTypes() {
    return this.#groupTypes;
  }
  /**
   * When traversing the {@link data!Data | Data} to build the tree UI nodes for
   * a {@link TreeView.GroupsHierarchy}, these are the values
   * of {@link data!DataObject.type | DataObject.type} that the
   * TreeView groups and subgroups the {@link data!DataObject | DataObjects} on.
   *
   * The grouping for the {@link treeview!TreeView.GroupsHierarchy | GroupsHierarchy} hierarchy has two levels. The major grouping type is given
   * in ````groupTypes[0]```` and the minor grouping type is given in ````storeyGroups[1]````.
   *
   * Example: ````[IfcBuilding, IfcBuildingStorey]````.
   */
  set groupTypes(groupTypes) {
    if (this.#groupTypes === groupTypes) {
      return;
    }
    this.#groupTypes = groupTypes;
    if (this.#hierarchy === _TreeView.GroupsHierarchy) {
      this.#rebuildNodes();
    }
  }
  /**
   * Highlights the tree view node that represents the given object {@link viewObject}.
   *
   * This causes the tree view to collapse, then expand to reveal the node, then highlight the node.
   *
   * If a node is previously highlighted, de-highlights that node and collapses the tree first.
   *
   * Note that if the TreeView was configured with ````pruneEmptyNodes: true```` (default configuration), then the
   * node won't exist in the tree if it has no viewObjects in the {@link scene!Scene | Scene}. in that case, nothing will happen.
   *
   * Within the DOM, the node is represented by an ````<li>```` element. This method will add a ````.highlighted-node```` class to
   * the element to make it appear highlighted, removing that class when de-highlighting it again. See the CSS rules
   * in the TreeView ifcviewer for an example of that class.
   *
   * @param {String} objectId ID of the {@link viewObject}.
   */
  showNode(objectId) {
    if (this.#showListItemElementId) {
      this.unShowNode();
    }
    const node = this.#objectNodes[objectId];
    if (!node) {
      return;
    }
    const nodeId = node.nodeId;
    const switchElementId = "switch-" + nodeId;
    const switchElement = document.getElementById(switchElementId);
    if (switchElement) {
      this.#expandSwitchElement(switchElement);
      switchElement.scrollIntoView();
      return;
    }
    const path = [];
    path.unshift(node);
    let parentNode = node.parentNode;
    while (parentNode) {
      path.unshift(parentNode);
      parentNode = parentNode.parentNode;
    }
    for (let i = 0, len = path.length; i < len; i++) {
      const node2 = path[i];
      const nodeId2 = node2.nodeId;
      const switchElementId2 = "switch-" + nodeId2;
      const switchElement2 = document.getElementById(switchElementId2);
      if (switchElement2) {
        this.#expandSwitchElement(switchElement2);
      }
    }
    const listItemElementId = "node-" + nodeId;
    const listItemElement = document.getElementById(listItemElementId);
    listItemElement.scrollIntoView({ block: "center" });
    listItemElement.classList.add("highlighted-node");
    this.#showListItemElementId = listItemElementId;
  }
  /**
   * De-highlights the node previously shown with {@link TreeView#showNode}.
   *
   * Does nothing if no node is currently shown.
   *
   * If the node is currently scrolled into view, keeps the node in view.
   */
  unShowNode() {
    if (!this.#showListItemElementId) {
      return;
    }
    const listItemElement = document.getElementById(this.#showListItemElementId);
    if (!listItemElement) {
      this.#showListItemElementId = null;
      return;
    }
    listItemElement.classList.remove("highlighted-node");
    this.#showListItemElementId = null;
  }
  /**
   * Expands the tree to the given depth.
   *
   * Collapses the tree first.
   *
   * @param depth Depth to expand to.
   */
  expandToDepth(depth) {
    this.collapse();
    const expand = (node, countDepth) => {
      if (countDepth === depth) {
        return;
      }
      const nodeId = node.nodeId;
      const switchElementId = `switch-${nodeId}`;
      const switchElement = document.getElementById(switchElementId);
      if (switchElement) {
        this.#expandSwitchElement(switchElement);
        const childNodes = node.childNodes;
        for (let i = 0, len = childNodes.length; i < len; i++) {
          const childNode = childNodes[i];
          expand(childNode, countDepth + 1);
        }
      }
    };
    for (let i = 0, len = this.#rootNodes.length; i < len; i++) {
      const rootNode = this.#rootNodes[i];
      expand(rootNode, 0);
    }
  }
  /**
   * Closes all the nodes in the tree.
   */
  collapse() {
    for (let i = 0, len = this.#rootNodes.length; i < len; i++) {
      const rootNode = this.#rootNodes[i];
      const objectId = rootNode.objectId;
      this.#collapseNode(objectId);
    }
  }
  /**
   * Destroys this TreeView.
   */
  destroy() {
    if (!this.#containerElement) {
      return;
    }
    this.#dataModels = {};
    if (this.#rootElement && !this.#destroyed) {
      this.#rootElement.parentNode.removeChild(this.#rootElement);
      this.view.onObjectVisibility.unsubscribe(this.#onViewObjectVisibility);
      this.view.onObjectXRayed.unsubscribe(this.#onViewObjectXRayed);
      this.#destroyed = true;
    }
    super.destroy();
  }
  /**
   * Adds a model to this tree view.
   *
   * @private
   * @param {String} modelId ID of a model {@link viewObject} in {@link scene!Scene#models}.
   * @param {Object} [options] Options for model in the tree view.
   * @param {String} [options.rootName] Optional display name for the root node. Ordinary, for "containment"
   * and {@link treeview!TreeView.GroupsHierarchy | GroupsHierarchy} hierarchy types, the tree would derive the root node name from the model's "IfcProject" element
   * name. This option allows to override that name when it is not suitable as a display name.
   */
  #addModel(modelId, options = {}) {
    if (!this.#containerElement) {
      return;
    }
    const model = this.#viewer.scene.models[modelId];
    if (!model) {
      this.error(`SceneModel not found: ${modelId}`);
      return;
    }
    const dataModel = this.data.models[modelId];
    if (!dataModel) {
      this.error(`DataModel not found: ${modelId}`);
      return;
    }
    if (this.#dataModels[modelId]) {
      this.error(`Model already added: ${modelId}`);
      return;
    }
    this.#dataModels[modelId] = dataModel;
    model.onDestroyed.one(() => {
      this.#removeModel(model.id);
    });
    this.#rebuildNodes();
  }
  /**
   * Removes a model from this tree view.
   *
   * @private
   * @param {String} modelId ID of a model {@link viewObject} in {@link scene!Scene#models}.
   */
  #removeModel(modelId) {
    if (!this.#containerElement) {
      return;
    }
    const dataModel = this.#dataModels[modelId];
    if (!dataModel) {
      return;
    }
    delete this.#dataModels[modelId];
    this.#rebuildNodes();
  }
  #rebuildNodes() {
    if (this.#rootElement) {
      this.#rootElement.parentNode.removeChild(this.#rootElement);
      this.#rootElement = null;
    }
    this.#rootNodes = [];
    this.#objectNodes = {};
    this.#createEnabledNodes();
  }
  #validate() {
    let valid = true;
    switch (this.#hierarchy) {
      case _TreeView.GroupsHierarchy:
        valid = this.#rootNodes.length > 0;
        break;
      case _TreeView.TypesHierarchy:
        valid = this.#rootNodes.length > 0;
        break;
      case _TreeView.AggregationHierarchy:
      default:
        valid = this.#rootNodes.length > 0;
        break;
    }
    return valid;
  }
  #validateMetaModelForStoreysHierarchy(level = 0, ctx, buildingNode) {
    return true;
  }
  #createEnabledNodes() {
    if (this.#pruneEmptyNodes) {
      this.#findEmptyNodes();
    }
    switch (this.#hierarchy) {
      case _TreeView.GroupsHierarchy:
        this.#buildGroupsNodes();
        if (this.#rootNodes.length === 0) {
          this.error("Failed to build hierarchy TreeView.GroupsHierarchy");
        }
        break;
      case _TreeView.TypesHierarchy:
        this.#buildTypesNodes();
        break;
      case _TreeView.AggregationHierarchy:
      default:
        this.#buildAggregationNodes();
    }
    if (this.#sortNodes) {
      this.#doSortNodes();
    }
    this.#synchNodesToEntities();
    this.#createNodeElements();
    this.expandToDepth(this.#autoExpandDepth);
  }
  #createDisabledNodes() {
    const objects = this.data.objects;
    for (let objectId in objects) {
      const dataObject = objects[objectId];
      if (Object.keys(dataObject.relating).length === 0) {
        const dataObjectType = dataObject.type;
        const name12 = dataObject.name;
        const rootName = name12 && name12 !== "" && name12 !== "Undefined" && name12 !== "Default" ? name12 : `${dataObjectType}`;
        const ul = document.createElement("ul");
        const li = document.createElement("li");
        ul.appendChild(li);
        this.#containerElement.appendChild(ul);
        this.#rootElement = ul;
        const switchElement = document.createElement("a");
        switchElement.href = "#";
        switchElement.textContent = "!";
        switchElement.classList.add("warn");
        switchElement.classList.add("warning");
        li.appendChild(switchElement);
        const span = document.createElement("span");
        span.textContent = rootName;
        li.appendChild(span);
      }
    }
  }
  #findEmptyNodes() {
    const objects = this.data.objects;
    for (let objectId in objects) {
      const dataObject = objects[objectId];
      if (Object.keys(dataObject.relating).length === 0) {
        this.#findEmptyNodes2(dataObject);
      }
    }
  }
  #findEmptyNodes2(dataObject) {
    const viewer = this.#viewer;
    const scene = viewer.scene;
    const aggregations = dataObject.related[this.#linkType];
    const objectId = dataObject.id;
    const viewObject = scene.objects[objectId];
    let sceneObjectCounts = 0;
    if (viewObject) {
      sceneObjectCounts++;
    }
    if (aggregations) {
      for (let i = 0, len = aggregations.length; i < len; i++) {
        const aggregation = aggregations[i];
        const aggregatedDataObject = aggregation.relatedObject;
        const aggregatedCount = this.#findEmptyNodes2(aggregatedDataObject);
        this.#dataObjectSceneObjectCounts[aggregatedDataObject.id] = aggregatedCount;
        sceneObjectCounts += aggregatedCount;
      }
    }
    this.#dataObjectSceneObjectCounts[dataObject.id] = sceneObjectCounts;
    return sceneObjectCounts;
  }
  #buildGroupsNodes() {
    const objects = this.data.objects;
    for (let objectId in objects) {
      const dataObject = objects[objectId];
      if (Object.keys(dataObject.relating).length === 0) {
        this.#buildGroupsNodes2(dataObject, [], null, null, null);
      }
    }
  }
  #buildGroupsNodes2(dataObject, pathNodes, buildingNode, storeyNode, typeNodes) {
    if (this.#pruneEmptyNodes && !this.#dataObjectSceneObjectCounts[dataObject.id]) {
      return;
    }
    const objectId = dataObject.id;
    const type = dataObject.type;
    const name12 = dataObject.name;
    const aggregations = dataObject.related[this.#linkType];
    if (pathNodes.length < this.#groupTypes.length) {
      const groupType = this.#groupTypes[pathNodes.length];
      if (pathNodes.length === 0) {
        if (type === groupType) {
          const node = {
            nodeId: objectId,
            objectId,
            title: this.#rootName || (name12 && name12 !== "" && name12 !== "Undefined" && name12 !== "Default" ? name12 : type),
            type,
            parentNode: null,
            numViewObjects: 0,
            numVisibleViewObjects: 0,
            checked: false,
            xrayed: false,
            childNodes: []
          };
          pathNodes.push(node);
          this.#rootNodes.push(node);
          this.#objectNodes[node.objectId] = node;
        }
      } else {
        if (type === groupType) {
          const parentNode = pathNodes[pathNodes.length - 1];
          const node = {
            nodeId: objectId,
            objectId,
            title: name12 && name12 !== "" && name12 !== "Undefined" && name12 !== "Default" ? name12 : `${type}`,
            type,
            parentNode,
            numViewObjects: 0,
            numVisibleViewObjects: 0,
            checked: false,
            xrayed: false,
            childNodes: []
          };
          parentNode.childNodes.push(node);
          pathNodes.push(node);
          this.#objectNodes[node.objectId] = node;
        }
      }
    } else {
      const parentNode = pathNodes[pathNodes.length - 1];
      const viewObjects = this.view.objects;
      const viewObject = viewObjects[objectId];
      if (viewObject) {
        typeNodes = typeNodes || {};
        let typeNode = typeNodes[type];
        if (!typeNode) {
          const typeNodeObjectId = parentNode.objectId + "." + type;
          const typeNodeNodeId = typeNodeObjectId;
          typeNode = {
            nodeId: typeNodeNodeId,
            objectId: typeNodeObjectId,
            title: `${type}`,
            type,
            parentNode,
            numViewObjects: 0,
            numVisibleViewObjects: 0,
            checked: false,
            xrayed: false,
            childNodes: []
          };
          parentNode.childNodes.push(typeNode);
          this.#objectNodes[typeNodeObjectId] = typeNode;
          typeNodes[type] = typeNode;
        }
        const leafNode = {
          nodeId: objectId,
          objectId,
          title: name12 && name12 !== "" && name12 !== "Undefined" && name12 !== "Default" ? name12 : "" + type,
          type,
          parentNode: typeNode,
          numViewObjects: 0,
          numVisibleViewObjects: 0,
          checked: false,
          xrayed: false,
          childNodes: []
        };
        typeNode.childNodes.push(leafNode);
        this.#objectNodes[leafNode.objectId] = leafNode;
      }
    }
    if (aggregations) {
      for (let i = 0, len = aggregations.length; i < len; i++) {
        const aggregation = aggregations[i];
        const aggregatedDataObject = aggregation.relatedObject;
        this.#buildGroupsNodes2(aggregatedDataObject, pathNodes, buildingNode, storeyNode, typeNodes);
      }
    }
  }
  #buildTypesNodes() {
    const objects = this.data.objects;
    for (let objectId in objects) {
      const dataObject = objects[objectId];
      if (Object.keys(dataObject.relating).length === 0) {
        this.#buildTypesNodes2(dataObject, null, null);
      }
    }
  }
  #buildTypesNodes2(dataObject, rootNode, typeNodes) {
    if (this.#pruneEmptyNodes && !this.#dataObjectSceneObjectCounts[dataObject.id]) {
      return;
    }
    const objectId = dataObject.id;
    const type = dataObject.type;
    const name12 = dataObject.name;
    const aggregations = dataObject.related[this.#linkType];
    if (aggregations) {
      for (let i = 0, len = aggregations.length; i < len; i++) {
        const aggregation = aggregations[i];
        const aggregatedDataObject = aggregation.relatedObject;
        this.#buildTypesNodes2(aggregatedDataObject, rootNode, typeNodes);
      }
    }
  }
  #buildAggregationNodes() {
    const objects = this.data.objects;
    for (let objectId in objects) {
      const dataObject = objects[objectId];
      if (Object.keys(dataObject.relating).length === 0) {
        this.#buildAggregationNodes2(dataObject, null);
      }
    }
  }
  #buildAggregationNodes2(dataObject, parentNode) {
    if (this.#pruneEmptyNodes && !this.#dataObjectSceneObjectCounts[dataObject.id]) {
      return;
    }
    const objectId = dataObject.id;
    const type = dataObject.type;
    const name12 = dataObject.name || type;
    const aggregations = dataObject.related[this.#linkType];
    const node = {
      nodeId: objectId,
      objectId,
      title: !parentNode ? this.#rootName || name12 : name12 && name12 !== "" && name12 !== "Undefined" && name12 !== "Default" ? name12 : type,
      type,
      parentNode,
      numViewObjects: 0,
      numVisibleViewObjects: 0,
      checked: false,
      xrayed: false,
      childNodes: []
    };
    if (parentNode) {
      parentNode.childNodes.push(node);
    } else {
      this.#rootNodes.push(node);
    }
    this.#objectNodes[node.objectId] = node;
    if (aggregations) {
      for (let i = 0, len = aggregations.length; i < len; i++) {
        const aggregation = aggregations[i];
        const aggregatedDataObject = aggregation.relatedObject;
        this.#buildAggregationNodes2(aggregatedDataObject, node);
      }
    }
  }
  #doSortNodes() {
    for (let i = 0, len = this.#rootNodes.length; i < len; i++) {
      const rootNode = this.#rootNodes[i];
      this.#sortChildNodes(rootNode);
    }
  }
  #sortChildNodes(node) {
  }
  #getSpatialSortFunc() {
  }
  #alphaSortFunc(node1, node2) {
    const title1 = node1.title.toUpperCase();
    const title2 = node2.title.toUpperCase();
    if (title1 < title2) {
      return -1;
    }
    if (title1 > title2) {
      return 1;
    }
    return 0;
  }
  #synchNodesToEntities() {
    const objectIds = Object.keys(this.data.objects);
    const dataObjects = this.data.objects;
    const viewObjects = this.view.objects;
    for (let i = 0, len = objectIds.length; i < len; i++) {
      const objectId = objectIds[i];
      const dataObject = dataObjects[objectId];
      if (dataObject) {
        const node = this.#objectNodes[objectId];
        if (node) {
          const viewObject = viewObjects[objectId];
          if (viewObject) {
            const visible = viewObject.visible;
            node.numViewObjects = 1;
            node.xrayed = viewObject.xrayed;
            if (visible) {
              node.numVisibleViewObjects = 1;
              node.checked = true;
            } else {
              node.numVisibleViewObjects = 0;
              node.checked = false;
            }
            let parentNode = node.parentNode;
            while (parentNode) {
              parentNode.numViewObjects++;
              if (visible) {
                parentNode.numVisibleViewObjects++;
                parentNode.checked = true;
              }
              parentNode = parentNode.parentNode;
            }
          }
        }
      }
    }
  }
  #withNodeTree(node, callback) {
    callback(node);
    const childNodes = node.childNodes;
    if (!childNodes) {
      return;
    }
    for (let i = 0, len = childNodes.length; i < len; i++) {
      this.#withNodeTree(childNodes[i], callback);
    }
  }
  #createNodeElements() {
    if (this.#rootNodes.length === 0) {
      return;
    }
    const rootNodeElements = this.#rootNodes.map((rootNode) => {
      return this.#createNodeElement(rootNode);
    });
    const ul = document.createElement("ul");
    rootNodeElements.forEach((nodeElement) => {
      ul.appendChild(nodeElement);
    });
    this.#containerElement.appendChild(ul);
    this.#rootElement = ul;
  }
  #createNodeElement(node) {
    const nodeElement = document.createElement("li");
    const nodeId = node.nodeId;
    if (node.xrayed) {
      nodeElement.classList.add("xrayed-node");
    }
    nodeElement.id = "node-" + nodeId;
    if (node.childNodes.length > 0) {
      const switchElementId = "switch-" + nodeId;
      const switchElement = document.createElement("a");
      switchElement.href = "#";
      switchElement.id = switchElementId;
      switchElement.textContent = "+";
      switchElement.classList.add("plus");
      switchElement.addEventListener("click", this.#switchExpandHandler);
      nodeElement.appendChild(switchElement);
    }
    const checkbox = document.createElement("input");
    checkbox.id = nodeId;
    checkbox.type = "checkbox";
    checkbox.checked = node.checked;
    checkbox.style["pointer-events"] = "all";
    checkbox.addEventListener("change", this.#checkboxChangeHandler);
    nodeElement.appendChild(checkbox);
    const span = document.createElement("span");
    span.textContent = node.title;
    nodeElement.appendChild(span);
    span.oncontextmenu = (e) => {
      this.onContextMenu.dispatch(this, {
        event: e,
        treeView: this,
        treeViewNode: node
      });
      e.preventDefault();
    };
    span.onclick = (e) => {
      this.onNodeTitleClicked.dispatch(this, {
        event: e,
        treeView: this,
        treeViewNode: node
      });
      e.preventDefault();
    };
    return nodeElement;
  }
  #expandSwitchElement(switchElement) {
    const parentElement = switchElement.parentElement;
    if (!parentElement) {
      return;
    }
    const expanded = parentElement.getElementsByTagName("li")[0];
    if (expanded) {
      return;
    }
    const nodeId = parentElement.id.replace("node-", "");
    const objectId = nodeId;
    const switchNode = this.#objectNodes[objectId];
    const childNodes = switchNode.childNodes;
    const nodeElements = childNodes.map((node) => {
      return this.#createNodeElement(node);
    });
    const ul = document.createElement("ul");
    nodeElements.forEach((nodeElement) => {
      ul.appendChild(nodeElement);
    });
    parentElement.appendChild(ul);
    switchElement.classList.remove("plus");
    switchElement.classList.add("minus");
    switchElement.textContent = "-";
    switchElement.removeEventListener("click", this.#switchExpandHandler);
    switchElement.addEventListener("click", this.#switchCollapseHandler);
  }
  #collapseNode(objectId) {
    const nodeId = objectId;
    const switchElementId = `switch-${nodeId}`;
    const switchElement = document.getElementById(switchElementId);
    if (!switchElement) {
      return;
    }
    this.#collapseSwitchElement(switchElement);
  }
  #collapseSwitchElement(switchElement) {
    if (!switchElement) {
      return;
    }
    const parent = switchElement.parentElement;
    if (!parent) {
      return;
    }
    const ul = parent.querySelector("ul");
    if (!ul) {
      return;
    }
    parent.removeChild(ul);
    switchElement.classList.remove("minus");
    switchElement.classList.add("plus");
    switchElement.textContent = "+";
    switchElement.removeEventListener("click", this.#switchCollapseHandler);
    switchElement.addEventListener("click", this.#switchExpandHandler);
  }
};

// ../sdk/src/contextmenu/index.ts
var contextmenu_exports = {};
__export(contextmenu_exports, {
  ContextMenu: () => ContextMenu
});

// ../sdk/src/contextmenu/ContextMenu.ts
var import_strongly_typed_events21 = __toESM(require_dist8());
var idMap = new Map2();
var Menu = class {
  id;
  parentItem;
  groups;
  menuElement;
  shown;
  mouseOver;
  constructor(id) {
    this.id = id;
    this.parentItem = null;
    this.groups = [];
    this.menuElement = null;
    this.shown = false;
    this.mouseOver = 0;
  }
};
var Group = class {
  items;
  constructor() {
    this.items = [];
  }
};
var Item = class {
  id;
  getTitle;
  doAction;
  getEnabled;
  getShown;
  itemElement;
  subMenu;
  enabled;
  parentMenu;
  shown;
  constructor(id, getTitle, doAction, getEnabled, getShown) {
    this.id = id;
    this.getTitle = getTitle;
    this.doAction = doAction;
    this.getEnabled = getEnabled;
    this.getShown = getShown;
    this.itemElement = null;
    this.subMenu = null;
    this.enabled = true;
  }
};
var ContextMenu = class {
  #id;
  #itemList;
  #rootMenu;
  #menuList;
  #nextId;
  #shown;
  #itemMap;
  #menuMap;
  #itemsCfg;
  #enabled;
  #context;
  #hideOnAction;
  #canvasTouchStartHander;
  /**
   * Emits an event each time this ContextMenu is shown.
   *
   * @event
   */
  onShown;
  /**
   * Emits an event each time this ContextMenu is hidden.
   *
   * @event
   */
  onHidden;
  /**
   * Creates a ````ContextMenu````.
   *
   * The ````ContextMenu```` will be initially hidden.
   *
   * @param {Object} [cfg] ````ContextMenu```` configuration.
   * @param {Object} [cfg.items] The context menu items. These can also be dynamically set on {@link ContextMenu#items}. See the class documentation for an example.
   * @param {Object} [cfg.context] The context, which is passed into the item callbacks. This can also be dynamically set on {@link ContextMenu#context}. This must be set before calling {@link ContextMenu#show}.
   * @param {Boolean} [cfg.enabled=true] Whether this ````ContextMenu```` is initially enabled. {@link ContextMenu#show} does nothing while this is ````false````.
   * @param {Boolean} [cfg.hideOnMouseDown=true] Whether this ````ContextMenu```` automatically hides whenever we mouse-down or tap anywhere in the page.
   * @param {Boolean} [cfg.hideOnAction=true] Whether this ````ContextMenu```` automatically hides after we select a menu item. Se false if we want the menu to remain shown and show any updates to its item titles, after we've selected an item.
   */
  constructor(cfg) {
    this.#id = idMap.addItem();
    this.#context = null;
    this.#enabled = false;
    this.#itemsCfg = [];
    this.#rootMenu = null;
    this.#menuList = [];
    this.#menuMap = {};
    this.#itemList = [];
    this.#itemMap = {};
    this.#shown = false;
    this.#nextId = 0;
    this.onShown = new EventEmitter(new import_strongly_typed_events21.EventDispatcher());
    this.onHidden = new EventEmitter(new import_strongly_typed_events21.EventDispatcher());
    if (cfg.hideOnMouseDown !== false) {
      document.addEventListener("mousedown", (event) => {
        if (!event.target.classList.contains("xeokit-context-menu-item")) {
          this.hide();
        }
      });
      document.addEventListener("touchstart", this.#canvasTouchStartHander = (event) => {
        if (!event.target.classList.contains("xeokit-context-menu-item")) {
          this.hide();
        }
      });
    }
    if (cfg.items) {
      this.items = cfg.items;
    }
    this.#hideOnAction = cfg.hideOnAction !== false;
    this.context = cfg.context;
    this.enabled = cfg.enabled !== false;
    this.hide();
  }
  /**
   * Sets the ````ContextMenu```` items.
   *
   * These can be updated dynamically at any time.
   *
   * See class documentation for an example.
   *
   * @type {Object[]}
   */
  set items(itemsCfg) {
    this.#clear();
    this.#itemsCfg = itemsCfg || [];
    this.#parseItems(itemsCfg);
    this.#createUI();
  }
  /**
   * Gets the ````ContextMenu```` items.
   *
   * @type {Object[]}
   */
  get items() {
    return this.#itemsCfg;
  }
  /**
   * Sets whether this ````ContextMenu```` is enabled.
   *
   * Hides the menu when disabling.
   *
   * @type {Boolean}
   */
  set enabled(enabled2) {
    enabled2 = !!enabled2;
    if (enabled2 === this.#enabled) {
      return;
    }
    this.#enabled = enabled2;
    if (!this.#enabled) {
      this.hide();
    }
  }
  /**
   * Gets whether this ````ContextMenu```` is enabled.
   *
   * {@link ContextMenu#show} does nothing while this is ````false````.
   *
   * @type {Boolean}
   */
  get enabled() {
    return this.#enabled;
  }
  /**
   * Sets the ````ContextMenu```` context.
   *
   * The context can be any object that you need to be provides to the callbacks configured on {@link ContextMenu#items}.
   *
   * This must be set before calling {@link ContextMenu#show}.
   *
   * @type {Object}
   */
  set context(context) {
    this.#context = context;
  }
  /**
   * Gets the ````ContextMenu```` context.
   *
   * @type {Object}
   */
  get context() {
    return this.#context;
  }
  /**
   * Shows this ````ContextMenu```` at the given page coordinates.
   *
   * Does nothing when {@link ContextMenu#enabled} is ````false````.
   *
   * Logs error to console and does nothing if {@link ContextMenu#context} has not been set.
   *
   * Fires a "shown" event when shown.
   *
   * @param {Number} pageX Page X-coordinate.
   * @param {Number} pageY Page Y-coordinate.
   */
  show(pageX, pageY) {
    if (!this.#context) {
      console.error("[ContextMenu] ContextMenu cannot be shown without a context - set context first");
      return;
    }
    if (!this.#enabled) {
      return;
    }
    if (this.#shown) {
      return;
    }
    this.#hideAllMenus();
    this.#updateItemsTitles();
    this.#updateItemsEnabledStatus();
    this.#showMenu(this.#rootMenu.id, pageX, pageY);
    this.#shown = true;
    this.onShown.dispatch(this, null);
  }
  /**
   * Gets whether this ````ContextMenu```` is currently shown or not.
   *
   * @returns {Boolean} Whether this ````ContextMenu```` is shown.
   */
  get shown() {
    return this.#shown;
  }
  /**
   * Hides this ````ContextMenu````.
   *
   * Fires a "hidden" event when hidden.
   */
  hide() {
    if (!this.#enabled) {
      return;
    }
    if (!this.#shown) {
      return;
    }
    this.#hideAllMenus();
    this.#shown = false;
    this.onHidden.dispatch(this, null);
  }
  /**
   * Destroys this ````ContextMenu````.
   */
  destroy() {
    this.#context = null;
    this.#clear();
    if (this.#id !== null) {
      idMap.removeItem(this.#id);
      this.#id = null;
    }
  }
  #clear() {
    for (let i = 0, len = this.#menuList.length; i < len; i++) {
      const menu = this.#menuList[i];
      const menuElement = menu.menuElement;
      menuElement.parentElement.removeChild(menuElement);
    }
    this.#itemsCfg = [];
    this.#rootMenu = null;
    this.#menuList = [];
    this.#menuMap = {};
    this.#itemList = [];
    this.#itemMap = {};
  }
  #parseItems(itemsCfg) {
    const visitItems = (itemsCfg2) => {
      const menuId = this.#getNextId();
      const menu = new Menu(menuId);
      for (let i = 0, len = itemsCfg2.length; i < len; i++) {
        const itemsGroupCfg = itemsCfg2[i];
        const group = new Group();
        menu.groups.push(group);
        for (let j = 0, lenj = itemsGroupCfg.length; j < lenj; j++) {
          const itemCfg = itemsGroupCfg[j];
          const subItemsCfg = itemCfg.items;
          const hasSubItems = subItemsCfg && subItemsCfg.length > 0;
          const itemId = this.#getNextId();
          const getTitle = itemCfg.getTitle || (() => {
            return itemCfg.title || "";
          });
          const doAction = itemCfg.doAction || itemCfg.callback || (() => {
          });
          const getEnabled = itemCfg.getEnabled || (() => {
            return true;
          });
          const getShown = itemCfg.getShown || (() => {
            return true;
          });
          const item = new Item(itemId, getTitle, doAction, getEnabled, getShown);
          item.parentMenu = menu;
          group.items.push(item);
          if (hasSubItems) {
            const subMenu = visitItems(subItemsCfg);
            item.subMenu = subMenu;
            subMenu.parentItem = item;
          }
          this.#itemList.push(item);
          this.#itemMap[item.id] = item;
        }
      }
      this.#menuList.push(menu);
      this.#menuMap[menu.id] = menu;
      return menu;
    };
    this.#rootMenu = visitItems(itemsCfg);
  }
  #getNextId() {
    return "ContextMenu_" + this.#id + "_" + this.#nextId++;
  }
  #createUI() {
    const visitMenu = (menu) => {
      this.#createMenuUI(menu);
      const groups = menu.groups;
      for (let i = 0, len = groups.length; i < len; i++) {
        const group = groups[i];
        const groupItems = group.items;
        for (let j = 0, lenj = groupItems.length; j < lenj; j++) {
          const item = groupItems[j];
          const subMenu = item.subMenu;
          if (subMenu) {
            visitMenu(subMenu);
          }
        }
      }
    };
    visitMenu(this.#rootMenu);
  }
  #createMenuUI(menu) {
    const groups = menu.groups;
    const html = [];
    html.push('<div class="xeokit-context-menu ' + menu.id + '" style="z-index:300000; position: absolute;">');
    html.push("<ul>");
    if (groups) {
      for (let i = 0, len = groups.length; i < len; i++) {
        const group = groups[i];
        const groupIdx = i;
        const groupLen = len;
        const groupItems = group.items;
        if (groupItems) {
          for (let j = 0, lenj = groupItems.length; j < lenj; j++) {
            const item = groupItems[j];
            const itemSubMenu = item.subMenu;
            const actionTitle = item.title || "";
            if (itemSubMenu) {
              html.push(
                `<li id="${item.id}" class="xeokit-context-menu-item"
                                style="${groupIdx === groupLen - 1 || j < lenj - 1 ? "border-bottom: 0" : "border-bottom: 1px solid black"}">
                                ${actionTitle} [MORE]</li>`
              );
            } else {
              html.push(
                '<li id="' + item.id + '" class="xeokit-context-menu-item" style="' + (groupIdx === groupLen - 1 || j < lenj - 1 ? "border-bottom: 0" : "border-bottom: 1px solid black") + '">' + actionTitle + "</li>"
              );
            }
          }
        }
      }
    }
    html.push("</ul>");
    html.push("</div>");
    const htmlString = html.join("");
    document.body.insertAdjacentHTML("beforeend", htmlString);
    const menuElement = document.querySelector("." + menu.id);
    menu.menuElement = menuElement;
    menuElement.style["border-radius"] = "4px";
    menuElement.style.display = "none";
    menuElement.style["z-index"] = 3e5;
    menuElement.style.background = "white";
    menuElement.style.border = "1px solid black";
    menuElement.style["box-shadow"] = "0 4px 5px 0 gray";
    menuElement.oncontextmenu = (e) => {
      e.preventDefault();
    };
    let lastSubMenu = null;
    if (groups) {
      for (let i = 0, len = groups.length; i < len; i++) {
        const group = groups[i];
        const groupItems = group.items;
        if (groupItems) {
          for (let j = 0, lenj = groupItems.length; j < lenj; j++) {
            const item = groupItems[j];
            const itemSubMenu = item.subMenu;
            item.itemElement = document.getElementById(item.id);
            if (!item.itemElement) {
              console.error("[ContextMenu] ContextMenu item element not found: " + item.id);
              continue;
            }
            item.itemElement.addEventListener("mouseenter", (event) => {
              event.preventDefault();
              const subMenu = item.subMenu;
              if (!subMenu) {
                if (lastSubMenu) {
                  this.#hideMenu(lastSubMenu.id);
                  lastSubMenu = null;
                }
                return;
              }
              if (lastSubMenu && lastSubMenu.id !== subMenu.id) {
                this.#hideMenu(lastSubMenu.id);
                lastSubMenu = null;
              }
              if (item.enabled === false) {
                return;
              }
              const itemElement = item.itemElement;
              const subMenuElement = subMenu.menuElement;
              const itemRect = itemElement.getBoundingClientRect();
              const menuRect = subMenuElement.getBoundingClientRect();
              const subMenuWidth = 200;
              const showOnLeft = itemRect.right + subMenuWidth > window.innerWidth;
              if (showOnLeft) {
                this.#showMenu(subMenu.id, itemRect.left - subMenuWidth, itemRect.top - 1);
              } else {
                this.#showMenu(subMenu.id, itemRect.right - 5, itemRect.top - 1);
              }
              lastSubMenu = subMenu;
            });
            if (!itemSubMenu) {
              item.itemElement.addEventListener("click", (event) => {
                event.preventDefault();
                if (!this.#context) {
                  return;
                }
                if (item.enabled === false) {
                  return;
                }
                if (item.doAction) {
                  item.doAction(this.#context);
                }
                if (this.#hideOnAction) {
                  this.hide();
                } else {
                  this.#updateItemsTitles();
                  this.#updateItemsEnabledStatus();
                }
              });
              item.itemElement.addEventListener("mouseup", (event) => {
                if (event.which !== 3) {
                  return;
                }
                event.preventDefault();
                if (!this.#context) {
                  return;
                }
                if (item.enabled === false) {
                  return;
                }
                if (item.doAction) {
                  item.doAction(this.#context);
                }
                if (this.#hideOnAction) {
                  this.hide();
                } else {
                  this.#updateItemsTitles();
                  this.#updateItemsEnabledStatus();
                }
              });
              item.itemElement.addEventListener("mouseenter", (event) => {
                event.preventDefault();
                if (item.enabled === false) {
                  return;
                }
                if (item.doHover) {
                  item.doHover(this.#context);
                }
              });
            }
          }
        }
      }
    }
  }
  #updateItemsTitles() {
    if (!this.#context) {
      return;
    }
    for (let i = 0, len = this.#itemList.length; i < len; i++) {
      const item = this.#itemList[i];
      const itemElement = item.itemElement;
      if (!itemElement) {
        continue;
      }
      const getShown = item.getShown;
      if (!getShown || !getShown(this.#context)) {
        continue;
      }
      const title = item.getTitle(this.#context);
      if (item.subMenu) {
        itemElement.innerText = title;
      } else {
        itemElement.innerText = title;
      }
    }
  }
  #updateItemsEnabledStatus() {
    if (!this.#context) {
      return;
    }
    for (let i = 0, len = this.#itemList.length; i < len; i++) {
      const item = this.#itemList[i];
      const itemElement = item.itemElement;
      if (!itemElement) {
        continue;
      }
      const getEnabled = item.getEnabled;
      if (!getEnabled) {
        continue;
      }
      const getShown = item.getShown;
      if (!getShown) {
        continue;
      }
      const shown = getShown(this.#context);
      item.shown = shown;
      if (!shown) {
        itemElement.style.visibility = "hidden";
        itemElement.style.height = "0";
        itemElement.style.padding = "0";
        continue;
      } else {
        itemElement.style.visibility = "visible";
        itemElement.style.height = "auto";
        itemElement.style.padding = null;
      }
      const enabled2 = getEnabled(this.#context);
      item.enabled = enabled2;
      if (!enabled2) {
        itemElement.classList.add("disabled");
      } else {
        itemElement.classList.remove("disabled");
      }
    }
  }
  #showMenu(menuId, pageX, pageY) {
    const menu = this.#menuMap[menuId];
    if (!menu) {
      console.error("[ContextMenu] Menu not found: " + menuId);
      return;
    }
    if (menu.shown) {
      return;
    }
    const menuElement = menu.menuElement;
    if (menuElement) {
      this.#showMenuElement(menuElement, pageX, pageY);
      menu.shown = true;
    }
  }
  #hideMenu(menuId) {
    const menu = this.#menuMap[menuId];
    if (!menu) {
      console.error("[ContextMenu] Menu not found: " + menuId);
      return;
    }
    if (!menu.shown) {
      return;
    }
    const menuElement = menu.menuElement;
    if (menuElement) {
      this.#hideMenuElement(menuElement);
      menu.shown = false;
    }
  }
  #hideAllMenus() {
    for (let i = 0, len = this.#menuList.length; i < len; i++) {
      const menu = this.#menuList[i];
      this.#hideMenu(menu.id);
    }
  }
  #showMenuElement(menuElement, pageX, pageY) {
    menuElement.style.display = "block";
    const menuHeight = menuElement.offsetHeight;
    const menuWidth = menuElement.offsetWidth;
    if (pageY + menuHeight > window.innerHeight) {
      pageY = window.innerHeight - menuHeight;
    }
    if (pageX + menuWidth > window.innerWidth) {
      pageX = window.innerWidth - menuWidth;
    }
    menuElement.style.left = pageX + "px";
    menuElement.style.top = pageY + "px";
  }
  #hideMenuElement(menuElement) {
    menuElement.style.display = "none";
  }
};

// ../sdk/src/modelconverter/index.ts
var modelconverter_exports = {};
__export(modelconverter_exports, {
  ModelConverter: () => ModelConverter
});

// ../sdk/src/modelconverter/ModelConverter.ts
var ModelConverter = class {
  /**
   * A collection of available loaders, mapped by format identifiers.
   * Each loader is responsible for parsing specific file formats.
   */
  loaders;
  /**
   * A collection of available exporters, mapped by format identifiers.
   * Each exporter generates output files in a specific format.
   */
  exporters;
  /**
   * A collection of conversion pipelines, indexed by pipeline name.
   * Each pipeline defines how input data is processed and converted into output formats.
   */
  pipelines;
  /**
   * Creates a new ModelConverter instance with the provided configuration.
   *
   * @param params - An object containing configured loaders, exporters, and optional pipelines.
   */
  constructor(params2) {
    this.loaders = params2.loaders;
    this.exporters = params2.exporters;
    this.pipelines = params2.pipelines || {};
  }
  /**
   * Transforms 3D model data using a specified conversion pipeline.
   *
   * This method loads the given input file data, constructs scene and data models, and then
   * writes the converted output using the configured exporters.
   *
   * @param convertRequest - The parameters specifying the pipeline and input data.
   * @returns A promise that resolves to a `ModelConverterResult` object containing the output files.
   *
   * @throws {SDKError} If required parameters are missing or if an unsupported pipeline is specified.
   */
  convert(convertRequest) {
    return new Promise((resolve2, reject) => {
      if (!convertRequest) {
        return reject(`Argument expected: convertRequest`);
      }
      const pipelineId = convertRequest.pipeline;
      if (!pipelineId) {
        return reject(`Argument expected: pipelineId`);
      }
      const pipeline = this.pipelines[pipelineId];
      if (!pipeline) {
        return reject(`Unsupported pipeline: "${pipelineId}" - supported pipelines are [${Object.keys(this.pipelines || {})}]`);
      }
      const conversionParamsInputs = convertRequest.inputs;
      if (!conversionParamsInputs) {
        return reject(`Argument expected: convertRequest.inputs`);
      }
      const pipelineInputs = pipeline.inputs;
      if (!pipelineInputs) {
        return reject(`No inputs defined on pipeline "${pipelineId}"`);
      }
      const pipelineInputIds = Object.keys(pipelineInputs);
      if (pipelineInputIds.length === 0) {
        return reject(`No inputs defined on pipeline "${pipelineId}"`);
      }
      const pipelineOutputs = pipeline.outputs;
      if (!pipelineOutputs) {
        return reject(`No outputs defined on pipeline "${pipelineId}"`);
      }
      const pipelineOutputIds = Object.keys(pipelineOutputs);
      if (pipelineOutputIds.length === 0) {
        return reject(`No outputs defined on pipeline "${pipelineId}"`);
      }
      for (let inputId in pipelineInputs) {
        const inputParams = pipelineInputs[inputId];
        const loaderId = inputParams.loader;
        if (!loaderId) {
          return reject(`No loader defined on input "${inputId}" of pipeline "${pipelineId}"`);
        }
        const loader = this.loaders[loaderId];
        if (!loader) {
          return reject(`Can't resolve loader "${loaderId}", referenced by input "${inputId}" of pipeline "${pipelineId}"`);
        }
      }
      for (let outputId in pipelineOutputs) {
        const outputParams = pipelineOutputs[outputId];
        const exporterId = outputParams.exporter;
        if (!exporterId) {
          return reject(`No exporter defined on output "${outputId}" of pipeline "${pipelineId}"`);
        }
        const exporter = this.exporters[exporterId];
        if (!exporter) {
          return reject(`Can't resolve exporter "${exporterId}", referenced by output "${outputId}" of pipeline "${pipelineId}"`);
        }
      }
      const result = {
        pipeline: pipelineId,
        outputs: {}
      };
      const scene = new Scene();
      const data = new Data();
      const processInputs = (done) => {
        const processNextInput = (index = 0) => {
          if (index >= pipelineInputIds.length) {
            done();
            return;
          }
          const pipelineInputId = pipelineInputIds[index];
          const pipelineInput = pipelineInputs[pipelineInputId];
          const conversionParamsInput = conversionParamsInputs[pipelineInputId];
          const loader = this.loaders[pipelineInput.loader];
          const fileData = conversionParamsInput;
          const sceneModelId = pipelineInput.sceneModel || "default";
          const sceneModel = scene.models[sceneModelId] || scene.createModel({
            id: sceneModelId
          });
          const dataModelId = pipelineInput.dataModel || "default";
          const dataModel = data.models[dataModelId] || data.createModel({
            id: dataModelId
          });
          if (sceneModel instanceof SDKError || dataModel instanceof SDKError) {
            processNextInput(index + 1);
          } else {
            loader.load({
              fileData,
              sceneModel,
              dataModel
            }).then(() => {
              processNextInput(index + 1);
            });
          }
        };
        processNextInput(0);
      };
      const buildSceneModels = (done) => {
        const sceneModelIds = Object.keys(scene.models);
        const buildNextSceneModel = (index = 0) => {
          if (index >= sceneModelIds.length) {
            done();
            return;
          }
          const sceneModelId = sceneModelIds[index];
          const sceneModel = scene.models[sceneModelId];
          sceneModel.build().then(() => {
            buildNextSceneModel(index + 1);
          }).catch((errMsg) => {
            done();
          });
        };
        buildNextSceneModel(0);
      };
      const buildDataModels = (done) => {
        const dataModelIds = Object.keys(data.models);
        const buildNextDataModel = (index = 0) => {
          if (index >= dataModelIds.length) {
            done();
            return;
          }
          const dataModelId = dataModelIds[index];
          const dataModel = data.models[dataModelId];
          dataModel.build().then(() => {
            buildNextDataModel(index + 1);
          }).catch((errMsg) => {
            done();
          });
        };
        buildNextDataModel(0);
      };
      const processOutputs = (done) => {
        const processNextOutput = (index) => {
          if (index >= pipelineOutputIds.length) {
            done();
            return;
          }
          const pipelineOutputId = pipelineOutputIds[index];
          const pipelineOutput = pipelineOutputs[pipelineOutputId];
          const exporter = this.exporters[pipelineOutput.exporter];
          const version2 = pipelineOutput.version;
          const sceneModelId = pipelineOutput.sceneModel || "default";
          const sceneModel = scene.models[sceneModelId] || scene.createModel({
            id: sceneModelId
          });
          const dataModelId = pipelineOutput.dataModel || "default";
          const dataModel = data.models[dataModelId] || data.createModel({
            id: dataModelId
          });
          if (sceneModel instanceof SDKError || dataModel instanceof SDKError) {
            processNextOutput(index + 1);
          } else {
            exporter.write({
              sceneModel,
              dataModel
            }).then((fileData) => {
              result.outputs[pipelineOutputId] = {
                fileData,
                fileDataType: exporter.fileDataType,
                version: version2,
                sceneModel,
                dataModel
              };
              processNextOutput(index + 1);
            });
          }
        };
        processNextOutput(0);
      };
      processInputs(() => {
        buildSceneModels(() => {
          buildDataModels(() => {
            processOutputs(() => {
              return resolve2(result);
            });
          });
        });
      });
    });
  }
  /**
   * Clears all pipeline configurations within this ModelConverter instance.
   *
   * After calling this method, the converter will not have any conversion pipelines configured.
   * You will need to call `setConfigs` to add new pipelines before calling `convert`.
   */
  clearConfigs() {
    this.pipelines = {};
  }
  /**
   * Configures conversion pipelines for this ModelConverter instance.
   *
   * This method allows updating or adding new conversion pipelines dynamically.
   *
   * @param params - An object containing new pipeline configurations.
   * @returns An `SDKError` if configuration validation fails, otherwise `void`.
   */
  setConfigs(params2) {
    for (let pipelineId in params2.pipelines) {
      const pipeline = params2.pipelines[pipelineId];
      const pipelineInputs = pipeline.inputs;
      if (!pipelineInputs) {
        return new SDKError(`No inputs defined on pipeline "${pipelineId}"`);
      }
      const pipelineInputIds = Object.keys(pipelineInputs);
      if (pipelineInputIds.length === 0) {
        return new SDKError(`No inputs defined on pipeline "${pipelineId}"`);
      }
      const pipelineOutputs = pipeline.outputs;
      if (!pipelineOutputs) {
        return new SDKError(`No outputs defined on pipeline "${pipelineId}"`);
      }
      const pipelineOutputIds = Object.keys(pipelineOutputs);
      if (pipelineOutputIds.length === 0) {
        return new SDKError(`No outputs defined on pipeline "${pipelineId}"`);
      }
      for (let inputId in pipelineInputs) {
        const inputParams = pipelineInputs[inputId];
        const loaderId = inputParams.loader;
        if (!loaderId) {
          return new SDKError(`No loader defined on input "${inputId}" of pipeline "${pipelineId}"`);
        }
        const loader = this.loaders[loaderId];
        if (!loader) {
          return new SDKError(`Can't resolve loader "${loaderId}" on input "${inputId}" of pipeline "${pipelineId}"`);
        }
      }
      for (let outputId in pipelineOutputs) {
        const outputParams = pipelineOutputs[outputId];
        const exporterId = outputParams.exporter;
        if (!exporterId) {
          return new SDKError(`No exporter defined on output "${outputId}" of pipeline "${pipelineId}"`);
        }
        const exporter = this.exporters[exporterId];
        if (!exporter) {
          return new SDKError(`Can't resolve exporter "${exporterId}" on output "${outputId}" of pipeline "${pipelineId}"`);
        }
      }
    }
    for (let pipelineId in params2.pipelines) {
      this.pipelines[pipelineId] = params2.pipelines[pipelineId];
    }
  }
};

// ../sdk/src/ifc2gltf2xgf/index.ts
var ifc2gltf2xgf_exports = {};
__export(ifc2gltf2xgf_exports, {
  Ifc2gltfManifestParams: () => Ifc2gltfManifestParams,
  convertIfc2gltfManifest: () => convertIfc2gltfManifest
});

// ../sdk/src/ifc2gltf2xgf/Ifc2gltfManifestParams.ts
var Ifc2gltfManifestParams = class {
  /**
   * Paths to glTF files created by if2gltf.
   */
  gltfOutFiles;
  /**
   * Paths to JSON metadata files created by if2gltf.
   *
   * Metadata file format is described by {@link metamodel!MetaModelParams | MetaModelParams}.
   */
  metadataOutFiles;
};

// ../sdk/src/ifc2gltf2xgf/convertIfc2gltfManifest.ts
function convertIfc2gltfManifest(ifc2gltfManifestParams) {
  const chunksManifest = {
    sceneModelMIMEType: "arraybuffer",
    sceneModelFiles: [],
    dataModelFiles: []
  };
  const { gltfOutFiles, metadataOutFiles } = ifc2gltfManifestParams;
  if (gltfOutFiles) {
    for (let i = 0, len = gltfOutFiles.length; i < len; i++) {
      chunksManifest.sceneModelFiles[i] = stripPathFromFilename(gltfOutFiles[i]);
    }
  }
  if (metadataOutFiles) {
    for (let i = 0, len = metadataOutFiles.length; i < len; i++) {
      chunksManifest.dataModelFiles[i] = stripPathFromFilename(metadataOutFiles[i]);
    }
  }
  return chunksManifest;
}
function stripPathFromFilename(fullPath) {
  return fullPath.split(/[/\\]/).pop();
}
export {
  basictypes_exports as basictypes,
  bcf_exports as bcf,
  boundaries_exports as boundaries,
  cameracontrol_exports as cameracontrol,
  cameraflight_exports as cameraflight,
  cityjson_exports as cityjson,
  cityjsontypes_1_1_3_exports as cityjsontypes_1_1_3,
  compression_exports as compression,
  constants_exports as constants,
  contextmenu_exports as contextmenu,
  core_exports as core,
  curves_exports as curves,
  data_exports as data,
  dotbim_exports as dotbim,
  gltf_exports as gltf,
  ifc2gltf2xgf_exports as ifc2gltf2xgf,
  ifctypes_exports as ifctypes,
  io_exports as io,
  kdtree2_exports as kdtree2,
  kdtree3_exports as kdtree3,
  ktx2_exports as ktx2,
  las_exports as las,
  locale_exports as locale,
  math_exports as math,
  matrix_exports as matrix,
  metamodel_exports as metamodel,
  modelchunksloader_exports as modelchunksloader,
  modelconverter_exports as modelconverter,
  pick_exports as pick,
  procgen_exports as procgen,
  rtc_exports as rtc,
  scene_exports as scene,
  treeview_exports as treeview,
  utils_exports as utils,
  viewer_exports as viewer,
  webglrenderer_exports as webglrenderer,
  xgf_exports as xgf,
  xkt_exports as xkt
};
/*! Bundled license information:

ste-core/dist/index.js:
  (*!
   * Strongly Typed Events for TypeScript - Core
   * https://github.com/KeesCBakker/StronlyTypedEvents/
   * http://keestalkstech.com
   *
   * Copyright Kees C. Bakker / KeesTalksTech
   * Released under the MIT license
   *)

ste-events/dist/index.js:
  (*!
   * Strongly Typed Events for TypeScript - Core
   * https://github.com/KeesCBakker/StronlyTypedEvents/
   * http://keestalkstech.com
   *
   * Copyright Kees C. Bakker / KeesTalksTech
   * Released under the MIT license
   *)

ste-signals/dist/index.js:
  (*!
   * Strongly Typed Events for TypeScript - Promise Signals
   * https://github.com/KeesCBakker/StronlyTypedEvents/
   * http://keestalkstech.com
   *
   * Copyright Kees C. Bakker / KeesTalksTech
   * Released under the MIT license
   *)

ste-promise-events/dist/index.js:
  (*!
   * Strongly Typed Events for TypeScript - Core
   * https://github.com/KeesCBakker/StronlyTypedEvents/
   * http://keestalkstech.com
   *
   * Copyright Kees C. Bakker / KeesTalksTech
   * Released under the MIT license
   *)

ste-promise-signals/dist/index.js:
  (*!
   * Strongly Typed Events for TypeScript - Promise Signals
   * https://github.com/KeesCBakker/StronlyTypedEvents/
   * http://keestalkstech.com
   *
   * Copyright Kees C. Bakker / KeesTalksTech
   * Released under the MIT license
   *)

ste-promise-simple-events/dist/index.js:
  (*!
   * Strongly Typed Events for TypeScript - Core
   * https://github.com/KeesCBakker/StronlyTypedEvents/
   * http://keestalkstech.com
   *
   * Copyright Kees C. Bakker / KeesTalksTech
   * Released under the MIT license
   *)

strongly-typed-events/dist/index.js:
  (*!
   * Strongly Typed Events for TypeScript
   * https://github.com/KeesCBakker/StronlyTypedEvents/
   * http://keestalkstech.com
   *
   * Copyright Kees C. Bakker / KeesTalksTech
   * Released under the MIT license
   *)

pako/dist/pako.esm.mjs:
  (*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) *)
*/
//# sourceMappingURL=xeokit-demo-bundle.js.map
